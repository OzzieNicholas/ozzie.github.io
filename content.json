{"meta":{"title":"Ozzie | Nicholas","subtitle":"","description":"OzzieNicholas的个人博客","author":"OzzieNicholas","url":"https://ozzienicholas.gitee.io","root":"/"},"pages":[{"title":"","date":"2021-03-18T17:49:11.377Z","updated":"2021-03-18T17:49:11.377Z","comments":true,"path":"404.html","permalink":"https://ozzienicholas.gitee.io/404","excerpt":"","text":"请留言告诉我您要访问哪个页面找不到了"},{"title":"","date":"2021-03-18T17:45:28.174Z","updated":"2021-03-18T13:58:09.160Z","comments":true,"path":"mylist/index.html","permalink":"https://ozzienicholas.gitee.io/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-18T17:45:28.193Z","updated":"2021-03-18T13:57:51.312Z","comments":true,"path":"tags/index.html","permalink":"https://ozzienicholas.gitee.io/tags/","excerpt":"","text":""},{"title":"所有分类","date":"2021-03-18T17:45:28.258Z","updated":"2021-03-18T13:57:28.462Z","comments":true,"path":"categories/index.html","permalink":"https://ozzienicholas.gitee.io/categories/","excerpt":"","text":""},{"title":"","date":"2021-03-19T01:41:44.865Z","updated":"2021-03-19T01:41:44.865Z","comments":true,"path":"about/index.html","permalink":"https://ozzienicholas.gitee.io/about/","excerpt":"","text":"终吾一生，愿念与征途，无非追求 “心之所向” 四字而已。 逝者如斯夫，虽若白驹之过隙，然何叹光阴之须臾？ 对酒当歌，人生几何！惟诗与远方，足矣！"},{"title":"我的朋友们","date":"2021-03-19T15:00:47.639Z","updated":"2021-03-19T15:00:47.639Z","comments":true,"path":"friends/index.html","permalink":"https://ozzienicholas.gitee.io/friends/","excerpt":"","text":"","author":"Ozzie"}],"posts":[{"title":"Matplotlib（下篇）","slug":"Matplotlib（下篇）","date":"2021-06-03T16:12:05.000Z","updated":"2021-06-03T16:33:35.560Z","comments":true,"path":"3c959dccffd8/","link":"","permalink":"https://ozzienicholas.gitee.io/3c959dccffd8/","excerpt":"","text":"多图合并显示Subplot 多合一显示均匀图中图 首先使用import导入matplotlib.pyplot模块, 并简写成plt。 使用plt.figure创建一个图像窗口.使用plt.subplot来创建小图。 plt.subplot(2,2,1)表示将整个图像窗口分为2行2列, 当前位置为1. 使用plt.plot([0,1],[0,1])在第1个位置创建一个小图。 plt.subplot(2,2,2)表示将整个图像窗口分为2行2列, 当前位置为2。 使用plt.plot([0,1],[0,2])在第2个位置创建一个小图。 plt.subplot(2,2,3)表示将整个图像窗口分为2行2列,当前位置为3。 plt.subplot(2,2,3)可以简写成plt.subplot(223), matplotlib同样可以识别。 使用plt.plot([0,1],[0,3])在第3个位置创建一个小图。 plt.subplot(224)表示将整个图像窗口分为2行2列, 当前位置为4。 使用plt.plot([0,1],[0,4])在第4个位置创建一个小图。 代码如下： 12345678910111213141516import matplotlib.pyplot as pltplt.figure()plt.subplot(2,2,1)plt.plot([0,1],[0,1])plt.subplot(2,2,2)plt.plot([0,1],[0,2])plt.subplot(223)plt.plot([0,1],[0,3])plt.subplot(224)plt.plot([0,1],[0,4])plt.show() 不均匀图中图 如果希望展示的小图的大小不相同, 应该怎么做呢? 以上面的4个小图为例, 如果把第1个小图放到第一行, 而剩下的3个小图都放到第二行。使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 当前位置为1。使用plt.plot([0,1],[0,1])在第1个位置创建一个小图。使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 当前位置为4。使用plt.plot([0,1],[0,2])在第4个位置创建一个小图。 这里需要解释一下为什么第4个位置放第2个小图。上一步中使用plt.subplot(2,1,1)将整个图像窗口分为2行1列, 第1个小图占用了第1个位置, 也就是整个第1行。这一步中使用plt.subplot(2,3,4)将整个图像窗口分为2行3列, 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置。 代码如下： 12345678910import matplotlib.pyplot as pltplt.figure()plt.subplot(2,1,1)plt.plot([0,1],[0,1])plt.subplot(2,3,4)plt.plot([0,1],[0,2])plt.show() 接着，使用plt.subplot(235)将整个图像窗口分为2行3列,当前位置为5。使用plt.plot([0,1],[0,3])在第5个位置创建一个小图。同上, 再创建plt.subplot(236)。代码如下： 12345678910111213141516import matplotlib.pyplot as pltplt.figure()plt.subplot(2,1,1)plt.plot([0,1],[0,1])plt.subplot(2,3,4)plt.plot([0,1],[0,2])plt.subplot(235)plt.plot([0,1],[0,3])plt.subplot(236)plt.plot([0,1],[0,4])plt.show() matplotlib 的 subplot 还可以是分格的,这里介绍三种方法同样也能达到 subplot() 函数的效果：subplot2grid、gridspec 和 subplots 。他们相比起普通的 subplot 会更加方便，在判断图的编号时不需要进行很复杂的考虑。 subplot2grid 使用plt.subplot2grid来创建第1个小图, (3,3)表示将整个图像窗口分成3行3列, (0,0)表示从第0行第0列开始作图，colspan=3表示列的跨度为3, rowspan=1表示行的跨度为1。colspan和rowspan缺省, 表示默认跨度为1。 代码如下： 12345678import matplotlib.pyplot as pltplt.figure()ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)ax1.plot([1, 2], [1, 2]) # 画小图ax1.set_title(&#x27;ax1_title&#x27;) # 设置小图的标题plt.show() 使用plt.subplot2grid来创建第2个小图, (3,3)表示将整个图像窗口分成3行3列, (1,0)表示从第1行第0列开始作图，colspan=2表示列的跨度为2. 同上画出 ax3, (1,2)表示从第1行第2列开始作图，rowspan=2表示行的跨度为2. 再画一个 ax4 和 ax5, 使用默认 colspan, rowspan。使用ax4.scatter创建一个散点图, 使用 ax4.setxlabel 和 ax4.setylabel 来对x轴和y轴命名。这样，我们就通过 subplot2grid() 完成了一张不均匀图中图。 细心的小伙伴可能可以注意到，在第一章我们设置标题与坐标轴时，使用的是plt.title()这样的语句，针对小图 ax ，我们的设置前都要加上 ‘set’。 代码如下： 12345678910111213141516import matplotlib.pyplot as pltplt.figure()plt.figure(figsize=(8, 6))ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)ax1.plot([1, 2], [1, 2]) # 画小图ax1.set_title(&#x27;ax1_title&#x27;) # 设置小图的标题ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)ax3 = plt.subplot2grid((3, 3), (1, 2), rowspan=2)ax4 = plt.subplot2grid((3, 3), (2, 0))ax5 = plt.subplot2grid((3, 3), (2, 1))ax4.scatter([1, 2], [2, 2])ax4.set_xlabel(&#x27;ax4_x&#x27;)ax4.set_ylabel(&#x27;ax4_y&#x27;)plt.show() gridspec gridspec 同样能帮助我们画出前文的图，个人觉得 gridspec 的使用是最为方便的，因为它允许我们使用索引的方式指定小图的大小和位置。首先，利用import导入matplotlib.pyplot模块, 并简写成plt. 利用import导入matplotlib.gridspec, 并简写成gridspec. 12import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec 使用plt.figure()创建一个图像窗口, 使用gridspec.GridSpec将整个图像窗口分成3行3列.使用plt.subplot来作图, gs[0, :]表示这个图占第0行和所有列, gs[1, :2]表示这个图占第1行和第2列前的所有列, gs[1:, 2]表示这个图占第1行后的所有行和第2列, gs[-1, 0]表示这个图占倒数第1行和第0列, gs[-1, -2]表示这个图占倒数第1行和倒数第2列. 代码如下： 123456789101112131415import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecplt.figure()plt.figure(figsize=(8, 8))gs = gridspec.GridSpec(3, 3)ax6 = plt.subplot(gs[0, :])ax7 = plt.subplot(gs[1, :2])ax8 = plt.subplot(gs[1:, 2])ax9 = plt.subplot(gs[-1, 0])ax10 = plt.subplot(gs[-1, -2])plt.show() subplots subplots 不同于 subplot, 它允许我们将图像窗口集合在一起表示。 首先，使用plt.subplots建立一个2行2列的图像窗口，sharex=True表示共享x轴坐标, sharey=True表示共享y轴坐标. ((ax11, ax12), (ax13, ax14))表示第1行从左至右依次放ax11和ax12, 第2行从左至右依次放ax13和ax14.接着使用ax11.scatter创建一个散点图. 代码如下： 1234567import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecf, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True)ax11.scatter([1,2], [1,2])plt.show() plt.tight_layout()表示紧凑显示图像, plt.show()表示显示图像。代码如下： 12345678import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecf, ((ax11, ax12), (ax13, ax14)) = plt.subplots(2, 2, sharex=True, sharey=True)ax11.scatter([1,2], [1,2])plt.tight_layout()plt.show() 图中图接下来我们来介绍 matplotlib 里一个很有意思的功能，叫做图中图(plot in plot)。通过它，我们可以在大图中嵌入小图。 生成数据123456# 导入pyplot模块import matplotlib.pyplot as plt# 创建数据x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6] 绘制大图 首先确定大图左下角的位置以及宽高： 1left, bottom, width, height = 0.1, 0.1, 0.8, 0.8 注意，4个值都是占整个figure窗口的百分比。在这里，假设figure的大小是10x10，那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。在klab上大家可能并不能理解figure的窗口大小，因为我们的图片会直接在代码下方显示，但对于其他平台，会出现弹出图片窗口的情况，这里的 figure 大小指的就是弹出窗口的大小。 接着，我们将大图坐标系添加到 figure 中，颜色为 r(red)，取名为 title。代码如下： 12345678910111213141516import matplotlib.pyplot as pltx = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]left, bottom, width, height = 0.1, 0.1, 0.8, 0.8fig = plt.figure()ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;title&#x27;)plt.show() 绘制小图 接着，我们来绘制左上角的小图，步骤和绘制大图一样，注意坐标系位置和大小的改变。 代码如下： 1234567891011121314151617181920212223import matplotlib.pyplot as pltx = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]left, bottom, width, height = 0.1, 0.1, 0.8, 0.8fig = plt.figure()ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;title&#x27;)left, bottom, width, height = 0.2, 0.6, 0.25, 0.25ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(y, x, &#x27;b&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;title inside 1&#x27;)plt.show() 最后，我们再来绘制右下角的小图。这里我们采用一种更简单方法，即直接往plt里添加新的坐标系： 12345678910111213141516171819202122232425262728import matplotlib.pyplot as pltx = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]fig = plt.figure()left, bottom, width, height = 0.1, 0.1, 0.8, 0.8ax1 = fig.add_axes([left, bottom, width, height])ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;title&#x27;)left, bottom, width, height = 0.2, 0.6, 0.25, 0.25ax2 = fig.add_axes([left, bottom, width, height])ax2.plot(y, x, &#x27;b&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;title inside 1&#x27;)plt.axes([0.6, 0.2, 0.25, 0.25])plt.plot(y[::-1], x, &#x27;g&#x27;) # 注意对y进行了逆序处理plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;title inside 2&#x27;)plt.show() 次坐标轴有时候我们会用到次坐标轴，即在同个图上有第2个y轴存在。这件事同样可以用matplotlib做到。 数据生成代码如下： 123x = np.arange(0, 10, 0.1)y1 = 0.05 * x**2y2 = -1 * y1 设置两个坐标系并画图可以看到，y2和y1是互相倒置的。所以，我们先获取figure默认的坐标系 ax1；然后对ax1调用twinx()方法，生成如同镜面效果后的ax2；最后接着进行绘图, 将 y1, y2 分别画在 ax1, ax2 上： 代码如下： 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npx = np.arange(0, 10, 0.1)y1 = 0.05 * x**2y2 = -1 * y1fig, ax1 = plt.subplots()ax2 = ax1.twinx()ax1.plot(x, y1, &#x27;g-&#x27;) # green, solid lineax1.set_xlabel(&#x27;X data&#x27;)ax1.set_ylabel(&#x27;Y1 data&#x27;, color=&#x27;g&#x27;)ax2.plot(x, y2, &#x27;b-&#x27;) # blueax2.set_ylabel(&#x27;Y2 data&#x27;, color=&#x27;b&#x27;)plt.show() 小练习下面，请选择以上任意一种方法，画出3个函数：y = x; y = x^2; y = 0.01*x - 0.01 代码如下： 123456789101112131415161718192021import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspecimport numpy as npx = np.linspace(-3, 3, 50)y1 = xy2 = x**2y3 = 0.01*x - 0.01plt.figure(figsize=(8, 8))gs = gridspec.GridSpec(2, 2)ax1 = plt.subplot(gs[0, 0])ax2 = plt.subplot(gs[0, 1])ax3 = plt.subplot(gs[1, :])ax1.plot(x,y1)ax2.plot(x,y2)ax3.plot(x,y3)plt.show() 3D作图与动画3D 作图 首先在进行 3D Plot 时除了导入 matplotlib ，还要额外添加一个模块，即 Axes 3D 3D 坐标轴显示,并且之后要先定义一个图像窗口，在窗口上添加3D坐标轴，显示成图，代码如下： 1234567import matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dfig = plt.figure()ax = Axes3D(fig)plt.show() 接下来给进 X 和 Y 值，并将 X 和 Y 编织成栅格。每一个（X, Y）点对应的高度值我们用下面这个函数来计算： 1234567# X, Y valueX = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y) # x-y 平面的网格R = np.sqrt(X ** 2 + Y ** 2)# height valueZ = np.sin(R) 做出一个三维曲面，并将一个 colormap rainbow 填充颜色，之后将三维图像投影到 XY 平面上做一个等高线图。其中，rstride 和 cstride 分别代表 row 和 column 的跨度。跨度越小，图形上的网格越密集，实际画出的 plot 3D 图像的代码如下： 123fig = plt.figure()ax = Axes3D(fig)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&#x27;rainbow&#x27;)) 完整的代码如下： 12345678910111213141516import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3DX = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y) # x-y 平面的网格R = np.sqrt(X ** 2 + Y ** 2)# height valueZ = np.sin(R)fig = plt.figure()ax = Axes3D(fig)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&#x27;rainbow&#x27;))plt.show() 投影 有时候我们在观察3D图形时，可能需要图形映射到平面中来观察。还记得之前学习过的等高线图吗，它可以帮助我们对3D图像进行投影。下面代码为添加 XY 平面的等高线,如果 zdir 选择了x，那么效果将会是对于 XZ 平面的投影，而调整offset可以调整投影出现的位置。 代码如下： 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3DX = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y) # x-y 平面的网格R = np.sqrt(X ** 2 + Y ** 2)# height valueZ = np.sin(R)fig = plt.figure()ax = Axes3D(fig)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&#x27;rainbow&#x27;))ax.contourf(X, Y, Z, zdir=&#x27;z&#x27;, offset=-1, cmap=plt.get_cmap(&#x27;rainbow&#x27;))plt.show() 如果 zdir 选择了x，那么效果将会是对于 XZ 平面的投影，效果如下： 1234567891011121314151617import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3DX = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y) # x-y 平面的网格R = np.sqrt(X ** 2 + Y ** 2)# height valueZ = np.sin(R)fig = plt.figure()ax = Axes3D(fig)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&#x27;rainbow&#x27;))ax.contourf(X, Y, Z, zdir=&#x27;x&#x27;, offset=-4, cmap=plt.get_cmap(&#x27;rainbow&#x27;))plt.show() Animation 动画最后，matplotlib还为我们提供了动画的接口。我们将使用其中一种方式 function animation 来为大家讲解，具体可参考 matplotlib animation api。下面，我们就开始吧！ 导入动画库并定义方程我们的数据是一个0~2π内的正弦曲线： 12345678910from matplotlib import pyplot as pltfrom matplotlib import animationimport numpy as npfig, ax = plt.subplots()x = np.arange(0, 2*np.pi, 0.01)line, = ax.plot(x, np.sin(x))plt.show() 构造动画函数与帧函数 接着，构造自定义动画函数animate，用来更新每一帧上各个x对应的y坐标值，参数表示第i帧；然后，构造开始帧函数init： 123456def animate(i): line.set_ydata(np.sin(x + i/10.0)) return line,def init(): line.set_ydata(np.sin(x)) return line, 参数设置（接下来，我们调用FuncAnimation函数生成动画）： fig 进行动画绘制的figure func 自定义动画函数，即传入刚定义的函数animate frames 动画长度，一次循环包含的帧数 init_func 自定义开始帧，即传入刚定义的函数init interval 更新频率，以ms计 lit 选择更新所有点，还是仅更新产生变化的点。应选择True，但mac用户请选择False，否则无法显示动画 因为平台的不兼容问题，请klab暂时无法进行动画的演示，请大家在自己的电脑上尝试进行动画作图吧~ 代码如下： 1234567891011121314151617181920212223from matplotlib import pyplot as pltfrom matplotlib import animationimport numpy as npfig, ax = plt.subplots()x = np.arange(0, 2*np.pi, 0.01)line, = ax.plot(x, np.sin(x))def animate(i): line.set_ydata(np.sin(x + i/10.0)) return line,def init(): line.set_ydata(np.sin(x)) return line,ani = animation.FuncAnimation(fig=fig, func=animate, frames=100, init_func=init, interval=20, blit=True)plt.show() 当然，你也可以将动画以mp4格式保存下来，但首先要保证你已经安装了ffmpeg 或者mencoder： 1ani.save(&#x27;basic_animation.mp4&#x27;, fps=30, extra_args=[&#x27;-vcodec&#x27;, &#x27;libx264&#x27;]) 用法总结 创建3D图：ax = Axes3D(fig) 画出3D图：ax.plot_surface() 投影：ax.contourf( 动画：animation.FuncAnimation() 小练习请我们根据之前所学的3D图画法画出3D数据 z = (x + y)^2， 并利用等高线图对其进行投影。 代码如下： 123456789101112131415from matplotlib import pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dimport numpy as npX = np.arange(-4, 4, 0.25)Y = np.arange(-4, 4, 0.25)X, Y = np.meshgrid(X, Y)Z = (X + Y)**2fig = plt.figure()ax = Axes3D(fig)ax.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=plt.get_cmap(&#x27;rainbow&#x27;))ax.contourf(X, Y, Z, zdir=&#x27;x&#x27;, offset=-4, cmap=plt.get_cmap(&#x27;rainbow&#x27;))plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"}]},{"title":"Matplotlib（上篇）","slug":"Matplotlib（上篇）","date":"2021-06-03T16:11:52.000Z","updated":"2021-06-03T16:16:56.206Z","comments":true,"path":"1852e70c31f8/","link":"","permalink":"https://ozzienicholas.gitee.io/1852e70c31f8/","excerpt":"","text":"为什么使用 Matplotlib Matplotlib 是一个非常强大的 Python 画图工具，可以帮助我们以直观的形式更好地了解数据。通过它，你可以画出线图、散点图、等高线图。 条形图、柱状图、3D 图形甚至是图形动画等等。下面是一些图例： Matplotlib 安装在不同环境下，Matplotlib的安装方式各不相同。在Kesci平台使用Matplotlib的小伙伴们可以免去安装的过程，因为Kesic内置了100+各语言数据分析工具包，我们可以直接调用。 Linux打开 Terminal 窗口, 输入以下内容： 12345# python 3+ 请复制以下在 terminal 中执行sudo apt-get install python3-matplotlib# python 2+ 请复制以下在 terminal 中执行sudo apt-get install python-matplotlib MacOS打开 Terminal 窗口, 输入以下内容： 12345# python 3+ 请复制以下在 terminal 中执行pip3 install matplotlib# python 2+ 请复制以下在 terminal 中执行pip install matplotlib Windows anaconda 安装 matplotlib pycharm 中运行代码 基础使用导入模块 使用 import 导入模块 matplotlib.pyplot，并简写成 plt；使用 import 导入模块 numpy，并简写成 np 12import matplotlib.pyplot as pltimport numpy as np 然后创建两组数据，使用np.linspace定义x：范围是(-3,3)，个数是50，将产生一组（-3，3）内均匀分布的50个数；(x,y1)表示曲线1，(x,y2)表示曲线2。 123x = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2 定义图像窗口并画图 在画图前使用 plt.figure() 定义一个图像窗口：编号为3；大小为(8, 5)；这两项参数可缺省。 其中，num 参数决定了程序运行后弹出的图像窗口名字，但在 klab 平台下不会显示。 接着，我们使用 plt.plot 画出(x ,y2)曲线；使用plt.plot画(x ,y1)曲线，曲线的颜色属性(color)为红色；曲线的宽度(linewidth)为1.0；曲线的类型(linestyle)为虚线，除了虚线外，大家还可使用以下线性：’-‘、’–’、’-.’、’:’ 。接着，我们使用 plt.show() 显示图像。 代码如下： 1234plt.figure(num=3, figsize=(8, 5))plt.plot(x, y2)plt.plot(x, y1, color=&#x27;red&#x27;, linewidth=1.0, linestyle=&#x27;--&#x27;)plt.show() 总结上面的代码，运行我们的第一个demo： 1234567891011121314151617 import matplotlib.pyplot as plt import numpy as np # 生成了基本的点 x = np.linspace(-3, 3, 50) y1 = 2*x+1 y2 = x**2 # 定义图像窗口并画图 # 定义窗口 plt.figure(num=3, figsize=(8, 5)) # 画线plt.plot(x, y1) plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=2.0, linestyle=&#x27;--&#x27;) # 显示图像 plt.show() 定义坐标轴名称及范围 使用plt.xlim设置x坐标轴范围：(-1, 2)； 使用plt.ylim设置y坐标轴范围：(-2, 3)； 使用plt.xlabel设置x坐标轴名称：’I am x’； 使用plt.ylabel设置y坐标轴名称：’I am y’； 代码如下： 1234567891011121314151617181920212223 import matplotlib.pyplot as plt import numpy as np # 生成了基本的点 x = np.linspace(-10, 10, 800) y1 = 2*x+1 y2 = x**2 # 定义图像窗口并画图 # 定义窗口 plt.figure(num=3, figsize=(8, 5)) # 画线 plt.plot(x, y1) plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=2.0, linestyle=&#x27;--&#x27;) # 生成x、y坐标轴的范围 plt.xlim((-1, 2))plt.ylim((-2, 3)) # 生成x、y坐标轴的名称 plt.xlabel(&#x27;I am x&#x27;) plt.ylabel(&#x27;I am y&#x27;) # 显示图像 plt.show() 定义坐标轴刻度及名称 有时候，我们的坐标轴刻度可能并不是一连串的数字，而是一些文字，或者我们想要调整坐标轴的刻度的稀疏，这时，就需要使用plt.xticks()或者plt.yticks()来进行调整。接下来便是步骤。 我们使用np.linspace定义新刻度范围以及个数：范围是(-1,2);个数是5。 使用plt.xticks设置x轴刻度：范围是(-1,2);个数是5。 使用plt.yticks设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]。 使用plt.show()显示图像。 代码如下： 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as np# 生成了基本的点x = np.linspace(-10, 10, 800)y1 = 2*x+1y2 = x**2# 定义图像窗口并画图# 定义窗口plt.figure(num=3, figsize=(8, 5))# 画线plt.plot(x, y1)plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=2.0, linestyle=&#x27;--&#x27;)# 生成x、y坐标轴的范围plt.xlim((-1, 2))plt.ylim((-2, 3))# 生成x、y坐标轴的名称plt.xlabel(&#x27;I am x&#x27;)plt.ylabel(&#x27;I am y&#x27;) 生成x。y坐标轴的新刻度以及名称new_ticks = np.linspace(-1, 2, 5)plt.xticks(new_ticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r’$really\\ bad$’, r’$bad$’, r’$normal$’, r’$good$’, r’$really\\ good$’]) 显示图像plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 ![img](https:&#x2F;&#x2F;cdn.kesci.com&#x2F;rt_upload&#x2F;063BF7746B414C04BB18AFD5BB23F503&#x2F;pdrfj0bbyc.png)### 设置图像边框颜色1. 大家可能会注意到，我们的图像坐标轴总是由上下左右四条线组成，我们也可以对它们进行修改。接下来就是步骤。2. 首先，使用 plt.gca() 获取当前坐标轴信息。3. 使用.spines设置边框：右侧边框；4. 使用.set_color设置边框颜色：默认白色； 5. 使用.spines设置边框：上边框；6. 使用.set_color设置边框颜色：默认白色；7. 代码如下： &#96;&#96;&#96;python import matplotlib.pyplot as plt import numpy as np # 生成了基本的点 x &#x3D; np.linspace(-10, 10, 800) y1 &#x3D; 2*x+1 y2 &#x3D; x**2 # 定义图像窗口并画图 # 定义窗口 plt.figure(num&#x3D;3, figsize&#x3D;(8, 5)) # 画线 plt.plot(x, y1) plt.plot(x, y2, color&#x3D;&#39;red&#39;, linewidth&#x3D;2.0, linestyle&#x3D;&#39;--&#39;) # 生成x、y坐标轴的范围 plt.xlim((-1, 2)) plt.ylim((-2, 3)) # 生成x、y坐标轴的名称 plt.xlabel(&#39;I am x&#39;) plt.ylabel(&#39;I am y&#39;) # 生成x。y坐标轴的新刻度以及名称 new_ticks &#x3D; np.linspace(-1, 2, 5) plt.xticks(new_ticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#39;$really\\ bad$&#39;, r&#39;$bad$&#39;, r&#39;$normal$&#39;, r&#39;$good$&#39;, r&#39;$really\\ good$&#39;]) # 设置图像边框颜色 # 获取当前坐标轴信息 ax &#x3D; plt.gca() # 指定哪条坐标轴并设置颜色 ax.spines[&#39;right&#39;].set_color(&#39;blue&#39;) ax.spines[&#39;top&#39;].set_color(&#39;yellow&#39;) # 函数有返回值。整形、字符串、元组、列表、集合、字典之类的 # 显示图像 plt.show() 调整刻度及边框位置（x 轴） 使用.xaxis.set_ticks_position设置x坐标刻度数字或名称的位置：bottom.（所有位置：top，bottom，both，default，none）； 使用.spines设置边框：x轴； 使用.set_position设置边框位置：y=0的位置；（位置所有属性：outward，axes，data） 代码如下： 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as np# 生成了基本的点x = np.linspace(-10, 10, 800)y1 = 2*x+1y2 = x**2# 定义图像窗口并画图# 定义窗口plt.figure(num=3, figsize=(8, 5))# 画线plt.plot(x, y1)plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=2.0, linestyle=&#x27;--&#x27;)# 生成x、y坐标轴的范围plt.xlim((-1, 2))plt.ylim((-2, 3))# 生成x、y坐标轴的名称plt.xlabel(&#x27;I am x&#x27;)plt.ylabel(&#x27;I am y&#x27;)# 生成x。y坐标轴的新刻度以及名称new_ticks = np.linspace(-1, 2, 5)plt.xticks(new_ticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#x27;$really\\ bad$&#x27;, r&#x27;$bad$&#x27;, r&#x27;$normal$&#x27;, r&#x27;$good$&#x27;, r&#x27;$really\\ good$&#x27;]) 设置图像边框颜色获取当前坐标轴信息ax = plt.gca() 指定哪条坐标轴并设置颜色ax.spines[‘right’].set_color(‘blue’)ax.spines[‘top’].set_color(‘yellow’) 函数有返回值。整形、字符串、元组、列表、集合、字典之类的设置刻度以及边框位置ax.xaxis.set_ticks_position(‘bottom’)ax.spines[‘bottom’].set_position((‘data’, 0)) 显示图像plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 ![img](https:&#x2F;&#x2F;cdn.kesci.com&#x2F;rt_upload&#x2F;E644E91621D9491E98DB08FA2F856230&#x2F;pdrk2mrh0v.png)### 调整刻度及边框位置（y 轴）1. 使用.yaxis.set_ticks_position设置y坐标刻度数字或名称的位置：left.（所有位置：left，right，both，default，none）2. 使用.spines设置边框：y轴；3. 使用.set_position设置边框位置：x&#x3D;0（y轴）的位置；（位置所有属性：outward，axes，data） 4. 使用plt.show显示图像.5. 代码如下： &#96;&#96;&#96;python import matplotlib.pyplot as plt import numpy as np # 生成了基本的点 x &#x3D; np.linspace(-10, 10, 800) y1 &#x3D; 2*x+1 y2 &#x3D; x**2 # 定义图像窗口并画图 # 定义窗口 plt.figure(num&#x3D;3, figsize&#x3D;(8, 5)) # 画线 plt.plot(x, y1) plt.plot(x, y2, color&#x3D;&#39;red&#39;, linewidth&#x3D;2.0, linestyle&#x3D;&#39;--&#39;) # 生成x、y坐标轴的范围 plt.xlim((-1, 2)) plt.ylim((-2, 3)) # 生成x、y坐标轴的名称 plt.xlabel(&#39;I am x&#39;) plt.ylabel(&#39;I am y&#39;) # 生成x。y坐标轴的新刻度以及名称 new_ticks &#x3D; np.linspace(-1, 2, 5) plt.xticks(new_ticks) plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#39;$really\\ bad$&#39;, r&#39;$bad$&#39;, r&#39;$normal$&#39;, r&#39;$good$&#39;, r&#39;$really\\ good$&#39;]) # 设置图像边框颜色 # 获取当前坐标轴信息ax &#x3D; plt.gca() # 指定哪条坐标轴并设置颜色 ax.spines[&#39;right&#39;].set_color(&#39;blue&#39;) ax.spines[&#39;top&#39;].set_color(&#39;yellow&#39;) # 函数有返回值。整形、字符串、元组、列表、集合、字典之类的 # 设置x轴刻度以及名称的位置 ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0)) # 设置y轴刻度以及名称的位置 ax.yaxis.set_ticks_position(&#39;left&#39;) ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0)) # 显示图像 plt.show() 小练习以上就是matplotlib的基本用法，是不是比较简单呢？ 现在，请根据上述所学内容，画出直线 y = x-1，线型为虚线，线宽为1， 纵坐标范围（-2，1），横坐标范围（-1，2），横纵坐标在（0，0）坐标点相交。 横坐标的 [-1,-0.5,1] 分别对应 [bad, normal, good]。 代码如下： 123456789101112131415161718192021222324252627282930313233import matplotlib.pyplot as pltimport numpy as np# 生成点的数据# (x, y)：(自变量. 因变量)x = np.linspace(-1, 2, 100)y = x-1# 生成图像窗口plt.figure()# 画线：一个函数对应使用一次 plt.plot 方法（有些函数不只一条线，比如双曲线）plt.plot(x, y, linewidth=1.0, linestyle=&#x27;-&#x27;)# x、y轴坐标的范围plt.xlim((-1, 2))plt.ylim((-2, 1))# 指定刻度及其名称plt.xticks([-1, -0.5, 1], [&#x27;bad&#x27;, &#x27;normal&#x27;, &#x27;good&#x27;])# 获取当前坐标轴的信息ax = plt.gca()# 再调整x、y轴的刻度位置ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)# 让y轴刻度位于x=0的位置ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 让x轴刻度位于y=0的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))# 显示图像plt.show() 用法总结 导入模块：import matplotlib.pyplot as plt 定义图像窗口：plt.figure() 画图：plt.plot(x, y) 定义坐标轴范围：plt.xlim()/plt.ylim() 定义坐标轴名称：plt.xlabel()/plt.ylabel() 定义坐标轴刻度及名称：plt.xticks()/plt.yticks() 设置图像边框颜色：ax = plt.gca() ax.spines[].set_color() 调整刻度位置：ax.xaxis.set_ticks_position()/ax.yaxis.set_ticks_position() 调整边框（坐标轴）位置：ax.spines[].set_position() 图例与标注添加图例 matplotlib 中的 legend 图例就是为了帮我们展示出每个数据对应的图像名称. 更好的让读者认识到你的数据结构。之前我们了解到关于坐标轴设置方面的一些内容，代码如下： 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2)plt.xlim((-1, 2))plt.ylim((-2, 3))new_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#x27;$really\\ bad$&#x27;, r&#x27;$bad$&#x27;, r&#x27;$normal$&#x27;, r&#x27;$good$&#x27;, r&#x27;$really\\ good$&#x27;])# 显示图像plt.show() 本节中我们将对图中的两条线绘制图例。 首先我们设置两条线的类型等信息（蓝色实线与红色虚线)，并且通过 label 参数为两条线设置名称。 比如直线的名称就叫做 “linear line”, 曲线的名称叫做 “square line”。 当然，只是设置好名称并不能使我们的图例出现，要通过plt.legend()设置图例的显示。 legend获取代码中的 label 的信息, plt 就能自动的为我们添加图例。 代码如下： 1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()plt.xlim((-1, 2))plt.ylim((-2, 3))new_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#x27;$really\\ bad$&#x27;, r&#x27;$bad$&#x27;, r&#x27;$normal$&#x27;, r&#x27;$good$&#x27;, r&#x27;$really\\ good$&#x27;])# 画线l1 = plt.plot(x, y1, label=&#x27;linear line&#x27;)l2 = plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=1.0, linestyle=&#x27;--&#x27;, label=&#x27;square line&#x27;)# 设置图例plt.legend()# 显示图像plt.show() 如果希望图例能够更加个性化，可通过以下方式更改：参数 loc 决定了图例的位置,比如参数 loc=’upper right’ 表示图例将添加在图中的右上角。 其中’loc’参数有多种，’best’表示自动分配最佳位置，其余的如下： ‘best’ : 0, ‘upper right’ : 1, ‘upper left’ : 2, ‘lower left’ : 3, ‘lower right’ : 4, ‘right’ : 5, ‘center left’ : 6, ‘center right’ : 7, ‘lower center’ : 8, ‘upper center’ : 9, ‘center’ : 10 代码如下： 1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()plt.xlim((-1, 2))plt.ylim((-2, 3))new_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#x27;$really\\ bad$&#x27;, r&#x27;$bad$&#x27;, r&#x27;$normal$&#x27;, r&#x27;$good$&#x27;, r&#x27;$really\\ good$&#x27;])# 画线l1 = plt.plot(x, y1, label=&#x27;linear line&#x27;)l2 = plt.plot(x, y2, color=&#x27;red&#x27;, linewidth=1.0, linestyle=&#x27;--&#x27;, label=&#x27;square line&#x27;)# 设置图例并指定位置plt.legend(loc=&#x27;upper right&#x27;)# 显示图像plt.show() 同样可以通过设置 handles 参数来选择图例中显示的内容。 首先，在上面的代码 plt.plot(x, y2, label=’linear line’) 和 plt.plot(x, y1, label=’square line’) 中用变量 l1 和 l2 分别存储起来，而且需要注意的是 l1, l2,要以逗号结尾, 因为plt.plot() 返回的是一个列表。 然后将 l1,l2 这样的objects以列表的形式传递给 handles。另外，label 参数可以用来单独修改之前的 label 信息, 给不同类型的线条设置图例信息。 代码如下： 12345678910111213141516171819import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y1 = 2*x + 1y2 = x**2plt.figure()plt.xlim((-1, 2))plt.ylim((-2, 3))new_sticks = np.linspace(-1, 2, 5)plt.xticks(new_sticks)plt.yticks([-2, -1.8, -1, 1.22, 3], [r&#x27;$really\\ bad$&#x27;, r&#x27;$bad$&#x27;, r&#x27;$normal$&#x27;, r&#x27;$good$&#x27;, r&#x27;$really\\ good$&#x27;]) 画线l1, = plt.plot(x, y1, label=’linear line’)l2, = plt.plot(x, y2, color=’red’, linewidth=1.0, linestyle=’–’, label=’square line’) 设置图例并指定位置plt.legend(handles=[l1,l2,], labels=[‘up’,’down’], loc=’best’) 显示图像plt.show() 1234567891011121314151617181920212223242526 ![img](https:&#x2F;&#x2F;cdn.kesci.com&#x2F;rt_upload&#x2F;3C82931E30FF47BD82438E03FBFF0315&#x2F;pdyhqz3b31.png)### Annotation 标注1. 当图线中某些特殊地方需要标注时，我们可以使用 annotation. matplotlib 中的 annotation 有两种方法，一种是用 plt 里面的 annotate，一种是直接用 plt 里面的 text 来写标注。首先回顾一下之前的画图教程： &#96;&#96;&#96;python import matplotlib.pyplot as plt import numpy as np x &#x3D; np.linspace(-3, 3, 50) y &#x3D; 2*x + 1 plt.figure(num&#x3D;1, figsize&#x3D;(8, 5),) ax &#x3D; plt.gca() ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0)) ax.yaxis.set_ticks_position(&#39;left&#39;) ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0)) plt.plot(x, y) plt.show() 然后标注出点(x0, y0)的位置信息。用plt.plot([x0, x0,], [0, y0,], ‘k–’, linewidth=2.5) 画出一条垂直于x轴的虚线。 其中，[x0, x0,], [0, y0,] 表示在图中画一条从点 (x0,y0) 到 (x0,0) 的直线，’k–’ 表示直线的颜色为黑色(black)，线形为虚线。 而 plt.scatter 函数可以在图中画点，此时我们画的点为 (x0,y0), 点的大小(size)为 50， 点的颜色为蓝色(blue),可简写为 b。 代码如下： 1234567891011121314151617181920212223242526import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y = 2*x + 1plt.figure(num=1, figsize=(8, 5),)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 画一条垂直于x轴的虚线x0 = 1y0 = 2*x0+1plt.plot([x0, x0], [0, y0], &#x27;k--&#x27;, linewidth=2.5)# 在图中画交点plt.scatter([x0], [y0], s=100, color=&#x27;b&#x27;)plt.plot(x, y)plt.show() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455 ![img](https:&#x2F;&#x2F;cdn.kesci.com&#x2F;rt_upload&#x2F;F3A72ED0D0E042ADA5DFBE98874643BD&#x2F;pdyig3h8a5.png)### 添加注释 annotate1. 接下来我们就对(x0, y0)这个点进行标注。2. 第一种方式就是利用函数 annotate()。3. 其中 r&#39;2x+1&#x3D;&#39; y0 代表标注的内容，可以通过字符串 %s 将 y0 的值传入字符串；4. 参数 xycoords&#x3D;&#39;data&#39; 是说基于数据的值来选位置, xytext&#x3D;(+30, -30) 和 textcoords&#x3D;&#39;offset points&#39; 表示对于标注位置的描述 和 xy 偏差值，即标注位置是 xy 位置向右移动 30，向下移动30, arrowprops是对图中箭头类型和箭头弧度的设置，需要用 dict 形式传入。5. 代码如下： &#96;&#96;&#96;python import matplotlib.pyplot as plt import numpy as np x &#x3D; np.linspace(-3, 3, 50) y &#x3D; 2*x + 1 plt.figure(num&#x3D;1, figsize&#x3D;(8, 5),) ax &#x3D; plt.gca() ax.spines[&#39;right&#39;].set_color(&#39;none&#39;) ax.spines[&#39;top&#39;].set_color(&#39;none&#39;) ax.xaxis.set_ticks_position(&#39;bottom&#39;) ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;, 0)) ax.yaxis.set_ticks_position(&#39;left&#39;) ax.spines[&#39;left&#39;].set_position((&#39;data&#39;, 0)) # 画一条垂直于x轴的虚线 x0 &#x3D; 1 y0 &#x3D; 2*x0+1 plt.plot([x0, x0], [0, y0], &#39;k--&#39;, linewidth&#x3D;2.5) # 在图中画交点 plt.scatter([x0], [y0], s&#x3D;100, color&#x3D;&#39;red&#39;) # 添加注释 plt.annotate( &#39;2x+1&#x3D;3&#39;, xy&#x3D;(x0, y0), xycoords&#x3D;&#39;data&#39;, xytext&#x3D;(+30, -30), textcoords&#x3D;&#39;offset points&#39;, fontsize&#x3D;16, arrowprops&#x3D;dict(arrowstyle&#x3D;&#39;-&gt;&#39;, connectionstyle&#x3D;&quot;arc3,rad&#x3D;.2&quot; ) ) plt.plot(x, y) plt.show() 添加注释 text 第二种注释方式是通过 text() 函数，其中 -3.7,3, 是选取text的位置, r’This is the some text.μ σi αt’ 为 text 的内容，其中空格需要用到转字符 \\ ,fontdict 设置文本字的大小和颜色。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y = 2*x + 1plt.figure(num=1, figsize=(8, 5),)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 画一条垂直于x轴的虚线x0 = 1y0 = 2*x0+1plt.plot([x0, x0], [0, y0], &#x27;k--&#x27;, linewidth=2.5)# 在图中画交点plt.scatter([x0], [y0], s=100, color=&#x27;red&#x27;)# 添加注释 annotateplt.annotate( &#x27;2x+1=3&#x27;, xy=(x0, y0), xycoords=&#x27;data&#x27;, xytext=(+30, -30), textcoords=&#x27;offset points&#x27;, fontsize=16, arrowprops=dict(arrowstyle=&#x27;-&gt;&#x27;, connectionstyle=&quot;arc3,rad=.2&quot; ) )# 添加注释 textplt.text(--3.7, -3, r&#x27;$This\\ is\\ the\\ some\\ text. \\mu\\ \\sigma_i\\ \\alpha_t$&#x27;, fontdict=&#123; &#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;red&#x27; &#125; )plt.plot(x, y)plt.show() tick 能见度 当图片中的内容较多，相互遮盖时，我们可以通过设置相关内容的透明度来使图片更易于观察，也即是通过本节中的bbox参数设置来调节图像信息.首先参考之前的例子, 我们先绘制图像基本信息。 代码如下： 1234567891011121314151617181920import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y = 0.1*xplt.figure()# 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序plt.plot(x, y, linewidth=10, zorder=1)plt.ylim(-2, 2)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))plt.show() 然后对被遮挡的图像调节相关透明度，本例中设置 x轴 和 y轴 的刻度数字进行透明度设置。其中label.set_fontsize(12)重新调节字体大小，bbox设置目的内容的透明度相关参，facecolor调节 box 前景色，edgecolor 设置边框， 本处设置边框为无，alpha设置透明度. 最终结果如下： 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-3, 3, 50)y = 0.1*xplt.figure()# 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序plt.plot(x, y, linewidth=10, zorder=1)plt.ylim(-2, 2)ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) # 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序 label.set_bbox(dict(facecolor=&#x27;white&#x27;, edgecolor=&#x27;None&#x27;, alpha=0.7, zorder=2))plt.show() 可能大家会觉得设置图例和标注的参数比较复杂很难记忆，不用担心，我们不需要刻意去记住，只要知道matplotlib提供了这样的画图功能，在使用的时候，在去查找相关参数即可！ 用法总结 添加图例：plt.legend() 画点：plt.scatter() 添加标注：plt.annotate() 添加注释：plt.text() 各类图形散点图 首先，先引入matplotlib.pyplot简写作plt,再引入模块numpy用来产生一些随机数据。 数据生成：生成1024个呈标准正态分布的二维数据组 (平均数是0，方差为1) 作为一个数据集，并图像化这个数据集。每一个点的颜色值用T来表示： 1234567import matplotlib.pyplot as pltimport numpy as npn = 1024 # data sizeX = np.random.normal(0, 1, n) # 每一个点的X值Y = np.random.normal(0, 1, n) # 每一个点的Y值T = np.arctan2(Y,X) # for color value 画图：数据集生成完毕，现在来用 plt.scatter 画出这个点集，输入X和Y作为location，size=75，颜色为T，color map用默认值，透明度alpha 为 50%。 x轴显示范围定位(-1.5，1.5)，并向xtick()函数传入空集()来隐藏x坐标轴，y轴同理： 12345678plt.scatter(X, Y, s=75, c=T, alpha=.5)plt.xlim(-1.5, 1.5)plt.xticks(()) # ignore xticksplt.ylim(-1.5, 1.5)plt.yticks(()) # ignore yticksplt.show() 总的代码如下： 12345678910111213141516import matplotlib.pyplot as pltimport numpy as npn = 1024 # data sizeX = np.random.normal(0, 1, n) # 每一个点的X值Y = np.random.normal(0, 1, n) # 每一个点的Y值T = np.arctan2(Y,X) # for color valueplt.scatter(X, Y, s=75, c=T, alpha=.5)plt.xlim(-1.5, 1.5)plt.xticks(()) # ignore xticksplt.ylim(-1.5, 1.5)plt.yticks(()) # ignore yticksplt.show() 柱状图柱状图是在数据分析过程中最为常用的图表，折线图和饼图能够表达的信息，柱状图都能够表达。在学术报告或工作场景下，大家应尽量使用柱状图来代替折线图与饼图。 数据生成：首先生成画图数据，向上向下分别生成2组数据，X为0到11的整数 ，Y是相应的均匀分布的随机数据。 画图：使用的函数是plt.bar，参数为X和Y，X代表横坐标，即柱形的位置，Y代表纵坐标，即柱形的高度。 代码如下： 12345678910111213141516171819202122232425# 导入模块import matplotlib.pyplot as pltimport numpy as np# 数据生成n = 12X = np.arange(n)Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n)Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n)# 柱状图plt.bar(X, +Y1)plt.bar(X, -Y2)# 设置坐标轴的刻度以及名称plt.xlim(-.5, n)plt.xticks(())plt.ylim(-1.25, 1.25)plt.yticks(())# 显示图像plt.show()# 需要划分功能块，对应的功能块有着对应的函数# 先定下基础的功能，再慢慢添加功能，在添加功能的时候，再想需要用什么函数去实现 修改颜色和标签：如果想要改变柱状图的颜色，并且希望每个柱形上方能够显示该项数值该怎么做呢？我们可以用 plt.bar 函数中的facecolor参数设置柱状图主体颜色，用edgecolor参数设置边框颜色；而函数 plt.text 可以帮助我们在柱体上方（下方）加上数值：用%.2f保留两位小数，用ha=’center’设置横向居中对齐，用va=’bottom’设置纵向底部（顶部）对齐。 代码如下： 1234567891011121314151617181920212223import matplotlib.pyplot as pltimport numpy as npn = 12X = np.arange(n)Y1 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n)Y2 = (1 - X / float(n)) * np.random.uniform(0.5, 1.0, n)plt.bar(X, +Y1, facecolor=&#x27;#FFCCCC&#x27;, edgecolor=&#x27;white&#x27;)plt.bar(X, -Y2, facecolor=&#x27;#6699CC&#x27;, edgecolor=&#x27;white&#x27;)for x, y in zip(X, Y1): plt.text(x, y , &#x27;%.2f&#x27; % y, ha=&#x27;center&#x27;, va=&#x27;bottom&#x27;)for x, y in zip(X, Y2): plt.text(x, -y , &#x27;%.2f&#x27; % y, ha=&#x27;center&#x27;, va=&#x27;top&#x27;)plt.xlim(-.5, n)plt.xticks(())plt.ylim(-1.25, 1.25)plt.yticks(())plt.show() 等高线图 数据生成：数据集即三维点 (x,y) 和对应的高度值，共有256个点。高度值使用一个 height function f(x,y) 生成。 x, y 分别是在区间 [-3,3] 中均匀分布的256个值，并用meshgrid在二维平面中将每一个x和每一个y分别对应起来，编织成栅格。 1234567def f(x,y): return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2)n = 256x = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)X,Y = np.meshgrid(x, y) 画图：接下来进行颜色填充。使用函数plt.contourf把颜色加进去，位置参数分别为：X, Y, f(X,Y)。8代表等高线的密集程度，这里被分为10个部分。如果是0，则图像被一分为二。透明度为0.75，并将 f(X,Y) 的值对应到color map的RdBu组中寻找对应颜色。大家可能并不能直观理解 colormap ，它可以将颜色和数字进行映射。如果暂时不能理解的话也没有关系，我们可以将其想象成matplotlib为我们提供的配色方案，大家可以查看此链接选择自己喜欢的配色方案应用在自己的图上。 1plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.RdBu) 代码如下： 1234567891011121314import matplotlib.pyplot as pltimport numpy as npdef f(x,y): return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2)n = 256x = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)X,Y = np.meshgrid(x, y)plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.RdBu)plt.show() 接下来，我们使用plt.contour函数划线。位置参数为：X, Y, f(X,Y)。颜色选黑色，线条宽度选0.5。代码如下： 1234567891011121314151617181920# 导入模块import matplotlib.pyplot as pltimport numpy as np# 数据生成def f(x,y): return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2)n = 256x = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)X,Y = np.meshgrid(x, y)# 绘图过程plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.RdBu)# 显示图像plt.show()# 把一个图拆分成两部分：函数图像的描绘、坐标轴等辅助信息 添加高度数字：最后我们要通过 plt.clabel() 在等高线上加入高度数值，即加入Label，其中参数 inline 控制是否将 Label 画在线里面，fontsize 设置字体大小为10。并将坐标轴隐藏。代码如下： 12345678910111213141516171819202122 # 导入模块 import matplotlib.pyplot as plt import numpy as np # 数据生成 def f(x,y): return (1 - x / 2 + x**5 + y**3) * np.exp(-x**2 -y**2) n = 256 x = np.linspace(-3, 3, n) y = np.linspace(-3, 3, n) X,Y = np.meshgrid(x, y) # 绘图过程 plt.contourf(X, Y, f(X, Y), 8, alpha=.75, cmap=plt.cm.RdBu) C = plt.contour(X, Y, f(X, Y), 8, colors=&#x27;black&#x27;, linewidth=.5) # 显示图像plt.show() # 把一个图拆分成两部分：函数图像的描绘、坐标轴等辅助信息 随机矩阵画图现在我们讲解怎样在matplotlib中打印出图像。这里我们打印出的是纯粹的数字，而非自然图像。 数据生成：首先生成一个 3x3 的 2D-array ，也就是三行三列的格子，array 中的每个值经过colormap与一个颜色对应并填充在格子中： 123a = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3) 画图：我们之前选cmap的参数时用的是：cmap=plt.cmap.RdBu，而现在，我们可以直接用单引号传入参数。 origin=’lower’代表的就是选择的原点的位置。而 interpolation 表示画图方式，从该链接可看到matplotlib官网上对于内插法的不同方法的描述。这里我们使用的是内插法中的 Nearest-neighbor 的方法，其他的方式也都可以随意取选。 1plt.imshow(a, interpolation=&#x27;nearest&#x27;, cmap=&#x27;RdBu&#x27;, origin=&#x27;lower&#x27; 代码如下： 12345678910import matplotlib.pyplot as pltimport numpy as npa = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3)plt.imshow(a, interpolation=&#x27;nearest&#x27;, cmap=&#x27;RdBu&#x27;, origin=&#x27;lower&#x27;)plt.show() 增加 colorbar：下面我们添加一个colorbar ，它可以为我们显示不同颜色的区块所对应的具体数值。其中shrink参数可以用来调整 colorbar 的长度，这里我们使colorbar的长度变短为原来的92%，这样我们2D图像就创建完毕了： 1234567891011121314import matplotlib.pyplot as pltimport numpy as npa = np.array([0.313660827978, 0.365348418405, 0.423733120134, 0.365348418405, 0.439599930621, 0.525083754405, 0.423733120134, 0.525083754405, 0.651536351379]).reshape(3,3)plt.imshow(a, interpolation=&#x27;nearest&#x27;, cmap=&#x27;RdBu&#x27;, origin=&#x27;lower&#x27;)plt.colorbar(shrink=.92)plt.xticks(())plt.yticks(())plt.show() 小练习现在，我们可以尝试用上述方法对豆瓣电影数据集进行分析。请根据数据集中的表格’电影影评.csv’画出电影星级分布图。横坐标为电影的评分星级，分别为1，2，3，4，5；纵坐标为该星级下的电影数量。 提示：使用value_counts()函数对不同星级的电影数量进行计算 代码如下： 123456789101112131415161718import matplotlib.pyplot as pltimport numpy as npimport pandas as pddata = pd.read_csv(&#x27;/home/kesci/input/movie_douban/电影影评.csv&#x27;)data = data[data[&#x27;星级&#x27;]&lt;=5]data_distri = data[&#x27;星级&#x27;].value_counts()plt.figure(figsize=(6,4))plt.bar(data_distri.index, data_distri.values)plt.ylim(0, 60000)#设置数值标签x = np.array(list(data_distri.index))y = np.array(list(data_distri.values))for a,b in zip(x,y): plt.text(a, b+500, &#x27;%.0f&#x27; % b, ha=&#x27;center&#x27;, va= &#x27;bottom&#x27;,fontsize=10)plt.show() 用法总结 散点图：plt.scatter() 柱状图：plt.bar() 等高线图：plt.contourf() 等高线图中增加label：plt.clabel() 矩阵画图：plt.imshow() 在随机矩阵图中增加colorbar：plt.colorbar()","categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"}]},{"title":"NumPy（超详细）","slug":"NumPy（超详细）","date":"2021-06-03T16:11:39.000Z","updated":"2021-06-03T16:16:10.001Z","comments":true,"path":"653ef868179f/","link":"","permalink":"https://ozzienicholas.gitee.io/653ef868179f/","excerpt":"","text":"NumPy 初识NumPy 简介 NumPy(Numerical Python) 是 Python 语言的一个扩展程序库，支持大量的维度数组与矩阵运算，同时对数组运算提供了大量的数学函数库。 Numpy 是一个运行速度非常快的数学库，内部解除了CPython的GIL（全局解释器锁），运行效率极好，主要用于数组计算，是大量机器学习框架的基础库，NumPy主要包括如下： 强大的N维数组对象 ndarray 广播功能函数 整合 C/C++/Fortran 代码的工具 线性代数、傅里叶变换、随机数生成等功能。 NumPy 通常与 SciPy（Scientific Python）和 Matplotlib（绘图库）组合使用，用于替代 MatLab。 NumPy的优缺点 NumPy优点如下： 对于同样的数值计算任务，使用NumPy要比直接编写Python代码便捷得多。 NumPy中的数组的存储效率和输入输出性能均远远优于Python中等价的基本数据结构，且其能够提升的性能是与数组中的元素成比例的。 NumPy的大部分代码都是用C语言写的，其底层算法在设计时就有着优异的性能，这使得NumPy比纯Python代码高效得多 NumPy缺点如下： 由于NumPy使用内存映射文件以达到最优的数据读写性能，而内存的大小限制了其对TB级大文件的处理； NumPy数组的通用性不及Python提供的list容器。 NumPy 安装1pip install --user numpy –user 选项可以设置只安装在当前的用户下，而不是写入到系统目录。 NumPy 数据类型 numpy支持的数据类型比 Python 内置的类型要多，基本上可以和 C 语言的数据类型对应上，其中部分类型对应为 Python 内置的类型。 bool_：布尔型数据类型（True 或者 False） int_：默认的整数类型（类似于 C 语言中的 long，int32 或 int64） intc：与 C 的 int 类型一样，一般是 int32 或 int 64 intp：用于索引的整数类型（类似于 C 的 ssize*t，通常是int32或 int64） int8：字节（-128 to 127） int16：整数（-32768 to 32767） int32：整数（-2147483648 to 2147483647） int64：整数（64bit） uint8：无符号整数（0 to 255） uint16：无符号整数（0 to 65535） uint32：无符号整数（0 to 4294967295） uint64：无符号整数（0 to 18446744073709551615） float： float64：类型的简写float16 半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位 float64：单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位 float64：双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位 complex_：complex128 类型的简写，即 128 位复数： complex64：复数，表示双 32 位浮点数（实数部分和虚数部分） complex128：复数，表示双 64 位浮点数（实数部分和虚数部分） 每个内建类型都有一个唯一定义它的字符代码： b：布尔类型 i：有符号整型 u：无符号整型 f：浮点型 c：复数浮点型 m：时间间隔 M：日期间隔 O：Python对象 S：字符串 U：Unicode V：原始数据（void） dtype 数据类型对象 数据类型对象dtype用于描述与数组对应的内存区域如何使用，依赖如下几个方面： 数据的类型（整数，浮点数或者 Python 对象） 数据的大小（例如， 整数使用多少个字节存储） 数据的字节顺序（小端法或大端法） 在结构化类型的情况下，字段的名称、每个字段的数据类型和每个字段所取的内存块的部分,如果数据类型是子数组，它的形状和数据类型。 字节顺序是通过对数据类型预先设定”&lt;”或”&gt;”来决定的。”&lt;”意味着小端法(最小值存储在最小的地址，即低位组放在最前面)。”&gt;”意味着大端法(最重要的字节存储在最小的地址，即高位组放在最前面)。 dtype 对象是使用以下语法构造的： 1numpy.dtype(object, align, copy) object - 要转换为的数据类型对象 align - 如果为 true，填充字段使其类似 C 的结构体。 copy - 复制 dtype 对象 ，如果为 false，则是对内置数据类型对象的引用 一个结构化数据类型 student，包含字符串字段 name，整数字段 age，及浮点字段 score，并将 dtype 应用到 ndarray 对象。 案例： 123456789import numpy if __name__ == &quot;__main__&quot;: student = numpy.dtype([(&quot;name&quot;, &quot;S20&quot;), (&quot;age&quot;, numpy.int8), (&quot;marks&quot;, &quot;&lt;f4&quot;)]) student_array = numpy.array([(&quot;Bauer&quot;, 22, 88), (&quot;Jack&quot;, 21, 90), (&quot;Alex&quot;, 78, 22)], dtype=student) print(student_array) # output:# [(b&#x27;Bauer&#x27;, 22, 88.) (b&#x27;Jack&#x27;, 21, 90.) (b&#x27;Alex&#x27;, 78, 22.)] ndarrayndarray简介 ndarray是NumPy的核心，ndarray封装了python原生的同数据类型的n维数组，通过正整数元组索引。 ndarray内部结构如下： 一个指向数据（内存或内存映射文件中的一块数据）的指针。 数据类型（dtype），描述在数组中的固定大小值的格子。 一个表示数组形状（shape）的元组，表示各维度大小的元组。 一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数。 ndarray 和 标准 Python 列表的区别如下： ndarray 在创建时具有固定的大小， 更改ndarray的大小将创建一个新数组并删除原来的数组，与Python的原生数组对象（可以动态增长）不同。 ndarray 中的元素必须具有相同的数据类型，因此在内存中的大小相同。 ndarray 有助于对大量数据进行高级数学和其它类型的操作。 通常，这些操作的执行效率更高，比使用Python原生数组的代码更少。 大部分基于Python的科学和数学软件包都使用NumPy数组，尽管通常也支持Python原生数组作为参数，但在处理前仍然会将输入数组转换为NumPy数组，而且通常输出为NumPy数组。为了高效地使用当今基于Python的科学计算工具，需要知道如何使用NumPy数组。 ndarray 对象的属性 ndarray 对象提供的关键属性如下： ndarray.ndim：数组的轴（维度）的个数，维度的数量被称为rank。 ndarray.shape：数组的维度，是一个整数的元组，表示每个维度中数组的大小。对于n行和m列的矩阵，shape是(n,m)。因此，shape元组的长度就是rank或维度的个数 ndim。 ndarray.size：数组元素的总数，等于shape的元素的乘积。 ndarray.dtype：描述数组中元素类型的对象。可以使用标准的Python类型创建或指定 dtype：NumPy提供自己的类型，如numpy.int32、numpy.int16和numpy.float64。 ndarray.itemsize：数组中每个元素的字节大小，等于 ndarray.dtype.itemsize。元素为 float64 类型的数组的 itemsize 为8（=64/8），而 complex32 类型的数组的 itemsize 为4（=32/8）。 ndarray.flags：ndarray对象的内存信息。 ndarray.real：ndarray元素的实部 ndarray.imag：ndarray 元素的虚部 ndarray.data：缓冲区包含数组的实际元素。 Ndarray.flags的内存信息属性如下： C_CONTIGUOUS (C)：数据是在一个单一的C风格的连续段中 F_CONTIGUOUS (F)：数据是在一个单一的Fortran风格的连续段中 OWNDATA (O)：数组拥有自己所使用的内存或从另一个对象中借用 WRITEABLE (W：)数据区域可以被写入，将值设置为 False，则数据为只读。 ALIGNED (A)：数据和所有元素都适当地对齐到硬件上 UPDATEIFCOPY (U)：数组是其它数组的一个副本，当数组被释放时，原数组的内容将被更新 案例： 123456789101112131415161718192021222324252627282930313233343536import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(15).reshape(5, 3) print(a) print(&quot;shape: &quot;, a.shape) print(&quot;ndim:&quot;, a.ndim) print(&quot;dtype:&quot;, a.dtype.name) print(&quot;itemsize: &quot;, a.itemsize) print(&quot;itemsize: &quot;, a.dtype.itemsize) print(&quot;size: &quot;, a.size) print(&quot;flags: &quot;, a.flags) print(&quot;data: &quot;, a.data) print(&quot;type:&quot;, type(a)) # output:# [[ 0 1 2]# [ 3 4 5]# [ 6 7 8]# [ 9 10 11]# [12 13 14]]# shape: (5, 3)# ndim: 2# dtype: int64# itemsize: 8# itemsize: 8# size: 15# flags: C_CONTIGUOUS : True# F_CONTIGUOUS : False# OWNDATA : False# WRITEABLE : True# ALIGNED : True# WRITEBACKIFCOPY : False# UPDATEIFCOPY : False# data: &lt;memory at 0x7f1b6fbf4b40&gt;# type: &lt;class &#x27;numpy.ndarray&#x27;&gt; 创建数组 numpy.empty(shape, dtype = float, order = &#39;C&#39;) numpy.empty 方法用来创建一个指定形状（shape）、数据类型（dtype）且未初始化的数组。 123456789import numpy if __name__ == &quot;__main__&quot;: array_empty = numpy.empty([2, 3]) print(array_empty) # output:# [[6.92184835e-310 1.23016891e-316 6.92184893e-310]# [6.92184893e-310 1.45897537e-303 2.72466824e-311]] numpy.array(p_object, dtype=None, copy=True, order=&#39;K&#39;, subok=False, ndmin=0)：创建数组，p_object为数组或序列，dtype为数组元素类型 12345678import numpy if __name__ == &quot;__main__&quot;: a = numpy.array([[1, 2, 3], [4, 5, 6]], numpy.int) print(a)# output:# [[1 2 3]# [4 5 6]] numpy.asarray(a, dtype = None, order = None)：创建数组，a为数组或序列，dtype为数组元素类型。 123456789import numpy if __name__ == &quot;__main__&quot;: array_as = numpy.asarray([[1, 2, 3, 4], [5, 6, 7, 8]]) print(array_as) # output:# [[1 2 3 4]# [5 6 7 8]] numpy.frombuffer(buffer, dtype = float, count = -1, offset = 0) numpy.frombuffer 用于实现动态数组。 buffer 参数为人以对象，以流的形式读入转化成 ndarray 对象。buffer 是字符串的时候，Python3 默认 str 是 Unicode 类型，所以要转成 bytestring 在原 str 前加上 b。 dtype参数，数组的数据类型，可选。 count参数，读取的数据量，默认为-1，读取所有的数据。 offset参数，读取的起始位置，默认为0。 案例 1234567891011import numpy if __name__ == &quot;__main__&quot;: # 使用 range 函数创建列表对象 l = range(10) it = iter(l) # 使用迭代器创建 ndarray x = numpy.fromiter(it, dtype=float) print(x)# output:# [0. 1. 2. 3. 4. 5. 6. 7. 8. 9.] numpy.ones(shape, dtype=None, order=&#39;C&#39;)：创建数值为1的数组，shape是数组的形状，dtype是数值类型。 12345678import numpy if __name__ == &quot;__main__&quot;: array_ones = numpy.ones((2, 3), numpy.int) print(array_ones)# output:# [[1 1 1]# [1 1 1]] numpy.zeros(shape, dtype=None, order=&#39;C&#39;)：创建数值为0的数组，shape是数组的形状，dtype是数值类型。 12345678import numpy if __name__ == &quot;__main__&quot;: array_zeros = numpy.zeros((2, 3), numpy.int) print(array_zeros)# output:# [[0 0 0]# [0 0 0]] numpy.full(shape, fill_value, dtype=None, order=&#39;C&#39;)：创建指定数值的数组，shape是数组的形状，fill_value是数值，dtype是数值类型。 12345678import numpy if __name__ == &quot;__main__&quot;: array_full = numpy.full((2, 3), 3.14, numpy.float) print(array_full)# output:# [[3.14 3.14 3.14]# [3.14 3.14 3.14]] numpy.eye(N, M=None, k=0, dtype=float, order=&#39;C&#39;)：创建单位矩阵，N为行数，M为列数。 12345678import numpy if __name__ == &quot;__main__&quot;: array_eye = numpy.eye(2, 3) print(array_eye)# output:# [[1. 0. 0.]# [0. 1. 0.]] numpy.diag(v, k=0)：创建对角矩阵，v是主对角线数值，k是对角线元素，k = 0表示主对角线，k&gt;0的值选择在主对角线之上的对角线中的元素，k&lt;0的值选择在主对角线之下的对角线中的元素。 12345678910import numpy if __name__ == &quot;__main__&quot;: array_diag = numpy.diag([1, 2, 3], k=1) print(array_diag)# output:# [[0 1 0 0]# [0 0 2 0]# [0 0 0 3]# [0 0 0 0]] numpy.random.rand(*dn)：创建指定shape的数组，数值范围在0~1之间。dn是可变参数，接收多个参数用于指定数组的shape。 12345678import numpy if __name__ == &quot;__main__&quot;: array_rand = numpy.random.rand(2, 3) print(array_rand)# output:# [[0.73299266 0.10939252 0.61875294]# [0.11556114 0.62150992 0.56455656]] numpy.random.uniform(low=0.0, high=1.0, size=None)：创建指定范围内的数值的数或数组，low为下限，high为上限，size为个数，可以为序列，用于指定数组的shape。 12345678910import numpy if __name__ == &quot;__main__&quot;: array_uniform = numpy.random.uniform(3, 3.14, (2, 3)) print(array_uniform) print(numpy.random.uniform(0, 100, 3))# output:# [[3.00724161 3.10009725 3.04795313]# [3.06319773 3.12678593 3.09834495]]# [73.03084565 34.16123519 95.58874675] numpy.randint(low, high=None, size=None, dtype=&#39;l&#39;)：创建指定范围内的数值的数或数组，low为下限，high为上限，size为个数，可以为序列，用于指定数组的shape。 1234567891011import numpy if __name__ == &quot;__main__&quot;: array_randint = numpy.random.randint(0, 10, (2, 3), dtype=numpy.int) print(array_randint) print(numpy.random.randint(0, 100, 3, dtype=numpy.int)) # output:# [[6 2 8]# [1 4 8]]# [60 16 25] numpy.arange(start=None, *args, **kwargs)：创建一维数组，其中包含位于半开区间[start, stop)内并均匀分布的值，step表示步长。 12345678import numpy if __name__ == &quot;__main__&quot;: array_arange = numpy.arange(0, 10, 3) print(array_arange) # output:# [0 3 6 9] numpy.arange(start=None, *args, **kwargs)：创建一维数组，其中包含位于半开区间[start, stop)内并均匀分布的值，step表示步长。 12345678import numpy if __name__ == &quot;__main__&quot;: array_arange = numpy.arange(0, 10, 3) print(array_arange) # output:# [0 3 6 9] numpy.linspace(start, stop, N)：创建N个在闭区间[start, stop]内均匀分布的值。 12345678import numpy if __name__ == &quot;__main__&quot;: array_linspace = numpy.linspace(0, 10, 5) print(array_linspace) # output:# [ 0. 2.5 5. 7.5 10. ] numpy.random.normal(loc=0.0, scale=1.0, size=None)：创建给定均值loc、标准差scale、维度size的正态分布。 123456789import numpy if __name__ == &quot;__main__&quot;: array_normal = numpy.random.normal(loc=1.75, scale=0.1, size=[2, 3]) print(array_normal) # output:# [[1.6629973 1.78608724 1.83688018]# [1.77781707 1.62255632 1.73506316]] ndarray 索引 ndarray对象的内容可以通过索引或切片来访问和修改，与 Python 中 list 的切片操作一样。 ndarray 数组可以基于 0 - n 的下标进行索引，切片对象可以通过内置的 slice 函数，并设置 start, stop 及 step 参数进行，从原数组中切割出一个新数组。 array[start : end:step]：截取start到end的切片，间隔为step array[start:]：截取从start到结尾的切片 array[:end]：截取从开始到end的切片 案例： 12345678910import numpy if __name__ == &quot;__main__&quot;: array_rand = numpy.arange(1, 10) print(array_rand) print(array_rand[1:7:2]) # output:# [1 2 3 4 5 6 7 8 9]# [2 4 6] ndarray数组可以通过整数数组进行索引，通常需要分别构造行索引和列索引的数组，通过行索引数组和列索引数组组合使用最终定位数组的索引。 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: array_rand = numpy.random.randint(0, 10, [5, 8]) print(array_rand) rows = numpy.array([[0, 0], [3, 3]]) cols = numpy.array([[0, 2], [0, 2]]) result = array_rand[rows, cols] print(result) # output:# [[6 1 7 7 6 1 0 5]# [9 5 4 6 1 0 8 0]# [0 2 1 5 3 3 5 6]# [4 4 5 0 2 5 2 2]# [1 9 8 5 7 1 3 2]]# [[6 7]# [4 5]] ndarray可以通过一个布尔数组来进行索，布尔索引通过布尔运算（如：比较运算符）来获取符合指定条件的元素的数组。 123456789101112131415import numpy if __name__ == &quot;__main__&quot;: array_rand = numpy.random.randint(0, 10, [5, 8]) print(array_rand) result = array_rand[array_rand &gt; 5] print(result) # output:# [[2 3 2 2 0 5 4 7]# [8 8 2 8 6 5 9 7]# [9 6 3 9 5 9 9 5]# [3 9 1 1 8 7 9 7]# [8 2 0 6 5 0 2 7]]# [7 8 8 8 6 9 7 9 6 9 9 9 9 8 7 9 7 8 6 7] 数组修改 numpy.ndarray.reshape(a, newshape, order=&#39;C&#39;)：把指定的数组改变形状，但元素个数不变；有返回值，即不对原始多维数组进行修改。a是数组，newshape为新的shape。 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, 10) b = numpy.reshape(a, [2, 5]) print(a) print(b) c = b.reshape([1, 10]) print(b) print(c) # output:# [2 7 0 7 3 0 3 2 5 2]# [[2 7 0 7 3]# [0 3 2 5 2]]# [[2 7 0 7 3]# [0 3 2 5 2]]# [[2 7 0 7 3 0 3 2 5 2]] numpy.ndarray.resize(a, new_shape)：把指定的数组改变形状，但元素个数可变，不足补0。numpy.resize作为含磺素使用时，不会对原始数组进行修改，返回新的结果数组；array.resize作为方法使用时，无返回值，会对原始多维数组进行修改。 12345678910111213141516171819202122import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, 10) print(a) # 不修改原始数组 b = numpy.resize(a, [3, 4]) print(a) print(b) # 修改原始数组 a.resize([3, 4]) print(a) # output:# [0 0 7 5 7 1 3 8 1 9]# [0 0 7 5 7 1 3 8 1 9]# [[0 0 7 5]# [7 1 3 8]# [1 9 0 0]]# [[0 0 7 5]# [7 1 3 8]# [1 9 0 0]] 数组迭代迭代数组简介NumPy 迭代器对象 numpy.nditer 提供了一种灵活访问一个或者多个数组元素的方式。 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(0, 12).reshape([2, 6]) print(a) it = numpy.nditer(a) for x in it: print(x, end=&quot;, &quot;) print(&quot;\\n&quot;) for x in numpy.nditer(a.T.copy(order=&#x27;C&#x27;)): print(x, end=&quot;, &quot;) # output:# [[ 0 1 2 3 4 5]# [ 6 7 8 9 10 11]]# 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,## 0, 6, 1, 7, 2, 8, 3, 9, 4, 10, 5, 11, 遍历顺序控制12345for x in numpy.nditer(arr, order=&#x27;F&#x27;): pass for x in numpy.nditer(arr.T, order=&#x27;C&#x27;): pass order=’F’，表示Fortran order，即列序优先； order=’C’，表示C order，即行序优先。 遍历修改数组元素值nditer 对象有一个可选参数 op_flags。 默认情况下，nditer将视待迭代遍历的数组为只读对象（read-only），为了在遍历数组的同时，实现对数组元素值得修改，必须指定 read-write 或者 write-only 的模式。 123456789101112131415import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(0, 12).reshape([2, 6]) print(a) it = numpy.nditer(a, op_flags=[&quot;readwrite&quot;]) for x in it: x[...] = x**2 print(a) # output:# [[ 0 1 2 3 4 5]# [ 6 7 8 9 10 11]]# [[ 0 1 4 9 16 25]# [ 36 49 64 81 100 121]] 外部循环 nditer的构造器拥有flags参数，可以接受下列值： c_index：可以跟踪 C 顺序的索引 f_index：可以跟踪 Fortran 顺序的索引 multi-index：每次迭代可以跟踪一种索引类型 external_loop：给出的值是具有多个值的一维数组，而不是零维数组 广播迭代如果两个数组是可广播的，nditer 组合对象能够同时迭代。 假设数组 a 的维度为 3X4，数组 b 的维度为 1X4 ，则使用迭代器（数组 b 被广播到 a 的大小）如下： 123456789101112131415import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(0, 12).reshape([3, 4]) print(a) b = [11, 12, 13, 14] it = numpy.nditer([a, b]) for x, y in it: print(&quot;%d:%d&quot; % (x, y), end=&quot;, &quot;) # output:# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]]# 0:11, 1:12, 2:13, 3:14, 4:11, 5:12, 6:13, 7:14, 8:11, 9:12, 10:13, 11:14, NumPy条件运算numpy.where(condition, x=None, y=None)三目运算，满足condition，为x；不满足condition，则为y。返回新的结果数组。 1234567891011import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, 10) print(a) b = numpy.where(a &lt; 5, 5, 0) print(b) # output:# [8 9 6 5 3 2 9 7 3 4]# [0 0 0 0 5 5 0 0 5 5] 统计函数 numpy.amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue)：根据指定轴统计矩阵的最大值，axis=0统计矩阵中每一列的最大值，axis=1统计矩阵中每一行的最大值，默认统计矩阵中的最大值。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 100, [3, 5]) print(a) # 统计整个矩阵的最大值 result = numpy.amax(a) print(result) # 统计矩阵中每一列的最大值 result = numpy.amax(a, axis=0) print(result) # 统计矩阵中每一行的最大值 result = numpy.amax(a, axis=1) print(result)# output:# [[85 54 46 38 98]# [27 65 23 13 63]# [43 68 31 42 82]]# 98# [85 68 46 42 98]# [98 65 82] numpy.amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue)：根据指定轴统计矩阵的最小值，axis=0统计矩阵中每一列的最小值，axis=1统计矩阵中每一行的最小值，默认统计矩阵中的最小值。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 100, [3, 5]) print(a) # 统计整个矩阵的最小值 result = numpy.amin(a) print(result) # 统计矩阵中每一列的最小值 result = numpy.amin(a, axis=0) print(result) # 统计矩阵中每一行的最小值 result = numpy.amin(a, axis=1) print(result)# output:# [[74 95 64 18 99]# [24 61 36 2 65]# [66 68 9 19 19]]# 2# [24 61 9 2 19]# [18 2 9] numpy.mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue)：根据指定轴统计矩阵的平均值，axis=0统计矩阵中每一列的平均值，axis=1统计矩阵中每一行的平均值，默认统计矩阵中的平均值。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 100, [3, 5]) print(a) # 统计整个矩阵的平均值 result = numpy.mean(a) print(result) # 统计矩阵中每一列的平均值 result = numpy.mean(a, axis=0) print(result) # 统计矩阵中每一行的平均值 result = numpy.mean(a, axis=1) print(result)# output:# [[38 36 68 78 58]# [41 38 84 92 95]# [52 86 62 94 33]]# 63.666666666666664# [43.66666667 53.33333333 71.33333333 88. 62. ]# [55.6 70. 65.4] numpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):根据指定轴统计矩阵的方差，axis=0统计矩阵中每一列的方差，axis=1统计矩阵中每一行的方差，默认统计矩阵中的方差。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 100, [3, 5]) print(a) # 统计整个矩阵的方差 result = numpy.std(a) print(result) # 统计矩阵中每一列的方差 result = numpy.std(a, axis=0) print(result) # 统计矩阵中每一行的方差 result = numpy.std(a, axis=1) print(result)# output:# [[80 68 47 51 2]# [75 38 97 70 98]# [57 66 64 17 70]]# 25.442746183015178# [ 9.87702159 13.69509239 20.7578633 21.92411154 40.30991055]# [26.59774427 21.9326241 19.36388391] numpy.sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue, initial=np._NoValue)：根据指定轴统计矩阵的求和，axis=0统计矩阵中每一列的求和，axis=1统计矩阵中每一行的求和，默认统计矩阵中的求和。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 100, [3, 5]) print(a) # 统计整个矩阵的求和 result = numpy.sum(a) print(result) # 统计矩阵中每一列的求和 result = numpy.sum(a, axis=0) print(result) # 统计矩阵中每一行的求和 result = numpy.sum(a, axis=1) print(result)# output:# [[87 16 90 96 83]# [23 96 52 76 39]# [46 5 55 91 66]]# 921# [156 117 197 263 188]# [372 286 263] numpy.percentile(a, axis=None, out=None, keepdims=np._NoValue)：计算数组中元素最大值与最小值的差（最大值 - 最小值） 12numpy.percentile(a, q, axis=None, out=None, overwrite_input=False, interpolation=&#x27;linear&#x27;, keepdims=False) 百分位数是统计中使用的度量，表示小于这个值的观察值的百分比。 参数a，输入数组 参数q，要计算的百分位数，在 0 ~ 100 之间 参数axis: 沿着计算百分位数的轴 numpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)：用于计算数组 a 中元素的中位数（中值） numpy.average(a, axis=None, weights=None, returned=False)：根据各自的权重计算数组中元素的加权平均值。 参数a，输入数组 参数axis，指定轴 weights：权重 案例： 123456789101112131415import numpy if __name__ == &quot;__main__&quot;: a = numpy.array([10, 20, 30, 40]) print(numpy.average(a)) weight = [1, 2, 3, 4] result = numpy.average(a, weights=weight) print(result) result = numpy.average(a, weights=weight, returned=True) print(result) # output:# 25.0# 30.0# (30.0, 10.0) 算术运算 数组与数的运算包括加、减、乘、除、取整、取模，可以使用函数也可以使用操作符。 numpy.add(x1, x2, *args, **kwargs)：将x1和x2相加，并将结果返回。 numpy.subtract(x1, x2, *args, **kwargs)：将x1和x2相减，并将结果返回。 numpy.multiply(x1, x2, *args, **kwargs)：将x1和x2相乘，并将结果返回。 numpy.divide(x1, x2, *args, **kwargs)：将x1和x2相除，并将结果返回。 numpy.mod(*args, **kwargs)：计算输入数组中相应元素的相除后的余数 numpy.power(x1, x2, *args, **kwargs)：将x1作为底数，计算x1的x2次幂。 numpy.reciprocal(x, *args, **kwargs)：返回x的倒数。 案例： 123456789101112131415161718192021222324252627282930313233import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [2, 5]) print(a) result = a + 5 print(result) result = a - 5 print(result) result = a * 5 print(result) result = a / 5 print(result) result = a // 5 print(result) result = a % 5 print(result) # output:# [[9 6 6 7 9]# [0 3 2 4 8]]# [[14 11 11 12 14]# [ 5 8 7 9 13]]# [[ 4 1 1 2 4]# [-5 -2 -3 -1 3]]# [[45 30 30 35 45]# [ 0 15 10 20 40]]# [[1.8 1.2 1.2 1.4 1.8]# [0. 0.6 0.4 0.8 1.6]]# [[1 1 1 1 1]# [0 0 0 0 1]]# [[4 1 1 2 4]# [0 3 2 4 3]] 数组间运算包括加、减、乘、除，但两个数组的shape必须一样。 numpy.intersect1d(ar1, ar2, assume_unique=False, return_indices=False)：查找两个数组中的相同元素。 numpy.setdiff1d(ar1, ar2, assume_unique=False)：查找在数组a中不在数组b中的元素。 numpy.union1d(ar1, ar2)：查找两个数组的并集元素 案例 1234567891011121314151617181920212223242526272829303132333435363738394041import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(1, 10, [2, 5]) b = numpy.random.randint(1, 10, [2, 5]) print(a) print(b) result = a + b print(result) result = a - b print(result) result = a * b print(result) result = a / b print(result) # 求交 result = numpy.intersect1d(a, b) print(result) # 求差 result = numpy.setdiff1d(a, b) print(result) # 求并 result = numpy.union1d(a, b) print(result) # output:# [[2 8 4 1 5]# [1 9 4 4 7]]# [[9 2 4 7 3]# [7 7 3 2 1]]# [[11 10 8 8 8]# [ 8 16 7 6 8]]# [[-7 6 0 -6 2]# [-6 2 1 2 6]]# [[18 16 16 7 15]# [ 7 63 12 8 7]]# [[0.22222222 4. 1. 0.14285714 1.66666667]# [0.14285714 1.28571429 1.33333333 2. 7. ]]# [1 2 4 7 9]# [5 8]# [1 2 3 4 5 7 8 9] 广播 广播(Broadcast)是 numpy 对不同shape的数组进行数值计算的方式， 对数组的算术运算通常在相应的元素上进行。 如果两个数组进行运算时必须要求shape相同，当运算中的 2 个数组的shape不同时，numpy 将自动触发广播机制。 广播机制的规则如下： 让所有输入数组都向其中形状最长的数组看齐，形状中不足的部分都通过在前面加 1 补齐。 输出数组的形状是输入数组形状的各个维度上的最大值。 如果输入数组的某个维度和输出数组的对应维度的长度相同或者其长度为 1 时，这个数组能够用来计算，否则出错。 当输入数组的某个维度的长度为 1 时，沿着此维度运算时都用此维度上的第一组值。如果条件不满足，抛出 “ValueError: frames are not aligned” 异常。 4x3 的二维数组与1x 3 的一维数组相加，等效于把一维数组 在二维上重复 4 次再运算。 案例： 12345678910111213141516import numpy if __name__ == &quot;__main__&quot;: a = numpy.array([[0, 0, 0], [10, 10, 10], [20, 20, 20], [30, 30, 30]]) b = numpy.array([1, 2, 3]) result = a + b print(result) # output:# [[ 1 2 3]# [11 12 13]# [21 22 23]# [31 32 33]] 矩阵运算 numpy.dot(a, b, out=None)：矩阵点乘，（M行，N列）*（N行，Z列）=（M行，Z列） 123456789101112131415import numpy if __name__ == &quot;__main__&quot;: # 成绩，期末考试成绩和平常作业成绩组成 score = numpy.array([[100, 87], [88, 87], [78, 80], [65, 89]]) # 权重因子，期末成绩占70%，平时作业成绩占30% q = numpy.array([[0.7], [0.3]]) result = numpy.dot(score, q) print(result) # output:# [[96.1]# [87.7]# [78.6]# [72.2]] numpy.vstack(tup)：矩阵垂直拼接（两个矩阵列数必须相同，行数随意），参数tup为数组的元组。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [3, 6]) b = numpy.random.randint(0, 10, [2, 6]) print(a) print(b) result = numpy.vstack((a, b)) print(result) # output:# [[2 5 7 6 2 8]# [1 7 2 2 0 0]# [1 1 5 8 3 4]]# [[6 5 3 4 9 9]# [4 3 2 4 2 9]]# [[2 5 7 6 2 8]# [1 7 2 2 0 0]# [1 1 5 8 3 4]# [6 5 3 4 9 9]# [4 3 2 4 2 9]] numpy.hstack(tup)：矩阵水平拼接（两个矩阵行数必须相同，列数随意），参数tup为数组的元组。 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [2, 3]) b = numpy.random.randint(0, 10, [2, 4]) c = numpy.random.randint(0, 10, [2, 5]) print(a) print(b) print(c) result = numpy.hstack((a, b, c)) print(result) # output:# [[5 4 2]# [3 3 3]]# [[7 0 7 7]# [3 5 0 2]]# [[8 6 3 0 2]# [3 9 7 4 1]]# [[5 4 2 7 0 7 7 8 6 3 0 2]# [3 3 3 3 5 0 2 3 9 7 4 1]] numpy.delete(arr, obj, axis=None)：矩阵删除，参数arr为数组；参数obj为要删除的对象；参数axis为轴，axis=0表示删除行，axis=1表示删除列，默认删除行和列。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [10, 10]) print(a) result = numpy.delete(a, [0, 2]) print(result) result = numpy.delete(a, [0, 2], axis=0) print(result) result = numpy.delete(a, [0, 2], axis=1) print(result) # output:# [[8 0 7 2 1 6 8 9 5 5]# [6 3 1 6 5 5 5 6 1 8]# [2 0 8 5 0 2 4 7 6 3]# [8 8 3 9 3 1 9 6 4 2]# [2 1 5 1 2 9 9 5 9 9]# [2 2 8 1 5 8 6 7 2 9]# [9 6 2 7 6 0 1 5 1 8]# [7 9 8 7 8 6 8 5 1 6]# [1 9 6 9 4 1 7 7 0 9]# [7 1 8 8 7 1 0 2 7 2]]# [0 2 1 6 8 9 5 5 6 3 1 6 5 5 5 6 1 8 2 0 8 5 0 2 4 7 6 3 8 8 3 9 3 1 9 6 4# 2 2 1 5 1 2 9 9 5 9 9 2 2 8 1 5 8 6 7 2 9 9 6 2 7 6 0 1 5 1 8 7 9 8 7 8 6# 8 5 1 6 1 9 6 9 4 1 7 7 0 9 7 1 8 8 7 1 0 2 7 2]# [[6 3 1 6 5 5 5 6 1 8]# [8 8 3 9 3 1 9 6 4 2]# [2 1 5 1 2 9 9 5 9 9]# [2 2 8 1 5 8 6 7 2 9]# [9 6 2 7 6 0 1 5 1 8]# [7 9 8 7 8 6 8 5 1 6]# [1 9 6 9 4 1 7 7 0 9]# [7 1 8 8 7 1 0 2 7 2]]# [[0 2 1 6 8 9 5 5]# [3 6 5 5 5 6 1 8]# [0 5 0 2 4 7 6 3]# [8 9 3 1 9 6 4 2]# [1 1 2 9 9 5 9 9]# [2 1 5 8 6 7 2 9]# [6 7 6 0 1 5 1 8]# [9 7 8 6 8 5 1 6]# [9 9 4 1 7 7 0 9]# [1 8 7 1 0 2 7 2]] numpy.append(arr, values, axis=None)：矩阵添加，参数arr为数组；参数values为要追加的对象；参数axis为轴，axis=0表示追加到行，axis=1表示追加到列，默认添加到所有数组元素的尾部。 1234567891011121314151617181920212223242526import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [3, 8]) print(a) result = numpy.append(a, [0, 2, 3]) print(result) # 追加一行 result = numpy.append(a, [[9, 9, 9, 9, 9, 9, 9, 9]], axis=0) print(result) # 追加一列 result = numpy.append(a, [[9], [9], [9]], axis=1) print(result) # output:# [[3 0 2 8 1 2 2 6]# [4 2 5 7 3 4 6 9]# [3 3 2 6 2 7 9 9]]# [3 0 2 8 1 2 2 6 4 2 5 7 3 4 6 9 3 3 2 6 2 7 9 9 0 2 3]# [[3 0 2 8 1 2 2 6]# [4 2 5 7 3 4 6 9]# [3 3 2 6 2 7 9 9]# [9 9 9 9 9 9 9 9]]# [[3 0 2 8 1 2 2 6 9]# [4 2 5 7 3 4 6 9 9]# [3 3 2 6 2 7 9 9 9]] numpy.insert(arr, obj, values, axis=None)：矩阵插入，参数arr为数组，obj为插入位置索引，values为插入的值，参数axis为轴，axis=0表示插入到行，axis=1表示插入到列，默认插入到所有数组元素的序列的指定位置。 12345678910111213141516171819202122232425import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, [3, 8]) print(a) result = numpy.insert(a, 0, [11, 12, 13]) print(result) result = numpy.insert(a, 0, [11, 12, 13, 14, 15, 16, 17, 18], axis=0) print(result) result = numpy.insert(a, 0, [11, 12, 13], axis=1) print(result) # output:# [[5 0 0 8 9 8 5 8]# [3 0 2 3 5 1 4 2]# [4 2 4 0 6 5 6 1]]# [11 12 13 5 0 0 8 9 8 5 8 3 0 2 3 5 1 4 2 4 2 4 0 6# 5 6 1]# [[11 12 13 14 15 16 17 18]# [ 5 0 0 8 9 8 5 8]# [ 3 0 2 3 5 1 4 2]# [ 4 2 4 0 6 5 6 1]]# [[11 5 0 0 8 9 8 5 8]# [12 3 0 2 3 5 1 4 2]# [13 4 2 4 0 6 5 6 1]] 位运算 bitwise_and对数组中整数的二进制形式执行位与运算。 bitwise_or对数组中整数的二进制形式执行位与运算。 invert对数组中整数进行位取反运算，即 0 变成 1，1 变成 0。 left_shift将数组元素的二进制形式向左移动到指定位置，右侧附加相等数量的 0。 right_shift将数组元素的二进制形式向右移动到指定位置，左侧附加相等数量的 0。 案例： 1234567891011121314151617181920212223242526272829303132333435363738import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(0, 12).reshape([3, 4]) print(a) b = [11, 12, 13, 14] print(b) result = numpy.bitwise_and(a, b) print(result) result = numpy.bitwise_or(a, b) print(a) result = numpy.invert(a) print(result) result = numpy.left_shift(a, 2) print(result) result = numpy.right_shift(result, 2) print(result) # output:# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]]# [11, 12, 13, 14]# [[ 0 0 0 2]# [ 0 4 4 6]# [ 8 8 8 10]]# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]]# [[ -1 -2 -3 -4]# [ -5 -6 -7 -8]# [ -9 -10 -11 -12]]# [[ 0 4 8 12]# [16 20 24 28]# [32 36 40 44]]# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]] 字符串处理 NumPy中对字符串的处理基于 Python 内置库中的标准字符串函数，对dtype为 numpy.string 或 numpy.unicode 的数组执行向量化字符串操作，相应函数在字符数组类（numpy.char）中定义。 numpy.char.add()：依次对两个数组的元素进行字符串连接。 numpy.char.multiply()：对数组的数值执行多次重度连接。 numpy.char.center()：将数组的数值字符串居中，并使用指定字符在左侧和右侧进行填充。 numpy.char.capitalize()：将数组数值字符串的第一个字母转换为大写： numpy.char.title()：将数组数值字符串的每个单词的第一个字母转换为大写： numpy.char.lower()：对数组的每个元素转换为小写，对每个元素调用 str.lower。 numpy.char.upper()：对数组的每个元素转换为大写，对每个元素调用 str.upper。 numpy.char.split()：通过指定分隔符对字符串进行分割，并返回数组。默认情况下，分隔符为空格。 numpy.char.splitlines()：以换行符作为分隔符来分割字符串，并返回数组。 numpy.char.strip()：用于移除开头或结尾处的特定字符。 numpy.char.join()：通过指定分隔符来连接数组中的元素或字符串 numpy.char.replace()：使用新字符串替换字符串中的所有子字符串。 numpy.char.encode()：对数组中的每个元素调用 str.encode 函数。 默认编码是 utf-8，可以使用标准 Python 库中的编×××。 numpy.char.decode()：对编码的元素进行 str.decode() 解码。 数学函数 NumPy 包含大量的各种数学运算的函数，包括三角函数，算术运算的函数，复数处理函数等。 numpy.sin(x, *args, **kwargs)：计算x的正弦并返回，x为弧度值 numpy.arcsin(x, *args, **kwargs)：计算x的反正弦并返回，返回为弧度值 numpy.cos(x, *args, **kwargs)：计算x的余弦并返回，x为弧度值 numpy.arccos(x, *args, **kwargs)：计算x的反余弦并返回，返回为弧度值 numpy.tan(x, *args, **kwargs)：计算x的正切并返回，x为弧度值 numpy.arctan(x, *args, **kwargs)：计算x的反正切并返回，返回为弧度值 numpy.degrees(x, *args, **kwargs)：计算x的角度值并返回，x为弧度值 案例： 12345678910111213141516import numpy if __name__ == &quot;__main__&quot;: angles = numpy.array([0, 45, 60, 90, 120, 150, 180]) result = numpy.sin(angles * numpy.pi / 180) print(result) result = numpy.arcsin(result) print(numpy.degrees(result)) result = numpy.cos(angles * numpy.pi / 180) print(result) result = numpy.arccos(result) print(result) result = numpy.tan(angles * numpy.pi / 180) print(result) result = numpy.arctan(result) print(result) numpy.around(a, decimals=0, out=None)：返回指定数字的四舍五入值。 参数a表示数值，可以为数组 参数decimals表示舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置 numpy.floor(x, *args, **kwargs)：返回数值x的下舍整数 numpy.ceil(x, *args, **kwargs)：返回数值x的上入整数。 案例： 1234567891011121314151617import numpy if __name__ == &quot;__main__&quot;: a = numpy.array([1.2, 3.14, -2.5, 9.8]) print(a) result = numpy.around(a,decimals=1) print(result) result = numpy.floor(a) print(result) result = numpy.ceil(a) print(result) # output:# [ 1.2 3.14 -2.5 9.8 ]# [ 1.2 3.1 -2.5 9.8]# [ 1. 3. -3. 9.]# [ 2. 4. -2. 10.] 排序过滤 numpy.sort(a, axis=-1, kind=&#39;quicksort&#39;, order=None) 参数a为要排序的数组 参数axis，沿着axis排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序。 参数kind，用于指定排序算法，’quicksort’（快速排序），’mergesort’（归并排序），’heapsort’（堆排序）。 order：如果数组包含字段，则是要排序的字段。 numpy.sort()作为函数使用时，不修改被排序的原始array；array.sort()作为方法使用时，会对原始array修改为排序后数组array。 NumPy 提供了多种排序的方法，不同的排序算法的特征在于执行速度，最坏情况性能，所需的工作空间和算法的稳定性。快速排序最坏效率O(n^2)，是不稳定排序算法，最快的排序算法；归并排序最坏效率为O(n*log(n))，是稳定的排序算法；堆排序最坏效率为O(n*log(n))，是不稳定排序算法。 案例： 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: a = numpy.random.randint(0, 10, 10) print(a) # 排序不会改变原始数组 b = numpy.sort(a) print(a) print(b) # 排序改变数组对象 a.sort() print(a) # output:# [3 9 4 7 3 7 9 0 6 3]# [3 9 4 7 3 7 9 0 6 3]# [0 3 3 3 4 6 7 7 9 9]# [0 3 3 3 4 6 7 7 9 9] numpy.argsort(a, axis=-1, kind=&#39;quicksort&#39;, order=None)：返回数组值从小到大的索引值。 参数a为输入数组 参数axis，沿着axis排序数组的轴，如果没有数组会被展开，沿着最后的轴排序， axis=0 按列排序，axis=1 按行排序。 参数kind，用于指定排序算法，’quicksort’（快速排序），’mergesort’（归并排序），’heapsort’（堆排序）。 order: 如果数组包含字段，则是要排序的字段。 numpy.lexsort(keys, axis=None)：对多个序列进行排序,每一列代表一个序列，排序时优先照顾靠后的列。 案例： 12345678910111213import numpy if __name__ == &quot;__main__&quot;: fruits = [&quot;banana&quot;, &quot;apple&quot;, &quot;copper&quot;] dv = [&quot;c&quot;, &quot;a&quot;, &quot;b&quot;] index = numpy.lexsort((fruits, dv)) print(index) result = [fruits[i] + &quot;, &quot; + dv[i] for i in index] print(result) # output:# [1 2 0]# [&#x27;apple, a&#x27;, &#x27;copper, b&#x27;, &#x27;banana, c&#x27;] numpy.msort(a)：按第一个轴对数组a进行排序，返回排序后的数组副本，相当于 numpy.sort(a, axis=0) numpy.sort_complex(a)：对复数按照先实部后虚部的顺序进行排序。 numpy.partition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None)：指定一个数kth，对数组进行分区。小于kth的排在kth前面，大于kth的排在kth后面。 numpy.argpartition(a, kth, axis=-1, kind=&#39;introselect&#39;, order=None)：可以通过关键字 kind 指定算法沿着指定轴对数组进行分区，并返回分区后的索引。 案例： 1234567891011121314151617import numpy if __name__ == &quot;__main__&quot;: x = [1, 4, 6, 5, 8, 4, 9] print(x) result = numpy.partition(x, 5) print(result) index = numpy.argpartition(x, 3) print(index) for i in index: print(x[i], end=&quot; &quot;) # output:# [1, 4, 6, 5, 8, 4, 9]# [4 1 4 5 6 8 9]# [1 0 5 3 4 2 6]# 4 1 4 5 8 6 9 numpy.extract(condition, arr)：根据某个条件从数组中抽取元素，返回满条件的元素 参数condition用于指示数组元素是否被提取。 参数arr表示输入数组。 案例： 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: x = numpy.arange(9).reshape(3, 3) print(x) condition = numpy.mod(x, 2) == 0 print(condition) result = numpy.extract(condition, x) print(result) # output:# [[0 1 2]# [3 4 5]# [6 7 8]]# [[ True False True]# [False True False]# [ True False True]]# [0 2 4 6 8] numpy.where(condition, x=None, y=None)：返回输入数组中满足给定条件的元素的索引。 1234567891011121314import numpy if __name__ == &quot;__main__&quot;: x = numpy.random.randint(0, 10, 10) print(x) condition = numpy.where(x &gt; 5) print(condition) result = x[condition] print(result) # output:# [1 7 5 5 9 9 7 0 2 8]# (array([1, 4, 5, 6, 9]),)# [7 9 9 7 8] numpy.nonzero(a)：返回输入数组中非零元素的索引。 12345678910111213import numpy if __name__ == &quot;__main__&quot;: x = numpy.random.randint(0, 10, 10) print(x) y = numpy.nonzero(x) print(y) result = x[y] print(result)# output:# [4 9 0 5 0 3 5 9 8 2]# (array([0, 1, 3, 5, 6, 7, 8, 9]),)# [4 9 5 3 5 9 8 2] numpy.argmax(a, axis=None, out=None)：沿给定轴返回数组中最大元素的索引 numpy.argmin(a, axis=None, out=None)：沿给定轴返回数组中最小元素的索引 案例： 12345678910111213141516171819202122232425import numpy if __name__ == &quot;__main__&quot;: x = numpy.random.randint(0, 10, 10) print(x) y = numpy.argmax(x) print(y) result = x[y] print(result) print(numpy.max(x)) y = numpy.argmin(x) print(y) result = x[y] print(result) print(numpy.min(x)) # output:# [3 4 7 3 6 9 4 3 4 4]# 5# 9# 9# 0# 3# 3 字节交换 计算机中，多字节对象通常被存储为连续的字节序列。字节顺序是跨越多字节的程序对象的存储规则。 大端模式：数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，大端模式的地址由小向大增加，而数据从高位往低位放。 小端模式：数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，小端模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。 numpy.ndarray.byteswap(self, inplace=False)：将 ndarray 中每个元素中的字节进行大小端转换。 1234567891011121314151617import numpy if __name__ == &quot;__main__&quot;: x = numpy.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=numpy.int16) print(x) for i in x: print(hex(i), end=&quot; &quot;) print(&quot;\\n&quot;) result = x.byteswap(True) for i in result: print(hex(i), end=&quot; &quot;) # output:# [1 2 3 4 5 6 7 8 9]# 0x1 0x2 0x3 0x4 0x5 0x6 0x7 0x8 0x9 # # 0x100 0x200 0x300 0x400 0x500 0x600 0x700 0x800 0x900 副本和视图 副本是一个数据的完整的拷贝，如果对副本进行修改，不会影响到原始数据，物理内存不在同一位置。 视图是数据的引用，通过视图可访问、操作原有数据，但原有数据不会产生拷贝。如果对视图进行修改，会影响到原始数据，物理内存在同一位置。 在 Python 中，对象赋值本质是对象的引用。当创建一个对象，然后将其赋给另一个变量时，Python并没有拷贝对象，而只是拷贝对象的引用，称为浅拷贝。 在 Python中，当进行赋值操作时，为使两个变量互不影响，可以使用 copy 模块中的 deepcopy 方法，称为深拷贝。 通常，切片操作会返回原数据的视图，调用 ndarray 的 view() 函数会产生视图；切片操作中调用deepCopy()函数会产生副本，调用 ndarray 的 copy() 函数会产生副本。 简单的赋值不会创建数组对象的副本。 案例： 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: x = numpy.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=numpy.int16) y = x print(id(x)) print(id(y)) y.shape = [3, 3] print(x) print(y) # output:# 140621988193024# 140621988193024# [[1 2 3]# [4 5 6]# [7 8 9]]# [[1 2 3]# [4 5 6]# [7 8 9]] ndarray.view() 方会创建一个新的数组对象，view方法创建的新数组的维数更改不会更改原始数据的维数。 123456789101112131415161718import numpy if __name__ == &quot;__main__&quot;: x = numpy.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=numpy.int16) y = x.view() print(id(x)) print(id(y)) y.shape = [3, 3] print(x) print(y) # output:# 140025825882960# 140025825245024# [1 2 3 4 5 6 7 8 9]# [[1 2 3]# [4 5 6]# [7 8 9]] 使用切片创建视图修改数据会影响到原始数组，视图虽然指向原数据，但会创建新的对象。 1234567891011121314151617181920212223242526import numpy if __name__ == &quot;__main__&quot;: x = numpy.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=numpy.int16) a = x[2:] b = x[5:] print(id(x)) print(id(a)) print(id(b)) print(a) print(b) a[0] = 11 b[0] = 12 print(a) print(b) print(x) # output:# 139764960379728# 139764959741792# 139764836999776# [3 4 5 6 7 8 9]# [6 7 8 9]# [11 4 5 12 7 8 9]# [12 7 8 9]# [ 1 2 11 4 5 12 7 8 9] ndarray.copy() 函数创建一个副本， 对副本数据进行修改，不会影响到原始数据。 12345678910111213141516import numpy if __name__ == &quot;__main__&quot;: x = numpy.array([1, 2, 3, 4, 5, 6, 7, 8, 9], dtype=numpy.int16) y = x.copy() print(id(x)) print(id(y)) y[0] = 10 print(x) print(y) # output:# 139690155443024# 139690154805088# [1 2 3 4 5 6 7 8 9]# [10 2 3 4 5 6 7 8 9] numpy.copy(a, order=&#39;K&#39;)：创建给定数组a的一个副本，可以作为数组的方法使用。 1234567891011121314151617181920import numpy if __name__ == &quot;__main__&quot;: array_normal = numpy.random.normal(loc=1.75, scale=0.1, size=[5, 5]) print(array_normal) b = array_normal[1, 2].copy() print(b) # 截取第1行至第3行（不包括第3行），第2列至第4列（不包括第4列）的数据 c = numpy.copy(array_normal[1:3, 2:4]) print(c) # output:# [[1.71679806 1.85533715 1.74308905 1.75119872 1.79173827]# [1.65084866 1.8366689 1.72241261 1.71965308 1.58003833]# [1.86165973 1.84692966 1.73746162 1.81721825 1.75710235]# [1.95509949 1.90046488 1.71245928 2.00848233 1.73175004]# [1.64957638 1.80259583 1.84005861 1.85791674 1.825334 ]]# 1.7224126132538562# [[1.72241261 1.71965308]# [1.73746162 1.81721825]] NumPy.matlib 矩阵模块matlib 模块简介 NumPy 中包含了一个矩阵库 numpy.matlib，numpy.matlib模块中的函数返回的是一个矩阵，而不是 ndarray 对象。 一个 mxn的矩阵是一个由m行（row)和n列（column）元素排列成的矩形阵列，矩阵里的元素可以是数字、符号或数学式。 矩阵创建 numpy.matlib.empty(shape, dtype, order)：创建矩阵，填充随机数据。 shape参数，定义新矩阵形状的整数或整数元组。 dtype参数，可选，数据类型。 order参数，可选项为C（行序优先） 或者 F（列序优先）。 矩阵是二维的，而 ndarray 是一个 n 维数组。 矩阵与ndarray是可互换的。 numpy.matlib.zeros(shape, dtype=None, order=&#39;C&#39;)：创建一个以 0 填充的矩阵。 numpy.matlib.ones(shape, dtype=None, order=&#39;C&#39;)：创建一个以 1 填充的矩阵。 numpy.matlib.eye(n, M,k, dtype)：numpy.matlib.eye() 函数返回一个矩阵，对角线元素为 1，其他位置为零。 n：返回矩阵的行数 M：返回矩阵的列数，默认为 n k：对角线的索引 dtype：数据类型 numpy.matlib.identity(n,dtype=None)：返回给定大小的单位矩阵。 单位矩阵是个方阵，从左上角到右下角的对角线（称为主对角线）上的元素均为 1，除此以外全都为 0。 numpy.matlib.rand(*args)：创建一个给定大小的矩阵，数据是随机填充的。 NumPy.linalg 线性代数模块linalg 线性代数模块NumPy 提供了线性代数函数库 linalg，linalg库包含了线性代数所需的所有功能。 线性代数运算 numpy.dot(a, b, out=None)：两个数组的点积，对应数组元素相乘。 a : ndarray 数组 b : ndarray 数组 out : ndarray, 可选，用来保存dot()的计算结果 对于两个一维的数组，计算的是两个数组对应下标元素的乘积和(数学上称为内积)；对于二维数组，计算的是两个数组的矩阵乘积；对于多维数组，通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和。 numpy.vdot(a, b)：两个向量的点积。 如果第一个参数是复数，那么其共轭复数会用于计算。 如果参数是多维数组，会被展开。 numpy.inner(a, b)：返回一维数组的向量内积。对于更高的维度，返回最后一个轴上的和的乘积。 numpy.matmul(x1, x2, *args, **kwargs)：返回两个数组的矩阵乘积，但如果任一参数的维数大于2，则将其视为存在于最后两个索引的矩阵的栈，并进行相应广播。另一方面，如果任一参数是一维数组，则通过在其维度上附加 1 来将其提升为矩阵，并在乘法后被去除。 对于二维数组，它就是矩阵乘法：numpy.linalg.det(a) 计算输入矩阵的行列式。 行列式在线性代数中是非常有用的值，从方阵的对角元素计算。 对于 2×2 矩阵，是左上和右下元素的乘积与其他两个的乘积的差。 对于矩阵[[a，b]，[c，d]]，行列式计算为 ad-bc。 较大的方阵被认为是 2×2 矩阵的组合。 numpy.linalg.solve(a, b)：求解线性矩阵方程。 numpy.linalg.inv(a)：计算矩阵的乘法逆矩阵。 逆矩阵（inverse matrix）：设A是数域上的一个n阶矩阵，若在相同数域上存在另一个n阶矩阵B，使得： AB=BA=E ，则称B是A的逆矩阵，而A则被称为可逆矩阵，E为单位矩阵。 NumPy IO操作 Numpy 可以读写磁盘上的文本数据或二进制数据。 NumPy 为 ndarray 对象引入了一个简单的文件格式：npy。 npy 文件用于存储重建 ndarray 所需的数据、图形、dtype 和其他信息。 numpy.save(file, arr, allow_pickle=True, fix_imports=True) 将数组以未压缩的原始二进制格式保存在扩展名为 .npy 的文件中。 参数file，要保存的文件，扩展名为 .npy，如果文件路径末尾没有扩展名 .npy，扩展名会被自动加上。 参数arr:，要保存的数组。 参数allow_pickle， 可选，布尔值，允许使用 Python pickles 保存对象数组，Python 中的 pickle 用于在保存到磁盘文件或从磁盘文件读取前，对对象进行序列化和反序列化。 参数fix_imports:，可选，为了方便 Pyhton2 中读取 Python3 保存的数据。 numpy.load(file, mmap_mode=None, allow_pickle=False, fix_imports=True,encoding=&#39;ASCII&#39;)：加载npy文件 file参数，文件名。 案例： 12345678910111213import numpy if __name__ == &quot;__main__&quot;: a = numpy.arange(0, 12).reshape([3, 4]) numpy.save(&quot;outfile.npy&quot;, a) b = numpy.load(&quot;outfile.npy&quot;) print(b) # output:# [[ 0 1 2 3]# [ 4 5 6 7]# [ 8 9 10 11]] numpy.savez(file, *args, **kwds)：将多个数组以未压缩的原始二进制格式保存在扩展名为 .npz 的文件中。 参数file，要保存的文件，扩展名为 .npz，如果文件路径末尾没有扩展名 .npz，扩展名会被自动加上。 参数args，要保存的数组，可以使用关键字参数为数组起一个名字，非关键字参数传递的数组会自动起名为 arr_0, arr_1。 参数kwds:，要保存的数组使用关键字名称。 案例： 123456789101112131415161718192021import numpy if __name__ == &quot;__main__&quot;: a = numpy.array([[1, 2, 3], [4, 5, 6]]) b = numpy.arange(0, 1.0, 0.1) c = numpy.sin(b) # c 使用了关键字参数 sin_array numpy.savez(&quot;outfile.npz&quot;, a, b, sin_array=c) r = numpy.load(&quot;outfile.npz&quot;) print(r.files) # 查看各个数组名称 print(r[&quot;arr_0&quot;]) print(r[&quot;arr_1&quot;]) print(r[&quot;sin_array&quot;]) # output:# [&#x27;sin_array&#x27;, &#x27;arr_0&#x27;, &#x27;arr_1&#x27;]# [[1 2 3]# [4 5 6]]# [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]# [0. 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554# 0.56464247 0.64421769 0.71735609 0.78332691] numpy.loadtxt(file, dtype=int, delimiter=&#39; &#39;)：以简单的文本文件格式读取数据。 参数file为要加载的文件名 参数dtype为数据类型 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。 numpy.savetxt(file, a, fmt=&quot;%d&quot;, delimiter=&quot;,&quot;)：以简单的文本文件格式存储数据。 参数file为要加载的文件名 参数a为要保存的数组 参数fmt为格式化字符串 参数 delimiter 可以指定各种分隔符、针对特定列的转换器函数、需要跳过的行数等。 案例： 1234567891011121314import numpy if __name__ == &quot;__main__&quot;: b = numpy.arange(0, 1.0, 0.1) c = numpy.sin(b) numpy.savetxt(&quot;outfile.txt&quot;, (b, c)) r = numpy.loadtxt(&quot;outfile.txt&quot;) print(r) # output:# [[0. 0.1 0.2 0.3 0.4 0.5# 0.6 0.7 0.8 0.9 ]# [0. 0.09983342 0.19866933 0.29552021 0.38941834 0.47942554# 0.56464247 0.64421769 0.71735609 0.78332691]]","categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"}]},{"title":"Python迭代器与生成器","slug":"迭代器与生成器","date":"2021-06-03T16:11:15.000Z","updated":"2021-06-03T16:15:49.426Z","comments":true,"path":"510c5b795b01/","link":"","permalink":"https://ozzienicholas.gitee.io/510c5b795b01/","excerpt":"","text":"前言迭代是Python中常用且非常强大的一个功能，它可以用于访问集合、列表、字符串、字典等数据结构的元素。我们经常使用循环和条件语句，我们也清楚哪些是可以迭代访问，但是具体它们之间有什么有什么异同之处？有哪些特点？什么是迭代器、什么是生成器、什么是可迭代对象？这些问题对于初学者而言却是很少去细致的研究，本文就来详细阐述一下它们之间的关系已经它们的特别之处。 可迭代对象 在讲解迭代器和生成器之前，先介绍一下可迭代对象。 可迭代对象是Python中一个非常庞大的概念，它主要包括如下三类： 迭代器（iterator） 生成器（generator） 序列 字符串（str） 列表（list） 元组（tuple） 集合（set） 字典 迭代器是可迭代对象的一个子集，而生成器又是迭代器的一个子集，是一种特殊的迭代器。除了迭代器之外，Python中还有序列、字典等可迭代对象。 现在已经直观的了解了可迭代对象与迭代器、生成器之间的关系，那么用Python语言怎么表述它们的区别呢？ 可迭代对象需要实现__iter__方法 迭代器不仅要实现__iter__方法，还需要实现__next__方法 在使用层面，可迭代对象可以通过 in 和 not in 访问对象中的元素，举一个例子： 123456789101112131415161718X = set([1,2,3,4,5])print(X)print(type(X))print(1 in X)print(2 not in X)for x in X: print(x) # 输出&#123;1, 2, 3, 4, 5&#125;&lt;class &#x27;set&#x27;&gt;TrueFalse12345 前面提到，可迭代对象实现了iter方法，但是它没有实现next，这也是判定迭代器和其他可迭代对象的关键之处，可以看一下通过next访问上述示例中可迭代对象X会报错： 1234next(X)# 输出TypeError: &#x27;set&#x27; object is not an iterator 报的错误是**’set’ object is not an iterator**，它指明了set集合是一个可迭代对象，但不是迭代器，下面就来介绍一下迭代器。 迭代器 迭代器是可迭代对象的一个子集，它是一个可以记住遍历的位置的对象，它与列表、元组、集合、字符串这些可迭代对象的区别就在于next方法的实现，其他列表、元组、集合、字符串这些可迭代对象可以很简单的转化成迭代器，通过Python内置的iter函数能够轻松把可迭代对象转化为迭代器，下面来看一个例子： 1234567891011121314X = [1,2,3,4,5]print(type(X))Y = iter(X)print(type(Y))print(next(Y))print(next(Y))print(next(Y))# 输出&lt;class &#x27;list&#x27;&gt;&lt;class &#x27;list_iterator&#x27;&gt;123 从上述示例中我们可以看出两点： 通过iter函数把list转化成了迭代器 可迭代器能够记住遍历位置，能够通过next方法不断从前往后访问 除了Python内置的iter之外，还可以通过Python内置的工具包itertools创建迭代器，其中函数包括： count cycle repeat accumulate chain compress dropwhile islice product permutations combinations itertools中包含很多用于创建迭代器的实用方法，如果感兴趣可以访问官方文档进行详细了解。 当然，也可以自己通过实现iter和next方法来定义迭代器： 12345678910111213141516171819202122232425262728class Iterator(object): def __init__(self, array): self.x = array self.index = 0 def __iter__(self): return self def __next__(self): if self.index &lt; len(self.x): value = self.x[self.index] self.index += 1 else: raise StopIteration return value it = Iterator([1,2,3,4,5])print(type(it))for i in it: print(i)# 输出&lt;class &#x27;__main__.Iterator&#x27;&gt;12345 生成器 生成器是迭代器的子集，换句话说，生成器一定是迭代器，但是迭代器不全是生成器对象。 提及生成器就不得不提及一个Python中的关键字yiled，在Python中一个函数可以用yiled替代return返回值，这样的话这个函数就变成了一个生成器对象，举个例子对比一下： 123456789def generator(array): for i in array: return i gen = generator([1,2,3,4,5])print(type(gen))# 输出&lt;class &#x27;int&#x27;&gt; 这是我们常见的return返回方式，这样的话generator函数获取的是一个int型对象，下面看一下换成yield关键字： 123456789def generator(array): for i in array: yield(i) gen = generator([1,2,3,4,5])print(type(gen))# 输出&lt;class &#x27;generator&#x27;&gt; 这样的话获取的是一个生成器generator，除了yield之外，在Python3.3之后还加入了yield from获取生成器，允许一个生成器将其部分操作委派给另一个生成器，使得生成器的用法变得更加简洁，yield from后面需要加上可迭代对象，这样可以把可迭代对象变成生成器，当然，这里的可迭代对象不仅包含列表、元组，还包含迭代器、生成器。yield from相对于yield的有几个主要优点： 代码更加简洁 可以用于生成器嵌套 易于异常处理 下面就从简洁代码方面举个例子说明一下： 1234567891011121314def generator(array): for sub_array in array: yield from sub_arraygen = generator([(1,2,3), (4,5,6,7)])# 输出1234567 当我们需要访问多层/多维可迭代对象时，我们就不需要逐层的去用for … in …**去访问，可以简单的通过yiled from把生成器委派给子生成器，除此之外还可以通过生成器表达式**的方法得到生成式，后面会介绍。 123456print(next(gen))print(next(gen))# 输出12 通过上面示例可以看出，生成器可以像迭代器那样使用iter和next方法。 读到这里可以会有疑惑，从这个示例看来生成器和迭代器并没有什么区别啊？为什么生成器还可以称得上是Python中的一大亮点？ 首先它对比于迭代器在编码方面更加简洁，这是显而易见的，其次生成器运行速度更快，最后一点，也是需要着重说明的一点：节省内存。 也许在一些理论性实验、学术论文阶段可以不考虑这些工程化的问题，但是在公司做项目时，内存和资源占用是无法逃避的问题 。如果我们使用其他可迭代对象处理庞大的数据时，当创建或者返回值时会申请用于存储整个可迭代对象的内存，显然这是非常浪费的，因为有的元素当前我们用不到，也不会去访问，但它却一直占用这内存。这时候就体现了生成器的优点，它不是一次性把所有的结果都返回，而是当我们每读取一次，它会返回一个结果，当我们不读取时，它就是一个生成器表达式，几乎不占用内存。 生成器表达式 首先来看一个对比示例： 1234567891011X = [1, 2, 3, 4, 5]it = [i for i in X]gen = (i for i in X)print(type(X))print(type(it))print(type(gen))# 输出&lt;class &#x27;list&#x27;&gt;&lt;class &#x27;list&#x27;&gt;&lt;class &#x27;generator&#x27;&gt; 首先说一下it = [i for i in X]**，这种用法叫做列表生成式，在很多编程规范中非常推崇的一种替代for循环的方式，仔细看一下代码会发现，it = [i for i in X]与gen = (i for i in X)**的区别非常小，只是一个用了中括号，一个用了小括号，但是它们的区别缺失非常大的，使用中括号的叫做列表生成式，获得的返回值是一个列表，而使用小括号叫做生成器表达式，获得的返回结果是一个生成器，这也是前面提到的，除了使用yield和yield from两个关键字外还可以使用生成器表达式获得生成器。","categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"}]},{"title":"Python文件操作","slug":"文件操作","date":"2021-06-03T16:10:41.000Z","updated":"2021-06-03T16:14:37.231Z","comments":true,"path":"519bde586d61/","link":"","permalink":"https://ozzienicholas.gitee.io/519bde586d61/","excerpt":"","text":"Python —— 文件操作 Python File close() 方法： 描述： Python 文件对象的 close() 方法用于关闭一个已打开的文件 关闭后的文件不能再进行读写操作，否则会触发 ValueError 错误 close() 方法允许调用多次 当 file 对象，被引用到操作另外一个文件时，Python 会自动关闭之前的 file 对象 当不再需要时，使用 close() 方法关闭文件是一个良好的编程习惯 语法： 1fileObject.close(); 案例： 123456# 打开文件fp = open(&quot;demo.txt&quot;, &quot;wb&quot;)print ( &quot;文件名为: &quot;, fp.name )# 关闭文件fp.close() 运行结果： 1文件名为: demo.txt Python File flush() 方法： 描述： Python 文件对象的 flush() 方法用于刷新缓冲区的，即将缓冲区中的数据立刻写入文件，同时清空缓冲区，不需要是被动的等待输出缓冲区写入 一般情况下，文件关闭后会自动刷新缓冲区，但如果想要在关闭前刷新它，就要使用 flush() 方法 语法： 1fileObject.flush(); 案例： 123456789# 打开文件fp = open(&quot;demo.txt&quot;, &quot;wb&quot;)print ( &quot;文件名为: &quot;, fp.name )# 刷新缓冲区fp.flush()# 关闭文件fp.close() 运行结果： 1文件名为: demo.txt Python File fileno() 方法： 描述： Python 文件对象的 fileno() 方法返回一个整型的文件描述符( fd ) 该文件描述符可用于底层操作系统的 I/O 操作 语法： 1fileObject.fileno(); 返回值：返回文件描述符 案例： 123456789# 打开文件fp = open(&quot;demo.txt&quot;, &quot;wb&quot;)print ( &quot;文件名为: &quot;, fp.name )fid = fp.fileno()print ( &quot;文件描述符为: &quot;, fid )# 关闭文件fp.close() 运行结果： 12文件名为: demo.txt文件描述符为: 3 Python File isatty() 方法： 描述：Python 文件对象的 isatty() 方法用于检测文件是否连接到一个终端设备，如果是返回 True，否则返回 False 语法： 1fileObject.isatty(); 返回值：如果连接到一个终端设备返回 True，否则返回 False 案例： 123456789# 打开文件fp = open(&quot;demo.txt&quot;, &quot;wb&quot;)print ( &quot;文件名为: &quot;, fp.name )ret = fp.isatty()print ( &quot;返回值 : &quot;, ret )# 关闭文件fp.close() 运行结果： 12文件名为: demo.txt返回值 : False Python 3 File next() 方法： 描述： Python 3 中的 File 对象不支持 next() 方法 Python 3 的内置函数 next() 通过迭代器调用文件对象的 __next__() 方法返回下一项 在循环中，next() 方法会在每次循环中调用，该方法返回文件的下一行，如果到达结尾( EOF ),则触发 StopIteration 语法： 1next(iterator[,default]) 参数： 返回值：返回文件下一行，如果到达文件末尾，则触发 StopIteration 异常 案例： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码在循环中使用 next() 方法输出文件的下一行 12345678910# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name )for index in range(5): line = next(fp) print ( &quot;第 %d 行 - %s&quot; % (index, line) )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下： 12345678910文件名为: demo.txt第 0 行 - www.xxx.cn第 1 行 - www.xxx.cn第 2 行 - www.xxx.cn第 3 行 - www.xxx.cn第 4 行 - www.xxx.cn Python File read() 方法： 描述： Python 文件对象的 read() 方法用于从文件读取指定的字节数 如果未给定或为负则读取所有 语法： 1fileObject.read(); 参数：size： 从文件中读取的字节数 返回值：返回从字符串中读取的字节 案例： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码使用 read() 方法从文件 demo.txt 中读取内容 123456789# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name )line = fp.read(10)print ( &quot;读取的字符串: %s&quot; % (line) )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 12文件名为: demo.txt读取的字符串: www.xxx.c Python File readline() 方法： 描述： Python 文件对象的 readline() 方法用于从文件读取整行，包括 “\\n” 字符 如果指定了一个非负数的参数，则返回指定大小的字节数，包括 “\\n” 字符 语法： 1fileObject.readline(); 参数：size：从文件中读取的字节数 返回值：返回从字符串中读取的字节 案例： 假设当前目录下存在文件 demo.txt 内容如下 123456789101112# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name )line = fp.readline()print ( &quot;读取第一行 %s&quot; % (line) )line = fp.readline(5)print ( &quot;读取的字符串为: %s&quot; % (line) )# 关闭文件fp.close() 运行以上 Python 范例，输出结果如下 1234文件名为: demo.txt读取第一行 www.xxx.cn读取的字符串为: www.t Python File readlines() 方法： 描述： Python 文件对象的 readlines() 方法用于读取所有行(直到结束符 EOF) 并返回每行组成列表 若给定 sizeint &gt; 0，返回总和大约为 sizeint 字节的行, 实际读取值可能比 sizhint 较大, 因为需要填充缓冲区 如果碰到结束符 EOF 则返回空字符串 语法： 1fileObject.readlines( sizehint ) 参数：sizehint：从文件中读取的字节数 返回值：返回列表，包含所有的行 案例： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码使用 readlines() 方法读取所有的行 12345678910111213# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name )line = fp.readlines()print ( &quot;读取的数据为: %s&quot; % (line))line = fp.readlines(2)print ( &quot;读取的数据为: %s&quot; % (line))# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 123文件名为: demo.txt读取的数据为: [&#x27;www.xxx.cn\\n&#x27;, &#x27;www.xxx.cn\\n&#x27;, &#x27;www.xxx.cn\\n&#x27;, &#x27;www.xxx.cn\\n&#x27;, &#x27;www.xxx.cn\\n&#x27;]读取的数据为: [] Python File seek() 方法： 描述：Python 文件对象的 seek() 方法用于移动文件读取指针到指定位置 语法： 1fileObject.seek(offset[, whence]) 参数： 案例： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码使用 seek() 方法重置了文件对象的游标 123456789101112131415# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name )line = fp.readline()print ( &quot;读取的数据为: %s&quot; % (line) )# 重新设置文件读取指针到开头fp.seek(0, 0)line = fp.readline()print ( &quot;读取的数据为: %s&quot; % (line) )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 1234文件名为: demo.txt读取的数据为: www.xxx.cn读取的数据为: www.xxx.cn Python File tell() 方法： 描述：Python 文件对象的 tell() 方法返回文件的当前游标位置，即文件指针当前位置 语法： 1fileObject.tell() 返回值：返回文件的当前位置 案例： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码使用 tell() 显示文件游标的位置 1234567891011121314# 打开文件fp = open(&quot;demo.txt&quot;, &quot;rw+&quot;)print ( &quot;文件名为: &quot;, fp.name ) line = fp.readline()print ( &quot;读取的数据为: %s&quot; % (line) ) # 获取当前文件位置pos = fp.tell()print ( &quot;当前位置: %d&quot; % (pos) )# 关闭文件fp.close() 运行以上 Pyhton 代码，输出结果如下 1234文件名为: demo.txt读取的数据为: www.xxx.cn当前位置: 12 Python File truncate() 方法： 描述：Python 文件对象的 truncate() 方法用于截断文件 如果指定了可选参数 size，则表示截断文件为 size 个字符 , 截断之后 size 后面的所有字符被删除 如果没有指定 size，则从当前位置起截断 语法： 1fileObject.truncate( [ size ]) 参数：size：可选，如果存在则文件截断为 size 字节 案例一： 假设当前目录下存在文件 demo.txt 内容如下 12345www.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cnwww.xxx.cn 下面的代码使用 truncate() 将文件 demo.txt 截断为只保留第一行 12345678910111213141516# 打开文件fp = open(&quot;demo.txt&quot;, &quot;r+&quot;)print ( &quot;文件名为: &quot;, fp.name )line = fp.readline()print ( &quot;读取第一行: %s&quot; % (line) )# 截断剩下的字符串fp.truncate()# 尝试再次读取数据line = fp.readline()print ( &quot;读取数据: %s&quot; % (line) )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 1234文件名为: demo.txt读取第一行: www.twle.cn读取数据: 打开文件 demo.txt 可以看到内容如下 1www.twle.cn 案例二： 针对同样的 demo.txt 文件 下面的代码使用 truncate() 方法将 demo.txt 文件截断为 10 个字符 123456789101112# 打开文件fp = open(&quot;demo.txt&quot;, &quot;r+&quot;)print ( &quot;文件名为: &quot;, fp.name )# 截取10个字节fp.truncate(10)str = fp.read()print ( &quot;读取数据: %s&quot; % (str) )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 12文件名为: demo.txt读取数据: www.twle.c 打开 demo.txt 文件，可以看到内容如下 1www.twle.c Python File write() 方法： 描述： Python 文件对象的 write() 方法用于向文件中写入指定字符串 在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的 语法： 1fileObject.write( [ str ]) 参数：str：要写入文件的字符串 案例： 下面的代码使用 write() 方法向 demo.txt 文件写入一些数据 12345678# 打开文件fp = open(&quot;demo.txt&quot;, &quot;w&quot;)print ( &quot;文件名为: &quot;, fp.name )str = &quot;python编程&quot;fp.write( str )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 1文件名为: demo.txt 打开文件 demo.txt，可以看到如下内容 12$ cat demo.txt python编程 Python File writelines() 方法： 描述： Python 文件对象的 writelines() 方法用于向文件中写入一序列的字符串 这一序列字符串可以是由迭代对象产生的，如一个字符串列表 注意： 该方法不会自动给每一行添加换行符 (\\n) ，需要自己手动添加 语法： 1fileObject.writelines( [ str ]) 参数：str：要写入文件的字符串序列 案例： 下面的范例使用 writelines() 写入一个字符串列表到文件 demo.txt 12345678# 打开文件fp = open(&quot;demo.txt&quot;, &quot;w&quot;)print ( &quot;文件名为: &quot;, fp.name )seq = [&quot;Python编程 1\\n&quot;, &quot;Python编程 2&quot;]fp.writelines( seq )# 关闭文件fp.close() 运行以上 Python 代码，输出结果如下 1文件名为: demo.txt 我们可以查看 demo.txt 文件内容，显示如下 123$ cat demo.txt Python编程 1Python编程 2","categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"}]},{"title":"CDC_Fully_Vaccinated_People","slug":"CDC-Fully-Vaccinated-People","date":"2021-04-28T01:45:04.000Z","updated":"2021-04-28T03:03:08.508Z","comments":true,"path":"abd437a364b8/","link":"","permalink":"https://ozzienicholas.gitee.io/abd437a364b8/","excerpt":"","text":"Headline CDC: Fully Vaccinated People Do Not Need to Wear Masks Outside In Most Cases. 疾病控制与预防中心：在大多数情况下，完全接种疫苗的人在户外不需要戴口罩 单词 词义 wear v. 穿，戴，损耗；n. 衣服，耐磨性，损耗 Introduction Vaccinated people will still need to wear a mask outdoors in crowded settings until widespread vaccination is achieved, according to the CDC. 根据疾病控制与预防中心的说法，在广泛的疫苗接种实现之前，接种过疫苗的人仍然需要在户外拥挤的环境中佩戴口罩。 单词 词义 widespread adj. 普遍的，广泛的，分布广的 Content Fully vaccinated individuals can safely attend small gatherings outdoors without wearing masks, the Centers for Disease Control and Prevention announced on Tuesday. 美国疾病控制与预防中心(Centers for Disease Control and Prevention)周二宣布，完全接种疫苗的人可以安全地参加小型户外集会，而不戴口罩。 单词 词义 individual adj. 个人的，独特的；n. 个人，个体 announce v. 宣布，述说，预示，警报 gather v. 收集，聚集，采集，皱起；n. 聚集，聚会 “If you’re fully vaccinated and want to attend a small outdoor gathering with people who are vaccinated and unvaccinated, or dine at an outdoor restaurant with friends from multiple households, the science shows – if you’re vaccinated – you can do so safely unmasked,” CDC Director Rochelle Walensky said at a press briefing. “如果你已经接种了疫苗，想和接种疫苗以及未接种疫苗的人一起参加一个小型户外聚会，或者和多个家庭的朋友一起在户外餐厅用餐，科学表明，如果你接种了疫苗，你可以安全地不戴口罩。”疾病预防控制中心主任罗谢尔·瓦伦斯基在一次新闻发布会上说。 单词 词义 dine v. 宴请，进餐 restaurant n. 餐馆 multiple adj. 许多的，多重的，多样的 household n. 一家人，一户，王室；adj. 家庭的，家用的 press v. 按，压，逼迫；n. 出版社，（新闻）发布会 brief adj. 简短的，简洁的，短暂的，草率的；n. 摘要，概要 press briefing 新闻发布会，记者招待会 Walensky said that “generally, for vaccinated people, outdoor activities without a mask are safe.” A growing body of evidence suggests that the risk of transmitting COVID-19 outdoors is significantly smaller than indoor transmission. But experts warn that the risk isn’t zero, and infections can still happen outside. Walensky说：“一般来说，对接种疫苗的人来说，不带口罩的户外活动是安全的。”越来越多的证据表明，COVID-19在室外传播的风险明显小于在室内传播。但专家警告说，这种风险不是零，感染仍可能发生在室外。 单词 词义 generally adv. 通常，一般 risk n. 风险，危险，冒险；v. 冒险 transmit v. 传输，传播，发射，遗传 significant adj. 重大的，有意义的，有效的；n. 象征，有意义的事务 warn v. 警告，提醒，通知 infection n. 感染，传染，影响，传染病 The CDC still recommends vaccinated people wear masks in crowded outdoor settings like concerts where social distancing might not be possible and unvaccinated people might be in attendance. 美国疾病控制与预防中心仍然建议接种疫苗的人在拥挤的户外场所如音乐会时戴口罩，因为这些场所可能无法保持社交距离，而且未接种疫苗的人可能会出席。 单词 词义 recommend v. 推荐，建议，出席，劝告，介绍 distance n. 距离，远方，间隔，疏远；v. 疏远 attendance n. 出席，到场，考勤 “We will continue to recommend this until widespread vaccination is achieved,” Walensky said. Walensky说：“我们将继续推荐这种方法，直到实现广泛的疫苗接种。” 单词 词义 achieve v. 取得，获得，实现，成功 She added that vaccinated individuals who have waited two weeks after their final dose can safely resume some indoor activities while wearing a mask. Those activities include going to a movie theater, attending a worship service, attending a small gathering inside, participating in a high-intensity exercise class and eating at an indoor restaurant or bar. 她补充说，在最后一次注射后等待两周的接种者可以戴着口罩安全地恢复一些室内活动。这些活动包括去电影院、参加礼拜、参加室内的小型聚会、参加高强度的锻炼课程和在室内餐厅或酒吧吃饭。 单词 词义 resume v. 重新开始，继续，恢复；n. 摘要，（个人）简历 theater n. 电影院，戏院，剧场 worship n. 崇拜，礼拜，尊敬；v. 敬奉，崇拜，做礼拜 participate v. 参与，参加，分享，分担 intensity n. 强度，强烈，亮度，紧张 bar n. 酒吧，法庭，条，棒；v. 禁止，阻拦；prep. 除…外 “Although these vaccines are extremely effective, we know that the virus spreads very well indoors,” Walensky said. “Until more people are vaccinated and while we still have more than 50,000 cases a day, mask use indoors will provide extra protection.” “尽管这些疫苗非常有效，但我们知道病毒在室内传播得非常好，”Walensky说。“在更多的人接种疫苗之前，尽管我们每天仍有超过5万例病例，但在室内使用口罩将提供额外保护。” 单词 词义 extra adj. 额外的，特大的；n. 额外的事物；adv. 额外，特别地 Unvaccinated people can also safely exercise with members of their household outdoors without a mask or attend a small outdoor gathering with fully vaccinated family and friends without a mask. 未接种疫苗的人也可以在不戴口罩的情况下与家人在户外安全锻炼，或与已接种疫苗的家人和朋友在不戴口罩的情况下参加小型户外聚会。 单词 词义 vaccinate v. 接种疫苗，给…注射疫苗；n. 疫苗接种者 The guidance comes as over 95 million people – nearly 29% of the total U.S. population – are fully vaccinated against the coronavirus, according to CDC data. More than 42% of the population has gotten at least one dose of the vaccine. As the vaccination effort moves on from those who want the shot the most to other groups, the rate is expected to fluctuate. 根据美国疾病控制与预防中心的数据，该指南发布之际，超过9500万人——近29%的美国总人口——已经完全接种了冠状病毒疫苗。超过42%的人口至少接种了一剂疫苗。随着疫苗接种工作从最希望接种疫苗的人群转向其他群体，预计接种比例将出现波动。 单词 词义 guidance n. 指导，引导，领导 against prep. 反对，违反，针对，迎战 coronavirus n. 冠状病毒 dose n. 剂量，一剂，一服；v. 服药，给…服药 rate n. 比率，速度，价格，等级；v. 认为，估价 fluctuate v. 波动，涨落，动摇 The CDC and the Food and Drug Administration last week lifted the recommended pause on the use of the Johnson &amp; Johnson coronavirus vaccine after examining a small number of cases of rare and severe blood clots in people who received the shot. The move came just hours after a CDC advisory committee gave its endorsement to resuming using the vaccine in people ages 18 and older. 美国疾病控制与预防中心(CDC)和美国食品药品监督管理局(FDA)上周取消了暂停使用强生(Johnson &amp; Johnson)冠状病毒疫苗的建议，此前，美国疾病控制与预防中心(CDC)和美国食品药品监督管理局(Food and Drug Administration)对接种该疫苗的人进行了少量罕见和严重的血块检查。就在几小时前，美国疾病控制与预防中心咨询委员会批准在18岁及以上人群中恢复使用疫苗。 单词 词义 lift v. 举起，抬头（看），提高；n. 电梯，举起 clot n. 凝块，黏团（尤指血块）；v. 凝结 advisory adj. 咨询的，顾问的，劝告的；n. 报告，公告 committee n. 委员会，理事会 According to CDC data, over 8 million doses of the Johnson &amp; Johnson vaccine have been administered. Close to 10 million additional doses have been delivered to states and territories and are ready for use. 根据CDC的数据，已经使用了超过800万剂强生疫苗。已向各州和地区运送了近1000万剂疫苗，随时可供使用。 单词 词义 deliver v. 交付，发表，递送，给予，实现；n. 投球 territory n. 领土，领域，范围，地域，版图 Note This article is excerpted from The New York Times. The link to the original article is “CDC: Fully Vaccinated People Do Not Need to Wear Masks Outside In Most Cases”","categories":[{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"}],"tags":[{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"}]},{"title":"Biden_to_Keep","slug":"Biden-to-Keep","date":"2021-04-17T10:59:50.000Z","updated":"2021-04-22T01:47:59.235Z","comments":true,"path":"5ab692b9249a/","link":"","permalink":"https://ozzienicholas.gitee.io/5ab692b9249a/","excerpt":"","text":"Headline Biden to Keep Refugee Admissions Cap at Record-Low Set by Trump, Reversing Earlier Pledge. 拜登将把难民准入上限保持在川普创下的历史最低水平，推翻了此前的承诺。 单词 词义 refugee n. 难民，避难者，逃亡者 admission n. 承认，坦白，录用，入场费 cap n. 盖，帽子；v. 覆盖，胜过，脱帽致意，给…戴帽 pledge n. 保证，誓言，抵押品；v. 保证，许诺，用 … 抵押 Introduction Biden moved to revise controversial regional refugee limits set by the Trump administration but will keep refugee admissions in fiscal 2021 to a historically low 15,000. 拜登修改了特朗普政府设定的有争议的地区难民限制，但将在2021财年将难民接收人数保持在历史最低的1.5万人。 单词 词义 revise v. 修正，复习，修订；n. 修订，校订 move to 移动到，倾向于 controversial adj. 有争议的，有争论的 regional adj. 地区的，局部的，整个地区的 Content President Joe Biden will keep the cap on the number of refugees allowed into the country this year at the historically low level set by the Trump administration, reneging on a pledge made just months ago to welcome more than 60,000 refugees into the U.S. through the end of the fiscal year in September. 美国总统拜登（Joe Biden）将把今年允许入境的难民人数上限维持在特朗普政府设定的历史最低水平，违背几个月前作出的承诺，即在9月份财政年度结束前欢迎超过6万难民入境。 单词 词义 renege v. 食言，否认，违约；n. 藏牌 Biden in February pledged to open the U.S for more people fleeing persecution and said he planned to raise the refugee ceiling from the 15,000 set for fiscal 2021 by the former administration to 62,500. 拜登今年2月承诺向更多逃离迫害的难民开放美国，并表示他计划将前政府为2021财年设定的难民上限从1.5万人提高到6.25万人。 单词 词义 persecution n. 迫害，烦扰 ceiling n. 天花板，上限 ceil v. 进一步取整 The president instead issued a presidential determination on Friday that could speed admissions but kept the cap at 15,000. The order does, however, reallocate controversial regional limits set by the Trump administration, designating more refugee spots for people from Africa, Central America and the Middle East, and doing away with Trump-era restrictions on refugees from Somalia, Syria and Yemen. 相反，总统在周五发布了一项总统决定，可能会加快招生速度，但将上限保持在1.5万人。然而，该命令确实重新分配了特朗普政府设定的有争议的地区限制，为来自非洲、中美洲和中东的人指定了更多的难民地点，并废除了特朗普时代对来自索马里、叙利亚和也门的难民的限制。 单词 词义 reallocate v. 重新分配，再指派 restriction n. 限制，约束，束缚 designate v. 指定，指派，任命，把…定命为；adj. 指定的，选定的 If the 15,000-refugee limit is met before the end of the fiscal year, “a subsequent Presidential Determination may be issued to increase admissions, as appropriate,” Friday’s determination said. 周五的决定说，如果在本财政年度结束前达到1.5万名难民的上限，“总统可能会发布后续决定，酌情增加接收人数”。 单词 词义 subsequent adj. 随后的，后来的 appropriate adj. 适当的，恰当的，合适的 “America needs to rebuild our refugee resettlement program. We will use all 15,000 slots under the new Determination and work with Congress on increasing admissions and building back to the numbers to which we’ve committed,” Jake Sullivan, the White House national security adviser, said in a tweet. “美国需要重建我们的难民安置项目。根据新的决定，我们将使用所有1.5万个名额，并与国会合作，增加招生人数，恢复到我们承诺的数量，”白宫国家安全顾问杰克·沙利文(Jake Sullivan)在twitter上说。 单词 词义 resettle v. （使）重新定居，（重新）安置 slot n. 位置，水沟；v. 跟踪，开槽于… The move to keep the cap at a historic low drew immediate condemnation from immigration advocates, refugee service providers and others, and marks a significant reversal from the Biden administration’s early, full-throated pledges to rebuild immigration systems decimated under Trump. 将移民上限保持在历史低点的举动立即招致了移民倡导者、难民服务提供者等人的谴责，标志着拜登政府早期高调承诺重建在特朗普执政期间遭到重创的移民体系的重大转变。 单词 词义 condemnation n. 谴责，定罪 advocate v. 提倡，拥护，为…辩护；n. 提倡者，拥护者，辩护律师 significant adj. 重大的，有效的，有意义的；n. 象征，有意义的事物 full-throated 高声喧嚷的，声音洪亮的 throat n. 喉咙，嗓子，嗓音；v. 开沟于…，用喉音说 “It’s going to take time to rebuild what has been so badly damaged. But that’s precisely what we’re going to do,” Biden said during a speech at the State Department in February. Biden also pledged to raise the refugee ceiling for 2022 to 125,000. The White House did not comment Friday on next year’s refugee determination. “重建被严重破坏的地方需要时间。但这正是我们将要做的，”拜登今年2月在国务院发表演讲时说。拜登还承诺将2022年的难民上限提高到12.5万人。白宫星期五没有对明年的难民决定发表评论。 单词 词义 precise adj. 精确的，明确的，严格的 The move comes as the administration faces increasing political pressure over the situation at the southwest border, where an influx of unaccompanied migrant children has overwhelmed government buildings and sent the administration scrambling to stand up additional shelters and facilities. 此举正值美国政府因西南边境局势面临越来越大的政治压力之际，大批举目无亲的移民儿童涌入西南边境，令政府大楼不堪重负，并迫使政府争相修建更多的避难所和设施。 单词 词义 influx n. 流入，汇集 accompany v. 陪伴，伴随，伴奏 overwhelm v. 淹没，覆盖，压垮 scramble v. 爬，攀登，争夺，抢占；n. 攀登，争夺 shelter n. 庇护，避难所，遮盖物；v. 保护，躲避 facility n. 设施，设备 Unaccompanied migrant children stay in the care of the Health and Human Services’ Office of Refugee Resettlement until they are released to a sponsor. The office also has a hand in settling refugees, but asylum-seekers at the border and international refugees go through distinctly different and separate processes. The vetting process for refugees can take up two years in some cases. 无人陪伴的移徙儿童在被释放给担保人之前，由难民重新安置卫生与人类服务办公室照料。该办公室也会帮助安置难民，但在边境寻求庇护者和国际难民的程序截然不同，也截然不同。在某些情况下，对难民的审查过程可能需要两年时间。 单词 词义 sponsor n. 赞助者，保证人，主办者；v. 赞助，发起 asylum n. 庇护，收容所，救济院 seek v. 寻求，寻找，探索 distinct adj. 明显的，独特的，清楚的 separate v. 使分离，使分开；adj. 单独的，不同的；n. 分开 The administration has been pressed since February on when it planned to officially raise the refugee ceiling. Press secretary Jen Psaki attempted to explain the delay Friday. 自今年2月以来，政府就一直受到压力，因为它计划正式提高难民上限。新闻秘书莎琪星期五试图解释推迟的原因。 单词 词义 attempt n. 企图，试图，攻击；v. 企图，试图，尝试 explain v. 说明，解释 “It took us some time to see and evaluate how ineffective, or how trashed in some ways the refugee processing system had become, and so we had to rebuild some of those muscles and put it back in place,” Psaki said. 普萨基说:“我们花了一些时间来观察和评估难民处理系统在某些方面变得多么无效，或者多么糟糕，所以我们必须重建一些肌肉，把它放回原处。” 单词 词义 evaluate v. 评价，估价，求…的值 ineffective adj. 无效的，失效的 muscle n. 肌肉，力量；v. 加强，使劲行进 Refugee agencies, however, have said they’re ready to dramatically step up admissions and rebuild the resettlement system. 然而，难民机构已经表示，他们已经准备好大幅增加接纳和重建安置系统。 单词 词义 agency n. 代理，中介，代理处 dramatical adj. 剧烈的，戏剧的，显著的 In a statement Friday, Lutheran Immigration and Refugee Service, one of eight resettlement organizations in the U.S., cheered Biden’s move to alter regional refugee allotments but denounced Biden’s decision to keep the record-low ceiling in place. 美国八个安置组织之一的路德教移民和难民服务处(Lutheran Immigration and Refugee Service)周五发表声明，对拜登改变地区难民分配的举动表示欢迎，但谴责拜登决定保持创纪录的低上限。 单词 词义 alter v. 改变，更改 allotment n. 分配（物），命运 denounce v. 谴责，告发 “It is deeply disappointing that the administration has elected to leave in place the shameful, record-low admissions cap of its predecessor. While it is true the Trump administration left the resettlement infrastructure in tatters, we feel confident and able to serve far more families than this order accounts for,” Krish O’Mara Vignarajah, president and chief executive officer of the organization, said in a statement. “非常令人失望的是，政府选择保留其前任的可耻的、创纪录低的招生上限。虽然特朗普政府的确让移民安置基础设施破败不堪，但我们感到有信心，也有能力服务的家庭远远超过这个名单的数量，”该组织总裁兼首席执行官克里什·奥马拉·维格纳拉贾(Krish O’mara Vignarajah)在一份声明中说。 单词 词义 disappoint v. 使失望 elect adj. 选出的，卓越的，当选的；v. 选举，推选；n. 被选的人 shameful adj. 可耻的，不体面的 infrastructure n. 基础设施，公共建设 tatter n. 碎步，碎纸；v. 扯碎，撕碎，使破烂 Sen. Bob Menendez, New Jersey Democrat and chairman of the Senate Foreign Relations Committee, sharply criticized the president Friday. 新泽西州民主党参议员、参议院外交关系委员会(Senate Foreign Relations Committee)主席梅内德斯(Bob Menendez)上周五严厉批评了总统。 单词 词义 chairman n. 主席，会长，董事长 sharply adv. 急剧地，锐利地 “By failing to issue a revised Determination, the White House has not only stymied the number of refugees permitted entrance into the United States, but also it has prevented the Department of State from admitting vetted refugees currently waiting in the system who do not fit into the unprecedentedly narrow refugee categories designated by the Trump administration,” Menendez said in a statement. “Failing to issue a new Determination undermines your declared purpose to reverse your predecessor’s refugee policies and to rebuild the Refugee Admissions Program to a target of 125,000 people in FY22, and threatens U.S. leadership on forced migration.” “由于没有发布修订后的决定，白宫不仅阻碍了允许进入美国的难民数量，但它也阻止了国务院接收目前在系统中等待的经过审查的难民，他们不属于特朗普政府划定的空前狭窄的难民类别，”梅内德斯在声明中说。“如果没有做出新的决定，就会破坏你所宣称的推翻前任难民政策、将难民接收计划重建到22财年目标12.5万人的目标的目标，也会威胁到美国在强迫移民问题上的领导地位。” 单词 词义 stymie v. 从中作梗，阻挠，妨碍；n. 妨碍球 permit v. 许可，允许；n. 许可证，执照 entrance n. 入口，进入；v. 使出神，使入迷 vet v. 审查，诊疗，作兽医；n. 兽医 precedent n. 先例，前例；adj. 在前的，在先的 narrow adj. 狭窄的，有限的，勉强的；n. 海峡，狭窄部分 undermine v. 破坏 purpose n. 目的，用途，意志；v. 决心，企图，打算 predecessor n. 前任，前辈 Trump, who campaigned on an anti-immigrant message, targeted the refugee program as soon as he took office, almost immediately slashing admissions from 110,000 to 50,000 and pushing the cap down further each year. 特朗普的竞选口号是反移民，他一上任就把目标对准了难民项目，几乎立即将入学人数从11万人削减到5万人，而且每年都在进一步降低上限。 单词 词义 anti adj. 反对的；n. 反对者 further adv. 进一步地，而且，更远地；adj. 更远的，深一层的；v. 促进，助长 It was an enormous deviation for the program, which has been robustly supported by both Republican and Democratic presidents and held up as an example of American’s moral leadership. The annual ceiling on admissions has historically averaged about 95,000. 这是对该计划的巨大偏差，该计划得到了共和党和民主党总统的大力支持，并被奉为美国道德领导力的典范。历史上，每年的招生上限为9.5万人次左右。 单词 词义 enormous adj. 庞大的，巨大的 deviation n. 偏差，误差，背离 robust adj. 健康的，强健的，粗鲁的 annual adj. 年度的，每年的；n. 年刊，年鉴，一年生植物 Note This article is excerpted from The New York Times. The link to the original article is “Biden to Keep Refugee Admissions Cap at Record-Low Set by Trump, Reversing Earlier Pledge”.","categories":[{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"}],"tags":[{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"}]},{"title":"数据结构（三）：线性表的应用","slug":"数据结构（三）：线性表的应用","date":"2021-04-13T12:56:02.000Z","updated":"2021-04-13T12:56:18.376Z","comments":true,"path":"9362806d3b04/","link":"","permalink":"https://ozzienicholas.gitee.io/9362806d3b04/","excerpt":"","text":"","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ozzienicholas.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"}]},{"title":"数据结构（二）：线性表","slug":"数据结构（二）：线性表","date":"2021-04-13T09:42:47.000Z","updated":"2021-04-13T12:59:06.018Z","comments":true,"path":"28ddff181a3b/","link":"","permalink":"https://ozzienicholas.gitee.io/28ddff181a3b/","excerpt":"","text":"线性表及其逻辑结构线性表的定义线性表的抽象数据类型描述 线性表的顺序存储结构线性表的顺序存储结构——顺序表顺序表基本运算的实现 线性表的链式存储结构线性表的链式存储结构——链表单链表双链表循环链表","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ozzienicholas.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"}]},{"title":"Biden Begins Long, Uphill Battle to Pass Infrastructure Package","slug":"Biden-Begins-Long","date":"2021-04-01T00:24:11.000Z","updated":"2021-04-15T01:47:23.395Z","comments":true,"path":"283503771a9b/","link":"","permalink":"https://ozzienicholas.gitee.io/283503771a9b/","excerpt":"","text":"HeadlineBiden Begins Long, Uphill Battle to Pass Infrastructure Package. 拜登为通过基础设施计划展开了漫长而艰难的斗争。 单词 词义 uphill adj. 上坡的，向上的；adv. 往上坡；n. 上升，登高 hill n. 小山，丘陵 battle n&amp;v. 战役，斗争，作战 Infrastructure n. 基础设施，公共建设 package n. 包，包裹，外壳，数据包；v. 打包；adj. 一揽子的 Introduction Past efforts have not only failed but become a political punchline – an example of a priority that an administration trumpets but never achieves. 过去的努力不仅失败了，而且成为了政治上的笑柄 —— 一个政府鼓吹但从未实现的优先事项的例子。 单词 词义 effort n. 努力，成就 not only … but … 不仅 … 而且 … not only … but also … 不仅 … 而且 … punchline n. 关键语，故事，笑料 priority n. 优先权，优先级，重点 Content President Joe Biden on Wednesday offered up a massive $2.25 trillion infrastructure plan that would usher in a new era of government spending and engagement on projects that have been neglected or delayed while expanding the very idea of “infrastructure” to include a host of domestic needs. 美国总统拜登（joebiden）周三提出了一项规模达2.25万亿美元的大规模基础设施建设计划，这将开启一个新时代，即政府支出和参与那些被忽视或拖延的项目，同时将“基础设施”的理念扩展到包括一系列国内需求。 单词 词义 offer up 贡献，风险 massive adj. 巨大的，大量的，雄伟的，厚重的 usher n. 接待员；n. 招待，接待 neglect v. 忽略，忽视，漏做；n. 忽略，忽视 delay v. 延期，推迟；n. 延期，延时，延迟器 a host of 许多，大量，众多 domestic adj. 国内的，家庭的；n. 国货，佣人 “It’s not a plan that tinkers around the edges. … It’s a once-in-a-generation investment in America,” Biden said at a speech at the Carpenters Pittsburgh Training Center. “It’s the largest American jobs investment since World War II. It’s big, yes. It’s bold, yes. And we can get it done.” 单词 词义 The plan – billed as an investment on par with the Interstate Highway System and the space race – would address traditional infrastructure projects, such as modernizing 20,000 miles of roads, repairing more than 10,000 bridges and improving the electrical grid, broadband and water supply pipes to reduce lead in drinking water. 单词 词义 But it also goes further in its definition of “infrastructure” to address social problems. The measure would use federal dollars to expand child care, boost long-term care under Medicaid, offer free access to community colleges and pay for community violence prevention programs, among many other items. 单词 词义 The package would be paid for by a hike on corporate taxes, raising the rate to 28% from the 21% set by the 2017 Tax Cuts and Jobs Act. It does not include an individual income tax hike on people making more than $400,000 a year, as Biden discussed during his campaign, nor the always-unpopular increase in the gasoline tax. 单词 词义 The president said he was open to other financing measures but would not accept anything that raised taxes on people making less than $400,000 a year. He said he has spoken with Senate Minority Leader Mitch McConnel, Kentucky Republican, adding that he would be inviting GOP lawmakers to the Oval Office to discuss the plan. 单词 词义 “Critics say we shouldn’t spend this money. They ask, ‘What do we get out of that?’ Well, they said the same thing when we flew into the space for the first time,” Biden said. 单词 词义 The president’s plan is ambitious in both a policy and political sense. Presidents in both parties have commonly bemoaned the poor state of the nation’s infrastructure and pledged to repair and modernize it, promising the job creation would make up for the big spending. 单词 词义 But such efforts have consistently failed – even after such dramatic moments as the deadly collapse of a bridge in Minneapolis in 2007. The term “Infrastructure Week” has become a political punchline, as an example of a priority that an administration trumpets but never achieves. 单词 词义 The Biden plan would take the nation back to a more traditional era, when the federal government took responsibility for things like assuring the functionality and safety of roads, bridges and drinking water. Spending in the Biden proposal includes $115 billion for roads and highways, $85 billion for mass transit and $80 billion to ease repair backlogs at a favorite Biden transportation operation, Amtrak. 单词 词义 The package has multiple programs aimed at reducing climate change, including $174 billion for grants and incentive programs to create a national network of 500,000 electric car chargers. That’s a critical step in encouraging the more environmentally friendly vehicles, says Northwestern University Kellogg School of Management professor David Besanko, who teaches courses in public economic and infrastructure strategy. 单词 词义 “It’s a chicken-and-egg thing,” he says, wherein people are reluctant to buy an electric car if they’ll end up stranded on the highway with no charging station nearby. 单词 词义 The package also has $650 billion for “at home” infrastructure, including retrofitting homes, building and upgrading public schools, providing broadband internet to rural areas and replacing lead pipes to ensure clean drinking water. 单词 词义 Further afield from the traditional infrastructure domain, the package would expand home-based care for seniors, boost wages for caregivers and call for passage of a law strengthening workers’ right to organize. 单词 词义 The nation is “long overdue in making a big national commitment to getting public works and infrastructure into good order,” Besanko says. But what’s notable about the Biden plan, he says, is that it goes way beyond basic transportation and public works programs, including proposals meant to thwart climate change, and make community college and housing more affordable. 单词 词义 “All of those things are outside the domain of traditional infrastructure,” Besanko says. 单词 词义 They also could imperil the package in Congress, where there is opposition in both parties to various parts of the plan. 单词 词义 A study released Wednesday by the Georgetown University Center for Education and the Workforce, for example, found that a hypothetical 10-year, $1.5 trillion plan aimed at traditional infrastructure would generate 15 million jobs, reviving the blue collar economy. 单词 词义 But adding in the other items will likely make passage of the package harder, says Nicole Smith, chief economist at the Georgetown center and one of the authors of the report. 单词 词义 “It’s everything under the sun,” Smith says. “Traditional infrastructure has a lot of bipartisan appeal. Sometimes what causes the stalemate is, ‘I don’t want the bridges and the quote-unquote welfare,’” Smith says. “When you make it a social issue (plan), that makes it a lot more difficult.” 单词 词义 And while the notion in general is popular – a Politico/Morning Consult poll released Wednesday morning found that 54% of Americans support a massive infrastructure plan even if it includes tax increases for both corporations and wealthier Americans – the big price tag is already drawing criticism from conservative circles. 单词 词义 Congressional Republicans, who passed a $2 trillion tax cut in 2017, have already indicated they will oppose tax hikes. The U.S. Chamber of Commerce on Wednesday issued a statement applauding the idea of making infrastructure a “top priority” but said making corporations pay for it was “dangerously misguided.” 单词 词义 Democrats, too, are pushing back. Several Democratic lawmakers from higher-tax states are insisting they will not vote for a tax package that does not lift the cap on state and local tax deductions imposed in the 2017 GOP bill. 单词 词义 Progressives, meanwhile, are calling the package way too small. 单词 词义 “The important context here is that it’s $2.25T spread out over 10 years. For context, the COVID package was $1.9T for this year alone, with some provisions lasting 2 years. Needs to be way bigger,” tweeted Rep. Alexandria Ocasio-Cortez, New York Democrat. 单词 词义 Biden’s plan would span eight years, although some shovel-ready projects would be completed earlier. The financing would take longer – 15 years – unusual in a city where federal budgeting is not planned out beyond a decade because of the uncertainties of the economy. 单词 词义 The White House said they are open to different funding mechanisms if members of Congress have other ideas. 单词 词义 Biden wants a bipartisan agreement, White House spokeswoman Karine Jean-Pierre told reporters en route to Pittsburgh. She said they expect the process to take longer than the $1.9 trillion American Rescue Plan, which was presented as an emergency package with aid that could not be delayed. 单词 词义 单词 词义 Note This article is excerpted from The New York Times. The link to the original article is “Biden Begins Long, Uphill Battle to Pass Infrastructure Package”.","categories":[{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"}],"tags":[{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"}]},{"title":"How Snubs to Public Health Left Missouri Behind on Vaccine Equity","slug":"How-Snubs-to-Public-Health","date":"2021-03-29T11:50:05.000Z","updated":"2021-04-15T00:45:33.055Z","comments":true,"path":"ebc3063d5984/","link":"","permalink":"https://ozzienicholas.gitee.io/ebc3063d5984/","excerpt":"","text":"Headline How Snubs to Public Health Left Missouri Behind on Vaccine Equity 公共卫生的怠慢是如何让密苏里州在疫苗公平问题上落后的 单词 词义 snub v. 冷落，斥责；n. 冷落，斥责 vaccine n. 疫苗；adj. 疫苗的 equity n. 公平，公正 Introduction The underfunding of public health and political backlash destabilized Missouri’s vaccine rollout, creating racial inequity and forcing some residents to drive hours to get shots. 公共卫生资金不足和政治反弹破坏了密苏里州疫苗的推广，造成种族不平等，迫使一些居民开几个小时的车去接种疫苗。 单词 词义 underfund v. 对…提供的资金不足 backlash n. 反冲，强烈抵制；v. 发生反冲，强烈反对 destabilize v. 使动摇 roll out n. 首次展示 racial adj. 种族的，人种的 inequity n. 不公平，不公正 force n. 力量，军队；v. 促使，强迫，强加 resident n. 居民，旅客；adj. 居住的，定居的 shot n. 发射，炮弹；adj. 用尽的，破旧的；v. 射击 ContentBy Lauren Weber | KHN ST. LOUIS—Missourians have driven hours to find vaccines in rural counties – at least those with cars and the time. Tens of thousands of doses are waiting to be distributed, slowly being rolled out in a federal long-term care program. Waitlists are hundreds of thousands of people long. Black residents are getting left behind. 圣路易斯-密苏里州的人们开了几个小时的车去农村地区寻找疫苗——至少是那些有车有时间的人。数以万计的疫苗正在等待分发，并在一个联邦长期护理项目中慢慢推出。候补名单上有数十万人。黑人居民被抛在了后面。 单词 词义 rural adj. 农村的，田园的 country n. 国家，乡村；adj. 故乡的，乡村的 dose n. 剂量，一剂，一服；v. 服药，给…服药 distribute v. 分配，散步，分开，把…分类 federal adj. 联邦的，同盟的；adv. 联邦政府地 program n. 程序，计划，大纲；v. 编程序，安排节目 waitlist n. 等候者名单；v. 把…放入等候者名单 hundred n. 一百，许多；adj. 一百的，许多的；num. 百 thousand n. 一千，一千个，许许多多 Missouri’s rocky vaccine rollout places it among the bottom states nationwide, with 23.7% of the population vaccinated with at least one dose as of Thursday, compared with the national average of 26.3%. If Missouri were on par with the national rate, that would be roughly equivalent to more than 162,000 additional people vaccinated, or almost the entire population of the city of Springfield. 密苏里州洛基疫苗的推广使其成为全国接种疫苗最少的州之一，截至周四，23.7%的人口至少接种了一剂疫苗，而全国平均水平为26.3%。如果密苏里州的疫苗接种率与全国水平相当，那大约相当于增加16.2万多人接种疫苗，或者几乎是斯普林菲尔德市的全部人口。 单词 词义 rocky adj. （多）岩石的，坚实的，摇晃的，头晕目眩的 among prep. 在…中间，…之一 nationwide adj. 全国性的，全国范围的；adv. 在全国 vaccinate v. 接种疫苗，给…注射疫苗 compare v. 比较，对比，与…相比；n. 比较 average n. 平均（数）；adj. 平均（数）的，中等的，典型的 par n. 标准，票面价值，平均数量；adj. 标准的，票面的 equivalent adj. 相等的，等价的，等效的；n. 对等的人/事，当量 additional adj. 附加的，额外的 almost adv. 几乎，差不多 entire adj. 全部的，整个的，全体的 Part of the problem,health experts said,is that the state bypassed its 115 local health departments in its initial vaccine rollout plans. Instead, state officials largely outsourced the work to hospitals, consultants and federal programs, reasoning hospitals and mass vaccination sites had the workforce and facilities to deliver high numbers of vaccines. 卫生专家说，部分问题在于该州在最初的疫苗推广计划中绕过了115个地方卫生部门。相反，州政府官员将大部分工作外包给医院、咨询机构和联邦项目，理由是医院和大规模疫苗接种点有足够的人力和设施来提供大量疫苗。 单词 词义 bypass n. 旁路，支路；v. 避开，忽视 department n. 部门 initial adj. 最初的，字首的；n. 原始细胞 instead adv. 代替，反而，相反 state n. 国家，州，情形；v. 规定，声明，陈述；adj. 国家的，正式的 official adj. 官方的，正式的，公务的；n. 官员，公务员 Meanwhile, local health departments and federally qualified health centers, which typically reach the most vulnerable populations not connected to traditional health systems, were each initially left to divvy up about 8% of the state’s vaccine supply. That allocation has since increased to 15%, but it hasn’t been enough to fill the remaining gaps. 与此同时，地方卫生部门和具有联邦资格的卫生中心，通常为那些没有与传统卫生系统相连的最脆弱人群提供服务，它们各自最初要分配该州约8%的疫苗供应。这一比例后来增至15%，但仍不足以填补剩余的缺口。 单词 词义 meanwhile adv. 同时；n. 同时 qualified adj. 合格的，有资格的 typically adv. 代表性地，作为特色地 vulnerable adj. 易受攻击的，有弱点的 connect v. 连接，关连 traditional adj. 传统的，惯例的 divvy v. 分摊，分配；n. 分摊，分配 allocation n. 分配，配置 since prep. 自…以后；conj. 自…以来，因为；adv. 此后 fill v. 装满，充满，满足；n. 满足 remain v. 保持，留下，剩余；n. 余留 gap n. 间隙，缺口，差距；v. 裂开 “You get what we pay for,” said Spring Schmidt, former co-acting director of the St. Louis County health department, noting public health departments in the state have been underfunded for decades. “This is an infrastructure that is similar to governmental utilities or other services that our citizens expect to be provided for them and tend to only notice when they fall.” “一分钱一分货，”圣路易斯县卫生局（St. Louis County health department）前联合代理主任斯普林·施密特（Spring Schmidt）说。他指出，几十年来，该州的公共卫生部门一直资金不足。“这是一种类似于政府公用事业或其他服务的基础设施，我们的公民希望为他们提供这些服务，只有当它们倒下时才会注意到。” 单词 词义 former adj. 从前的，前者的；n. 模板，模型 director n. 主任，主管，导演，人事助理 decade n. 十，十年 infrastructure n. 基础设施，公共建设 similar adj. 相似的；n. 类似物 governmental adj. 政府的，政治上的 utility n. 实用，效用，公共设施；adj. 实用的，通用的 citizen n. 公民，市民，百姓 expect v. 期望，认为，预料 provide v. 提供，规定，准备 tend v. 趋向，倾向，照料，照顾 fall v. 落下，跌倒，倒下；n. 落下，跌倒，降落，减少 The local health departments knew what needed to be done. “We’ve drilled for this, we’ve got plans on shelves that are collecting dust for this,” Schmidt said. 当地卫生部门知道需要做什么。施密特说:“我们为此进行了训练，我们已经在收集灰尘的架子上有了计划。” 单词 词义 drill n. 训练，演习，钻孔机；v. 钻孔，训练 dust n. 灰尘，尘土；v. 撒，拂去灰尘 But that’s the rub of long-standing health department underfunding: Even with all the plans honed in flu and H1N1 vaccination campaigns, health departments still would need the staff and facilities to pull off something of this scale, said Dr. Alex Garza, head of the St. Louis Metropolitan Pandemic Task Force, a consortium of the area’s major hospital systems. And the state and county governments aren’t providing the necessary funding to do the job. 但长期卫生部门资金不足的摩擦：即使所有的计划在训练流感和H1N1疫苗接种运动，卫生部门仍需要员工和设施来实现这种规模，该地区的主要医院系统的一个合伙人，亚历克斯·加尔萨博士说。而且州和县政府也没有提供必要的资金来完成这项工作。 单词 词义 rub v. 摩擦，惹怒；n. 摩擦，障碍，磨损处 long-standing adj. 长期存在的，存在已久的 even adv. 甚至，即使，实际上 hone v. 训练，磨（刀）；n. 磨石 campaign n. 运动，战役，竞选 staff n. 职员，参谋；adj. 职员的，行政工作的；v. 给…配备职员 facility n. 设施，设备，场所，才能 pull off 完成，脱去 scale n. 规模，比例；v. 衡量，攀登 consortium n. 财团，联合，合伙 necessary adj. 必要的，必须的，必然的；n. 必需品 fund n. 基金，资金，存款；v. 投资，资助 A 2020 Kaiser Health News and AP investigation found that Missouri public health staffing at the state level had fallen 8% from 2010 to 2019, a loss of 106 full-time employees. Public health spending per Missourian was $50 per year – one of the bottom 10 states in the nation. 《凯撒健康新闻》和美联社2020年的一项调查发现，从2010年到2019年，密苏里州公共卫生部门的工作人员减少了8%，减少了106名全职员工。每个密苏里州人每年的公共卫生支出为50美元，是全国最低的10个州之一。 单词 词义 investigation n. 调查，研究 loss of 损失 full-time adj. 专职的，全日制的，全部时间的 When the pandemic struck, local health departments had only 408 employees trained to give vaccinations, according to a report released Friday by #HealthierMO, a group advocating for better public health in the state. That means if only those staffers had given vaccines, they would each need to vaccinate some 15,000 people – in many cases, administering two shots. In even the most efficient scenario, with each person taking five minutes to vaccinate, that would take more than seven months for just one shot per person. 据倡导该州改善公共卫生的组织 #HealthierMO 周五发布的一份报告，当大流行袭来时，当地卫生部门只有408名员工接受过接种疫苗的培训。这意味着，如果这些工作人员已经接种了疫苗，他们每人将需要为大约1.5万人接种疫苗——在许多情况下，需要注射两针。即使在最有效的情况下，每个人需要5分钟来接种疫苗，每个人只需注射一针就需要超过7个月的时间。 单词 词义 pandemic adj. 在全国流行的；n. 流行病，瘟疫 struck v. 罢工，打击；adj. 受罢工影响的 advocate v. 提倡，拥护，为…辩护；n. 拥护者，辩护者，律师 in many cases 在许多情况下 administer v. 管理，执行，给予 efficient adj. 有效率的，有能力的，生效的 scenario n. 方案，情节，剧本，设想 At the same time, public health officials get blamed for enacting pandemic safety measures. State legislators are discussing limits to public health powers and local officials have withheld funding from their health departments, hindering their power to act in the crisis. 与此同时，公共卫生官员因制定大流行安全措施而受到指责。州议员正在讨论对公共卫生权力的限制，地方官员扣留了卫生部门的资金，阻碍了他们在危机中采取行动的权力。 单词 词义 at the same time 与此同时 blame v. 责备，归咎于；n. 责备，责任，过失 enact v. 颁布，制定法律，扮演，发生 measure n. 测量，措施，程度，尺寸；v. 测量，估量 legislator n. 立法者，民意代表 withhold v. 保留，隐瞒，忍住，克制 hinder v. 阻碍，打扰；adj. 后面的 act v. 行动，表现，起作用；n. 行为，假装 crisis n. 危机，危险期；adj. 危机的 A Question of Equity Missouri public health officials said the outsourcing approach missed the mark on the mission of public health: getting the vaccine to those who need it the most. 密苏里州公共卫生官员表示，外包方式没有达到公共卫生使命的目标：将疫苗提供给最需要的人。 单词 词义 outsource v. 把…外包，外包 approach v. 走进，与…接洽，几乎达到；n. 方法，方式，接洽 mark n. 标志，符号，痕迹，分数；v. 打分，做标记 mission n. 使命，任务，代表团；v. 派遣 Only 9.9% of Black Missourians are vaccinated, as opposed to 18.3% of white Missourians, according to available data. A series of reports produced by Deloitte, a major consulting firm advising the state on the rollout, showed a pattern of vaccine deserts in metro areas, where the state’s Black residents are concentrated. 根据现有数据，密苏里州只有9.9%的黑人接种疫苗，而白人接种疫苗的比例为18.3%。德勤（Deloitte）是一家主要的咨询公司，为该州的疫苗推广提供建议。该公司发布的一系列报告显示，在该州黑人居民集中的大都市地区，出现了疫苗沙漠的模式。 单词 词义 as opposed to 与…截然相反，对照… oppose v. 反对，反抗； available adj. 可获得的，可购买的，有空的 consult v. 查阅，商量，请教 advise v. 建议，劝告，警告，通知 pattern n. 模式，图案，样品，模式；v. 模仿，形成图案 desert n. 沙漠，荒原，冷清的地方；v. 遗弃，舍弃 metro n. 地铁，大都市 concentrate v. 集中，浓缩，聚集；n. 浓缩，精选 Nationally, non-Hispanic Black Americans are 1.9 times more likely to die of covid than white Americans, according to a Centers for Disease Control and Prevention analysis. Black Missourians make up 13.1% of the state’s COVID-19 deaths, higher than their 11.8% share of the population. 根据美国疾病控制与预防中心（Centers for Disease Control and Prevention）的分析，在全国范围内，非西班牙裔美国黑人死于 COVID-19 的可能性是美国白人的1.9倍。密苏里州的黑人占该州 COVID-19 死亡人数的13.1%，高于其人口的11.8%。 单词 词义 nationally adv. 全国性地 non-Hispanic 非西班牙裔，非西班牙人 likely adj. 很可能，合适的，有希望的；adv. 很可能，或许 analysis n. 分析，分解，验定 make up 组成，补足，化妆，编造 Some of the Deloitte reports in early March also found [nearly a third](https://covidvaccine.mo.gov/equity/pdf/State of Missouri_HealthPrism_Vaccine Distribution Analysis_03082021_Final.pdf) of Missouri residents traveled outside their county to get vaccinated. Democratic state Sen. Jill Schupp and other critics have said the initial rollout data show it’s because the geographic allocation of vaccines did not match up with population sizes. 德勤3月初的一些报告还发现，近三分之一的密苏里州居民到州外去接种疫苗。民主党州参议员吉尔·舒普（Jill Schupp）和其他评论家表示，最初推出的数据显示，这是因为疫苗的地理分布与人口规模不匹配。 单词 词义 early adj. 早期的，早熟的；adv. 提早，在初期 travel v. 长途旅行，经过；n. 旅行 geographic adj. 地理的，地理学的 allocation n. 分布，配置，安置 match up 使匹配，使相配 “If you are elderly and don’t do that kind of driving, if you’re low-income and don’t have that access to transportation, if you’re a working person who can’t take time off work to drive an hour and a half one way to get your vaccine – those people are left to fend for themselves,” Schupp said. “如果您年纪大一点，不做那种驾驶工作，如果您是低收入，也没有那样的交通工具，如果您是一个不能抽出一个半小时去开车接种疫苗的人，这些人只能自己保护自己，”舒普说。 单词 词义 elderly adj. 上了年纪的，稍老的 transportation n. 运输，运输工具，运输系统 take time off 休息，休假，抽出一部分时间 be left to 由 … 来决定 fend v. 谋生，保护，照料，供养 Decisions were made to prioritize vaccines based on population and risk factors, said state Health and Senior Services Director Dr. Randall Williams and Gov. Mike Parson’s deputy chief of staff, Robert Knodell. They say no single group would be happy with their allocation amid the limited initial vaccine supply. 州卫生和高级服务主任兰德尔·威廉姆斯博士和州长迈克·帕森的副幕僚长罗伯特·诺德尔说，决定根据人口和风险因素优先接种疫苗。他们说，在有限的初始疫苗供应中，没有一个群体会对他们的分配感到满意。 单词 词义 decision n. 决定，决心，决议 prioritize v. 优先考虑，优先处理 risk n. 风险，危险；v. 冒险 amid prep. 在 … 过程中，四周是 … Adam Crumbliss, the state’s director for its division of community and public health, noted state officials have concerns about data discrepancies that have made Missouri appear to be lagging. Missouri state health officials and federal government officials have sparred over at least four data issues. 密苏里州社区和公共卫生局局长亚当·克拉姆布利斯(Adam Crumbliss)指出，该州官员担心数据不一致，导致密苏里州显得落后。密苏里州卫生官员和联邦政府官员就至少四个数据问题进行了争论。 单词 词义 discrepancy n. 不符，矛盾，相差 lag n. 落后，延迟；v. 给…保温，滞后；adj. 最后的 sparred over 就…发生争论 spar n. 晶石，争论，拳斗；v. 争论，拳击 CDC spokesperson Kate Fowlie said a state file recording over 34,000 administered doses did not upload to federal systems due to data errors in January, and the state took two weeks to fix it. She added the CDC and Missouri have had an ongoing conversation about missing data from a provider who had improperly submitted counts of doses given. 疾控中心发言人凯特·福利(Kate Fowlie)表示，由于1月份的数据错误，记录超过3.4万剂剂量的州文件没有上传到联邦系统，州花了两周时间来修复它。她补充说，疾控中心和密苏里州正在就一名供应商丢失的数据进行对话，该供应商不正确地提交了所给剂量的计数。 单词 词义 record n. 记录，记载；v. 记录，记载，录制 administer v. 管理，执行，给予 ongoing adj. 仍在进行的，不断前进的，持续存在的 conversation n. 交谈，会话，交际，交往 Crumbliss also said some 76,000 unused doses are in the long-term care facilities pharmacy program with CVS and Walgreens, which slows down Missouri’s vaccination rate. The federal initiative has come under fire for its delays. Crumbliss还说，大约有7.6万剂未使用的疫苗在CVS和沃尔格林的长期护理设施药房项目中，这降低了密苏里州的疫苗接种率。联邦政府的这项倡议因拖延而受到抨击。 单词 词义 care facilities 护理设施 pharmacy n. 药房，配药学，药剂学 come under fire 遭到射击，遭到攻击 But according to the CDC, only 50,000 or so doses in the pharmacy program are left to be administered in Missouri. “A handful of long-term care facilities in Missouri had a late start on their first clinics, and are therefore still wrapping up the third and final clinics,” Fowlie said, noting the state could work with the federal partnership to redistribute any remaining doses. 但根据疾病控制与预防中心的数据，密苏里州的药房项目只剩下5万剂左右的剂量可供使用。福利说:“密苏里州的一些长期护理机构在他们的第一个诊所开始得比较晚，因此仍在筹备第三个和最后一个诊所。”他指出，密苏里州可以与联邦合作伙伴重新分配剩余的剂量。 单词 词义 handful n. 少数，一把 clinic n. 临床，诊所，医务室 therefore adv. 因此，所以 wrap up 包裹，圆满完成 partnership n. 合作伙伴，合伙关系 redistribute v. 重新分配，再分配 A Political Matter At the very heart of the heartland, Missouri is one of the states that never enacted a mask mandate – not even after the Republican governor and his wife contracted COVID-19 in September. 位于美国心脏地带的密苏里州是从未颁布口罩禁令的州之一，甚至在共和党州长及其妻子9月份感染COVID-19之后也没有。 单词 词义 heartland n. 中心地带 enact v. 颁布，制定（法律），扮演 mandate n. 授权，命令，指令；v. 授权，托管 contract v. 合同，契约，婚约；v. 收缩，缩短，感染 Parson also hasn’t shied away from fights with health officials. After Garza called for more vaccine doses to be allocated to the St. Louis area in early February, Parson accused him of spreading “fear and panic” with false information. 帕森斯也没有回避与卫生官员的争执。加尔扎在2月初呼吁向圣路易斯地区分配更多疫苗后，帕森斯指责他用错误的信息传播“恐惧和恐慌”。 单词 词义 shy away from v. 回避，退缩，躲避 shy adj. 害羞的，畏缩的，胆怯的；v. 投掷，吓退；n. 投掷 accuse v. 控告，指控，谴责 But after weeks of outcry, the state began to target the more populated St. Louis and Kansas City areas. Parson has also begun tweeting in support of local public health officials. 但经过数周的抗议，该州开始把目标对准人口更多的圣路易斯和堪萨斯城地区。帕森斯也开始在推特上支持当地公共卫生官员。 单词 词义 outcry n. 强烈抗议，尖叫 target n. 目标，指标，靶子；v. 把…作为目标，面向 Still, the political animus against public health is continuing in the Missouri Legislature — as it is in at least 23 other states – where lawmakers are weighing bills to curtail public health powers. The deployment of quarantine orders and other long-standing public health powers to combat the pandemic are now up for debate, while public health departments fight for funding. 尽管如此，针对公共卫生的政治敌意仍在密苏里州的立法机构中继续存在——至少其他23个州也是如此——立法者们正在权衡削减公共卫生权力的法案。检疫命令的部署和其他长期存在的公共卫生权力，以对抗大流行，现在是辩论，而公共卫生部门争取资金。 单词 词义 animus n. 敌意，意图，基本态度 against prep. 反对，针对，迎战，违反，对…不利 continue v. 继续，延续，仍旧，使…延长 lawmaker n. 立法者 weigh v. 权衡，考虑，称量 bill v. 宣布，开账单；n. 账单，钞票 curtail v. 缩减，剪短，剥夺…特权 deployment n. 调度，部署 quarantine n. 隔离，检疫 order n. 命令，顺序，规则 combat n. 战斗，搏斗，争论，反对；v. 与…战斗，防止 pandemic adj. 在全国流行的；n. 流行病，瘟疫 fund n. 基金，资金，存款；v. 资助，投资 “No one is wearing masks in the Capitol, and you’re asking public health officials to go and testify in person, against their own guidance,” said Will Marrs, a lobbyist for the Missouri Association of Local Health Agencies. “It’s very much not normal.” 密苏里州地方卫生机构协会(Missouri Association of Local health Agencies)的说客威尔·马勒斯(Will Marrs)说：“国会大厦里没有人戴着口罩，你要求公共卫生官员违背自己的意愿亲自去作证。”。“这非常不正常。” 单词 词义 testify v. 证明，作证 guidance n. 指导，引导，领导 lobbyist n. 说客， Legislators did not fight, however, over an emergency ruling for businesses and organizations to officially jump the vaccination line. So far, at least 90 have applied. Records obtained by KHN show that the state health department approved at least 15 entities to get the vaccines earlier, including health care giant Centene and the St. Louis Convention and Visitors Commission, as well as libraries and companies assisting in covid testing and vaccine manufacturing. 然而，立法人员并没有反对一项让企业和组织正式跳过疫苗接种线的紧急裁决。到目前为止，至少有90人提出了申请。KHN获得的记录显示，州卫生部门批准了至少15家实体更早获得疫苗，包括医疗保健巨头Centene和圣路易斯公约和访客委员会，以及协助covid - 19检测和疫苗生产的图书馆和公司。 单词 词义 legislator n. 立法者 emergency n. 紧急情况，突发事件 apply v. 申请，应用，请求 obtain v. 获得，流行 approve v. 批准，赞成，同意，为…提供证据 entity n. 实体，存在 giant n. 巨大，巨大的动物/植物；adj. 巨大的，伟大的 assist v. 参加，协助；n. 帮助，助攻 manufacture n. 制造，产品，制造业；v. 制造，加工，捏造 The Funding Question Even amid a pandemic, it’s been a struggle to get money to local health departments. The state used $9.8 million initially sent from the CDC last spring, instead of passing it along to local health departments. 即使是在大流行期间，为当地卫生部门筹集资金也很困难。该州使用了去年春天最初从疾控中心拨出的980万美元，而不是将其转给当地卫生部门。 单词 词义 struggle v. 奋斗，斗争，争夺，艰难地进行；n. 斗争，冲突，奋斗，难事 struggle for …. 为 … 奋斗 instead of 而不是 Last summer, state legislators decided that county commissioners would determine whether local health departments got CARES Act funding. Many commissioners were mad at their health departments for shutting down local businesses, so they refused to fork over funds, said Larry Jones, executive director for the Missouri Center for Public Health Excellence, a consortium of public health leaders. 去年夏天，州立法委员决定由县委员来决定当地卫生部门是否得到《护理法案》的资助。公共卫生领袖联盟密苏里公共卫生卓越中心(Missouri Center for Public health Excellence)的执行主任拉里·琼斯(Larry Jones)说，许多委员对卫生部门关闭当地企业感到愤怒，因此拒绝提供资金。 单词 词义 commissioner n. 理事，委员，总裁 mad adj. 疯狂的，发疯的，气愤的，迷恋的，特别喜欢的，激动的；n. 狂怒 refuse v. 拒绝，回绝；n. 垃圾，废弃物；adj. 废弃的 fork n. 叉，餐叉；v. 叉起，分叉，分歧 executive adj. 经营管理的，有执行权的，高级的；n. 主管，领导 consortium n. 财团，联合，合伙 According to a state health department survey, at least 40 local health departments hadn’t received any of the money as of early October. Those that did reported an average of 8% of county CARES money, instead of the state-recommended 15%. 根据州卫生部门的一项调查，截至10月初，至少有40个地方卫生部门没有收到任何资金。那些报告了平均8%的县医疗费用，而不是国家建议的15%。 单词 词义 survey n. 调查，测量，纵览；v. 调查，勘测，俯瞰 recommend v. 推荐，介绍，劝告，建议 In Kansas City, over $226,000 in CARES funds was allocated over the summer to Cruise Holidays, a travel company, according to Platte County’s Landmark newspaper. It wasn’t until this March that the local health department received almost $228,000, said department spokesperson Natalie Klaus, far less than the $1.8 million the state recommended. 在堪萨斯城，根据普拉特县的地标性报纸，超过22.6万美元的关怀基金在夏天被分配给了一家旅游公司Cruise Holidays。直到今年3月，当地卫生部门才收到了近22.8万美元的拨款，发言人娜塔莉·克劳斯(Natalie Klaus)说，这远远低于该州建议的180万美元。 单词 词义 landmark n. 地标，里程碑，纪念碑；adj. 有重大意义的；v. 赋予地标的地位 The state has been allocated $55 million from the CDC for the vaccine rollout, of which state health department spokesperson Lisa Cox said $20 million is heading to local departments soon. More is expected to come in the new $1.9 trillion federal stimulus package. 该州已从疾控中心拨出5500万美元用于疫苗推广，该州卫生部门发言人丽莎·考克斯表示，其中2000万美元将很快拨给地方部门。在新的1.9万亿美元的联邦经济刺激计划中，预计还会有更多的收入。 单词 词义 trillion n. 万亿；adj. 万亿的；num. 万亿 stimulus n. 激励，刺激，刺激物 Jones is concerned history will repeat itself with vaccination funding not getting where it helps the most people. Brian Castrucci, CEO of the de Beaumont Foundation, which advocates for public health, also isn’t optimistic. 琼斯担心历史会重演，疫苗接种资金无法到达最能帮助人们的地方。倡导公共健康的德博蒙特基金会的首席执行官布莱恩·卡斯蒂奇(Brian Castrucci)也不乐观。 单词 词义 advocate v. 提倡，拥护；n. 拥护者，辩护者，律师 optimistic adj. 乐观的，乐观主义的 “How confident are we that states that are actively trying to limit public health authority are going to do a good job of spending this money appropriately?” “我们有多大的信心，那些积极尝试限制公共卫生权力的州能把这笔钱花得很好?” 单词 词义 confident adj. 确信的，自信的 appropriate adj. 适当的，恰当的，合适的；v. 占用 Data reporter Hannah Recht contributed to this report. 数据记者汉娜·雷希特对此报道有贡献。 单词 词义 contribute v. 贡献，出力，投稿，捐献，有助于，促成 contribute to … 对 … 有贡献，有助于 … KHN (Kaiser Health News) is a national newsroom that produces in-depth journalism about health issues. Together with Policy Analysis and Polling, KHN is one of the three major operating programs at KFF (Kaiser Family Foundation). KFF is an endowed nonprofit organization providing information on health issues to the nation. KHN(凯撒健康新闻)是一个全国性的新闻编辑室，产生关于健康问题的深入新闻。KHN与政策分析和民意调查一起，是凯泽家族基金会(KFF)三大运作项目之一。KFF是一个捐赠的非盈利组织，向全国提供健康问题的信息。 单词 词义 operate v. 运转，操作，经营，引起，动手术，起作用 endow v. 赋予，捐赠，资助 Note This article is excerpted from The New York Times. The link to the original article is “How Snubs to Public Health Left Missouri Behind on Vaccine Equity”.","categories":[{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"}],"tags":[{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"}]},{"title":"WHO：COVID19 Origin Report ‘Roughly Now Finalized’","slug":"WHO_COVID19_Origin_Report","date":"2021-03-28T05:33:05.000Z","updated":"2021-04-08T03:30:52.596Z","comments":true,"path":"ed985442a002/","link":"","permalink":"https://ozzienicholas.gitee.io/ed985442a002/","excerpt":"","text":"Headline WHO: COVID-19 Origin Report ‘Roughly Now Finalized’ 世卫组织: COVID-19 起源报告“目前大致完成” 单词 词义 rough adj. 粗糙的，粗略的，艰苦的；n. 艰苦，粗糙的部分；v. 使粗糙，草拟 finalize v. 完成，使结束 Introduction The head of the international team behind an investigation into the origin of the virus said the highly anticipated report should be made public in the next few days. 病毒起源调查国际小组负责人表示，这份备受期待的报告将在未来几天公之于众。 单词 词义 behind prep. （跟）在…的后面，朝…后面，幕后；adv. 落后，在后面 investigation n. 调查，调查研究 anticipate v. 预料，预期，期望 Content “You probably heard me say in the past that we were very close to finalizing the report, and I’m the first one to regret it’s not yet out,” WHO expert Peter Ben Embarek said during a press conference. “But it’s roughly now finalized.” 世界卫生组织专家彼得·本·安巴雷克在新闻发布会上说：“你可能在过去听我说过，我们非常接近于敲定这份报告，而我是第一个感到遗憾的人，但现在已经大致完成了”。 单词 词义 regret v. 后悔，对…感到遗憾；n. 遗憾，歉意 yet adv. 还，但是，已经；conj. 但是，然而 press v. 压，按，逼迫，坚持；n. 报刊杂志，新闻界，出版社，按，压 conference n. 会议，讨论，联盟；v. 举行（或参加）会议 press conference 新闻发布会 Team members discussed some of their findings in February – including that it is “extremely unlikely” that the coronavirus originated in a lab – but the details of the report are highly anticipated. 研究小组成员在2月份讨论了他们的一些发现，包括冠状病毒起源于实验室的“极不可能”，但报告的细节备受期待。 单词 词义 February n. 二月 extremely adv. 非常，及其，极端地 coronavirus n. 冠状病毒 originate v. 引起，创作，发源 “The content is now complete, and, frankly speaking, I expect that in the next few days that whole process will be completed, and we’ll be able to release it publicly,” Embarek said. 安巴雷克说：“现在内容已经完成，坦率地说，我预计整个过程将在未来几天内完成，我们将能够公开发布。” 单词 词义 frankly adv. 坦率地，老实说 expect v. 期待，指望，认为 whole adj. 完整的，纯粹的；n. 整体，全部 release v. 释放，放开，免除，公开；n. 释放，发布，解放 “It’s a very slow and complicated process to get it there,” he added, noting work happening across several time zones and in both Chinese in English languages. “这是一个非常缓慢和复杂的过程，”他补充说。他指出，这项工作跨越了几个时区，在中文和英文中都有。 单词 词义 complicate v. 使复杂化，使恶化 zone n. 地带，地区；v. 分城区，环绕 White House press secretary Jen Psaki said on Friday that the Biden administration will examine the data behind the report before determining how to proceed. A State Department spokesman said in February that the U.S. would welcome WHO’s findings in an official report but that it will use the U.S. intelligence community to “reach our own conclusions.” 白宫新闻秘书珍·普萨基(Jen Psaki)周五表示，拜登政府将对这份报告背后的数据进行审查，然后再决定如何推进。美国国务院发言人今年2月表示，美国将在一份官方报告中欢迎世卫组织的调查结果，但美国将利用美国情报部门“得出我们自己的结论”。 单词 词义 secretary n. 秘书，书记，部长，大臣 administration n. 管理，行政，实施 examine v. 调查，检查，测试 determine v. 决定，判决，确定 proceed v. 开始，发生，行进；n. 收入，获利 spokesman n. 发言人，代言人 official adj. 官方的，正式的，公务的；n. 官员，公务员 intelligence n. 智慧，情报（机关），天分 conclusion n. 结论，推论 Former Director of the Centers for Disease Control and Prevention Robert Redfield recently told CNN that he believes the virus originated in a Chinese lab. 美国疾病控制和预防中心前主任罗伯特·雷德菲尔德最近告诉CNN，他认为病毒起源于中国的一个实验室。 单词 词义 former adj. 从前的，前任的；n. 模型，模板 director n. 主人，主管，导演 prevention n. 预防，阻止，妨碍 Leading infectious disease expert Anthony Fauci on Friday said that Redfield’s comments were just his opinion, noting that “there are other alternatives, others that most people hold by.” 权威传染病专家安东尼·福奇周五表示，雷德菲尔德的评论只是他的观点，并指出“还有其他选择，其他大多数人持有的。” 单词 词义 infectious adj. 传染的，传染性的 opinion n. 意见，主张 alternative adj. 供选择的，选择性的，交替的 hold by 坚持，持有，支持 Note note link green, This article is excerpted from The New York Times. The link to the original article is “WHO: COVID-19 Origin Report ‘Roughly Now Finalized’”.","categories":[{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"}],"tags":[{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"}]},{"title":"数据结构（一）：绪论","slug":"数据结构（一）：绪论","date":"2021-03-22T14:58:12.000Z","updated":"2021-04-12T10:52:21.780Z","comments":true,"path":"60568f9b024a/","link":"","permalink":"https://ozzienicholas.gitee.io/60568f9b024a/","excerpt":"","text":"什么是数据结构数据结构的定义 寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间的关系，然后用数学语言加以描述。有些问题的数据模型可以用具体的数学方程等来表示，但是更多的实际问题是无法用数学方程来表示的，这就需要从数据入手来分析并得到解决问题的方法。 数据是描述客观事物的数和字符的集合。 数据元素：数据元素是数据的基本单位（例如，某个班的基本信息表中，一个学生就是一个数据元素）。 有时，数据元素也称为元素、结点、顶点或者记录等。 一个数据元素也可以由若干个数据项组成。 数据项：数据项是具有独立含义的数据最小单位，也成为字段或者域（例如，某个班的基本信息表中，每一个数据元素，即每一个学生记录，都由学号、姓名等数据项构成）。 数据对象：数据对象是指性质相同的数据元素的集合，它是数据的一个子集。 在平时的交流中，所提及的数据通常是指数据对象。 数据结构：数据结构是指所有数据元素以及数据元素之间的关系。 可以看做是相互之间存在着某种特定关系的数据元素的集合。我们常把数据结构看做是带结构的数据元素的集合。 数据结构通常包括： 数据的逻辑结构：这是由数据元素之间的逻辑关系构成。 数据的存储结构：这是数据元素及其关系在计算机存储器中的存储表示，也成为数据的物理结构。 数据的运算：即施加在该数据上的操作。 逻辑结构 数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中得出的。 逻辑结构的表示：逻辑结构有很多中表示方式，常见的有图表和二元组等。 图像表示：采用表格或者图形直接描述数据的逻辑关系。 每个结点对应着一个数据元素。 两结点之间带箭头的连线表示它们之间的相邻关系。 二元组表示：二元组是一种通用的数据逻辑结构表示方式，一个二元组的表示例如：B = (D, R)，其中，D 表示数据元素的集合，R 表示 D 上的二元关系的集合，即： 12345D &#x3D; &#123;d_i | 1≤i≤n,n≥0&#125;d_i 表示 D 中第 i 个数据元素，n 为 D 中数据元素的个数。若 n&#x3D;0，则 D 是一个空集，表示 B 无结构或者认为具有任意结构 12345R &#x3D; &#123;r_j | 1≤j≤m,m≥0&#125; r_j 表示 R 中第 j 个关系，m 为 R 中关系的个数。 若 m&#x3D;0，则 R 是一个空集，表示 D 中的元素间不存在任何逻辑关系，等同于数学中的集合 1234R 中的一个关系 r 是序偶的集合，对于 r 中的任意序偶 &lt;x, y&gt;，表示元素 x 与 y 是相邻的，x 为 y 的直接前驱元素，简称前驱元素y 是 x 的直接后继元素，简称后继元素 12对于对称序偶集合，可表示为 (x, y)∈r，用图形表示逻辑关系时，对称序偶用不带箭头的连线表示 逻辑结构的类型 集合：指数据元素之间除了 “同属于一个集合” 的关系以外，没有其他关系。 线性结构：是指该结构中的数据元素之间存在一对一的关系。 特点：开始元素和终端元素是唯一的，除了开始元素和终端元素外，其余元素有且仅有一个前驱元素和一个后继元素。 典型的线性结构：线性表。 树形结构：是指该结构中的数据元素之间存在一对多的关系。 特点： 除了开始元素以外，每个元素有且仅有一个前驱元素。 除了终端元素以外，每个元素有一个或者多个后继元素。 典型的树形结构：二叉树。 图形结构：是指该结构中的数据元素之间存在多对多的关系。 特点：每个元素的前驱元素和后继元素的个数可以是任意的，因此图形结构没有（或者有多个）开始元素和终端元素。 树形结构与图形结构统称为非线性结构。 存储结构 数据逻辑结构在计算机存储器中的存储表示成为数据的存储结构（也称为映像），也就是逻辑结构在计算机中的存储实现。 当把数据对象存储到计算机中时，通常要求既要存每一个数据元素，又要存储数据元素之间的逻辑关系。 顺序存储结构 采用一组连续的存储单元存放所有的数据元素。所有的数据元素在存储器中占有一整块存储空间，两个逻辑上相邻的元素在存储器中的存储位置也相邻。 数据元素之间的逻辑关系由存储单元地址间的关系隐含表示，即顺序存储结构将数据的逻辑结构直接映射到存储结构。 主要优点：存储效率高。 因此可实现对元素的随机存取。 主要缺点：不便于数据修改。 链式存储结构 每个逻辑元素用一个内存结点存储，每个结点是单独分配的。 为了表示元素之间的逻辑关系，给每个结点附加指针域，用来存放相邻结点的存储地址。 主要优点：便于数据修改。 主要缺点：存储的空间利用率低，不能对元素随机存储。 分配给元素的存储单元有一部分被用来存储结点之间的逻辑关系，所以存储的空间利用率低。 逻辑上相邻的元素在存储空间不一定相邻，所以不能对元素随机存储。 索引存储结构 在存储数据元素信息的同时还建立附加的索引表。存储所有元素信息的表成为主数据表，其中每个数据元素有一个关键字和对应的存储地址。 索引表中的每一项称为索引项，索引项一般的形式为 “关键字，地址”，其中，索引表中所有的索引项都是按关键字排序的。 主要优点：查找效率高。 主要缺点：需要建立索引表，增加了空间开销。 数据运算 数据运算是指对数据实施的操作。 每种数据结构都有一组相应的运算，最常用的运算有检索、插入、删除、更新、排序等。 对于一种数据结构，其逻辑结构是唯一的，但可能对应着多种存储结构，并且，在不同的存储结构中，同一运算的实现过程可能不同。 数据类型和抽象数据类型 数据类型： 数据类型是一组性质相同的值的集合和定义在此集合上的一组操作的总称，是某种程序设计语言中已实现的数据结构。 C/C++ 中常用的数据类型：按照取值的不同，分为原子类型（不可再分的基本类型）和结构类型（可分解的）。 基本数据类型（int、bool、float、double、char） 指针类型 数组类型 结构体类型 共用体类型 自定义类型 存储空间的分配： 静态存储空间分配：是指在程序编译期间分配固定的存储空间的方式（如数组）。 动态存储空间分配：是指在程序运行期间动态地分配存储空间的方式（如使用 malloc()/free()）。 容易造成内存泄漏。 抽象数据类型（ADT）： 抽象数据类型指的是用户进行软件系统设计时，从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，而不考虑计算机的具体存储结构和运算的具体实现算法。 抽象数据类型中，数据对象和数据运算的声明与数据对象的表示和数据运算的实现相互分离。 一个具体问题的抽象数据类型的定义一般包括：数据对象、数据关系和基本运算。 一个抽象数据类型可用三元组（D, S, P）表示： 12345ADT 抽象数据类型名 &#123; 数据对象(D): 数据对象的声明 数据关系(S): 数据关系的声明 基本运算(P): 基本运算的声明&#125; 其中，基本运算的声明格式为： 1基本运算名(参数表): 运算功能描述 基本运算有两种参数： 值参数：只为运算提供输入值。 引用参数：以 &amp; 开头，除了可提供的输入值以外，还将返回输出结果。 例如，一个复数的抽象数据类型 Complex 的定义如下： 12345678910ADT Complex &#123; 数据对象: D = &#123;e1, e2 | e1, e2 均为实数&#125; // 一个复数由 e1, e2 两个实数构成 数据关系: R = &#123;&lt;e1, e2&gt; | e1 是实部, e2 是虚部&#125; // e1, e2 在复数中的逻辑关系是 &lt;e1, e2&gt; 基本运算: AssignComplex(&amp;z, v1, v2); // 构造复数 z, v1 为实部值, v2 为虚部值 DestoryComplex(&amp;z); // 销毁复数 z GetReal(z, &amp;real); // 用 real 返回复数 z 的实部值 GetImag(z, &amp;imag); // 用 imag 返回复数 z 的虚部值 Add(z1, z2, &amp;sum); // 用 sum 返回两个复数 z1 和 z2 相加的结果&#125; 抽象数据类型的两大特征：数据抽象和数据封装 算法及其描述什么是算法 算法是对特定问题求解步骤的一种描述，它是指令的有限序列。 算法的 5 大特征： 有穷性：必须在执行有穷步之后结束，每一步都在有穷时间内完成。 确定性：对相同的输入必须得到相同的输出，不能有二义性。 可行性：算法的每一个动作都能被机械地执行。 有输入：一个算法必须有 0 个或者多个输入。 有输出：一个算法必须有 1 个或者多个输出。 算法与程序的区别： 程序是指使用某种计算机语言对一个算法的具体实现，即具体要怎么做。 算法侧重于对解决问题的方法描述，即要做什么。 算法必须满足有穷性，而程序不一定满足有穷性。 算法设计的目标： 正确性：正确执行预先规定的功能和性能要求，这也是最基本的最重要的标准。 可使用性：用户友好性。 可读性：可读性好。 健壮性：容错性好。 高效率与低存储量需求：算法的效率主要是指算法的执行时间，算法存储量指的是算法执行过程中所需要的最大存储空间。效率和存储量都和问题的规模有关。 算法分析 算法分析就是分析算法占用计算机资源的多少。 性能分析： 时间性能分析：分析算法占用 CPU 时间的多少。 空间性能分析：分析算法占用内存空间的多少。 算法时间性能分析：通常有两种衡量算法时间性能的方法，即事后统计法和事前估算法。 事后统计法：编写算法对应程序，统计其执行时间，主要缺点有两个，一是必须要执行程序，而是存在很多干扰因素（比如计算机的运行速度，该程序对应的语言等）掩盖了算法本质。 事前估算法：撇开与计算机硬件、软件有关的技术，仅考虑算法本身的效率高低，认定一个特定算法的 “运作工作量” 的大小只依赖于问题的规模（通常用整数 n 表示），即算法的执行时间是问题规模的函数，因此，后面主要采用事前估算法来分析算法的时间性能。 算法时间复杂度分析： 计算算法的频度 T(n) 一个算法是由控制结构（顺序、分支、循环）和原操作（指固有数据类型的操作）构成的。 例如：求两个 n 阶矩阵 A、B 相加，即 C = A + B 的算法如下，计算其执行时间 T(n)： 123456789#define MAX 20void matrixadd(int n, int A[MAX][MAX], int B[MAX][MAX], int C[MAX][MAX]) &#123; int i, j; for(i=0; i&lt;n; i++) &#123; // 执行 n+1 次 for(j=0; j&lt;n; j++) &#123; // 执行 n(n+1) 次 C[i][j] = A[i][j] + B[i][j]; // 执行 n^2 次 &#125; &#125;&#125; 所以：T(n) = (n+1)+n(n+1)+n^2 = 2n^2+2n+1 = O(n^2) T(n) 用 “O” 表示 算法的时间复杂度就是用 T(n) 的数量级来表示的，记作 T(n) = O(f(n))，所以，算法时间复杂度也称为渐进时间复杂度。 递归算法时间复杂度分析： 递归算法是指算法中调用自己的成分。 递归算法分析也成为变长时空分析，非递归算法分析也成为定长时空分析。 算法空间复杂度分析： 一个算法的存储量包括：输入数据所占的空间、程序本身所占的空间和临时变量所占的空间。所以，算法空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度。 形参的空间会在调用该算法的算法中考虑，所以，算法占用的空间只需要考虑临时空间。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://ozzienicholas.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数据结构基础","slug":"数据结构基础","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"}]},{"title":"Next.js入门详解教程","slug":"Next-js入门详解教程","date":"2021-03-20T04:28:31.000Z","updated":"2021-03-20T04:29:38.014Z","comments":true,"path":"3e56fbdb64fa/","link":"","permalink":"https://ozzienicholas.gitee.io/3e56fbdb64fa/","excerpt":"","text":"引言 初识 Next.js，请查看它的官网介绍： Next.js 官网 Next.js 中文网 好吧，官网的话总是那么拗口，若对此感兴趣，请读者移步知乎：对 Next.js 的评价 另外附上两个你可能会用到的链接： Github 地址：Github - next.js 社区：Spectrum 初识Next.js安装 Next.js 支持 Windows、Mac 和 Linux系统，均可安装，但是前提是你已经安装了 Node.js 创建示例项目的过程如下： 12345mkdir hello-nextcd hello-nextnpm init -ynpm install --save react react-dom nextmkdir pages 使用 打开 hello-next/package.json，替换 scripts： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125; 启动 1npm run dev 在浏览器中打开 http://localhost:3000,你会看到页面显示 404 | This page could not be found. 创建你的第一个页面 创建 pages/index.js，并输入： 1234567const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/div&gt;);export default Index; 再次输入 npm run dev，就能看到效果了 上述案例中，我们在 pages/index.js 模块中默认（default）导出了一个简单的 React 组件 试错 尝试着错一次：将 pages/index.js 改为： 1234567const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js &lt;/div&gt;);export default Index; 重新启动，浏览器显示： 一般情况下，Next.js 将跟踪此类错误并在浏览器中显示，这便于我们快速发现错误，而你修改代码并保存后，页面将立即出现对应结果，而不会重新加载整个页面，这是通过 webpack 的 模块热替换 实现的，Next 默认支持这个功能 2020.3.30 页面间导航Introduction 我们的应用程序虽然很简单，只有一个页面，但是我们可以添加任意多个页面，例如： 创建 pages/about.js 来新建 “About” 页面 1234567const About = () =&gt; ( &lt;div&gt; &lt;p&gt;About Page&lt;/p&gt; &lt;/div&gt;);export default About; 修改 pages/index.js： 12345678const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;a href=&quot;http://localhost:3000/about&quot;&gt;This is a link to About-Page&lt;/a&gt; &lt;/div&gt;);export default Index; 之后我们可以通过 http://localhost:3000/about 来访问该页面 之后，我们需要连接两个页面，首先想到的是可以用一个 HTML 的 &lt;a /&gt; 标签实现，但是结果就是：浏览器会向服务器请求下一页并刷新当前页面，也就是这样做并不会执行客户端导航 为了支持浏览器端导航，我们需要使用 Next.js 提供的 Link 组件，这个组件是通过 next/link 导出的，接下来我们将使用它 我们需要准备一个简单的 Next.js 应用课程，请在 hello-next 下输入： 1git clone https://github.com/zeit/next-learn-demo.git 现在我们进入 hello-next/next-learn-demo/1-navigate-between-pages 启动程序： 123cd next-learn-demo/1-navigate-between-pagesnpm installnpm run dev 打开 http://localhost:3000/ 访问该程序 使用Link组件 注意，接下来的操作均在 hello-next/next-learn-demo/1-navigate-between-pages 下完成的 在 pages/index.js 中添加： 123456789101112import Link from &#x27;next/link&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;p&gt;Hello next.js&lt;/p&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Page&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; )&#125; 在这里，我们将 next/link 导入为 Link，并按照如下的方式使用： 123&lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Page&lt;/a&gt;&lt;/Link&gt; 访问 3000 端口可查看结果 这次点击链接同样会导航到 “About” 页面，这是客户端导航，操作在浏览器中进行，而不向浏览器发送请求，你可以通过打开浏览器的 网络请求检查器（network request inspector） 来验证这一点 后退按钮： 当你点击链接，再点击后退时，依然会切换到历史记录的上一页，也就是 next/link 为你完成了所有 location.history 的操作 添加链接道具 或许你需要在连接中添加属性或道具，比如你需要向链接中添加 title 属性，我们可以这样添加它： 123&lt;Link href=&quot;/about&quot;&gt; &lt;a title=&quot;About-Pages&quot;&gt;About Page&lt;/a&gt;&lt;/Link&gt; 查看元素，可以看到结果如下： 切记不可添加到错误的地方去，若写成如下： 123&lt;Link href=&quot;/about&quot; title=&quot;About-Pages&quot;&gt; &lt;a&gt;About Page&lt;/a&gt;&lt;/Link&gt; 则会在控制台中报错： 实际上，Link 组件上的标题道具无效，是因为 Link 只是一个包装器组件，只接收 href 和一些类似的道具。如果需要向其添加道具，则需要将道具添加到其子项，这种情况下，Link 组件的子代是锚标记 使用共享组件Introduction 我们可以通过导出 React 组件并将该组件放在 pages 目录中来创建页面，每个页面的 URL 都是基于文件名的，由于导出的页面是 JavaScript 模块，因此我们也可以将其他 JavaScript 组件导入其中 我们将创建一个公共的 Header 组件并将其用于多个页面，最后我们将研究实现 Layout 组件，并了解它如何帮我们定义多个页面的外观 运行 我们之前已经安装过了 next-learn-demo，这里直接使用： 进入 hello-next/next-learn-demo/2-using-shared-components，之后我们的操作也会在此目录下 运行： 12npm installnpm run dev 创建标题组件 下面创建一个 Header 组件，创建 2-using-shared-components/components/Header.js： 123456789101112131415161718import Link from &#x27;next/link&#x27;;const linkStyle = &#123; marginRight: 15,&#125;;const Header = () =&gt; ( &lt;div&gt; &lt;Link href=&quot;/&quot;&gt; &lt;a style=&#123;marginRight&#125;&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a style=&#123;marginRight&#125;&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Header; 现在，导入 Header 组件并在页面中使用它： 将 index.js 修改为： 12345678910import Header from &#x27;../components/Header&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/div&gt; )&#125; 将 about.js 修改为： 12345678910import Header from &#x27;../components/Header&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;p&gt;This is the About Page&lt;/p&gt; &lt;/div&gt; )&#125; 启动之后可以查看结果 试错：现在将 components 目录改名为 comps，报错如下： 我们不需要将我们的组件放在一个特殊的目录里，也就是说，该组件目录名称可以取为任何，实际上，唯一特殊的目录是 /pages 和 /public，你甚至可以在 /pages 里面创建组件. 布局组件 本节依然是在 2-using-shared-components/ 下完成的 我们将创建 Layout 组件，以实现各页面上的通用样式，在 components/MyLayout.js 中输入： 12345678910111213141516import Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const Layout = props =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &#123;props.children&#125; &lt;/div&gt;);export default Layout; 完成操作后，我们可以在页面中使用以下布局： 在 pages/index.js 中输入： 123456789import Layout from &#x27;../components/MyLayout&#x27;;export default function Index() &#123; return ( &lt;Layout&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/Layout&gt; )&#125; 在 pages/about.js 中输入： 123456789import Layout from &#x27;../components/MyLayout&#x27;;export default function About() &#123; return ( &lt;Layout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/Layout&gt; )&#125; 启动，查看样式 试错：将 MyLayout.js 中的 &#123;props.children&#125; 删除，再启动，观察结果： 页面上只保留了 Header 的内容，其他的均消失了 渲染子组件 前一个试错中，我们删除了 &#123;props.children&#125;，则 Layout 无法呈现我们放入 Layout 元素内的内容，如下所示： 1234567export default function About() &#123; return ( &lt;Layout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/Layout&gt; );&#125; 但这只是创建布局组件的一种方法，以下是其他方法。 方法一：布局为高阶组件 1234567891011121314151617181920// components/MyLayout.jsimport Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const withLayout = Page =&gt; &#123; return () =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &lt;Page /&gt; &lt;/div&gt; );&#125;;export default withLayout; 1234567// pages/index.jsimport withLayout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &lt;p&gt;Hello Next.js&lt;/p&gt;;export default withLayout(Page); 1234567// pages/about.jsimport withLayout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &lt;p&gt;This is the about page&lt;/p&gt;;export default withLayout(Page); 方法二：页面内容作为道具 123456789101112131415161718// components/MyLayout.jsimport Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const Layout = props =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &#123;props.content&#125; &lt;/div&gt;);export default Layout; 123456789// pages/index.jsimport Layout from &#x27;../components/MyLayout.js&#x27;;const indexPageContent = &lt;p&gt;Hello Next.js&lt;/p&gt;;export default function Index() &#123; return &lt;Layout content=&#123;indexPageContent&#125; /&gt;;&#125; 123456789// pages/about.jsimport Layout from &#x27;../components/MyLayout.js&#x27;;const aboutPageContent = &lt;p&gt;This is the about page&lt;/p&gt;;export default function About() &#123; return &lt;Layout content=&#123;aboutPageContent&#125; /&gt;;&#125; 创建动态页面Introduction 之前通过使用组件，我们创建了包含了多个页面的小案例，之前为了创建一个页面，我们必须新建一个文件作为模块导出，但是在一个真正的应用程序中，我们还需动态地创建页面以显示动态内容，接下来我们会使用 查询字符串 来实现这一点 我们将创建一个简单的博客应用，它在主页上展示一个所有文章的列表，展示如下： 主页有文章列表 点击某标题的链接，会出现对应的文章 安装设置 我们仍然使用之前安装过的 next-learn-demo，进入 next-learn-demo/3-create-dynamic-pages，接下来的一切也将在这个目录下完成 运行 12npm installnpm run dev 添加文章列表 首先，我们在文章主页添加标题列表，如下： 1234567891011121314151617181920212223import Link from &#x27;next/link&#x27;;import Layout from &#x27;../components/MyLayout.js&#x27;;const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt; &lt;a&gt;&#123;props.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;);export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &lt;PostLink title=&quot;Hello Next.js&quot; /&gt; &lt;PostLink title=&quot;Learn Next.js is awesome&quot; /&gt; &lt;PostLink title=&quot;Deploy apps with Zeit&quot; /&gt; &lt;/ul&gt; &lt;/Layout&gt; )&#125; 通过查询字符串传递数据 我们将通过查询字符串作为参数（也称查询参数）并传递数据，如： 123456789// pages/index.jsconst PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt; &lt;a&gt;&#123;props.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;); 此例中，查询参数是 title，我们使用 PostLink 来执行的操作 你也可以检查 Link 组件的 href 属性，以此类推，你可以使用查询字符串传递任何类型的数据 创建Post页面 现在我们需要创建 post 页面来显示博客文章，为此，我们需要从查询字符串中获得标题， 创建 pages/post.js 文件： 1234567891011121314import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/Layout&gt; );&#125;;export default Page; 启动项目，并点击三个标题链接 上面的运作过程如下： 首先从 next/router 导入并使用 useRouter 函数，该函数返回 Next.js 的是 router 对象 使用路由器（router）中的 query 对象，该对象保存了所有查询参数 然后，使用 router.query.title 获取标题 useRouter 函数的介绍： useRouter 允许你访问页面中的 router 对象，它是一个 React Hook，能与功能组件协同合工作 之前的示例中，useRouter 函数被放到预添加的页面组件中，而下面示例中，useRouter 函数在 Content 组件中，预添加的组件是 Page，但是功能不变 1234567891011121314151617181920import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../components/MyLayout&#x27;;const Content = () =&gt; &#123; const router = useRouter(); return ( &lt;&gt; &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/&gt; );&#125;;const Page = () =&gt; ( &lt;Layout&gt; &lt;Content /&gt; &lt;/Layout&gt;);export default Page; 使用动态路由清理URLIntroduction 请确保你正在使用是 Next.js 9 或更高版本接下来的操作都会在 next-learn-demo/4-clean-urls 中进行，请调至指定目录 我们已经知道了如何使用查询字符串创建动态页面，指向我们的某个博客文章的链接如： 1http：&#x2F;&#x2F; localhost：3000 &#x2F; post？title &#x3D; Hello％20Next.js 而此链接要表达的却是： 1http：&#x2F;&#x2F; localhost：3000 &#x2F; p &#x2F; hello-nextjs 动态路由 启动项目，在 4-clean-urls/ 下输入： 12npm installnpm run dev 我们将使用 Next.js 的 动态路由 功能，它允许你处理 /pages 动态路由 现在我们将创建新页面，并命名为 pages/p/[id].js，这也是我们创建的第一个动态路由，步骤如下： 首先，在 /pages 内添加文件夹 /p 然后，你需要在 /p 文件夹中创建 [id].js，并在这些 js 文件中添加如下内容： 123456789101112import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../../components/MyLayout&#x27;;export default function Post() &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/Layout&gt; );&#125;; 前一页是特殊的，它不会处理 /about 等静态路由，而是会处理 p/ 之后的路由，例如，此页面将处理 /p/hello-next.js，而 /p/post-1/another 页面名称中的带有方括号（[]）使其成为动态路由，你不能使页面名称的一部分成为动态名称，而只能使全名成为动态名称，例如，支持 /pages/p/[id].js，但不支持 /pages/p/post-[id].js 创建动态路线时，我们在方括号（[]）之间添加了 id，这是页面接受到查询参数的名称，因此对于 /p/hello-nextjs，该 query 对象将具有 &#123; id: &#39;hello-nextjs&#39; &#125;，我们可以使用 useRouter() 进行访问 现在，我们新的动态路由添加多个链接，修改 pages/index.js： 12345678910111213141516171819202122232425// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;props.id&#125;`&#125;&gt; &lt;a&gt;&#123;props.id&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;)export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &lt;PostLink id=&quot;Hello-Next.js&quot; /&gt; &lt;PostLink id=&quot;Learn-Next.js&quot; /&gt; &lt;PostLink id=&quot;Deploy-Next.js&quot; /&gt; &lt;/ul&gt; &lt;/Layout&gt; )&#125; 着重看看以下内容： 1234567const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;props.id&#125;`&#125;&gt; &lt;a&gt;&#123;props.id&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;) 在 &lt;Link&gt; 元素中，href 代表的是该页面在 pages 文件夹中的路径，而 as 代表的是该页面在浏览器中的 URL 路径 现在，你可以重新启动项目，注意观察 URL 的变化！ 动态路由可以很好地和浏览器历史记录配合使用，而我们要做的就是将 as 添加到链接组件中 为页面获取数据Introduction 接下来的操作都会在 next-learn-demo/6-fetching-data 中进行，请调至指定目录 现在我们已经能创建一个相对完整的 Next.js 应用，但还没有解决的是：如何从远程数据源中获取数据？，Next.js 提供了一个标准 API 来获取页面所需的数据，即 getInitialProps 异步函数 getInitialProps 只能添加到页面导出的默认组件中，在其他组件中是不会起作用的，它可以从远程数据源为指定页面获取数据，并将这些数据通过 props 传递到我们的页面，它会同时在客户端和服务器上工作，因为它在两个环境中都会被调用 我们将利用 getInitialProps 构建一个应用程序来显示有关 Batman TV Shows 的信息，利用的是公开的 TVmaze API 在即将演示的示例中，我们的主页上有一个文章列表，现在我们来展示 Batman TV shows 的节目列表，我们将从远程服务器上获取这些节目列表，而不是硬编码 在这个示例中，我们使用的是 TVMaze API 来获取 TV shows 节目列表，这是一个搜索电视节目的 API 安装设置 进入 next-learn-demo/6-fetching-data，输入： 12npm installnpm run dev 在浏览器中打开 http://localhost:3000/ 查看项目 获取BatmanShows的数据 首先，我们需要安装 isomorphic-unfetch，这是我们用来获取数据的工具库，这是浏览器的 fetch API 的一个简单实现，但在客户端和服务器环境中都可以使用 1npm install --save isomorphic-unfetch 将 pages/index.js 替换为以下内容： 1234567891011121314151617181920212223242526272829303132333435// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;import fetch from &#x27;isomorphic-unfetch&#x27;;const Index = props =&gt; ( &lt;Layout&gt; &lt;h1&gt;Batman TV Shows&lt;/h1&gt; &lt;ul&gt; &#123; props.shows.map(show =&gt; ( &lt;li key=&#123;show.id&#125;&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;show.id&#125;`&#125;&gt; &lt;a&gt;&#123;show.name&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/Layout&gt;);Index.getInitialProps = async function() &#123; const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;); const data = await res.json(); console.log(`Show data fetched. Count: $&#123;data.length&#125;`); return &#123; shows: data.map(entry =&gt; entry.show) &#125;;&#125;;export default Index; 我们着重分析下面这部分： 12345678910Index.getInitialProps = async function() &#123; const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;); const data = await res.json(); console.log(`Show data fetched. Count: $&#123;data.length&#125;`); return &#123; shows: data.map(entry =&gt; entry.show) &#125;;&#125;; 这是一个静态异步函数，可以添加到程序的任何页面中，使用此函数，我们就可以获取数据并作为 props 传递给我们的页面 以下便是我们的抓取结果，数据被抓取后，将会作为 props 的 ‘show’ 属性传递我们的页面中 注意，我们之前有一行用于打印信息的代码： 1console.log(`Show data fetched. Count: $&#123;data.length&#125;`); 那么到底是在服务器端输出呢，还是在浏览器端的控制台输出呢，现在刷新一下浏览器，会发现之后服务端的控制台显示 在这种情况下，消息只会在服务端输出，因为我们的页面是在服务端绘制的，所以，我们在服务端已经有了数据，没有必要在客户端再次获取这些数据 实现 Post 页面 现在让我们把 TV show 的详细信息添加到 post 中：将 pages/p/[id].js 替换为以下内容： 1234567891011121314151617181920212223// pages/p/[id].jsimport Layout from &#x27;../../components/MyLayout&#x27;;import fetch from &#x27;isomorphic-unfetch&#x27;;const Post = props =&gt; ( &lt;Layout&gt; &lt;h1&gt;&#123;props.show.name&#125;&lt;/h1&gt; &lt;p&gt;&#123; props.show.summary.replace(/&lt;[/]?[pb]&gt;/g), &#x27;&#x27; &#125;&lt;/p&gt; &lt;/Layout&gt;);Post.getInitialProps = async function(context) &#123; const &#123; id &#125; = context.query; const res = await fetch(`https://api.tvmaze.com/shows/$&#123;id&#125;`); const show = await res.json(); console.log(`Fetched show: $&#123;show.name&#125;`); return &#123; show &#125;;&#125;;export default Post; 注意该页的 getInitialProps： 123456789Post.getInitialProps = async function(context) &#123; const &#123; id &#125; = context.query; const res = await fetch(`https://api.tvmaze.com/shows/$&#123;id&#125;`); const show = await res.json(); console.log(`Fetched show: $&#123;show.name&#125;`); return &#123; show &#125;;&#125;; 该函数的第一个参数是 context 对象，此对象包含一个 query 对象，我们用 context.query 来获取信息，即 id 对象，并使其在 TVMaze API 中获取电视节目数据 在这个 getInitialProps 函数中，我们添加了一个 console.log 来打印节目的标题，现在我们看看它将打印到哪里 打开服务器和客户端的控制台，然后启动项目，访问 3000 端口 单击第一个 Batman show 的标题 结果是：会在客户端的控制台输出 与之前不同的是，我们这次只能在客户端看到消息，这是因为我们通过客户端导航到了 post 页面 当我们单击链接时，由于该链接是被 Next.js 的 &lt;Link&gt; 组件包装过的组件，所以页面转换将在浏览器中进行，而不会想服务器发起请求 但是，如果你直接访问的是 post 页面，而不是点击链接（例如，你直接访问 http://localhost:3000/p/975 ），消息会被打印在服务端，而不是客户端 为组件添加样式Introduction 接下来的操作都会在 next-learn-demo/7-styling-components 中进行，请调至指定目录 对于 React，我们可以使用许多不同的技术来设置样式，这些技术可以分为两大类： 传统的基于 CSS 文件的样式设计（包括 SASS、PostCSS 等） CSS in JS 传统的基于 CSS 文件的样式设计（尤其是 SSR）需要考虑一堆的实际问题，因此我们在为 Mext.js 设置样式时避免使用这种方法，相反，我们会在 JS 中使用 CSS，你可以使用它来设置某单个组件的样式，而不是导入 CSS 文件 为此，我们需要认识一个新的框架：styled-jsx，这是Next.js 预装了一个 CSS in JS 框架，它允许你为组件编写熟悉的 CSS 规则，这些 CSS 规则对组件以外的任何内容（当然也包括子组件）都没有影响，也就是说，你的 CSS 规则是有作用域的 安装设置 进入 next-learn-demo/7-styling-components 输入 12npm installnpm run dev 启动项目，访问应用 设置主页的样式 现在我们在主页中添加一些样式，进入 pages/index.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;function getPosts() &#123; return [ &#123; id: &#x27;hello-nextjs&#x27;, title: &#x27;Hello Next.js&#x27; &#125;, &#123; id: &#x27;learn-nextjs&#x27;, title: &#x27;Learn Next.js is awesome&#x27; &#125;, &#123; id: &#x27;deploy-nextjs&#x27;, title: &#x27;Deploy apps with ZEIT&#x27; &#125; ];&#125;export default function Blog() &#123; return ( &lt;Lauout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &#123; getPosts().map(post =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;style jsx&gt;&#123;` h1, a &#123; font-family: &#x27;Arial&#x27;; &#125; ul &#123; padding: 0 &#125; li &#123; list-style: none; margin: 5px, 0; &#125; a &#123; text-decoration: none; color: red; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/Lauout&gt; )&#125; 那个 &lt;style jsx&gt; 元素，就是我们编写 CSS 规则的地方 现在可以启动项目，查看结果 上面的代码中，我们没有直接在 &lt;style&gt; 标签内编写样式代码，而是写在模板字符串（&#123;``&#125;）里面的，Next.js 默认支持 babel 语法，而 styled-jsx 可以看做 babel 的一个插件，它将解析所有 CSS 并将其应用于构建工程 CSS样式和嵌套组件 现在我们将会对主页做一些更改，我们将会像这样隔离 Link 组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;function getPosts() &#123; return [ &#123; id: &#x27;hello-nextjs&#x27;, title: &#x27;Hello Next.js&#x27; &#125;, &#123; id: &#x27;learn-nextjs&#x27;, title: &#x27;Learn Next.js is awesome&#x27; &#125;, &#123; id: &#x27;deploy-nextjs&#x27;, title: &#x27;Deploy apps with ZEIT&#x27; &#125; ];&#125;const PostLink = (&#123; post &#125;) =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;);export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &#123;getPosts().map(post =&gt; ( &lt;PostLink key=&#123;post.id&#125; post=&#123;post&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;style jsx&gt;&#123;` h1, a &#123; font-family: &#x27;Arial&#x27;; &#125; ul &#123; padding: 0; &#125; li &#123; list-style: none; margin: 5px 0; &#125; a &#123; text-decoration: none; color: blue; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/Layout&gt; );&#125; 运行后发现：h1 的样式还在，但是链接已经失效了，如下： 上述结果显示：CSS 样式规则对子组件中的元素没有影响，styled-jsx 这个特性可以帮助你管理大型的应用程序的样式，在这种情况下，我们需要直接设置子组件的样式，在我们的示例中，我们需要对 Link 组件执行以下操作： 123456789101112131415161718192021const PostLink = (&#123; post &#125;) =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;style jsx&gt;&#123;` li &#123; list-style: none; margin: 5px 0; &#125; a &#123; text-decoration: none; color: blue; font-family: &#x27;Arial&#x27;; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/li&gt;); 拓展了解：全局选择器 全局样式 有时我们确实需要更改子组件内部的样式，尤其是在使用支持 React 的 markdown 时 我们需要安装 react-markdown 1npm install --save react-markdown 下面就是全局样式派上用场的地方，现在就来试试利用 styled-jsx 添加一些全局样式，打开 pages/p/[id].js： 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Markdown from &#x27;react-markdown&#x27;;import Layout from &#x27;../../components/MyLayout&#x27;;export default () =&gt; &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt; &lt;div className=&quot;markdown&quot;&gt; &lt;Markdown source=&#123;`This is our blog post.Yes. We can have a [link](/link).And we can have a title as well.### This is a titlr.And here&#x27;s the content. `&#125; /&gt; &lt;/div&gt; &lt;style jsx global&gt;&#123;` .markdown &#123; font-family: &#x27;Arial&#x27;; &#125; .markdown a &#123; text-decoration: none; color: red; &#125; .markdown a:hover &#123; opacity: 0.6; &#125; .markdown h3 &#123; margin: 0; padding: 0; text-transform: uppercase; &#125; `&#125;&lt;/style&gt; &lt;/Layout&gt; );&#125;; 注意，markdown 语法部分的缩进不可修改！！！ 我们定义的 style 作用于整个 &lt;div&gt; 标签部分，也就是作用于全局，虽然这样很方便，但是还是建议写带有作用域的样式 尽管如此，这依然是一个比普通样式标签更好的解决方案，使用 styled-jsx 时，所有必要的特定于浏览器厂商前缀和 CSS 校验都通过了一个 Babel 插件完成了，这并不会导致额外的开销 部署 Next.js 应用程序Introduction 接下来的操作都会在 next-learn-demo/8-deploying 中进行，请调至指定目录 ZEIT Now 是将应用程序部署到生产环境的最简单和可扩展的方法，但是，你可以部署 Next.js 应用程序，而且它相对来讲比较简单 现在我们将部署 Next.js 应用程序 进入 next-learn-demo/8-deploying，输入命令： 12npm installnpm run dev 部署到 ZEIT Now 我们来看一下 package.json 文件的 script 配置段： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot; &#125;, 首先，我们需要为生产环境编译我们的 Next.js 应用程序，它将生成一组优化的用于生产环境的代码： 1npm run build 然后，你需要启动 Next.js 应用程序并监听某个端口，此服务器将执行服务器端渲染并返回静态页面（使用上述命令编译） 1npm run start 现在可以查看效果：http://localhost:3000 运行两个实例 现在我们将为我们的应用程序启动两个实例，通常这样是为了横向扩展我们的应用程序 首先，将 package.json 中的 script 配置端替换为以下的内容： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start -p %PORT%&quot;&#125; 我们更改了 start 脚本，它卸载接受一个代表端口号的参数来启动应用程序 注意，%PORT% 是对于 Windows 来说的，Linux 对应的是 $PORT 现在构建我们的应用程序： 1npm run build 现在我们需要安装一个新的包，即：cross-env，我们在全局环境下安装： 1npm install cross-env -g 同时打开两个终端，分别在终端中输入： 12cross-env PORT=8000 npm startcross-env PORT=9000 npm start 在 Linux 上，则直接打开两个命令行终端，并分别在每个命令行终端上运行： 12PORT=8000 npm startPORT=9000 npm start 现在，在浏览器分别查看：http://localhost:8000 和 http://localhost:9000 可以得到的结果是，你只需要对应用程序构建一次。然后就可以在任意多个端口上启动它 结语 求进之路，持之谦卑","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"next.js","slug":"next-js","permalink":"https://ozzienicholas.gitee.io/tags/next-js/"}]},{"title":"Redux入门Demo：TodoList","slug":"Redux入门Demo：TodoList","date":"2021-03-20T04:27:54.000Z","updated":"2021-03-20T04:28:16.849Z","comments":true,"path":"54fba009696d/","link":"","permalink":"https://ozzienicholas.gitee.io/54fba009696d/","excerpt":"","text":"Demo说明 本次 Demo 使用了 antd 呈现样式，需要通过 npm install antd --save 安装该组件库 在使用 Redux 之前，需要安装 redux，可以用 npm install redux --save 安装 代码以及说明需熟记的图 结果样式 代码 目录结构 123456|-src |-index.js |-TodoList.js |-store |-index.js |-reducer.js /src/index.js 1234567891011//渲染页面import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;//引入TodoList组件import TodoList from &#x27;./TodoList&#x27;ReactDOM.render( &lt;TodoList /&gt;, document.getElementById(&#x27;root&#x27;)) /src/TodoList.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//TodoList组件import React, &#123; Component &#125; from &#x27;react&#x27;//引入storeimport store from &#x27;./store/index&#x27;//引入antd样式import &#x27;antd/dist/antd.css&#x27;//按需引入输入框、按钮、列表项样式import &#123; Input, Button, List &#125; from &#x27;antd&#x27;class TodoList extends Component &#123; constructor(props) &#123; super(props); //通过store的getState方法获取公共数据 this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); //只要store发生改变，就立即执行handleStoreChange这个方法 store.subscribe(this.handleStoreChange); &#125; render() &#123; return ( &lt;div style=&#123;&#123;marginLeft:&#x27;30px&#x27;, marginTop:&#x27;10px&#x27;&#125;&#125;&gt; &lt;div&gt; &lt;Input placeholder=&#x27;TodoList&#x27; style=&#123;&#123;width:&#x27;300px&#x27;, marginRight:&#x27;10px&#x27;&#125;&#125; value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;Button type=&#x27;primary&#x27; onClick=&#123;this.handleBtnClick&#125; &gt; 提交 &lt;/Button&gt; &lt;/div&gt; &lt;List bordered style=&#123;&#123;marginTop:&#x27;10px&#x27;, width:&#x27;500px&#x27;&#125;&#125; dataSource=&#123;this.state.list&#125; renderItem=&#123; (item, index) =&gt; ( &lt;List.Item onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125; &lt;/List.Item&gt; ) &#125; /&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; //触发功能：改变输入框值 const action = &#123; //将此需求用action表达 type: &#x27;CHANGE_INPUT_VALUE&#x27;, //type即需求的描述， value: e.target.value //value是要传给sotre的值 &#125;; store.dispatch(action); //将action传给store，store会自动将action对象的内容传给reducer &#125;; handleStoreChange() &#123; //得到新的state值 //用getState方法得到最新的store数据，并通知setState更新 this.setState(store.getState()) &#125;; handleBtnClick() &#123; //触发功能：增加列表项 const action = &#123; type: &#x27;ADD_LIST&#x27; &#125;; store.dispatch(action) //传给Store &#125;; handleItemDelete(index) &#123; // 触发功能：删除列表项 const action = &#123; type: &#x27;DELETE_LIST&#x27;, value: index &#125; store.dispatch(action) //传给store &#125;&#125;export default TodoList; /src/store/index.js 123456789101112//Store部分//从redux中引入createStore方法import &#123; createStore &#125; from &#x27;redux&#x27;;//引入Reducerimport reducer from &#x27;./reducer&#x27;;const store = createStore( //通过createStore()创建一个公共的数据存储仓 reducer, // 将reducer部分传递给store);export default store; /src/store/reducer.js 1234567891011121314151617181920212223242526272829303132//Reducer部分const defaultState = &#123; inputValue: &#x27;&#x27;, list: [1, 2, 3]&#125;;//reducer负责管理整个store中的数据//reducer里面必须返回一个函数，参数中的state就是整个store仓库里存储的数据export default (state = defaultState, action) =&gt; &#123; //state先定为defaultState if(action.type === &#x27;changeInputValue&#x27;) &#123; //若需触发改变输入框值的功能 //深拷贝state const newState = JSON.parse(JSON.stringify(state)); //改变state的输入框值，即是改变渲染的输入框值 newState.inputValue = action.value; //由于reducer不能直接修改传递过来的state，所以通过newState返回修改的结果 // store会根据newState替换原来的state值 return newState; &#125; if(action.type === &#x27;addTodoItem&#x27;) &#123; //若需触发增加列表项的功能 const newState = JSON.parse(JSON.stringify(state)); //深拷贝state newState.list.push(newState.inputValue); //添加列表项 newState.inputValue = &#x27;&#x27;; //清空输入栏 return newState; &#125; if(action.type === &#x27;DELETE_LIST&#x27;) &#123; //若需触发删除列表项的功能 const newState = JSON.parse(JSON.stringify(state)); //深拷贝state newState.list.splice(action.value, 1); //删除列表项 return newState; &#125; return state;&#125; 优化 之前写 action 的时候，我们会发现诸多不便，比如 type 很容易写错之类的，不如将 action 部分拆分出来，这会提高代码的质量，步骤如下： 新建文件： /src/store/actionTypes.js：用来单独保存 action 的 type /src/store/actionCreators.js：用来封装 action 的创建 代码： 12345/src/store/actionTypes.jsexport const CHANGE_INPUT_VALUE = &#x27;change_input_value&#x27;;export const ADD_LIST = &#x27;add_list&#x27;;export const DELETE_LIST = &#x27;delete_list&#x27;; 123456789101112131415/src/store/actionCreators.jsimport &#123; CHANGE_INPUT_VALUE, ADD_LIST, DELETE_LIST &#125; from &#x27;./actionTypes&#x27;;export const changeInputValueAction = (value) =&gt; (&#123; type: CHANGE_INPUT_VALUE, value&#125;);export const addListAction = () =&gt; (&#123; type: ADD_LIST&#125;);export const deleteListAction = (index) =&gt; (&#123; type: DELETE_LIST, index&#125;) 那么，/src/TodoList.js 可以改为： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import React, &#123; Component &#125; from &#x27;react&#x27;;import store from &#x27;./store/index&#x27;;import &#x27;antd/dist/antd.css&#x27;;import &#123; Input, Button, List &#125; from &#x27;antd&#x27;;//引入创建的 actionimport &#123; changeInputValueAction, addListAction, deleteListAction &#125; from &#x27;./store/actionCreators&#x27;;class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = store.getState(); this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleStoreChange = this.handleStoreChange.bind(this); store.subscribe(this.handleStoreChange); &#125; render() &#123; return ( &lt;div style=&#123;&#123;marginLeft:&#x27;30px&#x27;, marginTop:&#x27;20px&#x27;&#125;&#125;&gt; &lt;div&gt; &lt;Input placeholder=&#x27;TodoList&#x27; style=&#123;&#123;width:&#x27;300px&#x27;, marginRight:&#x27;10px&#x27;&#125;&#125; value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;Button type=&#x27;primary&#x27; onClick=&#123;this.handleBtnClick&#125; &gt; 提交 &lt;/Button&gt; &lt;/div&gt; &lt;List bordered style=&#123;&#123;marginTop:&#x27;10px&#x27;, width:&#x27;500px&#x27;&#125;&#125; dataSource=&#123;this.state.list&#125; renderItem=&#123; (item, index) =&gt; ( &lt;List.Item onClick=&#123;this.handleItemDelete.bind(this, index)&#125;&gt; &#123;item&#125; &lt;/List.Item&gt; ) &#125; /&gt; &lt;/div&gt; ) &#125; handleInputChange(e) &#123; //直接使用 changeInputValueAction，并传入参数 e.target.value const action = changeInputValueAction(e.target.value); store.dispatch(action); &#125; handleBtnClick() &#123; //直接使用 addListAction 这个 action const action = addListAction(); store.dispatch(action) &#125; handleStoreChange() &#123; this.setState(store.getState()) &#125; handleItemDelete(index) &#123; //直接使用 deleteListAction 这个 action const action = deleteListAction(index); store.dispatch(action) &#125;&#125;export default TodoList; 总结 store 必须是唯一的 只有 store 才能改变自己的内容（注意，reducer 是不能改变的） Reducer 必须是纯函数 目前，我们学到的 Redux 的核心 API 有： createStore() store.dispatch() store.getState() store.subScribe()","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"redux","slug":"redux","permalink":"https://ozzienicholas.gitee.io/tags/redux/"}]},{"title":"React教程（五）：TodoList案例","slug":"React教程（五）：TodoList案例","date":"2021-03-20T04:27:10.000Z","updated":"2021-03-20T04:27:31.740Z","comments":true,"path":"c470b271c23e/","link":"","permalink":"https://ozzienicholas.gitee.io/c470b271c23e/","excerpt":"","text":"组件代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// TodoList.jsimport React, &#123; Component, Fragment &#125; from &#x27;react&#x27;;class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: &#x27;&#x27;, list: [] &#125; &#125; render() &#123; return ( &lt;Fragment&gt; &lt;input value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt;提交&lt;/button&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;li key=&#123;index&#125; onClick=&#123;this.handleItemDelete.bind(this, index)&#125; &gt; &#123;item&#125; &lt;/li&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; list: [...this.state.list, this.state.inputValue], inputValue: &#x27;&#x27; &#125;) &#125; handleItemDelete(index) &#123; const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;export default TodoList; 组件拆分重构父组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// TodoList.jsimport React, &#123;Component, Fragment&#125; from &#x27;react&#x27;;import TodoItem from &#x27;./TodoItem.js&#x27;;class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: &#x27;&#x27;, list: [] &#125; &#125;; render() &#123; return ( &lt;Fragment&gt; &lt;label htmlFor=&quot;insertArea&quot;&gt;输入内容&lt;/label&gt; &lt;input id=&quot;insertArea&quot; className=&quot;input&quot; value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange.bind(this)&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick.bind(this)&#125;&gt; 提交 &lt;/button&gt; &lt;ul&gt; &#123; this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem content=&#123;item&#125; index=&#123;index&#125; itemDelete=&#123;this.handleItemDelete.bind(this)&#125; /&gt; ) &#125;) &#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; handleInputChange(e) &#123; this.setState(&#123; inputValue: e.target.value &#125;) &#125; handleBtnClick() &#123; this.setState(&#123; list: [...this.state.list, this.state.inputValue], inputValue: &#x27;&#x27; &#125;) &#125; handleItemDelete(index) &#123; const list = [...this.state.list]; list.splice(index, 1); this.setState(&#123; list: list &#125;) &#125;&#125;;export default TodoList; 子组件12345678910111213141516171819202122// TodoItem.jsimport React, &#123;Component&#125; from &#x27;react&#x27;;class TodoItem extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125;; render() &#123; return ( &lt;li onClick=&#123;this.handleClick&#125;&gt; &#123;this.props.content&#125; &lt;/li&gt; ) &#125;; handleClick() &#123; this.props.itemDelete(this.props.index) &#125;&#125;;export default TodoItem; 代码优化 这里主要是对之前拆分组件的代码进行优化，既考虑美观更考虑性能上的损耗 父组件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// TodoList.jsimport React, &#123;Component, Fragment&#125; from &#x27;react&#x27;;import TodoItem from &#x27;./TodoItem.js&#x27;;class TodoList extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; inputValue: &#x27;&#x27;, list: [] &#125;; this.handleInputChange = this.handleInputChange.bind(this); this.handleBtnClick = this.handleBtnClick.bind(this); this.handleItemDelete = this.handleItemDelete.bind(this); &#125;; render() &#123; return ( &lt;Fragment&gt; &lt;label htmlFor=&quot;insertArea&quot;&gt;输入内容&lt;/label&gt; &lt;input id=&quot;insertArea&quot; className=&quot;input&quot; value=&#123;this.state.inputValue&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;button onClick=&#123;this.handleBtnClick&#125;&gt; 提交 &lt;/button&gt; &lt;ul&gt; &#123;this.getTodoItem()&#125; &lt;/ul&gt; &lt;/Fragment&gt; ) &#125; getTodoItem() &#123; return ( this.state.list.map((item, index) =&gt; &#123; return ( &lt;TodoItem key=&#123;index&#125; content=&#123;item&#125; index=&#123;index&#125; itemDelete=&#123;this.handleItemDelete&#125; /&gt; ) &#125;) ) &#125; handleInputChange(e) &#123; const value = e.target.value; this.setState(() =&gt; (&#123; inputValue: value &#125;)); &#125; handleBtnClick() &#123; this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue], inputValue: &#x27;&#x27; &#125;)); &#125; handleItemDelete(index) &#123; this.setState((prevState) =&gt; &#123; const list = [...prevState.list]; list.splice(index, 1); return &#123;list&#125; &#125;); &#125;&#125;;export default TodoList; 子组件123456789101112131415161718192021222324// TodoItem.jsimport React, &#123;Component&#125; from &#x27;react&#x27;;class TodoItem extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125;; render() &#123; const &#123;content&#125; = this.props; return ( &lt;li onClick=&#123;this.handleClick&#125;&gt; &#123;content&#125; &lt;/li&gt; ) &#125;; handleClick() &#123; const &#123;itemDelete, index&#125; = this.props; itemDelete(index) &#125;&#125;;export default TodoItem;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"}]},{"title":"React教程（四）：事件处理","slug":"React教程（四）：事件处理","date":"2021-03-20T04:26:39.000Z","updated":"2021-03-20T04:26:53.794Z","comments":true,"path":"3be8c2facc48/","link":"","permalink":"https://ozzienicholas.gitee.io/3be8c2facc48/","excerpt":"","text":"与 DOM 元素事件的区别 这个我们在之前提到过，就是 React 元素的事件必须使用 camelCase 的命名方法（类似 onClick 这种），而不是全小写的形式（类似 onclick 这种） React 元素的事件使用 JSX 语法，传入的是句柄，而不是一个字符串，例如： React 元素事件： 12345&lt;!-- 点击按钮即触发 add 函数 --&gt;&lt;!-- 注意 onClick 大写，以及 add 用花括号括起来 --&gt;&lt;button onClick=&#123;add&#125;&gt; doSomething...&lt;/button&gt; DOM 元素事件： 12345&lt;!-- 点击按钮即触发 add 函数 --&gt;&lt;!-- 注意 onclick 小写，以及 add 用字符串表示 --&gt;&lt;button onclick=&quot;add()&quot;&gt; doSomething...&lt;/button&gt; 在原生 DOM 中，我们可以通过 false 来阻止 默认事件，但这在 React 中行不通，React 中需要使用 preventDefault() 来阻止默认行为，例如，下面都会阻止默认打开指向的网页： DOM： 123&lt;a href=&quot;https://www.baidu.com/&quot; onclick=&quot;console.log(&#x27;已点击&#x27;); return false&quot;&gt; Click Me&lt;/a&gt; React： 123456789101112131415161718192021222324252627import React, &#123; Component &#125; from &#x27;react&#x27;;import ReactDOM from &quot;react-dom&quot;;class App extends Component &#123; constructor(props) &#123; super(props); // 为了在回调中使用 this，这里必须绑定 this this.handleClick = this.handleClick.bind(this); &#125; render() &#123; return ( &lt;a href=&quot;https://www.baidu.com/&quot; onClick=&#123;this.handleClick&#125;&gt; Click Me &lt;/a&gt; ) &#125; handleClick(e) &#123; // 这里的 e 是一个合成事件 e.preventDefault(); // 阻止默认事件，使得点击链接不会跳转 console.log(&#x27;The link was clicked.&#x27;); &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)) 原生事件与合成事件 原生事件：比如你在 componentDidMount 方法里面通过 addEventListener 绑定的事件就是原生事件，使用原生事件的时候注意在 componentWillUnmount 中解除绑定 removeEventListener 合成事件：react 实现了一个 “合成事件层”，这个事件模型保证了和 W3C 标准保持一致，这个事件层消除了 IE 与 W3C 标准之间的兼容问题 事件委托：合成事件会以事件委托的方式绑定到组件的最上层，并在组件卸载时自动销毁绑定的事件 如果混用 “原生事件“ 与 ”合成事件“，比如用原生事件在 document 上面绑定，然后在组件里面绑定的事件想要通过 e.stopPropagation() 来阻止事件冒泡到 document，这是不可以的，因为 e.stopPropagation 是内部 “合成事件” 层面的，解决方法是要用 e.nativeEvent.stopImmediatePropagation() 合成事件的 event 对象只在当前 event loop 有效，如果你想在事件里面调用一个 promise，在 resolve 之后去拿 event 对象会拿不到（并且没有错误抛出）： 123handleClick(e) &#123; promise.then(() =&gt; doSomethingWith(e));&#125; 参考：React — 合成事件 关于 this 的绑定 在用 class 创建组件的时候，函数通常都是声明为 class 中的方法 在 react 中，除了构造函数和生命周期钩子函数会自动绑定 this，class 中的方法不会默认绑定 this，在前一个案例中，如果你的 handleClick 方法没有绑定 this，那么会报错 “handleClick is not defined” 在方法上绑定 this 的途径有： 通过 bind() 在调用时绑定： 12345678910class App extends Component &#123; render() &#123; return ( &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick() &#123; alert(&quot;Hello World&quot;) &#125;&#125; Function.prototype.bind(thisArg [, arg1 [, arg2, …]]) 是 ES5 新增的函数扩展方法，bind() 返回一个新的函数对象，该函数的 this 被绑定到 this.Arg 上，并向事件处理器中传入参数 在构造函数中绑定： 1234567891011121314class App extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick() &#123; alert(&quot;Hello World&quot;) &#125;&#125; 这样做的好处，如果组件中需要多次使用该方法，那么仅需要在构造函数中绑定一次即可，而不是每次使用时都加上 bind 来绑定 用箭头函数绑定： 1234567891011class App extends Component &#123; render() &#123; return ( // 这实际上是执行了一个回调函数，在回调函数中执行 handleClick 方法 &lt;button onClick=&#123; () =&gt; &#123;this.handleClick()&#125; &#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick() &#123; alert(&quot;Hello World&quot;) &#125;&#125; 箭头函数则会捕获其所在上下文的 this 值，作为自己的 this 值，使用箭头函数就不用担心函数内的this 不是指向组件内部了 这种语法的问题是每次渲染组件时都会创建不同的回调函数，如果我们将这个回调函数作为 prop 传入子组件，那么这个组件很可能会有额外的重新渲染，所以最佳的方案还是写在构造器中 传递参数 若采用 bind 绑定 this 的方法，则传参的方式为：this.方法名.bind(this, arg1, arg2, ...)，例如： 12345678910class App extends Component &#123; render() &#123; return ( &lt;button onClick=&#123;this.handleClick.bind(this, 0, 1)&#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick(num) &#123; alert(num1 + num2) &#125;&#125; 若采用构造器中绑定 this 的方法，则传参的方式为：this.方法名(arg1, arg2, ...)，例如： 1234567891011121314class App extends Component &#123; constructor(props) &#123; super(props); this.handleClick = this.handleClick.bind(this, 0, 1) &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick(num1, num2) &#123; alert(num1+num2) &#125;&#125; 这也是推荐的方式 若采用箭头函数绑定 this 的方法，则传参的方式为：() =&gt; &#123;this.方法名(arg1, arg2, ...)&#125;，例如： 12345678910class App extends Component &#123; render() &#123; return ( &lt;button onClick=&#123; () =&gt; &#123;this.handleClick(0, 1)&#125; &#125;&gt;Click Me&lt;/button&gt; ) &#125; handleClick(num1, num2) &#123; alert(num1 + num2) &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"}]},{"title":"React教程（三）：State与生命周期","slug":"React教程（三）：State与生命周期","date":"2021-03-20T04:24:31.000Z","updated":"2021-03-20T04:26:24.222Z","comments":true,"path":"86e6fb92280e/","link":"","permalink":"https://ozzienicholas.gitee.io/86e6fb92280e/","excerpt":"","text":"State介绍 React 数据流 在 react 中，数据是单向流动的，即从父组件到子组件 state 与 props 是 react 组件中最重要的概念： state 只关心每个组件自己内部的状态，这些状态也只能在组件内部改变 如果顶层组件初始化 props，那么 react 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件 把组件看做一个函数，那么 props 可看做这个函数要接收的参数，state 可看做函数的内部参数，总体上返回一个 Virtual DOM 的实现 认识 state react 把组件看作是一个状态机：通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致，组件的任何 UI 改变，组件就会自动调用 render 重新渲染 UI，这个更改的动作会通过 this.setState方法来触发，state中的所有状态都用于反映 UI 的变化，不应有多余状态 什么样的数据属性可以当作状态？当更改这个状态（数据）需要更新组件 UI 的就可以认为是 state，下面这些可以认为 不是 状态： 可计算的数据：比如一个数组的长度 和 props 重复的数据：除非这个数据是要做变更的 通过 props 从父组件中获取 在组件的整个生命周期中都保持不变 通过其他状态（state）或者属性（props）计算得到 在组件的render方法中使用（这种情况下，这个变量更适合定义为组件的一个普通属性） state 与 props 的区别：state 和 props 的变化都会触发组件 UI 的重新渲染，区别在于能否自身修改 props 是通过父组件传递给子组件的，对于使用它的组件来说是只读的，props 只能在父组件中修改 state 是组件内部自己维护的状态，使用它的组件在自身就可以修改 概括起来就类似于，state 是组件对内的接口，props 是组件对外的接口 react 通过 this.state 来访问 state，通过 this.setState 来更新 state，当 this.setState 被调用的时候，react 会重新调用 render 方法来重新渲染 UI state 的修改state 不能直接修改：直接以赋值的形式修改 state 不会触发组件的 render，修改 state 需要用 setState 方法： 1234567// 错误this.stae.title = &quot;react&quot;;// 正确this.setState (&#123; title: &quot;react&quot;&#125;) state 的类型 建议把 state 当做是不可变对象，state 中包含的所有状态都应该是不可变对象，当 state 中的某个状态发生变化，我们应该重新创建这个状态对象，而不是直接修改原来的状态 根据状态类型，state 可以分为以下三种： 数字，字符串，布尔值，null，undefined 这五种不可变类型：因为其本身就是不可变的，如果要修改状态的话，直接赋新值就可以，例如： 12345this.setState(&#123; a: 1, b: &quot;Hello&quot;, c: true&#125;) 数组 类型：JS 中数组类型为可变类型，假设现在有一个数组类型的状态 “books”，当你向 “book” 增加一个字符串常量时，需要使用数组的 concat 方法或者 ES6 的数组扩展语法，例如： 123456789101112131415// 方法一：先将 state 赋值给另外的变量，然后使用 concat 创建新数组let books = this.state.books;this.setState (&#123; books: books.concat([&quot;oneBook&quot;])&#125;)// 方法二：使用 preState、concat 创建数组this.setState (preState =&gt; (&#123; books: preState.books.concat([&quot;oneBook&quot;])&#125;))// 方法三：ES6 数组扩展语法this.setState (preState =&gt; (&#123; books: [...preState.books, &quot;oneBook&quot;]&#125;)) 当从 books 中截取部分元素作为新状态时，要使用数组的 slice 方法： 12345678910&#x2F;&#x2F; 方法一：先将 state 赋值给另外的变量，然后使用 slice 创建新数组let books &#x3D; this.state.books;this.setState (&#123; books: books.slice(1, 3);&#125;)&#x2F;&#x2F; 方法二：使用 preState、slice 创建新数组this.setState (preState, (&#123; books: preState.books.slice(1, 3)&#125;)) 当从 books 中过滤部分元素后，作为新状态，使用数组的 filter 方法： 1234567891011121314// 方法一：先将 state 赋值给另外的变量，然后使用 filter 创建新数组let books = this.state.books;this.setState (&#123; books: books.filter(item =&gt; &#123; return item == &quot;oneBook&quot; &#125;)&#125;)// 方法二：使用 preState、filter 创建新数组this.setState (preState =&gt; (&#123; books: preState.books.filter(item =&gt; &#123; return item == &quot;oneBook&quot; &#125;)&#125;)) 注意：不要使用 push、pop、shift、unshift、splice 等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改的，应当使用不会修改原数组而返回一个新数组的方法，例如 concat、slice、filter 等 普通对象 类型（不包括字符串、数组）：JS 中对象也是可变类型，修改对象类型的状态时，不要修改原来的状态，可以使用 ES6 的 Object.assign 方法或者对象扩展语法。假设现在有一个对象类型的状态 “owner”，当你向对象中增加一个键值对 name: &quot;ozzie&quot;，时，需要使用 Object.assgin 方法或者对象的扩展语法： 使用 Object.assgin 方法： 12345678910// 方法一：将 state 先赋值给另外的变量，然后使用 Object.assign 创建新对象let owner = this.state.owner;this.setState (&#123; owner: Object.assgin(&#123;&#125;, owner, &#123;name: &quot;ozzie&quot;&#125;)&#125;)//方法二：使用 preState、Object.assgin 创建新对象this.setState (preState, (&#123; owner: Object.assgin(&#123;&#125;, preState.owner, &#123;name: &quot;ozzie&quot;&#125;)&#125;)) 使用对象扩展语法： 12345678910// 方法一：将 state 先赋值给另外的变量，然后使用对象扩展语法创建新对象let owner = this.state.owner;this.setState (&#123; owner: &#123;...owner, name: &quot;ozzie&quot;&#125;&#125;)// 方法二：使用 preState、对象扩展语法创建新对象this.setState (preState =&gt; (&#123; owner: &#123;...preState.owner, name: &quot;ozzie&quot;&#125;&#125;)) 创建新的状态对象的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然，也可以使用一些 Immutable 的 JS 库，如 Immutable.js，实现类似的效果。 为什么组件的状态最好是不可变对象呢？ 一方面，对不可变对象的修改会返回一个新对象，不需要担心原有对象在不小心的情况下被修改导致的错误，方便程序的管理和调试 另一方面是出于性能考虑，当对象组件状态都是不可变对象时，在组件的shouldComponentUpdate方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的render调用 生命周期 生命周期就是框架会在规定的时间自动触发的函数 React 16.0 之前的生命周期生命周期图示 生命周期函数分类： 生命周期函数的执行流程： 生命周期阶段分析 按执行顺序可大致分为：初始化阶段、挂载阶段、更新阶段、卸载阶段 初始化阶段：constructor() constructor 是 ES6 对类的默认语法，通过 new 命令生成一个新的对象实例时自动调用方法（调用一次），该方法是必须有的，若没有显式定义，则会默认添加空的 constructor 方法，若有显式定义，则会手动调用 super 方法 若在 constructor 中访问 this.props，则需要传入 props： 123456class App extends React.Component &#123; constructor(props) &#123; super(props); // 声明 constructor 时必须调用 super 方法 console.log(this.props) // 此时可以正常访问 this.props &#125;&#125; constructor 也常用来初始化 state： 123456class App extends React.Component &#123; constructor(props) &#123; super(props); // 声明 constructor 时必须调用 super 方法 this.state = &#123;name: &quot;ozzie&quot;&#125;; // 状态初始化 &#125;&#125; 挂载阶段：componentWillMount()、render() 和 componentDidMount() componentWillMount()：在组件挂载之前调用，且全局只调用一次，一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经历了 constructor() 初始化数据后，但是还未渲染 DOM时 render()：render 是一个组件必须定义的生命周期函数，用来渲染 DOM，而且它必须返回一个 react 元素（通常返回一个 UI 组件），不负责组件的实际渲染工作，之后由 react 自身根据此元素去渲染出页面 DOM 注：render 必须是纯函数，且不能在 render 里面修改 state，这会触发死循环导致栈溢出 componentDidMount()：组件第一次渲染完成，此时 DOM 节点已经生成，它在组件挂载完成后调用，且全局只调用一次，可以在这里调用 ajax 请求，返回数据 setState 后组件会重新渲染 更新阶段：componentWillReceiveProps(nextProps)、shouldComponentUpdate(nextProps,nextState)、componentWillUpdate(nextProps,nextState) 以及 componentDidUpdate(prevProps, prevState) react 组件渲染机制：无论是 setState 引起的 state 更新，还是父组件重新 render 导致的 props 更新，更新之后的 state 和 props 无论相对之前是否有变化，都将重新 render componentWillReceiveProps (nextProps)：props 发生变化或者父组件重新渲染都会触发此函数，该钩子比较 nextProps 与 this.props，将 nextProps 的 state 替换掉当前的 state，从而重新渲染组件： 12345678componentWillReceiveProps (nextProps) &#123; nextProps.num !== this.props.num &amp;&amp; this.setState (&#123; num: nextProps.num &#125;, () =&gt; &#123; console.log(this.state.num:nextProps) // 将 state 更新为 nextProps，在 setState 的第二个参数（回调）中可打印出新的 state &#125;)&#125; shouldComponentUpdate(nextProps,nextState)：组件挂载后，每次调用 setState 后都会调用此钩子来判断是否需要重新渲染，即用 nextProps、nextState 与 this.props、this.state 比较来判断是否需要重新渲染，需要重新渲染则返回 true，再重新 render，否则返回 false 一般此钩子用于性能优化：当要更新一个组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它所有的子组件重新执行 render，形成新的虚拟DOM，再用 diff 算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染，这样做会造成性能浪费，所以可以根据需要，在 shouldComponentUpdate() 中加入条件判断，避免不必要的更新 componentWillUpdate(nextProps,nextState)：在组件即将被更新时触发，shouldComponentUpdate 返回 true 或者调用 forceUpdate 之后，此钩子会被调用。 注：不能在此钩子中使用 setState，否则会触发重复循环 componentDidUpdate(prevProps, prevState)：此方法在组件更新之后被调用，除了首次 render 之后调用 componentDidMount，其它 render 结束之后都是调用此钩子，它可以操作组件更新 DOM，preProps 以及 prevState 这两个参数指的是组件更新前的 props 和 state 注：该钩子内 setState 有可能会触发重复渲染，需要自行判断，否则会进入死循环 卸载阶段：componentWillUnmount() componentWillUnmount()：此钩子在组件卸载前被调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器、取消 Redux 的订阅事件、清除 componentDidMount 中手动创建的DOM元素等等，以避免引起内存泄漏 代码测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import React, &#123; Component &#125; from &#x27;react&#x27;;import ReactDOM from &quot;react-dom&quot;;class Father extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; number: 0, name: &quot;Fan&quot; &#125; &#125; UNSAFE_componentWillMount() &#123; console.log(&quot;Father: componentWillMount&quot;) // 1 &#125; shouldComponentUpdate(nextProps, nextState) &#123; console.log(&quot;Father: shouldComponentUpdate&quot;) // if(nextState.number%2 === 0) return true else &#123; return false; &#125; &#125; componentWillUpdate() &#123; console.log(&quot;Father: componentWillUpdate&quot;) // &#125; componentDidUpdate() &#123; console.log(&quot;Father: componentDidUpdate&quot;) &#125; handleClick() &#123; let num = this.state.number this.setState(&#123; number: num + 1 &#125;) &#125; render() &#123; console.log(&quot;Father: render&quot;) // 2 return ( &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;+&lt;/button&gt; &lt;hr /&gt; &#123;this.state.number%2==0 ? &lt;Son number=&#123;this.state.number&#125;&gt;&lt;/Son&gt; : null&#125; &lt;/div&gt; ) &#125; componentDidMount() &#123; console.log(&quot;Father: componentDidMount&quot;) // 3 &#125;&#125;class Son extends React.Component &#123; UNSAFE_componentWillMount() &#123; console.log(&quot;Son: componentWillMount&quot;) // 1 &#125; componentDidMount() &#123; console.log(&quot;Son: componentDidMount&quot;) // 3 &#125; componentWillReceiveProps() &#123; console.log(&quot;Son: componentWillReceiveProps&quot;) &#125; shouldComponentUpdate() &#123; console.log(&quot;Son: shouldComponentUpdate&quot;) // return false; return true; &#125; componentWillUpdate() &#123; console.log(&quot;Son: componentWillUpdate&quot;) // &#125; componentDidUpdate() &#123; console.log(&quot;Son: componentDidUpdate&quot;) &#125; render() &#123; console.log(&quot;Son: render&quot;) return ( &lt;div&gt; &lt;h1&gt;子组件&lt;/h1&gt; &lt;p&gt;&#123;this.props.number&#125;&lt;/p&gt; &lt;/div&gt; ) &#125; componentWillUnmount() &#123; console.log(&quot;Son: componentWillUnmount&quot;) &#125;&#125;ReactDOM.render( &lt;Father /&gt;, document.getElementById(&quot;root&quot;)) 打开控制台，点击按钮，观察各个钩子的执行顺序 React 16.4 生命周期生命周期图示 相对原版的变化对比 新版移除的三个生命周期钩子： componentWillMount componentWillReceiveProps componentWillUpdate 新版声明的生命周期钩子： static getDerivedStateFromProps(nextProps, prevState) getSnapshotBeforeUpdate(prevProps, prevState) 为什么需要改变生命周期见文章：新老生命周期对比 新增生命周期钩子的分析 static getDerivedStateFromProps(nextProps, prevState)： 每次渲染之前都会调用，不管造成重新渲染的原因是什么，不管初始挂载还是之后更新都会调用，功能可以说是代替了 componentWillReceiveProps()，因为 componentWillReceiveProps() 只有在父组件造成重新渲染时才调用 两个参数：nextProps 表示父组件传入的值，prevState 表示组件自身的 state 使用该方法，需要在该方法中返回一个 对象或null： 若返回对象，则会更新 state 若返回 null，则表示不更新 使用钩子时要初始化 state，否则在控制台中会出现警告信息，不能在该方法内部调用 this.state getSnapshotBeforeUpdate(prevProps, prevState)： 在 render() 之后，componentDidUpdate() 之前调用，此钩子返回的任何值都将作为参数传递给componentDidUpdate()，功能可以说是代替了 componentWillUpdate，因为常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中处理 两个参数：prevProps 表示更新前的 props，prevState 表示更新前的 state 代码测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React, &#123; Component &#125; from &#x27;react&#x27;;import ReactDOM from &quot;react-dom&quot;;class Father extends Component &#123; constructor(props) &#123; super(props) this.state = &#123; number: 0 &#125; &#125; handleClick() &#123; let num = this.state.number this.setState(&#123; number: num + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;父组件&lt;/h1&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleClick.bind(this)&#125;&gt;+&lt;/button&gt; &lt;hr /&gt; &lt;Son number=&#123;this.state.number&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125;&#125;class Son extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; number: 0 &#125; &#125; // nextProps 是父给子传递的过来的新的数据 // prevState 是子的上一次的状态 //每次更新都会触发 static getDerivedStateFromProps(nextProps, prevState) &#123; // nextProps 表示父向下传递的新的值 1 2 3 4 5 // prevState 0 0 0 console.log(nextProps, prevState) // &#123;number: 0&#125; &#123;number: 0&#125; let &#123; number &#125; = nextProps; console.log(number) // if(number%2 === 0) // return &#123; number:number+10 &#125; // else // return &#123; number:number+100 &#125; // prevState 表示是子组件的上一次状态 if (number % 2 === 0) &#123; console.log(prevState.number) return &#123; number: prevState.number + number + 10 &#125; &#125; else &#123; console.log(prevState.number) return &#123; number: prevState.number + number + 100 &#125; &#125; &#125; handleChange() &#123; let num = this.state.number this.setState(&#123; number: num + 1000 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;子组件&lt;/h1&gt; &lt;p&gt;&#123;this.state.number&#125;&lt;/p&gt; &lt;button onClick=&#123;this.handleChange.bind(this)&#125;&gt;改变状态&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;Father /&gt;, document.getElementById(&quot;root&quot;)) 打开控制台，点击按钮，观察各个钩子的执行顺序 本节介绍了 state 以及 生命周期，虽然对生命周期还是晕晕的，但是之后遇到案例了会继续分析的，加油！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"}]},{"title":"React教程（二）：初识组件与Props","slug":"React教程（二）：初识组件与Props","date":"2021-03-20T04:20:28.000Z","updated":"2021-03-20T04:20:43.426Z","comments":true,"path":"3458eef757e3/","link":"","permalink":"https://ozzienicholas.gitee.io/3458eef757e3/","excerpt":"","text":"组件介绍认识组件 组件（component）能够将 UI 划分为独立的、可复用的部分，这样我们就只需专注于构建每一个单独的部件。从概念上看，组件就像是函数：接受任意的输入（称为属性，即 Props），返回 React 元素。可以说，一个 React 应用就是构建在 React 组件之上的 组件有两个核心概念：props 与 state，一个组件就是通过这两个属性的值在 render 方法里面生成这个组件对应的 HTML 结构 注意：组件生成的 HTML 结构只能有一个单一的根节点 Propsprops 就是组件的属性，在外部通过 JSX 属性传入设置，一旦初识设置完成，那么 this.props 就是不可更改的，所以，不要轻易更改设置 this.props 里面的值 Statestate 就是组件的当前状态，你可以简单地把组件看做是一个 “状态机”，根据状态 state 呈现不同的 UI 展示，一旦状态（数据）更改，组件就会自动调用 render 重新渲染 UI，这个更改的动作会通过 this.setState 方法来触发 划分状态数据 原则：让组件尽可能地少状态（这样组件逻辑就越容易维护） 什么样的数据属性可以当作状态？当更改这个状态（数据）需要更新组件 UI 时，就可以认为是 state，比如下面这些就可以认为 不是状态 的 可计算的数据：比如一个数组的长度 和 props 重复的数据（除非这个数据是要做变更的） 无状态组件我们也可以用纯粹的函数来定义无状态的组件（stateless function），这种组件没有状态，没有生命周期，只是简单的接受 props 渲染生成 DOM 结构，无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义： 12345const HelloMessage &#x3D; (props) &#x3D;&gt; &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;render( &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt;, document.getElementById(&quot;root&quot;)) 因为无状态组件只是函数，所以它没有实例返回，这点在想用 refs 获取无状态组件的时候要注意，参见DOM 操作 组件的定义 React 中，组件的定义有两种方式：函数定义、类定义 函数定义这是最简单的定义组件的方式，就像写一个 JS 函数一样： 123function HelloMessage(props) &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;&#125; 类定义用 ES6 中的类来定义组件，这比函数定义更加灵活： 12345class HelloMessage extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt; &#125;&#125; 补充注意，组件的名称必须以 大写字母 开头，因为 React 会将以小写字母开头的组件视为原生 DOM 标签，比如 &lt;div /&gt; 代表 HTML 的 &lt;div&gt; 标签，而 &lt;Div /&gt; 则代表一个组件，并且需要在作用域内使用组件 渲染组件我们在之前遇到的 React 元素都只是 DOM 标签，例如： 1const element &#x3D; &lt;div&gt;Hello&lt;&#x2F;div&gt; 除此之外，React 元素还能是自定义的组件，例如： 1const element &#x3D; &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt; 当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性以及子组件转换为单个对象传递给组件，这个对象被称之为 props，例如下面这段代码会在页面上渲染为 &lt;div&gt;Hello Ozzie&lt;/div&gt; 12345678function HelloMessage(props) &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;&#125;const element &#x3D; &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt;;ReactDOM.render( element, document.getElementById(&quot;root&quot;)) 这个 name=&quot;Ozzie&quot; 最终会以 props.name 的方式传递给组件 对上述代码，渲染过程如下： 对 &lt;HelloMessage name=&quot;Ozzie&quot;/&gt; 元素，调用了 ReactDOM.render 方法 React 将 &#123;name: &quot;Ozzie&quot;&#125; 作为 props 的实参来调用 HelloMessage 组件 HelloMessage 完成渲染，返回 &lt;div&gt;Hello Ozzie&lt;/div&gt; 元素 ReactDOM 计算最小更新代价，然后更新 DOM 组合组件初识组合组件使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用 这就意味着我们可以在一个组件的内部引用其他的组件，在 React 组件中，要想包含其他组件作为子组件，只需要把组件当作一个 DOM 元素引入就可以了，例如下面的代码中，我们会在 &lt;App /&gt; 组件中多次调用 &lt;HelloMessage /&gt; 组件 1234567891011121314151617181920class HelloMessage extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt; &#125;&#125;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;HelloMessage name&#x3D;&quot;A&quot; &#x2F;&gt; &lt;HelloMessage name&#x3D;&quot;B&quot; &#x2F;&gt; &lt;HelloMessage name&#x3D;&quot;C&quot; &#x2F;&gt; &lt;&#x2F;div&gt; ) &#125;&#125;ReactDOM.render( &lt;App &#x2F;&gt;, document.getElementById(&quot;root&quot;)) 注意，在 React 中，组件必须返回单一的根元素，换句话说，就是 render() 的返回内容必须只有一个根标签，所以上面的三个 &lt;HelloMessage /&gt; 组件都被一个 &lt;div&gt; 根标签包裹着，如果是下面这种，就会出错！！！ 1234567render() &#123; return ( &lt;HelloMessage name&#x3D;&quot;A&quot; &#x2F;&gt; &lt;HelloMessage name&#x3D;&quot;B&quot; &#x2F;&gt; &lt;HelloMessage name&#x3D;&quot;C&quot; &#x2F;&gt; )&#125; 这里出现了三个根标签，是错误的写法 循环插入子元素如果组件中存在着需要循环插入的子元素，为了保证重新渲染 UI 时能正确地显示这些子元素，每个元素都需要通过一个特殊的 key 属性去指定一个唯一的值，至于这么做的原因，粗略地说，是为了内部 diff 的效率，详细原因参考：Reconciliation key 必须直接在循环中设置，例如： 123456789101112131415const ListItemWrapper &#x3D; (props) &#x3D;&gt; &lt;li&gt;&#123;props.data&#125;&lt;&#x2F;li&gt;const MyComponent &#x3D; (props) &#x3D;&gt; &#123; return ( &lt;ul&gt; &#123;props.array.map((item) &#x3D;&gt; &#123; return &lt;ListItemWrapper key&#x3D;&#123;item.id&#125; data&#x3D;&#123;item&#125; &#x2F;&gt; &#125;)&#125; &lt;&#x2F;ul&gt; )&#125;ReactDOM.render( &lt;MyComponent array&#x3D;&#123;[1, 2, 3]&#125; &#x2F;&gt;, document.getElementById(&quot;root&quot;)) 以上过程梳理如下： &lt;MyComponent /&gt; （父组件）嵌套着 &lt;ListItemWrapper /&gt; （子组件） 父组件接受外部传入的数据，并放在父组件的 props 中，props 的 array 属性是一个数组 遍历 props.array 中的每一个元素，赋给 item，再将 item 的下标（也就是 item.id）作为 key 值保证正确渲染，再将 item 通过 data 传给子组件，所以，子组件的 props.data 也就是父组件中的 item 最后在每一个子组件中渲染出来 你也可以用一个 key 值作为属性，子元素作为属性值的对象字面量来显示子元素列表，虽然这种用法的场景有限，但是在这种情况下要注意生成的子元素重新渲染后在 DOM 中显示的顺序问题，参考：Keyed Fragments 实际上，浏览器在遍历每一个字面量对象的时候都会保持顺序一致，除非属性值可以用整数来替换，这会导致顺序紊乱，为了防止这种情况，我们最好在 key 值前面加上字符串前缀，承接上一个案例，修改如下： 123456789render() &#123; const obj &#x3D; &#123;&#125;; this.props.array.forEach((item) &#x3D;&gt; &#123; obj[&#39;item:&#39; + item.id] &#x3D; &lt;li&gt;&#123;item&#125;&lt;&#x2F;li&gt; &#125;) return ( &lt;ol&gt;&#123;obj&#125;&lt;&#x2F;ol&gt; )&#125; this.props.children组件标签里面包含的子元素会通过 this.props.children 传递进来，比如： 1234ReactDOM.render ( &lt;Parent&gt;&lt;Child &#x2F;&gt;&lt;&#x2F;Parent&gt;, document.getElementById(&quot;root&quot;)) 1234ReactDOM.render ( &lt;Parent&gt;&lt;span&gt;hello&lt;&#x2F;span&gt;&#123;&#39;World&#39;&#125;&lt;&#x2F;Parent&gt;, document.getElementById(&quot;root&quot;)) HTML 元素会作为 React 的组件对象，JS 表达式的结果是一个文字结点，都会存入 Parent 组件的 props.children 一般来说，可以直接将 props.children 这个属性作为父组件的子元素来渲染，承接上一段代码，定义父组件如下： 1const Parent &#x3D; (props) &#x3D;&gt; &lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt; props.children 通常是一个组件对象的数组，但是当只有一个子元素的时候，props.children 将是这个唯一的子元素，而不是数组了。 Props 的只读性无论是函数式定义还是类定义组件，都不能修改自身的 props 来看看下面这个函数： 123function sum(a, b) &#123; return a+b;&#125; 这样的函数被称为纯函数，它的特点有： 函数不会改变入参 对于相同的输入，函数总会返回相同的值 与纯函数对应的，是非纯函数，如下： 123function withdraw (account, amount) &#123; account.total -= amount;&#125; 这里的非纯函数在函数体内改变了入参 React 的规定是：所有 React 组件都必须像纯函数一样保护它们的 props 不被更改 本节主要认识了 React 组件以及 props 的用法，继续加油吧！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"}]},{"title":"React教程（一）：JSX的认识与使用","slug":"React教程（一）：JSX的认识与使用","date":"2021-03-20T04:19:45.000Z","updated":"2021-03-20T04:20:12.084Z","comments":true,"path":"6b9099691f77/","link":"","permalink":"https://ozzienicholas.gitee.io/6b9099691f77/","excerpt":"","text":"简单了解 JSX 相关文档：JSX 、JSX · TypeScript 、JSX 简介 虽然 JSX 语法糖并不是必须的，但可以明显地感受到 JSX 很利于提升开发效率，例如： 未使用 JSX： 1234567891011121314class HelloMessage extends React.Component &#123; render() &#123; return React.createElement ( &quot;div&quot;, null, &quot;Hello &quot;, this.props.name ); &#125;&#125;ReactDOM.render( React.createElement( HelloMessage, &#123; name: &quot;Ozzie&quot; &#125; ), document.getElementById(&quot;container&quot;)) 使用 JSX： 12345678910111213class HelloMessage extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello &#123;this.props.name&#125; &lt;div&gt; ) &#125;&#125;ReactDOM.render( &lt;HelloMessage name&#x3D;&#39;ozzie&#39; &#x2F;&gt;, document.getElementById(&quot;container&quot;)) 详谈 JSX 语法 JSX 是 JS 的语法糖，所以在语法上更贴近 JS 而不是 HTML 用 JSX 写 DOM 结构，有两种形式： 原生的 HTML 标签，用小写的字符串表示，例如： 12345678import React, &#123;Component&#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;const myDivElement &#x3D; &lt;div className&#x3D;&quot;foo&quot;&#x2F;&gt; &#x2F;&#x2F;小写字符串是标签ReactDOM.render( myDivElement, document.getElementById(&quot;root&quot;)) 注意，HTML 的 class 在 JSX 中要写成 className，因为 class 在 JS 中是保留关键字，同理，某些属性也要变化写法，比如 for 要写成 htmlFor，tabindex 要变成 tabIndex React 组件，用大写的变量表示，像使用 HTML 标签一样引用 React 组件，例如： 123456789import React, &#123;Component&#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;import MyComponent from &#39;.&#x2F;MyComponet&#39;; &#x2F;&#x2F;引入组件var myDivElement &#x3D; &lt;MyComponent &#x2F;&gt; &#x2F;&#x2F;大写变量是组件ReactDOM.render( myDivElement, document.getElementById(&quot;root&quot;)) JSX 特定属性： 使用引号将属性值指定为字符串字面量： 1const element &#x3D; &lt;div tabIndex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;div&gt; 使用大括号将属性值指定为 JS 表达式： 1const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125;&gt;&lt;&#x2F;img&gt; 注：在属性中嵌入 JS 表达式时，不要在大括号外面加上引号，要么使用引号（对于字符串），要么使用大括号（对于表达式），对于同一属性不能同时使用两种符号 JSX 中的注释 单行注释 1&#123;&#x2F;* 注释内容 *&#x2F;&#125; 多行注释 1234&#123;&#x2F;* 注释 内容*&#x2F;&#125; 例如： 123456789101112131415161718192021222324252627import React, &#123;Component&#125; from &quot;react&quot;;import ReactDOM from &quot;react-dom&quot;;class Hello extends Component &#123; render() &#123; &#x2F;&#x2F;单行注释 &#x2F;* 多行 注释 *&#x2F; return ( &lt;div&gt; &#123;&#x2F;*单行注释*&#x2F;&#125; &#123;&#x2F;* 多行 注释 *&#x2F;&#125; Hello JSX &lt;&#x2F;div&gt; ) &#125;&#125;ReactDOM.render( &lt;Hello &#x2F;*组件注释*&#x2F; &#x2F;&gt;, document.getElementById(&quot;root&quot;)) 由此可见，只是在原本 JS 注释上加括号即可 JSX 防止注入攻击 —— HTML 转义：ReactDOM 在渲染所有元素前，会默认进行 转义，防止 XSS（cross-site-scripting, 跨站脚本） 攻击，所以如果 JSX 中包含转义后的实体字符，比如 &amp;copy;，最后显示到 DOM 中不会正确显示，因为 React 自动把 &amp;copy; 中的特殊字符转义了。有几种解决办法： 使用对应字符的 Unicode 编码：查询编码 使用数组组装，如：&lt;div&gt;&#123;[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]&#125;&lt;/div&gt; 直接插入原始 HTML： 1&lt;div dangerouslySetInnerHTML=&#123;&#123;__html: &#x27;cc &amp;copy; 2015&#x27;&#125;&#125; /&gt; 直接使用 UTF-8 字符 JSX 与 HTML 的差异：DOM Differences 开始使用 JSX！使用 JSX 的相关配置 如何使用 JSX 呢，浏览器并不能直接解析 JSX 代码，我们可以引入 Babel 来编译 JSX 代码 了解 Babel：Babel 官网 新建目录，并初始化 1npm init -y 在目录下新建文件，使其结构如下： 123|-dist #打包文件放置目录|-index.js #入口文件|-index.html #主html文件 安装 webpack 与 webpack-cli： 1npm install webpack webpack-cli --save-dev 安装 react 与 react-dom： 1npm install react react-dom --save-dev 安装 babel-loader、babel-core、babel-preset-env、babel-preset-react： 1npm install babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;preset-react --save-dev 配置 webpack.config.js： 1234567891011121314151617181920//webpack.config.jsconst path = require(&#x27;path&#x27;);module.exports = &#123; mode: &#x27;development&#x27;, entry: &#x27;./index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;, module: &#123; rules: [&#123; test: /.\\js$/, exclude: /node_modules/, options: &#123; presets: [&#x27;@babel/preset-env&#x27;] &#125;, loader: &quot;babel-loader&quot;, &#125;] &#125;&#125; 此时，还需配置一个 babel 规则，新建一个 .babelrc 文件： 1234//.babelrc&#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;, &quot;@babel/preset-react&quot;]&#125; 主文件 现在配置所需要的包已经全部安装，配置文件也已经写好，我们开始编写主文件 编写 index.html： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写 index.js： 12345678910111213141516import React, &#123;Component&#125; from &#39;react&#39;;import ReactDOM from &#39;react-dom&#39;;class HelloMessage extends Component &#123; render() &#123; return ( &lt;div&gt; Hello &#123;this.props.name&#125; &lt;&#x2F;div&gt; ) &#125;&#125;ReactDOM.render( &lt;HelloMessage name&#x3D;&quot;ozzie&quot; &#x2F;&gt;, document.getElementById(&quot;root&quot;)) 打包 现在配置与主文件都完成了，就需要通过打包，来让主文件来使用这些经过打包后的文件：进入根目录，输入： 1npx webpack 进入 /dist 目录，你会发现多出一个 bundle.js，那就是打包后的文件 打开 index.html，就能看到我们的结果 以上就是初学者需要掌握的 JSX 知识，继续加油吧ヾ(◍°∇°◍)ﾉﾞ","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"}],"tags":[{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue-Cli3构建项目","slug":"Vue-Cli3构建项目","date":"2021-03-20T04:18:37.000Z","updated":"2021-03-20T04:19:11.082Z","comments":true,"path":"22759e22fe38/","link":"","permalink":"https://ozzienicholas.gitee.io/22759e22fe38/","excerpt":"","text":"项目结构浏览","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue-cli","slug":"vue-cli","permalink":"https://ozzienicholas.gitee.io/tags/vue-cli/"}]},{"title":"vue-router（四）：重定向，别名与vue-router传参","slug":"vue-router（四）：重定向，别名与vue-router传参","date":"2021-03-20T04:17:29.000Z","updated":"2021-03-20T04:17:45.207Z","comments":true,"path":"c239d7aef9ab/","link":"","permalink":"https://ozzienicholas.gitee.io/c239d7aef9ab/","excerpt":"","text":"重定向 一般刚进入应用时，都是进入 / 这个根路由的，若想直接由 / 跳转到 /index，有两种方法： 一是用重定向，二是用 vue-router 的导航式编程，这里我们讲第一种 主 html 文件：index.html： 1234567891011121314151617&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/&quot;&gt;path: /&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由配置文件：/src/router.js： 123456789101112131415161718192021222324252627// /src/router.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import Index from &quot;./components/Index&quot;;Vue.use(VueRouter);const routes = [ &#123; path: &quot;/&quot;, redirect: &quot;/index&quot;, // 重定向到 &quot;/index&quot; 路由 &#125;, &#123; path: &quot;/index&quot;, component: Index &#125;]const router = new VueRouter(&#123; routes,&#125;)const app = new Vue(&#123; router&#125;).$mount(&quot;#app&quot;) 路由文件：/src/components/Index.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;index&quot;&gt; &lt;p&gt;Index Page&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;index&quot;&#125;&lt;&#x2F;script&gt; 启动项目，观察效果，发现我们一打开项目，就直接跳转到了 /index 对应的页面 这就是因为，我在配置路由时，通过 redirect 将路由 / 重定向到了 /index，所以加载时，直接找 /index 对应的那个组件，渲染出来即可 也就是说，重定向的意思是：若将 /a 重定向到 /b，则访问 /a 时 URL 会被自动替换为 /b，然后匹配路由为 /b 上面的案例中，我们初步接触了重定向，现在总结一下重定向的三个常见用法： 用字符串表示重定向的路由： 1234567891011// /src/router.jsconst routes = [ &#123; path: &quot;/a&quot;, redirect: &quot;/b&quot; // 将 &quot;/a&quot; 重定向到 &quot;/b&quot; &#125;]const router = new VueRouter(&#123; routes,&#125;) 重定向的目标也可以是一个命名的路由： 1234567891011// /src/router.jsconst routes = [ &#123; path: &quot;/a&quot;, redirect: &#123; name: &quot;foo&quot; &#125; &#125;]const router = new VueRouter(&#123; routes,&#125;) 也可以是通过一个方法来动态地返回重定向的目标： 1234567891011121314// /src/router.jsconst routes = [ &#123; path: &quot;/a&quot;, redirect: to =&gt; &#123; // 方法接收 &quot;目标路由&quot; 作为参数 // return 返回重定向的字符串路径或者路径对象 &#125; &#125;]const router = new VueRouter(&#123; routes,&#125;) 其他的高级用法，请参考：vue-router/example/redirect 别名 别名也重定向的意义有些相反，对比学习即可 解释一下什么是 “别名”：若 /a 的别名是 /b，那么就相当于说，/b 的实质匹配路径其实是 /a，也就是，/a 与 /b 的对应的内容都是一样的，只不过当你访问 /b 时，URL 保持 /b，但是匹配路由为 /a 设置 /a 的别名为 /b 的方法是： 12345678910111213// /src/router.jsconst routes = [ &#123; path: &quot;/a&quot;, component: Index, alias: &quot;/b&quot; &#125;]const router = new VueRouter(&#123; routes,&#125;) 注意，当你设置了 path: &quot;/&quot; 时，再设置别名是不起作用的 “别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构 更多高级用法请查：vue-router/examples/route-alias vue-router参数传递 声明式导航 &lt;router-link :to=&quot;...&quot;&gt; 以及编程式导航 router.push(...) 都可以传参，这里主讲前者，同样的规则也适合编程式的导航 通过 &lt;router-link&gt; 中的 to 传参，例如： 1&lt;router-link :to=&quot;&#123; name:&quot;xxx&quot;, params:&#123;key:value&#125; &#125;&quot;&gt;example&lt;/router-link&gt; name 就是我们在路由配置文件中设置的 name 值 命名路由就是用一个名称来标识路由，在 &lt;router-link&gt; 中设置 name，最后在路由配置时设置对应的 name 即可，如： 123456&lt;!-- index.html --&gt;&lt;!-- 匹配路由 &quot;/user/123&quot; --&gt;&lt;router-link :to=&quot;&#123; name:&quot;user&quot;, params:&#123;id:123&#125; &#125;&quot;&gt; path: &quot;/user/123&quot;&lt;/router-link&gt; 1234567891011// /src/router.jsconst routes = [ path: &quot;/user/:id&quot;, name: &quot;user&quot; component: User,]const router = new VueRouter(&#123; routes,&#125;) params 就是我们要以对象形式传入的参数，最后用 $route.params.键名 的形式进行接收 通过 name 传参，例如： 1234567891011// /src/router.jsconst routes = [ path: &quot;/&quot;, name: &quot;user&quot;, component: User,]const router = new VueRouter(&#123; routes,&#125;) 此时我们就可以用 $route.name 来接收值，比如： 123456789101112&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; &lt;!-- 接收 name 的值 --&gt; &lt;p&gt;&#123;&#123;$route.name&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;&#125;&lt;&#x2F;script&gt; URL 传参：在配置文件里以冒号的形式设置参数，例如： 12345&lt;div id=&quot;app&quot;&gt; &lt;!-- 匹配路由为 &quot;/ozzie/20&quot; --&gt; &lt;router-link to=&quot;/ozzie/20&quot;&gt;example&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 12345678910// /src/router.jsconst routes = [ path: &quot;/:name/:age&quot;, // name 接收值为 &quot;ozzie&quot;，age 接收值为 20 component: User]const router = new VueRouter(&#123; routes,&#125;) 12345678910111213&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; &lt;!-- 接收由 router.js 传过来的 name 以及 age 的值 --&gt; &lt;p&gt;&#123;&#123;$route.params.name&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;&#123;&#123;$route.params.age&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;&#125;&lt;&#x2F;script&gt; 正则表达式在 URL 传值中的应用：我们还可以将正则表达式作为参数匹配路由，例如： 12345678910// /src/router.jsconst routes = [ path: &quot;/:name/:age(\\\\d+)&quot;, // 这里的正则使得 age 只能是数字 component: User]const router = new VueRouter(&#123; routes,&#125;)","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://ozzienicholas.gitee.io/tags/vue-router/"}]},{"title":"vue-router（三）：编程式导航、命名路由与命名视图","slug":"vue-router（三）：编程式导航、命名路由与命名视图","date":"2021-03-20T04:16:32.000Z","updated":"2021-03-20T04:17:03.668Z","comments":true,"path":"f1f5fb8f3c3f/","link":"","permalink":"https://ozzienicholas.gitee.io/f1f5fb8f3c3f/","excerpt":"","text":"编程式导航router.push 之前我们都是用过 &lt;router-link&gt; 来定义的导航链接，它会默认会被渲染成一个 &lt;a&gt; 标签，除此之外，我们还可以借助 router 的实例方法实现：router.push(location, &lt;onComplete&gt;, &lt;onAbort&gt;) 注：在 vue 实例中，可以通过 $router 来访问路由实例，所以你也可以调用 this.$router.push 其实，当你使用 &lt;router-link&gt; 时，本身就会在内部调用 router.push 方法，所以，使用 &lt;router-link to=&quot;...&quot;&gt; 就等同于 router.push(...) 声明式 编程式 &lt;router-link :to=&quot;...&quot;&gt; router.push(...) router.push() 方法的参数可以是一个字符串路径，也可以是一个描述地址的对象，例如： 1234567891011// 字符串router.push(&#x27;home&#x27;)// 对象router.push(&#123; path: &#x27;home&#x27; &#125;)// 命名的路由router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId: &#x27;123&#x27; &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: &#x27;register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125;&#125;) 如果在方法中存在了 path，那么就不要另外写 params，它会被自动忽略，需要用另一种写法取代： 12345678const userId = &#x27;123&#x27;router.push(&#123; name: &#x27;user&#x27;, params: &#123; userId &#125;&#125;) // /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // /user/123// 这里的 params 不生效router.push(&#123; path: &#x27;/user&#x27;, params: &#123; userId &#125;&#125;) // /user router.replace该方法的含参形式为：router.replace(location, &lt;onComplete&gt;, &lt;onAbort&gt;)，它与 router.push 方法的区别是：router.push 会向 history 栈中添加一条新纪录，所以当用户点击浏览器后退按钮时可以返回之前的 URL，而 router.replace 不会，它是直接替换掉当前的 history 记录 声明式 编程式 &lt;router-link to=&quot;...&quot; replace&gt; router.replace(...) router.go该方法的含参形式为 router.go(n)，n 是一个整数，意思是在 history 记录中向前或者向后退多少步，类似于 window.history.go(n)，例如： 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 命名路由 我们想用一个名称来标识一个路由，这样会更方便一些 我们可以在创建 VueRouter 实例的时候，在 routes 配置中给某个路由设置名称，例如： 123456789const routes = [ path: &quot;/user/:id&quot;, name: &quot;user&quot; component: User,]const router = new VueRouter(&#123; routes,&#125;) 在使用这种命名路由时，可以给 &lt;router-link&gt; 的 to 属性传递一个对象，如： 12&lt;!-- 匹配路由 &quot;/user/123&quot; --&gt;&lt;router-link :to=&quot;&#123;name: &#x27;home&#x27;, params: &#123;id: 123&#125;&#125;&quot;&gt;path: &quot;/user/123&lt;/router-link&gt; 若使用 router.push，则为： 12// 匹配路同样是 &quot;/user/123&quot;router.push(&#123; name: &quot;user&quot;, params: &#123; id: 123 &#125;&#125;) 命名视图 若你想在同一路由中同时展示多个视图，例如在同一布局中，有 sidebar（侧导航）和 main（主内容）两个视图，就需要命名视图 使用命名视图可以让你在页面中拥有多个单独命名的视图，而不是像之前那样，只有单一的出口 感受命名视图 主 html 文件：index.html 123456789101112131415161718192021222324252627&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello vue-router&lt;/h1&gt; &lt;p&gt; &lt;!-- 对应 /user 匹配路由 --&gt; &lt;router-link to=&quot;/&quot;&gt;path: &quot;/user&quot;&lt;/router-link&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 对应 /user/:id 匹配路由 --&gt; &lt;router-link to=&quot;/user/home&quot;&gt;path: &quot;/user/foo&quot;&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 若没有 name 属性，即没有设置名字，则会默认为 default --&gt; &lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由配置文件：/src/router.js： 1234567891011121314151617181920212223242526272829303132333435363738// /src/router.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import User from &quot;./components/User&quot;;import Foo from &quot;./components/Foo&quot;;import Bar from &quot;./components/Bar&quot;;// import Home from &quot;./components/Home&quot;;Vue.use(VueRouter);const routes = [ &#123; path: &quot;/&quot;, components: &#123; // 注意这里是 components default: User, // 若没有 name 属性，默认为 User 组件 a: Foo, // name=&quot;a&quot; 时渲染 Foo 组件 b: Bar // name=&quot;b&quot; 时渲染 Bar 组件 &#125; &#125;, &#123; path: &quot;/user/:id&quot;, components: &#123; // 注意这里是 components default: Foo, // 若没有 name 属性，默认为 Foo 组件 a: Bar, // name=&quot;a&quot; 时渲染 Bar 组件 b: User // name=&quot;b&quot; 时渲染 User 组件 &#125; &#125;,]const router = new VueRouter(&#123; routes,&#125;)const app = new Vue(&#123; router&#125;).$mount(&quot;#app&quot;) 一个视图要用一个组件渲染，对应到这里的多个视图，则需要多个组件，注意这里应该是 components 而不是之前的 component 路由文件：/src/components/ User.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; &lt;h2&gt;User &#123;&#123; this.$route.params.id &#125;&#125;&lt;&#x2F;h2&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;,&#125;&lt;&#x2F;script&gt; Foo.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;foo&quot;&gt; Foo &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;foo&quot;&#125;&lt;&#x2F;script&gt; Bar.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;bar&quot;&gt; Bar &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;bar&quot;&#125;&lt;&#x2F;script&gt; 启动项目，注意观察两个链接对应的样式，以及为什么会出现这种样式 嵌套命名视图 之前我们只是简单地在一个路由中同时展示了多个独立组件 有时我们在一个路由中，同时展示的组件之间也可能会有嵌套关系，这时同样需要命名嵌套组件 这里以一个设置面板为例： Home：一个视图组件 User：一个常规组件 A、B、C 是嵌套的视图组件 这里我们可以先不管 CSS 的具体布局样式，专注到组件上 主 html 文件：index.html： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./src/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Nested Named Views&lt;/h1&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由配置文件：/src/router.js： 123456789101112131415161718192021222324252627282930313233343536373839// /src/router.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import Home from &quot;./components/Home&quot;;import A from &quot;./components/A&quot;;import B from &quot;./components/B&quot;;import C from &quot;./components/C&quot;;Vue.use(VueRouter);const routes = [ &#123; path: &quot;/&quot;, component: Home, children: [ &#123; path: &quot;/user/foo&quot;, component: A &#125;, &#123; path: &quot;/user/bar&quot;, components: &#123; default: B, other: C &#125; &#125; ] &#125;]const router = new VueRouter(&#123; routes,&#125;)const app = new Vue(&#123; router&#125;).$mount(&quot;#app&quot;) 路由文件：/src/components/ Home.vue： 123456789101112131415161718&lt;template&gt; &lt;div id&#x3D;&quot;home&quot; class&#x3D;&quot;home&quot;&gt; &lt;h2&gt;Home&lt;&#x2F;h2&gt; &lt;User&#x2F;&gt; &lt;router-view class&#x3D;&quot;home_A&quot;&#x2F;&gt; &lt;router-view class&#x3D;&quot;home_C&quot; name&#x3D;&quot;other&quot;&#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import User from &quot;.&#x2F;User&quot;export default &#123; name: &quot;home&quot;, components: &#123; User, &#125;&#125;&lt;&#x2F;script&gt; User.vue： 12345678910111213&lt;template&gt; &lt;div id&#x3D;&quot;user&quot; class&#x3D;&quot;user&quot;&gt; &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;foo&quot;&gt;path: user&#x2F;foo&lt;&#x2F;router-link&gt; &lt;br&gt;&lt;br&gt; &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;bar&quot;&gt;path: user&#x2F;bar&lt;&#x2F;router-link&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;,&#125;&lt;&#x2F;script&gt; A.vue： 12345678910111213&lt;template&gt; &lt;div id&#x3D;&quot;A&quot;&gt; &lt;p&gt; This template is A &lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;isA&quot;&#125;&lt;&#x2F;script&gt; B.vue： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;p&gt; This template is B &lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;isB&quot;&#125;&lt;&#x2F;script&gt; C.vue： 12345678910111213&lt;template&gt; &lt;div&gt; &lt;p&gt; This template is C &lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;isC&quot;&#125;&lt;&#x2F;script&gt; 样式文件：/src/style.css： 123456789101112131415161718192021222324252627/* /src/style.css */h2 &#123; grid-area: header;&#125;.home &#123; display: grid; grid-template-columns: auto 1fr; grid-template-rows: auto; grid-template-areas: &quot;header header&quot; &quot;nav content&quot; &quot;nav helper&quot; ;&#125;.user &#123; grid-area: nav; border: 1px dotted; margin-right: .75rem; padding: .3rem;&#125;.home_A &#123; grid-area: content;&#125;.home_C &#123; grid-area: helper;&#125; 启动项目，观察效果……","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://ozzienicholas.gitee.io/tags/vue-router/"}]},{"title":"vue-router（二）：动态路由与嵌套路由","slug":"vue-router（二）：动态路由与嵌套路由","date":"2021-03-20T04:15:48.000Z","updated":"2021-03-20T04:16:12.243Z","comments":true,"path":"c2bf453959cb/","link":"","permalink":"https://ozzienicholas.gitee.io/c2bf453959cb/","excerpt":"","text":"动态路由响应路由参数的变化 在之前的案例中，每一个路由都对应着一个单独的组件 现在我们想，在一个组件中，根据不同的路由响应出不同的结果，这就意味着我们需要响应路由参数的变化 主 html 文件：index.html 1234567891011121314151617181920212223&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello vue-router&lt;/h1&gt; &lt;p&gt; &lt;!-- 不同的路由 --&gt; &lt;router-link to=&quot;/user/foo&quot;&gt;path: &quot;/user/foo&quot;&lt;/router-link&gt; &lt;br&gt;&lt;br&gt; &lt;router-link to=&quot;/user/bar&quot;&gt;path: &quot;/user/bar&quot;&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由配置文件：/src/router.js 1234567891011121314151617181920212223// /src/router.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import User from &quot;./components/User&quot;;Vue.use(VueRouter);const routes = [ &#123; path: &quot;/user/:id&quot;, // 以 id 为动态路径参数，映射不同的路由 component: User // 不同的路由都对应着同一个组件：User &#125;]const router = new VueRouter(&#123; routes,&#125;)const app = new Vue(&#123; router&#125;).$mount(&quot;#app&quot;) 响应不同的路由，需要 动态路径参数（dynamic segment），这个参数要以冒号开头，所以主文件中的 /user/foo 与 user/bar 都可以映射到 User 组件中渲染 路由文件：/src/component/User.vue 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; User &#123;&#123; this.$route.params.id &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;&#125;&lt;&#x2F;script&gt; 动态路由参数用 : 标记，当匹配到一个路由时（比如 /user/foo），参数值会被设置到 this.$route.params，这个值可以在每一个组件中使用，所以，在 User 组件中，我们可以用 this.$route/params.id 来对应出具体是哪一个组件 这里的 this.$route.params.id 可以简写为 $route.params.id 启动项目：npx webpack 或者 npm run dev 多段路由参数：你可以在一个路由中设置 多段路由参数，而且对应的值都会与仅有一个路由参数一样，会被映射到 $route.params，例如： 模式 匹配路径 $route.params /user/:username /user/ozzie { username: ‘ozzie’ } /user/:username/age/:age /user/ozzie/age/20 { username: ‘ozzie’ , age: 20} 除了动态参数的值会被设置到 $route.params，还有其他信息，比如 $route.query（对应查询参数），详情请查：API 文档 组件实例的复用： 当使用路由参数时，例如上面例子中，从 /user/foo 导航到 /user/bar，原先的组件实例会被复用，因为这两个路由都对应着同一个组件，复用避免了将组件销毁再创建的过程，不过这也使得组件的生命周期钩子不会再被调用 但若你想对路由参数的变化做出相应时，可以使用以下两种方法： 监听 $route 的变化： 12345678910111213141516&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; User &#123;&#123; this.$route.params.id &#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;, watch: &#123; &#39;$route&#39;(to, from) &#123; console.log(&quot;changed...&quot;) &#x2F;&#x2F; 如果路由变化了，则打印此语句 &#125; &#125;&#125;&lt;&#x2F;script&gt; 使用 beforeRouteUpdate 导航守卫，这个之后进阶概念中会讲到 捕获所有路由 常规路由匹配是通过 / 分隔的，如果想匹配任意路由，可以使用通配符 *： 12345678910const routes = [ &#123; path: &quot;*&quot;, // 会匹配所有的路由，通常用于客户端 404 错误 // component... &#125;, &#123; path: &quot;/user-*&quot;, // 会匹配以 &quot;/user-&quot; 开头的任意路由 // component... &#125;] 当使用通配符路由时，需要确保你的路由顺序是正确的 — 含有通配符的路由应该放在最后 当使用一个通配符时，$route.params 会自动添加一个 pathMatch 参数，它包含了 URL 通过通配符将被匹配的部分： 1234567// 路由为：&#123; path: &quot;*&quot; &#125;this.$route.push(&quot;/x&quot;);this.$route.params.pathMatch; // &quot;/x&quot;// 路由为：&#123; path: &quot;/user-*&quot; &#125;this.$route.push(&quot;/user-admin&quot;);this.$route.params.pathMatch; // &quot;admin&quot; 匹配的优先级若同一个路由指向多个组件，那么匹配的优先级就按照路由定义的时间顺序而定，先定义的优先级就高，比如： 12345678910const routes = [ &#123; path: &quot;/user&quot;, component: UserA &#125;, &#123; path: &quot;/user&quot;, component: UserB &#125;] 那么对于同一路由 /user，对应着的组件就应该是 UserA 而非 UserB 嵌套路由 实际的开发中，组件之间是相互嵌套的，那么这也对应着按照某种结构嵌套的路由，例如： 12345678&#x2F;user&#x2F;foo&#x2F;profile &#x2F;user&#x2F;foo&#x2F;posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 接下来我们使用嵌套路由配置来表达这种关系，在这之前，我们得弄明白 &lt;router-view&gt;&lt;/router-view&gt; 的作用：这对标签是最顶层的出口，它用于渲染最高级路由匹配到的组件，所以，类比组件之间使用 component 来相互嵌套，路由之间也可以用 &lt;router-view&gt; 相互嵌套 主 html 文件：index.html： 123456789101112131415161718192021222324252627&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello vue-router&lt;/h1&gt; &lt;p&gt; &lt;!-- 对应 /user/:id 匹配路由 --&gt; &lt;router-link to=&quot;/user/home&quot;&gt;path: &quot;/user/foo&quot;&lt;/router-link&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 对应 /user/:id/foo 匹配路由 --&gt; &lt;router-link to=&quot;/user/:id/foo&quot;&gt;path: &quot;/user/:id/foo&quot;&lt;/router-link&gt; &lt;br&gt;&lt;br&gt; &lt;!-- 对应 /user/:id/bar 匹配路由 --&gt; &lt;router-link to=&quot;/user/:id/bar&quot;&gt;path: &quot;/user/:id/bar&quot;&lt;/router-link&gt; &lt;/p&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 路由配置文件：/src/router.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// /src/router.jsimport Vue from &quot;vue&quot;;import VueRouter from &quot;vue-router&quot;;import User from &quot;./components/User&quot;;import Foo from &quot;./components/Foo&quot;;import Bar from &quot;./components/Bar&quot;;import Home from &quot;./components/Home&quot;;Vue.use(VueRouter);const routes = [ &#123; path: &quot;/user/:id&quot;, component: User, // 使用嵌套路由时，需要在 VueRouter 的参数中使用 children children: [ &#123; // 当 /user/:id 会匹配成功 // Home 组件会被渲染在 User 组件的 &lt;router-view&gt; 中 path: &quot;&quot;, component: Home &#125;, &#123; // 当 /user/:id/foo 匹配成功时 // Foo 组件会被渲染在 User 组件的 &lt;router-view&gt; 中 path: &quot;foo&quot;, component: Foo &#125;, &#123; // 当 /user/:id/bar 匹配成功时 // Bar 组件会被渲染在 User 组件的 &lt;router-view&gt; 中 path: &quot;bar&quot;, component: Bar &#125; ] &#125;]const router = new VueRouter(&#123; routes,&#125;)const app = new Vue(&#123; router&#125;).$mount(&quot;#app&quot;) 路由文件： User.vue： 123456789101112&lt;template&gt; &lt;div id&#x3D;&quot;user&quot;&gt; &lt;h2&gt;User &#123;&#123; this.$route.params.id &#125;&#125;&lt;&#x2F;h2&gt; &lt;router-view&gt;&lt;&#x2F;router-view&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;user&quot;,&#125;&lt;&#x2F;script&gt; Home.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;home&quot;&gt; Home &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;home&quot;&#125;&lt;&#x2F;script&gt; Foo.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;foo&quot;&gt; Foo &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;foo&quot;&#125;&lt;&#x2F;script&gt; Bar.vue： 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;bar&quot;&gt; Bar &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;bar&quot;&#125;&lt;&#x2F;script&gt; 启动项目：npx webpack 或者 npm run dev 点击不同的链接，注意显示的内容 以 / 开头的嵌套路径会被当作根路径，所以在使用嵌套组件时无需设置嵌套的根路径 children 的配置就类似于 route 的配置那样，都是数组中嵌套着多重配置对象，所以可以用类似的方法嵌套多重路由","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://ozzienicholas.gitee.io/tags/vue-router/"}]},{"title":"vue-router（一）：初识vue-router","slug":"vue-router（一）：初识vue-router","date":"2021-03-20T04:14:56.000Z","updated":"2021-03-20T04:15:12.735Z","comments":true,"path":"7285f87f8102/","link":"","permalink":"https://ozzienicholas.gitee.io/7285f87f8102/","excerpt":"","text":"配置项目 创建一个目录 project，并进入，新建几个目录与文件，最后整个 demo 目录如下： 12345678|-project # 根目录 |-index.html # 主html文件 |-dist # 打包文件放置目录 |-src # 资源文件目录 |-router.js # 打包入口文件，写路由的文件 |-components # 单文件组件目录 |-Foo.vue # 路由组件 |-Bar.vue # 路由组件 运行以下命令初始化 package.json： 1npm init -y 安装项目依赖：（这里我直接给出 package.json 文件） 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;name&quot;: &quot;project&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.17&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;, &quot;cross-env&quot;: &quot;^5.2.0&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.11&quot;, &quot;node-sass&quot;: &quot;^4.9.2&quot;, &quot;sass-loader&quot;: &quot;^7.1.0&quot;, &quot;style-loader&quot;: &quot;^0.21.0&quot;, &quot;url-loader&quot;: &quot;^1.0.1&quot;, &quot;vue-loader&quot;: &quot;^14.2.3&quot;, &quot;vue-router&quot;: &quot;^3.2.0&quot;, &quot;vue-style-loader&quot;: &quot;^4.1.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.17&quot;, &quot;webpack&quot;: &quot;^4.16.4&quot;, &quot;webpack-cli&quot;: &quot;^3.1.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.5&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 复制此文件，你可以直接运行 npm install 配置 webpack：根目录下新建 webpack.config.js： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//webpack.config.jsconst path = require(&#x27;path&#x27;); //node中的path对象，用于处理目录的对象const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./src/router&#x27;, //入口文件地址 output: &#123; //输出 path: path.join(__dirname, &#x27;./dist&#x27;), //打包输出文件的地址，使用绝对路径 filename: &#x27;bundle.js&#x27;, //webpack打包后的文件名 publicPath: &#x27;/dist/&#x27;, //公共文件生成的地址 &#125;, mode: &#x27;development&#x27;, module: &#123; rules: [ //加载器loader &#123; //编译css test: /\\.css$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; //编译scss test: /\\.scss$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;, &#123; //编译sass test: /\\.sass$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader?indentedSyntax&#x27;] &#125;, &#123; //编译.vue文件 test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loaders: &#123; &#x27;scss&#x27;: [ &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27; ], &#x27;sass&#x27;: [ &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader?indentedSyntax&#x27; ] &#125; &#125; &#125;, &#123; //转换es6语法 test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, options: &#123; presets: [[&#x27;env&#x27;, &#123;modules: false&#125;], &#x27;stage-0&#x27;] &#125; &#125;, &#123; //图片转化 test: /\\.(png|jpg|gif|svg)$/, loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name].[ext]?[hash]&#x27; &#125; &#125; ] &#125;, resolve: &#123; //别名，可以直接使用别名来代表设定的路径以及其他 alias: &#123; vue$: &#x27;vue/dist/vue.esm.js&#x27;, filter: path.join(__dirname, &#x27;./src/filters&#x27;), components: path.join(__dirname, &#x27;./src/components&#x27;) &#125;, //require时省略的扩展名，如require(&#x27;module&#x27;)不需要写成require(&#x27;module.js&#x27;) extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], &#125;, devServer: &#123; //服务器配置相关，以实现自动刷新 historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, //开启source-map，webpack有多种source-map，在官网文档中可以查到 devtool: &#x27;#eval-source-map&#x27;&#125; 初次感受 vue-router 需要的配置已经完成了，现在开始编写各文件 主 html 文件： 1234567891011121314151617181920212223242526&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello vue-router&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件来导航 --&gt; &lt;!-- 通过 &quot;to&quot; 来指定链接 --&gt; &lt;!-- &lt;router-link&gt; 默认会被渲染为一个 &lt;a&gt; 标签 --&gt; &lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt; &lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将被渲染到这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写入口文件 router.js： 123456789101112131415161718192021222324252627282930313233//src/router.js// 导入模块import Vue from &quot;vue&quot;; // 导入 vueimport VueRouter from &quot;vue-router&quot;; // 导入 vue-router// 导入组件，一个组件一个路由import Foo from &quot;./components/Foo&quot;;import Bar from &quot;./components/Bar&quot;;Vue.use(VueRouter); // 路由插件必须在 vue 中注册才能使用const routes = [ // 定义路由 // 每个路由应该映射一个组件 // component 可以是用 vue.extend() 创建的组件构造器或者一个组件配置对象 &#123; path: &quot;/foo&quot;, component: Foo &#125;, &#123; path: &quot;/bar&quot;, component: Bar &#125;]const router = new VueRouter(&#123; // 创建一个 VueRouter 实例，传入 routes 配置 routes, // 相当于 routes: routes&#125;)const app = new Vue(&#123; // 创建和挂载根实例 // 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能 router&#125;).$mount(&quot;#app&quot;) 编写两个组件文件，分别对应两个路由： /src/components/Foo.vue 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;foo&quot;&gt; Foo &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;foo&quot;&#125;&lt;&#x2F;script&gt; /src/components/Bar.vue 1234567891011&lt;template&gt; &lt;div id&#x3D;&quot;bar&quot;&gt; Bar &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;bar&quot;&#125;&lt;&#x2F;script&gt; 启动项目： 可以用 npx webpack 先将文件编译为静态文件，再打开 index.html 也可以用 npm run dev 打开一个端口热加载此项目","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://ozzienicholas.gitee.io/tags/vue-router/"}]},{"title":"Vuex教程（三）：TodoList案例","slug":"Vuex教程（三）：TodoList案例","date":"2021-03-20T04:14:00.000Z","updated":"2021-03-20T04:14:25.082Z","comments":true,"path":"be60763b1592/","link":"","permalink":"https://ozzienicholas.gitee.io/be60763b1592/","excerpt":"","text":"初始化项目 需要安装的依赖包：vuex、axios、ant-design-vue，vuex 我们已经有了，需要安装另外两个： 1npm install axios ant-design-vue --save-dev 我们承接之前创建过的项目，删除 /src/components 文件夹，清空 /src/App.vue 以及 /src/store/index.js 中的代码 项目的基本 UI 结构主文件 /src/main.js123456789101112131415import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;// 导入 ant-design-vue 组件库import Antd from &#x27;ant-design-vue&#x27;// 导入组件库的样式表import &#x27;ant-design-vue/dist/antd.css&#x27;Vue.config.productionTip = falseVue.use(Antd) // 安装组件库new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;) 组件文件 /src/App.vue12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;template&gt; &lt;div id&#x3D;&quot;app&quot;&gt; &lt;a-input placeholder&#x3D;&quot;请输入任务&quot; class&#x3D;&quot;my_ipt&quot; &#x2F;&gt; &lt;a-button type&#x3D;&quot;primary&quot;&gt;添加事项&lt;&#x2F;a-button&gt; &lt;a-list bordered :dataSource&#x3D;&quot;list&quot; class&#x3D;&quot;dt_list&quot;&gt; &lt;a-list-item slot&#x3D;&quot;renderItem&quot; slot-scope&#x3D;&quot;item&quot;&gt; &lt;!-- 复选框 --&gt; &lt;a-checkbox&gt;&#123;&#123;item.info&#125;&#125;&lt;&#x2F;a-checkbox&gt; &lt;!-- 删除链接 --&gt; &lt;a slot&#x3D;&quot;actions&quot;&gt;删除&lt;&#x2F;a&gt; &lt;&#x2F;a-list-item&gt; &lt;!-- footer区域 --&gt; &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;footer&quot;&gt; &lt;!-- 未完成的任务个数 --&gt; &lt;span&gt;0条剩余&lt;&#x2F;span&gt; &lt;!-- 操作按钮 --&gt; &lt;a-button-group&gt; &lt;a-button type&#x3D;&quot;primary&quot;&gt;全部&lt;&#x2F;a-button&gt; &lt;a-button&gt;未完成&lt;&#x2F;a-button&gt; &lt;a-button&gt;已完成&lt;&#x2F;a-button&gt; &lt;&#x2F;a-button-group&gt; &lt;!-- 把已经完成的任务清空 --&gt; &lt;a&gt;清除已完成&lt;&#x2F;a&gt; &lt;&#x2F;div&gt; &lt;&#x2F;a-list&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &#39;app&#39;, data() &#123; return &#123; list: [ &#123; id: 0, info: &#39;任务A&#39;, done: false &#125;, &#123; id: 1, info: &#39;任务B&#39;, done: false &#125;, &#123; id: 2, info: &#39;任务C&#39;, done: false &#125;, &#123; id: 3, info: &#39;任务D&#39;, done: false &#125;, &#123; id: 4, info: &#39;任务E&#39;, done: false &#125; ] &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style scoped&gt; #app &#123; padding: 10px; &#125; .my_ipt &#123; width: 500px; margin-right: 10px; &#125; .dt_list &#123; width: 500px; margin-top: 10px; &#125; .footer &#123; display: flex; justify-content: space-between; align-items: center; &#125;&lt;&#x2F;style&gt; 启动项目用 npm run serve 启动，如下： 逻辑实现列表数据的动态加载 目的：上面的列表数据都是已经写死了的，现在我们要将数据专门放到一个 json 文件中，再通过 axios 动态获取 将 App.vue 中的 list 清空，再在 public 目录下新建 list.json 文件，粘贴原 list 中的元素，即： 1234567891011121314151617181920212223242526272829// /public/list.json[ &#123; &quot;id&quot;: 0, &quot;info&quot;: &quot;任务A&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 1, &quot;info&quot;: &quot;任务B&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 2, &quot;info&quot;: &quot;任务C&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 3, &quot;info&quot;: &quot;任务D&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 4, &quot;info&quot;: &quot;任务E&quot;, &quot;done&quot;: false &#125;] 我们将通过 axios 请求 list.json，将数据挂载到 store 中进行存储，需要注意，axios 发起请求是一个异步操作，所以我们要将获取数据的异步操作定义到 actions 中，所以我们打开 /store/index.js，导入 axios 并添加 actions 函数： 123456789// /store/index.jsactions: &#123; getList(context) &#123; axios.get(&#x27;../../list.json&#x27;).then((data) =&gt; &#123; console.log(data) // 测验是否拿到数据 &#125;) &#125;&#125; 在 App.vue 中调用 actions 中的 getList 函数，并且由于获取数据需要最开始执行，所以我们新建一个生命周期函数： 12345// App.vuecreated() &#123; this.$store.dispatch(&quot;getList&quot;)&#125; 启动项目，打开控制台，结果如下： 这说明数据请求成功 现在需要将拿到的数据放在 state 中存储，我们通过在 actions 中调用对应的 mutations 来实现： 123456789101112131415161718// /store/index.jsstate: &#123; list: [] // 所有的任务列表&#125;,mutations: &#123; initList(state, list) &#123; // 第一个参数只能是 state state.list = list &#125;&#125;,actions: &#123; getList(context) &#123; axios.get(&quot;../../list.json&quot;).then((&#123;data&#125;) =&gt; &#123; // 将 data 传给 initList context.commit(&quot;initList&quot;, data) &#125;) &#125;&#125; 这样就把整个 list 存储到了 list 中，打开控制台，查看 vuex 状态如下： 现在 state 中已经存在了 list，现在我们将 list 渲染到 App 组件中，现在我们将 state 中的 list 映射到组件中，即可使用： 123456789101112131415// App.vueimport &#123; mapState &#125; from &quot;vuex&quot;;export default &#123; name: &quot;app&quot;, data() &#123; return &#123; &#125; &#125;, created() &#123; this.$store.dispatch(&quot;getList&quot;) &#125;, computed: &#123; ...mapState([&quot;list&quot;]) &#125;&#125; 启动项目，渲染成功： 文本输入框的双向同步 目的：在文本输入框输入内容时，state 中的数据可以同步更新 在 state 中新增一条状态，用于监听输入内容，并映射到组件中，并在 input 中绑定值 12345678// /store/index.jsstate: &#123; // 所有的任务列表 list: [], // 文本框的内容，并赋初值 inputValue: &quot;something...&quot;&#125; 12345// App.vuecomputed: &#123; ...mapState([&quot;list&quot;, &quot;inputValue&quot;])&#125; 123&lt;!-- App.vue --&gt;&lt;a-input placeholder=&quot;请输入任务&quot; class=&quot;my_ipt&quot; :value=&quot;inputValue&quot;/&gt; 启动项目，查看结果： 输入框中默认出现了 “something” 为文本框绑定输入事件，并在方法中定义该事件： 1234567&lt;!-- App.vue --&gt;&lt;a-input placeholder=&quot;请输入任务&quot; class=&quot;my_ipt&quot; :value=&quot;inputValue&quot; @change=&quot;handleInputChange&quot;/&gt; 12345678// App.vuemethods: &#123; handleInputChange(e) &#123; // e 是事件参数 // 拿到输入框中的值 console.log(e.target.value) &#125;&#125; 在 mutations 中定义函数来改变 store 中的 inputValue 值： 12345678910// /store/index.jsmutations: &#123; initList(state, list) &#123; // 第一个参数只能是 state state.list = list &#125;, setInputValue(state, value) &#123; state.inputValue = value &#125;&#125; 再在函数中触发 setInputValue 函数： 12345678910// App.vuemethods: &#123; handleInputChange(e) &#123; // e 是事件参数 // 拿到输入框中的值 console.log(e.target.value); // 触发 setInputValue 函数 this.$store.commit(&quot;setInputValue&quot;, e.target.value) &#125;&#125; 点击添加事项 目的：点击 “添加事项” 即能新增一个任务项 在按钮处添加事件，并在方法中写入事件内容： 123&lt;!-- App.vue --&gt;&lt;a-button type=&quot;primary&quot; @click=&quot;addItemToList&quot;&gt;添加事项&lt;/a-button&gt; 如果用户输入为空的话，那么不应该添加该项，否则就应该触发 mutations 中的函数来添加新的项：（下面的 addItem 我们待会儿会定义，现在先写着） 12345678910111213// App.vuemethods: &#123; addItemToList() &#123; // 如果用户输入内容为空，则不应该添加此项 if(this.inputValue.trim().length &lt;= 0) &#123; // 弹出一个警告框，表示不能为空 return this.$message.warning(&quot;文本框内容不能为空&quot;) &#125; // 否则就触发 mutations 中的函数 addItem this.$store.commit(&quot;addItem&quot;) &#125;&#125; 之前我们的数据中，id 最大值为4，那么新的项的 id 应该为5： 123456// /store/index.jsstate: &#123; // 下一个 id nextId: 5&#125; 在 mutations 中定义 addItem 函数： 123456789101112131415// /store/index.jsmutations: &#123; // 添加列表项 addItem(state) &#123; const obj = &#123; // 定义一个对象用来存储新的项 id: state.nextId, // id 为新的 id info: state.inputValue.trim(), // 内容为输入内容 done: false // 完成状态初始设置为未完成 &#125; state.list.push(obj) // 在 list 中添加新的项 state.nextId ++ // 新的 id 自增，为继续添加项做准备 state.inputValue = &quot;&quot; // 清空输入框 &#125;&#125; 启动项目，点击 “添加事项”，查看结果： 点击前： 点击后： 当输入框为空，我仍然点击 “添加事项” 时，会弹出警告框： 删除对应事项 目的：点击 ”删除“，既能删除对应项 在按钮中添加删除元素事件： 123&lt;!-- App.vue --&gt;&lt;a slot=&quot;actions&quot; @click=&quot;deleteItemById(item.id)&quot;&gt;删除&lt;/a&gt; 在方法中定义事件，触发 mutations 中的函数（并给该函数传入参数 id）： 123456789// App.vuemethods: &#123; // 根据 id 删除 item 项 deleteItemById(id) &#123; // 触发 deleteItem 函数，并传参为 id this.$store.commit(&quot;deleteItem&quot;, id) &#125;&#125; 在 mutations 中定义 deleteItem 函数： 1234567891011121314// /store/index.jsmutations: &#123; // 删除列表项 deleteItem(state, id) &#123; // 根据 id 来查找对应项的索引 // 如果未找到，那么 findIndex 方法会返回给 index 的值为 -1 const index = state.list.findIndex(item =&gt; item.id === id) // 根据索引查找对应元素 if(index != -1) &#123; // 找到就删除 state.list.splice(index, 1) &#125; &#125;&#125; 启动项目，查看结果：点击 “删除” 检验 复选框状态的绑定 目的：将每一项的状态（“完成” 或者 “未完成”）与页面上的复选框做绑定 打开 /public/list.json 文件，目前所有的项的状态我们都默认为 “未完成”，即 &quot;done&quot;: false，现在我们手动定义两个已完成的项：我们将前面两项改为 &quot;done&quot;: true： 1234567891011121314151617181920212223242526272829// /public/list.json[ &#123; &quot;id&quot;: 0, &quot;info&quot;: &quot;任务A&quot;, &quot;done&quot;: true &#125;, &#123; &quot;id&quot;: 1, &quot;info&quot;: &quot;任务B&quot;, &quot;done&quot;: true &#125;, &#123; &quot;id&quot;: 2, &quot;info&quot;: &quot;任务C&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 3, &quot;info&quot;: &quot;任务D&quot;, &quot;done&quot;: false &#125;, &#123; &quot;id&quot;: 4, &quot;info&quot;: &quot;任务E&quot;, &quot;done&quot;: false &#125;] 在 App.vue 中，给复选框绑定一个值，来判断该项的状态： 123&lt;!-- App.vue --&gt;&lt;a-checkbox :checked=&quot;item.done&quot;&gt;&#123;&#123;item.info&#125;&#125;&lt;/a-checkbox&gt; 启动项目，前面两项已选中： 现在我们来完成修改任务状态的功能 给复选框绑定一个事件，监听变化： 123456&lt;!-- App.vue --&gt;&lt;a-checkbox :checked=&quot;item.done&quot; @change=&quot;checkedChange($event, item.id)&quot;&gt; &#123;&#123;item.info&#125;&#125;&lt;/a-checkbox&gt; 在 methods 中定义该方法，并触发 mutation 函数，传参为该项的 id，以此来改变 state 中 done 的状态： 12345678// App.vuemethods: &#123; // 根据 id 改变复选框 checkedChange(e, id) &#123; this.$store.commit(&quot;changeChecked&quot;, id) &#125;&#125; 在 mutations 中定义 changeChecked 函数，改变状态： 1234567891011121314// /store/index.jsmutations: &#123; // 改变复选框状态 changeChecked(state, id) &#123; // 根据 id 来查找对应项的索引 // 如果未找到，那么 findIndex 方法会返回给 index 的值为 -1 const index = state.list.findIndex(item =&gt; item.id === id) // 根据索引查找对应元素 if(index != -1) &#123; // 找到就改变状态 state.list[id].done = !state.list[id].done &#125; &#125;&#125; 启动项目，之前是前两项勾选，现在取消前两项勾选，并勾选第三项 统计未完成的任务条数 目的：统计出 “未完成” 状态的任务项的条数，并渲染该数据 之前介绍过，getters 起着一个装饰的作用，类似于组件中的计算属性，现在我们就借助 getters 完成此功能 在 store 中定义一个 getters 函数： 12345678910// /store/index.jsexport default new Vuex.Store(&#123; getters: &#123; unDoneLength(state) &#123; // 过滤出未完成的项，返回已完成的项的个数 return state.list.filter(item =&gt; item.done===false).length &#125; &#125;,&#125;) 映射为组件的计算属性： 123456789// App.vue// 按需导入 mapGetters 模块import &#123; mapState, mapGetters &#125; from &quot;vuex&quot;;// 定义计算属性computed: &#123; ...mapGetters([&quot;unDoneLength&quot;])&#125; 在组件中使用该值： 123&lt;!-- App.vue --&gt;&lt;span&gt;&#123;&#123;unDoneLength&#125;&#125;条剩余&lt;/span&gt; 启动项目，查看结果： 清楚已完成的任务项 目的：点击 “清除已完成”，即会清除所有的完成项 给 “清除已完成” 链接绑定事件： 123&lt;!-- App.vue --&gt;&lt;a @click=&quot;clean&quot;&gt;清除已完成&lt;/a&gt; 在 methods 中定义该方法，并触发 mutation 函数： 12345678// App.vuemethods: &#123; // 清楚已完成项 clean() &#123; this.$store.commit(&quot;cleanDone&quot;) &#125;&#125; 在 mutations 中定义该函数： 123456789// /store/index.jsmutations: &#123; // 清除已完成项 cleanDone(state) &#123; // 过滤掉已完成的项，返回未完成的项 state.list = state.list.filter(item =&gt; item.done===false) &#125;&#125; 启动项目，查看结果：之前默认是前两项勾选，现在我点击 “清除已完成”，得到结果： 底部样式的切换 目的：现在只有底部的 “全部” 按钮才有高亮显示，其余按钮没有样式，现在我们要实现点击就切换高亮显示 在三个按钮中添加事件： 12345678&lt;!-- App.vue --&gt;&lt;a-button-group&gt; &lt;a-button type=&quot;primary&quot; @click=&quot;changeStyle(&#x27;all&#x27;)&quot;&gt;全部&lt;/a-button&gt; &lt;a-button type=&quot;default&quot; @click=&quot;changeStyle(&#x27;unDone&#x27;)&quot;&gt;未完成&lt;/a-button&gt; &lt;a-button type=&quot;default&quot; @click=&quot;changeStyle(&#x27;done&#x27;)&quot;&gt;已完成&lt;/a-button&gt;&lt;/a-button-group&gt;&lt;!-- 注：&quot;primary&quot;表示有高亮样式，&quot;default&quot;表示没有高亮样式 --&gt; 在 state 中定义不同的数据列表： 12345// /store/index.jsstate: &#123; viewKey: &quot;all&quot; // 默认为全部数据&#125; 在 methods 中定义方法，触发 mutation 函数，并传入参数 key： 12345678// App.vuemethods: &#123; // 修改页面上的显示列表 changeStyle(key) &#123; this.$store.commit(&quot;changeView&quot;, key) &#125;&#125; 在 mutations 中定义函数 changeStyle，并修改 state 中 viewKey 的值为 key： 12345678// /store/index.jsmutations: &#123; // 修改视图的关键字 changeView(state, key) &#123; state.viewKey = key &#125;&#125; 映射为组件的计算属性： 12345// App.vue computed: &#123; ...mapState([&quot;list&quot;, &quot;inputValue&quot;, &quot;viewKey&quot;]) &#125; 用三元表达式为每个按钮设置样式，确定是否高亮显示： 12345678910111213141516&lt;!-- App.vue --&gt;&lt;a-button-group&gt; &lt;a-button :type=&quot;viewKey===&#x27;all&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot; @click=&quot;changeStyle(&#x27;all&#x27;)&quot;&gt; 全部 &lt;/a-button&gt; &lt;a-button :type=&quot;viewKey===&#x27;unDone&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot; @click=&quot;changeStyle(&#x27;unDone&#x27;)&quot;&gt; 未完成 &lt;/a-button&gt; &lt;a-button :type=&quot;viewKey===&#x27;done&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot; @click=&quot;changeStyle(&#x27;done&#x27;)&quot;&gt; 已完成 &lt;/a-button&gt;&lt;/a-button-group&gt; 点击样式查看结果： 点击 “未完成”： 点击 “已完成”： 列表数据的切换 目的：现在我们绑定的数据源是 state 中的 list，不管你点击 “未完成” 还是 “已完成”，都会显示全部数据，所以现在我们要按需渲染出列表数据 我们借助 getters 来显示需要的数据 在 getters 中定义函数，实现按需返回： 123456789101112131415// /store/index.jsgetters: &#123; infoList(state) &#123; // 根据按钮返回对应的数据 if(state.viewKey === &quot;all&quot;) &#123; // 全部 return state.list &#125; if(state.viewKey === &quot;unDone&quot;) &#123; // 未完成 return state.list.filter(item =&gt; item.done===&quot;done&quot;) &#125; if(state.viewKey === &quot;done&quot;) &#123; // 已完成 return state.list.filter(item =&gt; item.done===&quot;unDone&quot;) &#125; &#125;&#125; 映射为组件的计算属性，另外，由于我们将用 infoList 代替 list，所以计算属性中映射的 list 可以删除： 123456// App.vuecomputed: &#123; ...mapState([&quot;inputValue&quot;, &quot;viewKey&quot;]), ...mapGetters([&quot;unDoneLength&quot;, &quot;infoList&quot;])&#125;, 将数据源由 list 切换为 infoList： 12345&lt;!-- App.vue --&gt;&lt;a-list bordered :dataSource=&quot;infoList&quot; class=&quot;dt_list&quot;&gt; &lt;!-- ...此处内容省略 --&gt;&lt;/a-list&gt; 整体代码：以上便是此 demo 的详细说明，下面直接给出全部代码：vuex-todolist","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://ozzienicholas.gitee.io/tags/vuex/"}]},{"title":"Vuex教程（二）：几大核心概念","slug":"Vuex教程（二）：几大核心概念","date":"2021-03-20T04:13:24.000Z","updated":"2021-03-20T04:13:42.443Z","comments":true,"path":"75f824da8763/","link":"","permalink":"https://ozzienicholas.gitee.io/75f824da8763/","excerpt":"","text":"核心概念概述vuex 的核心概念如下： State Mutation Action Getter State认识statestate 提供唯一的公共数据源，所有共享的数据都要放在 store 的 state 中进行存储 创建 state123456// 创建 store 数据源，提供唯一的公共数据const store = new Vuex.Store(&#123; // 创建一个新的 store 实例对象 state: &#123; // store 的 state 属性用来创建公共数据源 count: 0 // state 中的这些数据就是需要全局共享的数据 &#125;&#125;) 组件访问 state 中的数据方式一：this.$store.state.全局数据名称12this.$store.state.全局数据名称// 组件中的 &lt;template&gt; 部分里面省略 this，直接写成 $store.state.全局数据名称 方式二：映射为计算属性 从 vuex 中按需导入 mapState 函数 1import &#123; mapState &#125; from &quot;vuex&quot;; 通过刚才导入的 mapState 函数，将当前组件需要的全局数据，映射为当前组件的 computed 计算属性： 123computed: &#123; ...mapState([&quot;count&quot;]) // 将 count 映射为计算属性&#125; 当有多个全局数据要导出的时候，建议用这一种方式 Mutation认识 mutation 不能用方法来改变全局数据，vue 不允许组件直接修改 store 中的数据 只能通过 mutation 来变更 store 中的数据，不可以直接操作 store 中的数据 虽然这种方式操作起来稍微繁琐，但是可以集中监控所有数据的变化 不能在 mutations 函数中执行异步操作 定义 mutation1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; //此对象里面可以定义很多的事件处理函数 add(state) &#123; //变更状态: count += 1 state.count ++; &#125; &#125;&#125;) 在组件中调用 mutations 中的函数方式一：this.$store.commit(“函数名”)触发 mutations 函数： 123456methods: &#123; handle() &#123; // &quot;add&quot;即为 mutations 中的函数名 this.$store.commit(&quot;add&quot;) &#125;&#125; 向 mutations 函数中传递参数： 1234567891011121314151617181920// 定义 mutations 函数const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; addN(state, step) &#123; // 变更状态: count += step state.count += step; &#125; &#125;&#125;)// 触发 mutations 函数methods: &#123; handle() &#123; // 用 commit 函数触发 mutations 函数时传递参数 this.$store.commit(&quot;addN&quot;, 3) // 向 addN 函数传参为3 &#125;&#125; 方式二：映射为方法 从 vuex 中按需导入 mapMutations 函数： 1import &#123; mapMutations &#125; from &quot;vuex&quot; 通过 mapMutations 函数，将需要的 mutations 函数映射为 methods 方法： 123methods: &#123; ...mapMutations([&quot;addN&quot;])&#125; Action认识 action action 用于处理异步任务，如果通过异步操作处理变更数据，必须通过 action，而不能使用 mutation 但是在 action 中还是要通过触发 mutation 的方式间接变更数据，action 本身并不能改变 state 中的数据 定义 action123456789101112131415161718const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; add(state) &#123; state.count ++; &#125; &#125;, action: &#123; addAsync(context) &#123; // 把 context 看作是 store 的一个实例对象 setTimeout(() =&gt; &#123; // 延时 1 秒后触发 add 函数 context.commit(&quot;add&quot;) // mutations 中的函数 &#125;, 1000) &#125; &#125;&#125;) 触发 action方式一：this.$store.dispatch(“函数名”)触发 actions 函数： 12345methods: &#123; handle() &#123; this.$store.dispatch(&quot;addAsync&quot;) &#125;&#125; 触发 actions 函数时携带参数： 123456789101112131415161718192021222324252627// 定义 actions 函数const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; addN(state, step) &#123; state.count += step; &#125; &#125;, actions: &#123; addNAsync(context, step) &#123; setTimeout(() =&gt; &#123; // 将参数 step 传给要触发的 addN 函数 context.commit(&quot;addN&quot;, step) &#125;, 1000) &#125; &#125;&#125;)// 触发 actions 函数methods: &#123; handle() &#123; // 将参数 2 传给要触发的 addNAsync 函数 this.$store.dispatch(&quot;addNAsync&quot;, 2) &#125;&#125; 方式二：映射为方法 从 vuex 中按需导入 mapActions 函数 1import &#123; mapActions &#125; from &quot;vuex&quot; 将指定的 actions 函数映射为当前组件的 methods 方法： 123methods: &#123; ...mapActions([&quot;addNAsync&quot;])&#125; Getter认识 getter getter 不会改变 store 中的数据，仅仅是起到一个包装的作用 getter 用于对 store 中的数据进行加工处理形成新的数据，类似于组件中的计算属性，store 中的数据发生变化时，getter 的数据也会跟着变化 定义 getter12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, getters: &#123; showNum: state =&gt; &#123; return &quot;当前的 count 值为：&quot; + state.count &#125; &#125;&#125;) 使用 getter方式一：this.$store.getters.”名称”1&lt;h1&gt; this.$store.getters.showNum &lt;/h1&gt; 方式二：映射为计算属性 从 vuex 中按需导入 mapGetters 函数： 1import &#123; mapGetters &#125; from &quot;vuex&quot; 将指定的 getters 函数映射为当前组件的计算属性： 123computed: &#123; ...mapGetters([&quot;showNum&quot;])&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://ozzienicholas.gitee.io/tags/vuex/"}]},{"title":"Vuex教程（一）：初次感受Vuex","slug":"Vuex教程（一）：初次感受Vuex","date":"2021-03-20T04:12:51.000Z","updated":"2021-03-20T04:13:08.129Z","comments":true,"path":"c6eabb17a429/","link":"","permalink":"https://ozzienicholas.gitee.io/c6eabb17a429/","excerpt":"","text":"vuex 概述回顾组件传值 父组件向子组件传值：一般用 v-bind 属性绑定实现 子组件向父组件传值：一般同 v-on 事件绑定实现 兄弟组件间共享数据：一般用 EventBus 实现 引入 vuex 什么是 vuex：它是实现组件全局状态（数据）管理的一种机制，可以很方便地实现组件之间数据的共享 不使用 vuex 对比 使用 vuex： 可见，在不使用 vuex 时，要使用大范围或者频繁的数据共享是很麻烦的 使用 vuex 统一管理状态的好处： 能够在 vuex 中集中管理共享的数据，易于开发和后期维护 能高效地实现组件之间的数据共享，提高开发效率 存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 什么样的数据适合存储到 vuex 中 一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；而对于组件私有的数据，存储在组件自身的 data 中即可 但在实际上，把组件中所有的数据存到 vuex 中也是可以的 vuex 的基本使用 安装 vuex 依赖包： 1npm install vuex --save-dev 导入 vuex 包： 12import Vuex from &quot;vuex&quot;Vue.use(Vuex) //将导入的 vuex 安装到项目中使用 创建 store 对象： 123456const store = new Vuex.Store(&#123; // state 中存放的就是全局共享的数据 state: &#123; // ... &#125;&#125;) 将 store 对象挂载到 vuex 实例中： 1234567new Vue(&#123; el: &quot;#app&quot;, render: h =&gt; h(app), // 将创建的共享数据对象，挂载到 vue 实例中 // 所有的组件，就可以直接从 store 中获取全局的数据了 store&#125;) 创建 vuex 项目 在 cmd 中输入 vue ui 来打开 vue 的可视化面板 点击 “创建”，选择或输入自己要将项目放置的目录 跳转到对应目录下之后，点击 “在此创建新项目” 如图所示： 名称：这个自定义即可 包管理器：选择 npm 管理 Git：我们选择初始化一个 git 仓储，初始化的提交消息我们暂且写为 “init project” 点击 “下一步” 选择 “手动”，我们来自定义安装哪些依赖项，再点击 “下一步” 需要确定安装的有以下四项： “Babel” “Vuex” “Linter / Formatter” “使用配置文件” 勾选好后点击 “下一步” 在 Select... 选项中，我们选择 “ESLint with error prevention only” 这一项，再点击 “创建项目” 会弹出一个 “保存为预设” 的窗口，我们暂且点击 “创建项目，不保存预设” 以上便是全部步骤，现在开始创建，可能需要等待一会儿…… 创建成功时，你的浏览器会显示：（先暂时不关终端以及这个窗口，我们马上就会用到） 感受 vuex 的功能查看项目效果 回到浏览器中，点击 “任务”，再点击 “serve”，最后点击 “运行”： 等到右边的显示完成后，即为完成 点击 “启动 app”，即可看到此项目的效果 现在我们关闭浏览器和终端，开始重新编辑项目 重新编辑项目 现在我们想感受一个 vuex 的功能目标是：我们在整个项目中共享一个 count 值，然后用按钮操控 count 的加减 整个项目的文件结构如下： 同时打开 /src/store/index.js 以及 /src/main.js，你会发现，vuex 如何被使用的呢： /src/store/index.js：初始化 vuex，并导出 store /src/main.js：导入 store，并在 vue 实例中使用 删除 /src/components/HelloWorld.vue 定义 store，对 /src/components/store/index.js 修改如下： 12345678910111213141516171819import Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; add(state) &#123; state.count ++ &#125;, sub(state) &#123; this.state -- &#125; &#125;&#125;) 在 /src/components 下创建 Addition.vue 以及 Subtract.vue，分别用来控制 count 的增加和减少： 1234567891011121314151617181920&#x2F;&#x2F; Addtion.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;当前最新的 count 值为：&#123;&#123; this.$store.state.count &#125;&#125;&lt;&#x2F;h3&gt; &lt;button @click&#x3D;&quot;add&quot;&gt;加1&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123; add() &#123; this.$store.commit(&quot;add&quot;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 1234567891011121314151617181920&#x2F;&#x2F; Substract.vue&lt;template&gt; &lt;div&gt; &lt;h3&gt;当前最新的 count 值为：&#123;&#123; this.$store.state.count &#125;&#125;&lt;&#x2F;h3&gt; &lt;button @click&#x3D;&quot;sub&quot;&gt;减1&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123;&#125;; &#125;, methods: &#123; sub() &#123; this.$store.commit(&quot;sub&quot;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 将 /src/App.vue 替换为： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;my-addtion &#x2F;&gt; &lt;hr &#x2F;&gt; &lt;my-substract &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Addition from &quot;.&#x2F;components&#x2F;Addtion&quot; &#x2F;&#x2F; 导入 Addtion 组件import Substract from &quot;.&#x2F;components&#x2F;Substract&quot; &#x2F;&#x2F; 导入 Substract 组件export default &#123; data() &#123; return &#123;&#125;; &#125;, components: &#123; &#x2F;&#x2F; 将导入的组件注册为私有的子组件 &quot;my-addtion&quot;: Addition, &quot;my-substract&quot;: Substract &#125;&#125;&lt;&#x2F;script&gt; 我们之前在创建项目时不小心使用了 ESLint，现在我们在根目录下创建 vue.config.js 来消除这个效果： 1234// vue.config.jsmodule.exports = &#123; lintOnSave: false&#125; 启动项目： 1npm run serve 至此，你可以打开浏览器查看效果了，如果通过按钮可以实现对 state 的控制，那么这个 demo 就成功了 本节只是引入了 vuex 的概念以及简单地使用了 vuex，体验 demo 即可，代码部分之后详细说明，加油！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vuex","slug":"vuex","permalink":"https://ozzienicholas.gitee.io/tags/vuex/"}]},{"title":"Vue教程（十）：详解生命周期","slug":"Vue教程（十）：详解生命周期","date":"2021-03-20T04:11:52.000Z","updated":"2021-03-20T04:12:09.153Z","comments":true,"path":"41065790d3f7/","link":"","permalink":"https://ozzienicholas.gitee.io/41065790d3f7/","excerpt":"","text":"生命周期钩子，也叫 “生命周期函数”、“生命周期事件”，之前在 Vue教程（三）：实例与模板语法 中简单介绍了生命周期，现在详细解释 之前说过，在 Vue 中要渲染一块页面内容的时候，会有这么几个过程： ① 解析语法生成 AST。 ② 根据 AST 结果，完成 data 数据初始化。 ③ 根据 AST 结果和 data 数据绑定情况，生成虚拟 DOM。 ④ 将虚拟 DOM 生成真正的 DOM 插入到页面中，此时页面会被渲染。 但是，不只是有上面四个过程，接下来，当我们绑定的数据进行更新的时候，又会产生以下这些过程： ⑤ 框架接收到数据变更的事件，根据数据生成新的虚拟 DOM 树。比较新旧两棵虚拟 DOM 树，得到差异。 ⑥ 把差异应用到真正的 DOM 树上，即根据差异来更新页面内容。 ⑦ 注销实例，清空页面内容，移除绑定事件、监听器等。 所以，在整个页面或是某块页面内容（组件）中，Vue 提供了以下的一些关键的生命周期钩子： 生命周期钩子函数 该函数的说明 对应上述步骤 beforeCreate 初始化实例前，data、methods 等不可获取 ①之后，②之前 created 实例初始化完成，此时可获取 data 里数据和methods事件，无法获取 DOM ②之后，③ 之前 beforeMount 虚拟 DOM 创建完成，此时未挂载到页面中，vm.$el 可获取未挂载模板 ③ 之后，④ 之前 mounted 数据绑定完成，真实 DOM 已挂载到页面，vm.$el 可获取真实 DOM ④ 之后 beforeUpdate 数据更新，DOM Diff 得到差异，未更新到页面 ⑤ 之后，⑥ 之前 updated 数据、页面均已更新 ⑥ 之后 beforeDestroy 实例销毁前 ⑦ 之前 destroyed 实例销毁完成 ⑦ 之后 我们可以更新官方的生命周期图如下： ![image-20201007004027110](https://user-images.githubusercontent.com/49378661/95237553-f36c0480-083a-11eb-8fba-a0db3711b86d.png) 生命周期钩子的使用案例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, template: &quot;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&quot;, data() &#123; return &#123; message: &quot;欢迎来到Vue的世界&quot; &#125;; &#125;, methods: &#123; test() &#123;&#125; &#125;, beforeCreate: function() &#123; // 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用 console.log(&quot;beforeCreate&quot;, this.message, this.test, this.$el); &#125;, created: function() &#123; // 在实例创建完成后被立即调用 // 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调 // 挂载阶段还没开始，$el 属性目前不可见 console.log(&quot;created&quot;, this.message, this.test, this.$el); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用：相关的 render 函数首次被调用 console.log(&quot;beforeMount&quot;, this.message, this.test, this.$el); &#125;, mounted: function() &#123; // el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子 // 如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内 // mounted 不会承诺所有的子组件也都一起被挂载 // 如果希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted console.log(&quot;mounted&quot;, this.message, this.test, this.$el); this.$nextTick(function() &#123; // 此处整个视图已渲染完毕 &#125;); &#125;, beforeUpdate: function() &#123; // 数据更新时调用，发生在虚拟 DOM 打补丁之前 // 这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器 &#125;, updated: function() &#123; // 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子 // 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作 &#125;, beforeDestroy: function() &#123; // 实例销毁之前调用。在这一步，实例仍然完全可用 &#125;, destroyed: function() &#123; // Vue 实例销毁后调用 // 调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁 &#125; &#125;);&lt;/script&gt; 看控制台的输出： 可以大致分为三个阶段：创建阶段、运行阶段、销毁阶段 创建阶段：beforeCreated、created、beforeMount、mounted beforeCreate：实例刚刚从内存中创建出来，还没有初始化 data 以及 methods，只包含一些自带的其他生命周期函数。 created：实例已经从内存中创建完成，此时，data 和 methods 都已经创建完成。 boforeMount：此处已经完成了模板的编译，但还未渲染到界面中去。 mounted：模板已经渲染到了浏览器，创建阶段结束，接下来进入运行阶段。 案例： 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var v = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;hello world!&quot; &#125;, // 如果没有template,则会将 el 中元素当作 template，如果有 template，则会覆盖 el 中的 dom template: &quot;&lt;div id=&#x27;app&#x27; style=&#x27;color: red;&#x27;&gt;&lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&quot;, // Vue实例刚刚被初始化，data和methods还没有值 beforeCreate() &#123; console.log(&#x27;1. beforeCreate=====&#x27; + this.message) // 设置debugger &#125;, // Vue实例创建完成，data和methods可以被使用了 created() &#123; console.log(&#x27;2. created=====&#x27; + this.message) // 设置debugger &#125;, // 内存中的Dom已经渲染完成，还没有显示到浏览器 beforeMount() &#123; console.log(&#x27;3. beforeMount=====&#x27; + this.message) // 设置debugger &#125;, //模版已经渲染到浏览器，创建阶段结束 mounted() &#123; // 设置debugger console.log(&#x27;4. mounted=====&#x27; + this.message) &#125; &#125;)&lt;/script&gt; 运行阶段：beforeUpdate、updated beforeUpdate：实例中的 data 已经更新，但是页面中的数据未更新，也就是，实例的 data 比页面的数据先更新。 可以多想一点的是，在 updated 之后存在一个过渡阶段：先根据 data 中的数据，在内存中渲染出一个新的DOM，当新的DOM树更新之后，会重新渲染到真实的界面中去，从而实现了从数据层（model）到视图层（view）的转换。这个阶段不属于生命周期，只是便于学习抽象化的中间处理过程。 updated：页面重新渲染，页面数据与 data 保持一致。 案例： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; message: &quot;hello world!&quot; &#125;, // 如果没有template,则会将el中元素当作template，如果有template，则会覆盖el中的dom template: &quot;&lt;div id=&#x27;app&#x27; style=&#x27;color: red;&#x27;&gt;&lt;h1&gt;&#123;&#123; message &#125;&#125;&lt;/h1&gt;&lt;/div&gt;&quot;, beforeCreate() &#123; console.log(&#x27;1. beforeCreate=====&#x27; + this.message) &#125;, created() &#123; console.log(&#x27;2. created=====&#x27; + this.message) &#125;, beforeMount() &#123; console.log(&#x27;3. beforeMount=====&#x27; + this.message) &#125;, mounted() &#123; console.log(&#x27;4. mounted=====&#x27; + this.message) &#125;, beforeUpdate() &#123; console.log(&quot;此时的message已经更新，但是浏览器页面上的数据没有发生变化&quot;, this.message) // 修改数据之后，添加断点，页面上的数据和当前message不一致 // 设置debugger &#125;, updated() &#123; console.log(&quot;更新结束，页面数据已更新&quot;) &#125; &#125;) // 在修改数据之前，添加断点 // 设置debugger vm.message = &#x27;这是 Vue 的生命周期的运行阶段&#x27;&lt;/script&gt; 销毁阶段：beforeDestroy、destroyed beforeDestroy：此时 Vue 的生命周期已经进入销毁阶段，但是实例上的各种数据还处于可用的状态。 destroyed：组件已全部销毁，Vue 实例也被销毁，所有数据均不可用。 更详细的参考图：","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（九）：组件终结篇","slug":"Vue教程（九）：组件终结篇","date":"2021-03-20T04:11:14.000Z","updated":"2021-03-20T04:11:35.883Z","comments":true,"path":"d955e5aaf64c/","link":"","permalink":"https://ozzienicholas.gitee.io/d955e5aaf64c/","excerpt":"","text":"Prop使用 Prop 传递数据 组件实例的作用域是孤立的。这意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项，子组件要显示地用 props 选项声明它期望获得的数据。 组件获得了 prop 之后，它就如同该组件的 data 一样，可以在模板内使用，而对于根组件，也可以如同 vm.prop 一样使用。 关于 Prop 的大小写：HTML 对大小写是不敏感的，也就是说，在浏览器解析时，会把所有的大写字符解释成小写字符，所以，当你使用 DOM 中的模板时，所以，以驼峰命名法（camelCase）命名的字符需要被替换为对应的短横线分割命名（kebab-case）。 案例： 1234567891011121314&lt;div id&#x3D;&quot;app&quot;&gt; &lt;!-- test-msg 是短横线命名法 --&gt; &lt;child test-msg&#x3D;&quot;This is testMsg&quot;&gt;&lt;&#x2F;child&gt;&lt;&#x2F;div&gt;&lt;script&gt; Vue.component(&quot;child&quot;, &#123; &#x2F;&#x2F; testMsg 是驼峰命名法 props: [&quot;testMsg&quot;], &#x2F;&#x2F; 声明 props template: &quot;&lt;div&gt;&#123;&#123;testMsg&#125;&#125;&lt;&#x2F;div&gt;&quot; &#125;) var app &#x3D; new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;&#x2F;script&gt; 注意，如果你使用的是字符串模板，那么上述限制是不存在的。 字符串模板：指的是组件选项中用 template 引出来的模板，例如下面的 &lt;div&gt;Hello World&lt;/div&gt; 就是字符串模板 123Vue.component(&quot;example&quot;, &#123; template: &quot;&lt;div&gt;Hello World&lt;/div&gt;&quot;&#125;) 非字符串模板：单文件组件中，用 &lt;template&gt; 指定的模板，也就是说，写在 HTML 中的就是非模板字符串，这也与官网说的 “HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名” 吻合。例如： 123&lt;template&gt; &lt;div&gt;Hello World&lt;&#x2F;div&gt;&lt;&#x2F;template&gt; 动态 Prop在模板中，若要动态地将父组件的数据传给子组件，就直接使用 v-bind 即可，例如： 1234567891011121314151617&lt;div id&#x3D;&quot;app&quot;&gt; &lt;input v-model&#x3D;&quot;inputValue&quot;&gt; &lt;hr &#x2F;&gt; &lt;child :child-msg&#x3D;&quot;inputValue&quot;&gt;&lt;&#x2F;child&gt;&lt;&#x2F;div&gt;&lt;script&gt; Vue.component(&quot;child&quot;, &#123; props: [&quot;childMsg&quot;], template: &quot;&lt;span&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;span&gt;&quot; &#125;) var app &#x3D; new Vue(&#123; el: &quot;#app&quot;, data: &#123; inputValue: &quot;This is inputValue&quot; &#125; &#125;)&lt;&#x2F;script&gt; 字面量语法与动态语法 这里要说的是一个常见的错误，那就是错误地以为使用字面量语法能传递数值，如： 1&lt;child msg=&quot;100&quot;&gt;&lt;/child&gt; 其实这里是用字面量语法来传递的，它是一个字面量的 Prop，这里的 msg 传递的是字符串 “100” 而非 数值 100。 若想传递数值 100，则要使用 v-bind，它的值也会被当作 JS 表达式计算。 单向数据流 prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你 不应该 在子组件内部改变 prop 。否则，Vue 会在控制台给出警告。 然而，我们要修改 prop 中数据，通常是因为这两种原因： prop 作为初始值传入后，子组件想把它当作局部数据来用 prop 作为初始值传入，由子组件处理成其它数据输出 对于上述原因，解决的方式是： 定义一个局部变量，并用 prop 的值初始化它： 123456props: [&quot;parentMsg&quot;],data: function() &#123; return &#123; childMsg: this.parentMsg &#125;&#125; 在父组件接收到 parentMsg 的值，最后在子组件中把值赋给 childMsg，再使用 childMsg 即可 定义一个计算属性，处理 prop 的值并返回： 123456props: [&quot;parentMsg&quot;],computed: &#123; funMsg: function() &#123; return this.trim().toLowerCase() &#125;&#125; 在父组件接收到 parentMsg 的值，最后在子组件中映射为计算属性 另外要注意，在 JS 中，对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态 Prop 验证 我们可以为组件的 props 指定规格来进行验证，换句话说，就是子组件来接收父组件时，子组件可以检查该值是不是需要的 prop，如果传入的数据不符合规格，Vue 会发出警告。尤其是开发组件给其他人使用时，这很有用。 之前接收 prop 没有考虑到规格验证，所以一直都是 props: [&quot;A&quot;, &quot;B&quot;] 这种字符串数组的形式，但现在要指定验证规格，则要用对象的形式，而不能用字符串数组： 12345678910111213141516171819202122232425262728293031323334Vue.component(&quot;child&quot;, &#123; props: &#123; // 基础类型检测（若是 &quot;null&quot; 或 &quot;undefined&quot;，则是任何类型都可以） // 此处规定 propA 必须是数值类型 propA: Number, // 多种类型检测，满足一种即可 propB: [String, Number], // 规定必传，且必须为字符串 propC: &#123; type: String, required: true &#125;, // 必须是数值类型，若不传则默认为 100 propD: &#123; type: Number, default: 100 &#125;, // 注意，若要限定为数组或对象，则默认值应由一个工厂函数返回 propE: &#123; type: Object, default: function() &#123; return &#123; msg: &quot;Hello World&quot; &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function(value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面的原生构造器： String Number Boolean Function Object Array type 也可以是一个自定义构造器函数，使用 instanceof 检测，若使用开发版本，当 prop 验证失败时，Vue会在抛出警告，如： 1234function Add(x, y) &#123; this.x = x this.y = y&#125; 之后再使用： 12345Vue.component(&quot;example&quot;, &#123; props: &#123; ret: Add &#125;&#125;) 以此来验证 ret 对应的 prop 值是否是 new Add 创建的 非 Prop 的 属性组件是可以接收任意的属性的，但是当一个非 prop 的属性传入组件，而该组件又没有对应的 prop 定义时，这些属性会被添加到这个组件的根元素上，例如： 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;child msg=&quot;test&quot;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;child&quot;, &#123; template: &quot;&lt;div&gt;Hello World&lt;/div&gt;&quot; &#125;) var app = new Vue(&#123; el: &quot;#app&quot; &#125;)&lt;/script&gt; 打开控制台，查看元素： 替换/合并已有的属性观察下面的案例，我们在组件内部已经设置好了 type=&quot;b&quot; class=&quot;B&quot;，但是在外部又传入了 type=&quot;a&quot; class=&quot;A&quot; ： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .A &#123; font-size: 30px; &#125; .B &#123; color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- 外部传入 --&gt; &lt;child type=&quot;a&quot; class=&quot;A&quot;&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;child&quot;, &#123; // 内部设置 template: &quot;&lt;div type=&#x27;b&#x27; class=&#x27;B&#x27;&gt;Hello World&lt;/div&gt;&quot; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 打开控制台： 对于绝大部分属性，从外部传入的会替换掉组件自身设置的，但是 class 与 style 属性会合并，不过，若是外部 class/style 与 内部 class/style 相冲突，优先的仍是外部 禁用属性继承前面提到过，非 prop 属性会被挂载到根组件上，但如果你不想组件的根元素继承属性，可以在组件选项中设置 inheritAttrs: false，例如： 123Vue.component(&quot;child&quot;, &#123; inheritAttrs: false&#125;) inheritAttrs 非常适合与实例的 $attrs 搭配使用，$attrs 属性包含了传递给一个组件的属性名和属性值，有了 inheritAttrs 和 $attrs，你就可以亲自决定这些属性会被挂载到哪个元素上，这在写 基础组件 时常会用到，例如： 123456789101112Vue.component(&quot;base-input&quot;, &#123; inheritAttrs: false, props: [&quot;label&quot;, &quot;value&quot;], template: ` &lt;label&gt;&#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot; &gt; &lt;/label&gt; `&#125;) 注意，inheritAttrs 不会影响到 style 与 class 的绑定 自定义事件事件的命名 不同于组件名以及 prop 名，事件名不存在任何大小写转化，也就是说，只需要保证前后使用的事件名是完全一致的即可，因为事件名不会被用作一个 JS 变量名或者 property 名，所以就不需要使用 camelCase（驼峰命名法）以及 PascalCase（帕斯卡命名法） v-on 事件监听器在 DOM 模板中会自动转换为全小写（因为 HTML 对大小写是不铭感的），例如 v-on:myEvent 会被转换为 v-on:myevent，这将导致 myEvent 不会被监听到。 所以，综合组件名与 prop 名的命名规则，最佳的方案是一直使用 kebab-case 命名法 用 v-on 绑定自定义事件 父组件是使用 props 将数据传递给子组件，若是子组件把数据传递出去，就应该使用自定义事件 每个 Vue 实例都实现了事件接口，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 Vue 的事件系统分离自浏览器的 EventTarget，不过，他们的运行虽然类似，但是 $on 与 $emit 并不是 addEventListener 以及 dispatchEvent 的别名 关于 v-on 绑定自定义事件的例子，可以查看另一篇博文：组件通信详解 自定义组件的 v-model官网案例默认情况下，组件的 v-model 会利用属性 value 以及 事件 input，但是，像单选框、复选框这类型的输入控件可能会将 value 的属性用作不同的目的（比如 &lt;input type=&quot;checkbox&quot;&gt; 中的 value），model 选项可以用来避免此类冲突： 123456789101112131415Vue.component(&quot;base-checkbox&quot;, &#123; model: &#123; prop: &quot;checked&quot;, event: &quot;change&quot; &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=&quot;checkbox&quot; v-bind:checked=&quot;checked&quot; v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot; &gt; `&#125;) 注意，在组件的 props 选项里声明 checked 这个 prop 是必须的 在这个组件上使用 v-model 如下： 1&lt;base-checkbox v-model=&quot;testValue&quot;&gt;&lt;/base-checkbox&gt; 这里的 testValue 的值会传入名为 checked 的 prop，同时，当 &lt;base-checkbox&gt; 触发一个 change 事件并附带一个新值的时候，这个 testValue 的 property 将会被更新 自理解案例自定义事件也可以用来创建自定义的表单输入组件，使用 v-model 来进行数据的双向绑定，牢记： 1&lt;input v-model=&quot;something&quot;&gt; 仅仅是一个语法糖： 1&lt;input v-bind:value=&quot;something&quot; v-on:input=&quot;something=$event.target.value&quot;&gt; 所以，在组件中使用，相当于下面的简写： 1&lt;component-input v-bind:value=&quot;something&quot; v-on:input=&quot;something=arguments[0]&quot;&gt;&lt;/component-input&gt; 所以，要让 v-model 生效，必须： 接受一个 value 属性 在有新的 value 时触发 input 事件 简单的案例： 1234567891011121314151617181920212223242526272829&lt;div id=&quot;app&quot;&gt; &lt;component-input v-model=&quot;price&quot;&gt;&lt;/component-input&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;component-input&quot;, &#123; template: ` &lt;input ref=&quot;input&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;updateValue($event.target.value)&quot; &gt; `, props: [&quot;value&quot;], methods: &#123; // 此函数不是直接更新值，而是用来对输入值进行格式化和位数限制 updateValue: function(value) &#123; // 删除两侧的空格，并保留2位小数 var formattedValue = value.trim().slice(0, value.indexOf(&quot;.&quot;) + 3) // 若值不统一，则手动覆盖以保证一致 if (formattedValue != value) &#123; this.$refs.input.value = formattedValue &#125; // 通过 input 事件发出数值 this.$emit(&quot;input&quot;, Number(formattedValue)) &#125; &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot; &#125;) 上述的案例中仍有漏洞，比如输入的可能是标点符号之类的 下面是一个更完善的货币过滤器的案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.rawgit.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e/raw/974aa47f8f9c5361c5233bd56be37db8ed765a09/currency-validator.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;currency-input label=&quot;Price&quot; v-model=&quot;price&quot;&gt;&lt;/currency-input&gt; &lt;currency-input label=&quot;Shipping&quot; v-model=&quot;shipping&quot;&gt;&lt;/currency-input&gt; &lt;currency-input label=&quot;Handling&quot; v-model=&quot;handling&quot;&gt;&lt;/currency-input&gt; &lt;currency-input label=&quot;Discount&quot; v-model=&quot;discount&quot;&gt;&lt;/currency-input&gt; &lt;p&gt;Total: $&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;currency-input&quot;, &#123; template: ` &lt;div&gt; &lt;label v-if=&quot;label&quot;&gt;&#123;&#123;label&#125;&#125;&lt;/label&gt; &lt;input ref=&quot;input&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;updateValue($event.target.value)&quot; v-on:focus=&quot;selectAll&quot; v-on:blur=&quot;formatValue&quot; &gt; &lt;/div&gt; `, props: &#123; value: &#123; type: Number, default: 0 &#125;, label: &#123; type: String, default: &quot;&quot; &#125;, &#125;, mounted: function() &#123; this.formatValue() &#125;, methods: &#123; updateValue: function(value) &#123; var result = currencyValidator.parse(value, this.value) if (result.warning) &#123; this.$refs.input.value = result.value &#125; this.$emit(&#x27;input&#x27;, result.value) &#125;, formatValue: function() &#123; this.$refs.input.value = currencyValidator.format(this.value) &#125;, selectAll: function(event) &#123; setTimeout(function() &#123; event.target.select() &#125;, 0) &#125; &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; price: 0, shipping: 0, handling: 0, discount: 0 &#125;, computed: &#123; total: function() &#123; return (( this.price * 100 + this.shipping * 100 + this.handling * 100 - this.discount * 100 ) / 100).toFixed(2) &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这个接口不仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型，例如： 123&lt;voice-recognizer v-model=&quot;question&quot;&gt;&lt;/voice-recognizer&gt;&lt;webcam-gesture-reader v-model=&quot;gesture&quot;&gt;&lt;/webcam-gesture-reader&gt;&lt;webcam-retinal-scanner v-model=&quot;retinalImage&quot;&gt;&lt;/webcam-retinal-scanner&gt; 非父子组件通信关于非父子组件通信的例子，可以查看另一篇博文：组件通信详解 将原生事件绑定到组件 若想把原生事件绑定到根组件上，可以用 v-on 的 .native 修饰符，例如： 1&lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt; 不过需要注意，在尝试监听类似 &lt;input&gt; 这类非常特殊的元素时，可能会失效，例如： 12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;base-input v-on:focus.native=&quot;onFocus&quot;&gt;&lt;/base-input&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&quot;base-input&quot;, &#123; template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot; &gt; &lt;/label&gt; ` &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, &#125;)&lt;/script&gt; 此时，父级的 .native 将会默默失败，onFocus 将不会被调用，但是这并不会报任何错 为解决此问题，vue 提供了一个 $listeners 的属性，它是一个对象，里面包含了作用在组件上的所有监听器，如： 1234&#123; focus: function(event) &#123;/*...*/&#125;, input: function(value) &#123;/*...*/&#125;&#125; 将 $listeners 与 v-on=&quot;$listeners&quot; 配合，将所有的事件监听器指向这个组件的某个特定元素，例如： 1234567891011121314151617181920212223242526272829Vue.component(&quot;base-input&quot;, &#123; inheritAttrs: false, props: [&quot;label&quot;, &quot;value&quot;], computed: &#123; inputListeners: function() &#123; var vm = this return Object.assign(&#123;&#125;, // 从父级添加所有的监听器 this.$listeners, // 再添加自定义监听器，或覆写一些行为 &#123; // 这里确保组件配合 v-model 的工作 input: function(event) &#123; vm.$emit(&quot;input&quot;, $event.target.value) &#125; &#125; ) &#125; &#125;, template: ` &lt;label&gt; &#123;&#123; label &#125;&#125; &lt;input v-bind=&quot;$attrs&quot; v-bind:value=&quot;value&quot; v-on=&quot;inputListeners&quot; &gt; &lt;/label&gt; `&#125;) 现在 &lt;base-input&gt; 组件完全可以像一个普通的 &lt;input&gt; 元素一样使用了，即，所有跟它相同的属性和监听器都可以工作，不必再使用 .native监听器 .sync 修饰符 一个组件只能定义一个 v-model，但若其他的 prop 也需要双向绑定呢？之前的自定义事件告诉我们，可以通过子组件发射一个事件，再用父组件监听一个事件，再更新 prop，例如： 父组件 1234567891011121314151617&lt;template&gt; &lt;child v-bind:value=&quot;myValue&quot; v-on:valueChanged=&quot;e =&gt; myValue = e&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import Chlid from &quot;./Child.vue&quot;;export default &#123; components: &#123; child: Child &#125;, data() &#123; return &#123; myValue: 1234, &#125; &#125;,&#125;&lt;/script&gt; 子组件： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;input v-on:input=&quot;onInput&quot; v-bind:value=&quot;value&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; value: &#123; type: String &#125; &#125;, methods: &#123; onInput(e) &#123; this.$emit(&quot;valueChanged&quot;, e.target.value) &#125; &#125;&#125;&lt;/script&gt; 但是这样未免太麻烦，我们可以通过 .sync 简化过程： 组件内触发的事件以 update: myPropName 命名，相应地，上述子组件改为 update: value 父组件的 v-bind:value 加上 .sync 修饰符，即 v-bind:value.sync 在修改之前，我们好好地认识一下 .sync： 阅读官方文档：.sync 修饰符，vue 2.3.0 时，我们重新引入了 .sync 修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器 例如： 1&lt;child :foo.sync=&quot;bar&quot;&gt;&lt;/child&gt; 会被扩展为： 1&lt;child :foo=&quot;bar&quot; @update:foo=&quot;val =&gt; bar = val&quot;&gt;&lt;/child&gt; 在子组件需要更新 foo 的值时，它需要显式地触发一个更新事件： 1this.$emit(&quot;update: foo&quot;, newValue) 可能上述的过程还是有点晕，请看下面这个案例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;./vue.js&quot;&gt;&lt;/script&gt; &lt;style&gt; .btn &#123; padding: 30px 20px 30px 5px; border: 1px solid #ddd; margin-bottom: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;child :show.sync=&quot;valueChild&quot; class=&quot;btn&quot;&gt;&lt;/child&gt; &lt;button @click=&quot;changeValue&quot;&gt;toggle&lt;/button&gt; &lt;/div&gt; &lt;script&gt; Vue.component(&quot;child&quot;, &#123; props: [&quot;show&quot;], template: ` &lt;div v-if=&quot;show&quot;&gt; &lt;p&gt;默认值是 &#123;&#123;show&#125;&#125;，所以是显示的&lt;/p&gt; &lt;button @click.stop=&quot;closeDiv&quot;&gt;关闭&lt;/button&gt; &lt;/div&gt; `, methods: &#123; closeDiv() &#123; // 触发 input 事件，改变 show 的值为 false this.$emit(&quot;update:show&quot;, false) &#125; &#125; &#125;) var app = new Vue(&#123; el: &quot;#app&quot;, data: &#123; valueChild: true &#125;, methods: &#123; changeValue() &#123; this.valueChild = !this.valueChild &#125; &#125; &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; .sync 的功能是：当子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。如果不用 .sync，那么上面的那个弹窗功能，我们也可以通过父子组件通信来解决，只是稍微有点麻烦。 回到之前的父子组件中，我们不采用 props/$emit，而是用 .sync，那么就应该修改为： 父组件： 1234567891011121314151617&lt;template&gt; &lt;child v-bind:value.sync=&quot;myValue&quot; v-on:valueChanged=&quot;e =&gt; myValue = e&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import Chlid from &quot;./Child&quot;;export default &#123; data() &#123; return &#123; myValue: 1234, &#125; &#125;, components: &#123; child: Child &#125;,&#125;&lt;/script&gt; 子组件： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;input v-on:input=&quot;onInput&quot; v-bind:value=&quot;value&quot;/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: [&quot;value&quot;], methods: &#123; onInput(e) &#123; this.$emit(&quot;update: value&quot;, e.target.value) &#125; &#125;&#125;&lt;/script&gt; 注意，.sync 修饰符的 v-bind 不能和表达式一起使用，这是无效的，例如 v-bind:type.sync=&quot;doc.type + &#39;!&#39;&quot; 是无效的，与 v-model 类似，你只能提供你想要绑定的属性名 当我们需要同时将 .sync 绑定到多个属性上时，可以将多个属性整合到一个对象中，再对此对象使用 .sync，这样就会把对象中的每一个属性都作为独立的 prop 传递出去，且每一个 prop 都已经绑定为：v-bind:prop.sync","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（八）：ToDoList案例","slug":"Vue教程（八）：ToDoList案例","date":"2021-03-20T04:10:38.000Z","updated":"2021-03-20T04:10:56.066Z","comments":true,"path":"34ed31bc146a/","link":"","permalink":"https://ozzienicholas.gitee.io/34ed31bc146a/","excerpt":"","text":"ToDoList要求 目标： 显示一个输入框，一个按钮 在输入框中输入内容，点击按钮即在页面中显示出该内容，之后输入框恢复空白 若要完全理解这个小demo，需要一些前提条件： vue基础指令 初步理解JavaScript中的作用域以及this关键字 Vue全局组件以及局部组件的用法 最普通的方式12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;!-- v-model实现双向数据绑定 --&gt; &lt;button type=&quot;button&quot; @click=&quot;buttonClick&quot;&gt;添加&lt;/button&gt; &lt;!-- @click触发点击事件 --&gt; &lt;ul&gt; &lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;!-- v-for绑定数据来循环渲染 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;!-- 引入Vue --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; //创建一个新的实例对象 el: &#x27;#app&#x27;, //el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素） data: &#123; //data:data就是Vue实例中的数据 list: [], //对应到v-for指令的数据 inputValue: &#x27;&#x27; //对应到v-model的数据绑定 &#125;, methods: &#123; //方法 buttonClick: function()&#123; //对应到@click的方法 //将input框中的内容添加到list中，this指向的是这个app实例 this.list.push(this.inputValue); //添加完之后清空input框 this.inputValue = &#x27;&#x27;; &#125; &#125; &#125;)&lt;/script&gt; 全局组件实现1234567891011121314151617181920212223242526272829303132&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;!-- v-model实现双向数据绑定 --&gt; &lt;button type=&quot;button&quot; @click=&quot;buttonClick&quot;&gt;添加&lt;/button&gt; &lt;!-- @click触发点击事件 --&gt; &lt;ul&gt; &lt;!-- 使用组件 --&gt; &lt;!-- 注意命名规则，全局组件的TodoItem在这里要写成todo-item --&gt; &lt;todo-item v-bind:content=&#x27;item&#x27; v-for=&#x27;item in list&#x27;&gt;&lt;/todo-item&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;!-- 引入Vue --&gt;&lt;script type=&quot;text/javascript&quot;&gt; //用Vue中的component方法用来定义一个全局组件 Vue.component(&#x27;TodoItem&#x27;, &#123; //组件名为TodoItem props: [&#x27;content&#x27;], //来自父组件的传值，即要渲染的content值 template: &#x27;&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&#x27;, //HTML模板，在其中仍然用插值表达式来显示content值 &#125;) var app = new Vue(&#123; //创建一个新的实例对象 el: &#x27;#app&#x27;, //el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素） data: &#123; //data:data就是Vue实例中的数据 list: [], //对应到v-for指令的数据 inputValue: &#x27;&#x27; //对应到v-model的数据绑定 &#125;, methods: &#123; //方法 buttonClick: function()&#123; //对应到@click的方法 //将input框中的内容添加到list中，this指向的是这个app实例 this.list.push(this.inputValue); //添加完之后清空input框 this.inputValue = &#x27;&#x27;; &#125; &#125; &#125;)&lt;/script&gt; 其实，对比我们之前用最普通的方式，这里无非就是把之前的&lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; 换成了&lt;todo-item v-bind:content=&#39;item&#39; v-for=&#39;item in list&#39;&gt;&lt;/todo-item&gt;， 然后定义了一个全局的组件TodoItem 那么，组件与普通方式之间，分别对应着什么呢？ 我们用Vue.component方法定义了一个叫TodoItem的全局组件，它的template属性的值，就是用来替换&lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;的 注册组件之后我们就可以使用啦，我们在div中直接用&lt;todo-item&gt;&lt;/todo-item&gt;即可 另外，为了替换掉普通方法中的v-for=&#39;item in list&#39;， 我们在组件中使用了v-bind:content=&#39;item&#39;以及v-for=&#39;item in list&#39; 最后一步：组件传值，我们现在只有v-bind:connent和content，还没传值呢，所以我们用props属性来接受父组件的传值（也就是这里的input框中的输入，另外，实际上这里的Vue实例最外层就是父组件） 来梳理一下整个过程： 在input框中输入内容，并点击添加，触发buttonClick()，data.list添加input框中的内容 v-for用item遍历了data.list，并将值通过v-bind:content传给&lt;todo-item&gt;&lt;/todo-item&gt;标签 最后用插值表达式将content打印出来 局部组件实现123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot;/&gt; &lt;!-- v-model实现双向数据绑定 --&gt; &lt;button type=&quot;button&quot; @click=&quot;buttonClick&quot;&gt;添加&lt;/button&gt; &lt;!-- @click触发点击事件 --&gt; &lt;ul&gt; &lt;!-- 注意命名，这里的名称以Vue实例中的components的属性名为准 --&gt; &lt;todo v-bind:content=&#x27;item&#x27; v-for=&#x27;item in list&#x27;&gt;&lt;/todo&gt; &lt;!-- 使用组件 --&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; &lt;!-- 引入Vue --&gt;&lt;script type=&quot;text/javascript&quot;&gt; var TodoItem = &#123; //定义局部组件的名称为TodoItem props: [&#x27;content&#x27;], //接受父组件传值 template: &#x27;&lt;li&gt;&#123;&#123; content &#125;&#125;&lt;/li&gt;&#x27;, //HTML模板 &#125; var app = new Vue(&#123; //创建一个新的实例对象 el: &#x27;#app&#x27;, //el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素） components: &#123; //注册组件 //定义时为TodoItem，现在在实例中另外取名为todo，使用时以后者为准 todo: TodoItem, &#125;, data: &#123; //data:data就是Vue实例中的数据 list: [], //对应到v-for指令的数据 inputValue: &#x27;&#x27; //对应到v-model的数据绑定 &#125;, methods: &#123; //方法 buttonClick: function()&#123; //对应到@click的方法 //将input框中的内容添加到list中，this指向的是这个app实例 this.list.push(this.inputValue); //添加完之后清空input框 this.inputValue = &#x27;&#x27;; &#125; &#125; &#125;)&lt;/script&gt; 其实这里的局部组件已经很容易掌握了，对比之前，全局组件是用Vue.component方法定义的，而局部组件直接将整个内容写成了一个对象 然后在Vue实例中，通过components属性，将该组件作为属性值注册了该组件，最后直接使用组件 增加一个功能要求 在之前的ToDoList基础上，要增加一项功能： 点击一项内容，点击后即消失 在输入框中回车即可添加一项 知识前提： 组件传值 JavaScript字符串方法 Vue按键修饰符 组件实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;div id=&quot;app&quot;&gt; &lt;!-- 事件修饰符将回车事件keyup.enter指向buttonClick函数 --&gt; &lt;input type=&quot;text&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;buttonClick&quot;/&gt; &lt;button type=&quot;button&quot; @click=&quot;buttonClick&quot;&gt;添加&lt;/button&gt; &lt;ul&gt; &lt;todo-item v-bind:content = &#x27;item&#x27; v-for = &#x27;(item, index) in list&#x27; v-bind:index = &#x27;index&#x27; v-on:delete = &#x27;parentDelete&#x27;&gt; &lt;/todo-item&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;TodoItem&#x27;, &#123; props: [&#x27;content&#x27;, &#x27;index&#x27;], //接受来自父组件的传值 //点击元素，触发子组件的childDelete事件 template: &#x27;&lt;li @click=&quot;childDelete&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/li&gt;&#x27;, methods: &#123; /*子组件向外触发一个名为delete的事件，这个事件将会被父组件监听，从而触发parentDelete 子组件向父组件传的值不仅有事件名称delete，还有一个index来表示该元素的下标*/ childDelete: function()&#123; this.$emit(&#x27;delete&#x27;, this.index); //this.index来自于props接受的值 &#125; &#125; &#125;) var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; list: [], inputValue: &#x27;&#x27; &#125;, methods: &#123; buttonClick: function()&#123; this.list.push(this.inputValue); this.inputValue = &#x27;&#x27;; &#125;, //父组件监听到子组件的delete事件被触发时 parentDelete: function(index)&#123; //接受子组件的传值，index来自于子组件的this.index this.list.splice(index, 1); //js字符串方法删除指定下标的元素 &#125; &#125; &#125;)&lt;/script&gt; 很明显，我们不该从上往下读代码，这样是自己为难自己，我们应该从功能的角度考虑. 我们要实现的功能是：点击元素，让它消失，但是元素在子组件中，消失与否是受父组件的list与v-for共同确定渲染的 所以，我们的大概思路应该是： 点击元素，让子组件将该元素的下标都传给父组件 然后父组件删除在list中该下标的元素，即可实现整个过程 所以，我们的关键操作是： 在定义局部组件时，给template属性的HTML模板添加childDelete，点击时触发 通过this.$emit将this.index传给父组件，但是我们需要为此绑定一个事件，以供父组件实时监听，我们命名为delete 父组件通过v-on:delete监听到时，触发parentDelete来删除该元素 但是parentDelete肯定需要知道该元素下标，所以我们在最开始就要把下标传给子组件，子组件再返回给parentDelete 子组件与父组件之间的传值，个人感觉取决于什么时候用，比如这里的多个事件对应的多个传值，也就是说，我们在传值时务必弄清楚这个值所对应的事件是什么 单文件组件重构安装@vue/cli 现在，我们完全建立一个新文件 project，并进入该目录下 卸载旧版本的 vue-cli，并下载新版本的 123npm uninstall -g vue-clinpm install -g @vue/clivue -V // 检查vue-cli版本 构建项目 进入 /project 中，输入以下命令并一直默认即可 1vue create my-app 启动项目 12cd my-appnpm run serve 打开 http://localhost:8080 查看初始效果 开始写组件 进入 src/APP.vue，删除所有代码，重写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;div&gt; &lt;input type=&quot;text&quot; v-model=&quot;info&quot;&gt; &lt;button @click=&quot;handleClick&quot;&gt;添加&lt;/button&gt; &lt;/div&gt; &lt;hr&gt; &lt;h2&gt;Vue 组件 dom 结构&lt;/h2&gt; &lt;ul&gt; &lt;todo-item v-for=&quot;(item, key) in list&quot; :key=&quot;key&quot;&gt; &lt;!-- 具名插槽 v-slot:item 是 vue2.6 的新语法 --&gt; &lt;template v-slot:item=&quot;itemProps&quot;&gt; &lt;span :style=&quot;&#123;fontSize: &#x27;20px&#x27;, color: itemProps.checked ? &#x27;red&#x27;: &#x27;blue&#x27;&#125;&quot;&gt; &#123;&#123;item&#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/todo-item&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import TodoItem from &#x27;./components/TodoItem.vue&#x27;export default &#123; name: &#x27;app&#x27;, data() &#123; return &#123; msg: &#x27;Hello World&#x27;, info: &#x27;&#x27;, list: [] &#125; &#125;, methods: &#123; handleClick: function() &#123; this.list.push(this.info) this.info = &#x27;&#x27; &#125; &#125;, components: &#123; TodoItem &#125;&#125;&lt;/script&gt; 新建 components/TodoItem.vue： 123456789101112131415161718192021222324&lt;template&gt; &lt;li class=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;slot name=&quot;item&quot; v-bind=&quot;&#123;checked&#125;&quot;&gt;&lt;/slot&gt; &lt;/li&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &#x27;item&#x27;, props: [&#x27;item&#x27;], data() &#123; return &#123; checked: false &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt; .item &#123; color: red; &#125;&lt;/style&gt; 重新输入 npm run serve 查看结果","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（七）：组件通信详解","slug":"Vue教程（七）：组件通信详解","date":"2021-03-20T04:09:56.000Z","updated":"2021-03-20T04:10:13.449Z","comments":true,"path":"47a92c648838/","link":"","permalink":"https://ozzienicholas.gitee.io/47a92c648838/","excerpt":"","text":"Props / $emit 父传子用 props：父组件通过 v-bind 将数据传递出去，子组件通过 props 接收数据子传父用 $emit：子组件通过 emit 将数据传递出去，父组件通过事件接收数据 Props：父组件传给子组件 父组件： 1234567891011121314151617181920&lt;template&gt; &lt;div class&#x3D;&quot;section&quot;&gt; &lt;child :list&#x3D;&quot;list&quot;&gt;&lt;&#x2F;child&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &quot;.&#x2F;Child&quot;export default &#123; name: &quot;Father&quot;, components: &#123; child: Child &#125;, data() &#123; return &#123; list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件： 1234567891011&lt;template&gt; &lt;div&gt; &lt;p v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&quot;list&quot;]&#125;&lt;&#x2F;script&gt; 上述过程是： 父组件通过 v-bind 将数组绑定到 list 上 子组件通过 props 接收传过来的 list，并循环数组渲染出每个元素 注：Props 只能从父组件传向子组件，即单向数据流，而且 Props 是只读的，所有的尝试修改都会报错 $emit：子组件传给父组件$emit 会绑定一个自定义事件，当语句被执行时，就会将该事件中的参数传递给父组件，父组件通过 v-on 接收参数，我们承接上一个案例，在渲染每个子组件的同时，在父组件中显示出该元素的下标： 父组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div class&#x3D;&quot;section&quot;&gt; &lt;child :list&#x3D;&quot;list&quot; @printIndex&#x3D;&quot;printIndex&quot;&gt;&lt;&#x2F;child&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import Child from &quot;.&#x2F;Child&quot;export default &#123; name: &quot;Father&quot;, components: &#123; child: Child &#125;, data() &#123; return &#123; msg: &quot;点击元素即显示对应下标&quot;, list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] &#125; &#125;, methods: &#123; printIndex(idx) &#123; this.msg &#x3D; idx &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;p v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; props: [&quot;list&quot;], methods: &#123; emitIndex(index) &#123; this.$emit(&quot;printIndex&quot;, index) &#125; &#125;&#125;&lt;&#x2F;script&gt; 上述过程是： 子组件先是接收父组件传递过来的 list，再遍历数组渲染元素 渲染时绑定点击事件，触发函数 emitIndex 通过 $emit 向父组件传递事件 printIndex，并将 index 参数传入该事件中 父组件监听着 printIndex 事件，最后再使用接收到的 index $Parent / $children $parent： 当前组件树的根 Vue 实例，如果当前实例没有父实例，此实例将会是其自己。 获取之后，我们可以使用它的属性和方法。 $children： 当前实例的直接子组件，需要注意，$children 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 $children 来进行数据绑定，考虑使用一个数组配合 v-for 来生成子组件，并且使用 Array 作为真正的来源。 获取的是子组件实例的集合，返回的是一个数组 同样，获取成功之后我们可以使用它的实例和方法 父组件： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class&#x3D;&quot;parent&quot;&gt; &lt;child&gt;&lt;&#x2F;child&gt; &lt;p&gt;在父组件中改变子组件的值：&lt;button @click&#x3D;&quot;changeVal&quot;&gt;点击改变子组件的值&lt;&#x2F;button&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import child from &quot;.&#x2F;child&quot;export default &#123; name: &quot;parent&quot;, components: &#123; child &#125;, data() &#123; return &#123; parentMsg: &quot;this is parent&quot; &#125; &#125;, methods: &#123; changeVal() &#123; this.$children[0].childMsg &#x3D; &quot;this is new child&quot; &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class&#x3D;&quot;child&quot;&gt; &lt;span&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;span&gt; &lt;p&gt;在子组件中获取父组件的值：&#123;&#123;parent&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;在子组件中改变父组件的值：&lt;button @click&#x3D;&quot;change&quot;&gt;点击改变父组件的值&lt;&#x2F;button&gt;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &quot;child&quot;, data() &#123; return &#123; childMsg: &quot;this is child&quot; &#125; &#125;, computed: &#123; parent() &#123; return this.$parent.parentMsg &#125; &#125;, methods: &#123; change() &#123; this.$parent.parentMsg &#x3D; &quot;this is new parent&quot; &#125; &#125;&#125;&lt;&#x2F;script&gt; 另外，如果子组件是公共组件，会被多个父组件调用，那么，针对不同的父组件调用，子组件会每次都会生成一个实例，这也是Vue的重要机制，$parent 会获取每个调用它的父组件实例，子组件中通过 $parent 会改变每个调用它的父组件中的对应属性。 eventBus 总线 通过一个空的 vue 实例作为中央事件总线，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或者接收事件，所有组件都可通知其他组件 初始化：创建一个事件总线，并将其导出，以便其他模块可以使用它或者监听它 1234// event.jsimport Vue from &quot;vue&quot;export const EventBus = new Vue() 根组件：将两个子组件渲染出来 123456789101112131415161718&lt;template&gt; &lt;div class&#x3D;&quot;app&quot;&gt; &lt;child_a&gt;&lt;&#x2F;child_a&gt; &lt;child_b&gt;&lt;&#x2F;child_b&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import ChildA from &quot;.&#x2F;ChildA&quot;import ChildB from &quot;.&#x2F;ChildB&quot;export default &#123; name: &quot;app&quot;, components: &#123; child_a: ChildA, child_b: ChildB &#125;&#125;&lt;&#x2F;script&gt; 子组件 ChildA：此组件的功能是：通过 EventBus.$emit 发送事件（即此处的 addtion ），即点击按钮就触发 numA 加 1 的事件,将 numA 的最新值传给总线 123456789101112131415161718192021222324&lt;template&gt; &lt;div class&#x3D;&quot;ChildA&quot;&gt; &lt;button @click&#x3D;&quot;addtion&quot;&gt;点击递增&lt;&#x2F;button&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;export default &#123; name: &quot;ChildA&quot;, data() &#123; return &#123; numA: 1 &#125; &#125;, methods: &#123; addtion() &#123; EventBus.$emit(&quot;addtion&quot;, &#123; numA: this.numA++ &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件 ChildB：此组件的功能是：通过 EventBus.$on 接收事件，接收到最新值，并将其通过计算，再渲染出来 1234567891011121314151617181920212223&lt;template&gt; &lt;div class&#x3D;&quot;ChildB&quot;&gt; ChildB 组件中 numB 的值（也就是 ChildA 组件中 numA 的值）：&#123;&#123;numB&#125;&#125; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;export default &#123; name: &quot;ChildB&quot;, data() &#123; return &#123; numB: 0 &#125; &#125;, mounted() &#123; EventBus.$on(&quot;addtion&quot;, param &#x3D;&gt; &#123; &#x2F;&#x2F; 这里的 param 是一个对象，属性是 numA this.numB &#x3D; param.numA &#125;) &#125;&#125;&lt;&#x2F;script&gt; $attrs / $listeners 在 vue2.4 中，为了解决跨级之间的数据传递需求，引入了 $attrs 和 $listeners，新增了 inheritAttrs 选项，在 vue2.4 之前默认父作用域不作为 prop 被识别以及被获取的特性绑定（class 与 style 除外），将会出现 “回退”，从而作为普通的 HTML 特性引用在子组件的根元素上 $attrs：包含了父作用域不作为 prop 被识别以及被获取的特性绑定（class 与 style 除外） 当一个组件没有声明任何 prop 时，这里会包含所有在父作用域的绑定（class 与 style 除外），并且可通过 v-bind=&quot;$attrs&quot; 传入内部组件，通常配合 inheritAttrs 一起使用 $listeners：包含了父作用域中的 v-on 事件监听器（不包含 .native），它可以通过 v-on=&quot;$listeners&quot; 传入内部组件 根组件：将数据传给子组件 ChildA.vue 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class&#x3D;&quot;app&quot;&gt; &lt;child_a :name &#x3D; &quot;name&quot; :age &#x3D; &quot;age&quot; :gender &#x3D; &quot;gender&quot; :height &#x3D; &quot;height&quot; &gt; &lt;&#x2F;child_a&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import ChildA from &quot;.&#x2F;ChildA&quot;export default &#123; name: &quot;app&quot;, components: &#123; child_a: ChildA, &#125;, data() &#123; return &#123; name: &quot;ozzie&quot;, age: 20, gender: &quot;男&quot;, height: &quot;178&quot; &#125; &#125;&#125;&lt;&#x2F;script&gt; 子组件 ChildA.vue：将数据传递给孙组件 ChildB.vue： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class&#x3D;&quot;ChildA&quot;&gt; &lt;p&gt;ChildA 部分：&lt;&#x2F;p&gt; &lt;p&gt;name: &#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;ChildA 中的 $attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt; &lt;hr&gt; &lt;child_b v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child_b&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import ChildB from &quot;.&#x2F;ChildB&quot;export default &#123; name: &quot;ChildA&quot;, components: &#123; child_b: ChildB &#125;, inheritAttrs: false, &#x2F;&#x2F; 关闭了挂载到组件根元素上的没有在 props 声明的属性 props: &#123; name: String &#125;, created() &#123; console.log(this.$attrs) &#x2F;&#x2F; &#123;age: 20, gender: &quot;男&quot;, height: &quot;178&quot;&#125; &#125;&#125;&lt;&#x2F;script&gt; 孙组件 ChildB.vue： 12345678910111213141516171819202122&lt;template&gt; &lt;div class&#x3D;&quot;ChildB&quot;&gt; &lt;p&gt;ChildB 部分：&lt;&#x2F;p&gt; &lt;p&gt;age: &#123;&#123;age&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;ChildB 中的 $attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt; &lt;hr&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;export default &#123; name: &quot;ChildB&quot;, inheritAttrs: false, props: &#123; age: Number &#125;, created() &#123; console.log(this.$attrs) &#x2F;&#x2F; &#123;gender: &quot;男&quot;, height: &quot;178&quot;&#125; &#125;&#125;&lt;&#x2F;script&gt; 结果如下： Vuex 此部分我已放在了：Vuex教程（二）：几大核心概念 暂时说到这里，之后会陆续补充","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（六）：组件的理解、定义、使用","slug":"Vue教程（六）：组件的理解、定义、使用","date":"2021-03-20T04:08:31.000Z","updated":"2021-03-20T04:09:39.763Z","comments":true,"path":"114013a3cada/","link":"","permalink":"https://ozzienicholas.gitee.io/114013a3cada/","excerpt":"","text":"组件的理解什么是组件？ 组件其实就是页面中的一部分，它是一个具有独立的逻辑和功能或界面，同时又能根据规定的接口规则进行相互融合，变成一个完整的应用。就好比电脑的鼠标、硬盘等一个个元件 前端组件化的核心思路就是将一个巨大复杂的东西才分成粒度合理的小东西 使用组件的好处 提高开发效率 方便重复使用 简化调试步骤 提升项目的可维护性 便于协同开发 Vue 中的组件 Vue 允许我们使用小型、独立和通常可复用的组件构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树 Vue 中的组件可以理解为预先定义好的 ViewModel 类 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例，一个 Vue 组件可以预先定义很多个选项，但最核心的是： 模板（template）：模板声明了数据和最终展现给用户的 DOM 之间的映射关系，注意，组件的template模板必须有且仅有一个根标签，即在template中，所有的内容都要用一个标签包裹起来 初始数据（data）：这是一个组件的初始数据状态，对于可复用的组件来说，这通常是私有的状态， 接收的外部参数（props）：组件之间通过参数来进行数据的传递和共享，参数传递遵循单向数据流的规则（即只能从上至下传递） 方法（methods）：对组件中数据的改动操作一般都在组件的方法内进行，可以通过 v-on 指令将用户输入事件与组件方法进行绑定 生命周期钩子（lifecycle hooks）：一个组件会触发多个生命周期钩子函数，比如 created、attached、destroyed 等等，在这些钩子函数中，我们可以封装一些自己的逻辑，和传统的 MVC 相比，这也可以理解为 Controller 的逻辑被分化到了这些钩子函数中 组件的使用 这里大致地将组件分为：全局组件、局部组件、嵌套组件、单文件组件 全局组件 认识全局组件：全局组件即为所有 Vue 实例都可以使用的组件 全局组件的注册与使用： 注册：要注册一个全局组件，你可以使用 Vue.component(tagName, options) 1234Vue.component(&#x27;my-component&#x27;, &#123; template: &#x27;&lt;div&gt;Hello Vue&lt;/div&gt;&#x27; //其他选项...&#125;) //注意:组件名不要有大写字母，多个单词使用中划线 &#x27;-&#x27;隔开 使用：组件注册之后，便可以在 父实例 的模块中以自定义元素的形式来使用，注意，要确保在初始化根实例之前注册了组件 123&lt;div id=&#x27;example&#x27;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt; 完整代码示例： 123456789101112&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; Vue.component(&#x27;my-component&#x27;, &#123; //在根实例之前注册 template: &#x27;&lt;div&gt;A custom component!&lt;/div&gt;&#x27; &#125;) // 创建根实例 new Vue(&#123; el: &#x27;#example&#x27; &#125;)&lt;/script&gt; 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 应用场景：若该组件的功能需在任何被Vue实例挂载的标签中引用，则建议用全局组件 局部组件 认识局部组件：局部组件的优点是相对于全局组件而言的，例如，当你使用 webpack 这样的构件系统时，如果注册的是全局组件，就意味着不管你是否使用，此组件都会存在于你构件的系统中，造成无谓的 js加载，而局部组件只需要在你的根实例里面去调用这个定义的组件即可。 局部组件的注册与使用： 注册： 1234var Child = &#123; template: &quot;&lt;div&gt;A custom component!&lt;/div&gt;&quot; // 其他选项...&#125; 使用： 1234567new Vue(&#123; //... components: &#123; &#x27;my-component&#x27;: Child // &lt;my-component&gt; 将只在父模板可用 &#125;&#125;) 完整代码示例： 123456789101112131415&lt;div id=&quot;example&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var Child = &#123; //在根实例之前注册 template: &quot;&lt;div&gt;A custom component!&lt;/div&gt;&quot; &#125; // 创建根实例 new Vue(&#123; el: &quot;#example&quot;, components: &#123; &#x27;my-component&#x27;: Child &#125; &#125;)&lt;/script&gt; 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;div&gt;A custom component!&lt;/div&gt;&lt;/div&gt; 嵌套组件 认识嵌套组件：如下图所示，组件之间是可以相互嵌套的 父组件中嵌套子组件的方法： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;container&quot;&gt; &lt;h3&gt;我爱吃什么水果有这些：&lt;/h3&gt; &lt;ol&gt; &lt;todolist&gt;&lt;/todolist&gt; &lt;!-- 引用 --&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; //定义子组件 var child = Vue.component(&#123; template: &quot;&lt;div&gt;嵌套的子组件&lt;/div&gt;&quot;, &#125;); //定义父组件 var todolist = Vue.component(&#123; template:&#x27;&lt;div&gt;&lt;li v-for=&quot;item in datas&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt;&lt;child&gt;&lt;/child&gt;&lt;/div&gt;&#x27;, data()&#123; //组件中的数据必须是函数，而不是对象！ return&#123; datas: [ &#123; id: 0, text: &#x27;苹果&#x27; &#125;, &#123; id: 1, text: &#x27;香蕉&#x27; &#125;, &#123; id: 2, text: &#x27;雪梨&#x27; &#125;, ] &#125; &#125;, components: &#123; &#x27;child&#x27;: child, &#125; &#125;); //定义一个Vue实例 var app = new Vue(&#123; el: &#x27;#container&#x27;, data: &#123;&#125;, components: &#123; //注册(当然也可以用&quot;Vue.component(&#x27;todolist&#x27;,todolist);&quot;全局注册) &#x27;todolist&#x27;: todolist, &#125; &#125;)&lt;/script&gt; 注意：在使用子组件之前必须先定义子组件，否则会报错 为什么这里的 data 的值是一个函数呢，因为我们这里定义的组件很有可能被复用，如果像普通的一个Vue实例，那么改动一个地方，就会引起整个组件的改变，但是我们每次复用组建的情况都可能不同，所以用一个 function 来返回对象，换句话说，组件的 data 是私有的，该 data 中的数据只能在对应的组件模板中使用 webpack 打包单文件组件 注：这里不阐述 webpack 的安装之类的，若需要请阅读：webpack 笔记 了解单文件组件：官网 &gt;&gt;&gt; https://cn.vuejs.org/v2/guide/single-file-components.html 创建一个目录 test，并进入，新建几个目录与文件，最后整个 demo 目录如下： 1234567|-test # 根目录 |-index.html # 主html文件 |-dist # 打包文件放置目录 |-src # 资源文件目录 |-main.js # 打包入口文件 |-components # 单文件组件目录 |-app.vue # 单文件组件 运行以下命令初始化 package.json： 1npm init -y 安装项目依赖：想要编译其他的文件比如 react，coffce 等，就必须要加载很多对应的 loader，而 .vue 文件也是同样的道理。 这里我就不一一列出来需要加载哪些包了，因为最后的安装包都会在 package.json 中显示，所以我直接展示 package.json 文件，如下： 123456789101112131415161718192021222324252627282930313233343536&#123; &quot;name&quot;: &quot;test&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;dev&quot;: &quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^2.5.17&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;babel-core&quot;: &quot;^6.26.3&quot;, &quot;babel-loader&quot;: &quot;^7.1.5&quot;, &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;, &quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;, &quot;babel-preset-stage-3&quot;: &quot;^6.24.1&quot;, &quot;cross-env&quot;: &quot;^5.2.0&quot;, &quot;css-loader&quot;: &quot;^1.0.0&quot;, &quot;file-loader&quot;: &quot;^1.1.11&quot;, &quot;node-sass&quot;: &quot;^4.9.2&quot;, &quot;sass-loader&quot;: &quot;^7.1.0&quot;, &quot;style-loader&quot;: &quot;^0.21.0&quot;, &quot;url-loader&quot;: &quot;^1.0.1&quot;, &quot;vue-loader&quot;: &quot;^14.2.3&quot;, &quot;vue-style-loader&quot;: &quot;^4.1.1&quot;, &quot;vue-template-compiler&quot;: &quot;^2.5.17&quot;, &quot;webpack&quot;: &quot;^4.16.4&quot;, &quot;webpack-cli&quot;: &quot;^3.1.0&quot;, &quot;webpack-dev-server&quot;: &quot;^3.1.5&quot; &#125;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;&#125; 按照这份 package.json 文件直接输入 npm install 即可 配置 webpack：依赖项我们已经全部安装好了，那么下一步就是在根目录下新建 webpack.config.js 来进行配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//webpack.config.jsconst path = require(&#x27;path&#x27;); //node中的path对象，用于处理目录的对象const webpack = require(&#x27;webpack&#x27;);module.exports = &#123; entry: &#x27;./src/main&#x27;, //入口文件地址 output: &#123; //输出 path: path.join(__dirname, &#x27;./dist&#x27;), //打包输出文件的地址，使用绝对路径 filename: &#x27;bundle.js&#x27;, //webpack打包后的文件名 publicPath: &#x27;/dist/&#x27;, //公共文件生成的地址 &#125;, mode: &#x27;development&#x27;, module: &#123; rules: [ //加载器loader &#123; //编译css test: /\\.css$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;] &#125;, &#123; //编译scss test: /\\.scss$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27;] &#125;, &#123; //编译sass test: /\\.sass$/, use: [&#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader?indentedSyntax&#x27;] &#125;, &#123; //编译.vue文件 test: /\\.vue$/, loader: &#x27;vue-loader&#x27;, options: &#123; loaders: &#123; &#x27;scss&#x27;: [ &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader&#x27; ], &#x27;sass&#x27;: [ &#x27;vue-style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;sass-loader?indentedSyntax&#x27; ] &#125; &#125; &#125;, &#123; //转换es6语法 test: /\\.js$/, loader: &#x27;babel-loader&#x27;, exclude: /node_modules/, options: &#123; presets: [[&#x27;env&#x27;, &#123;modules: false&#125;], &#x27;stage-0&#x27;] &#125; &#125;, &#123; //图片转化 test: /\\.(png|jpg|gif|svg)$/, loader: &#x27;url-loader&#x27;, options: &#123; name: &#x27;[name].[ext]?[hash]&#x27; &#125; &#125; ] &#125;, resolve: &#123; //别名，可以直接使用别名来代表设定的路径以及其他 alias: &#123; vue$: &#x27;vue/dist/vue.esm.js&#x27;, filter: path.join(__dirname, &#x27;./src/filters&#x27;), components: path.join(__dirname, &#x27;./src/components&#x27;) &#125;, //require时省略的扩展名，如require(&#x27;module&#x27;)不需要写成require(&#x27;module.js&#x27;) extensions: [&#x27;*&#x27;, &#x27;.js&#x27;, &#x27;.vue&#x27;, &#x27;.json&#x27;], &#125;, devServer: &#123; //服务器配置相关，以实现自动刷新 historyApiFallback: true, noInfo: true, overlay: true &#125;, performance: &#123; hints: false &#125;, //开启source-map，webpack有多种source-map，在官网文档中可以查到 devtool: &#x27;#eval-source-map&#x27;&#125; 我们已经配置好了所有，现在开始编写主 html 文件： 123456789101112131415161718&lt;!-- index.html --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #app &#123; font-size: 30px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;app&#x27;&gt;&lt;/div&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写入口文件 /src/main.js： 1234567891011//src/main.jsimport Vue from &#x27;vue&#x27;; //RS6语法import App from &#x27;./components/app&#x27;; //引入vue文件Vue.config.debug = true; //开启错误提示new Vue(&#123; el: &#x27;#app&#x27;, render: h =&gt; h(App)&#125;) 编写组件文件 /src/components/app.vue： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;!-- &#x2F;src&#x2F;components&#x2F;app.vue --&gt; &lt;div id&#x3D;&#39;app&#39;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;&#x2F;div&gt; &lt;&#x2F;template&gt;&lt;script&gt;export default &#123; name: &#39;#app&#39;, data() &#123; return &#123; message: &#39;Hello Vue&#39; &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&#39;scss&#39;&gt; $example: red; body &#123; p &#123; color: $example; &#125; &#125;&lt;&#x2F;style&gt; 最后在根目录下执行 1npm run dev 可以查看到的结果如下： 由于我们配置了热更新，所以在改代码时页面会同步变化 本篇主要目的是入门如何使用组件，而关于组件通信，以及单文件组件的更多的配置会在之后说明","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（五）：Class与Style绑定","slug":"Vue教程（五）：Class与Style绑定","date":"2021-03-20T04:07:57.000Z","updated":"2021-03-20T04:08:14.913Z","comments":true,"path":"e7c6b30a13d6/","link":"","permalink":"https://ozzienicholas.gitee.io/e7c6b30a13d6/","excerpt":"","text":"绑定元素的 class 列表以及它的内联样式常常通过数据绑定来实现，因为它们都是属性，所以我们可以用 v-bind 来实现，用 v-bind 来绑定 class 与 style 时，表达式的类型可以是：字符串、对象、数组 绑定 Class对象语法 我们可以传给 v-bind:class 一个对象，以动态地切换 class： 12345678910111213141516171819202122232425262728&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;style&gt; .active &#123; color: red; &#125; &lt;&#x2F;style&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;&#123; active: isActive &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt; &lt;button @click&#x3D;&quot;changeClass&quot;&gt;是否绑定active&lt;&#x2F;button&gt; &lt;&#x2F;div&gt; &lt;script&gt; var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; isActive: true &#125;, methods: &#123; changeClass: function() &#123; this.isActive &#x3D; (this.isActive &#x3D;&#x3D; true ? false : true) &#125; &#125; &#125;) &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 是否绑定 active 这个 class，取决于 isActive 的值是否为真 我们也可以传入多个属性来动态地切换 class： 12345678910&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;&#123; classOne: isClassOne, classTwo: isClassTwo &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; isClassOne: true, isClassTwo: true &#125;&#125;) 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p class=&quot;classOne classTwo&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 你也可以直接绑定一个对象： 123456789101112&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;classObj&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; classObj: &#123; A: true, B: true, &#125; &#125;&#125;) 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p class=&quot;A B&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 使用计算属性：可以通过计算属性返回的对象来确定需要绑定的 class，这是一个常用且强大的模式，例如： 123456789101112131415161718&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;classObj&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; A: true, B: true, &#125;, computed: &#123; classObj: function() &#123; &#x2F;&#x2F;这将决定绑定的class return &#123; classA: this.A &amp;&amp; !this.B, classB: this.A &amp;&amp; this.B &#125; &#125; &#125;&#125;) 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p :class=&quot;classB&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 数组语法 我们将一个数组传给 v-bind:class，以应用一个 class 列表： 123456789101112&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;[ classA, classB ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; classA: &quot;A&quot;, classB: &quot;B&quot; &#125;&#125;)&lt;&#x2F;script&gt; 渲染结果为： 123&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;A B&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 数组中仍然可以使用三元表达式，这可以切换列表中的 class： 12345678910111213&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;[ classA?classB:classA, classC ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; classA: &quot;A&quot;, classB: &quot;B&quot;, classC: &quot;C&quot; &#125;&#125;)&lt;&#x2F;script&gt; 数组中的三元表达式确定了绑定 classA 还是 classB，但是 classC 是肯定会绑定的 渲染结果为： 123&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;B C&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 当有多个条件 class 需要处理时，写三元表达式有些繁琐，可以在数组中嵌套对象语法： 12345678910111213&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;[ &#123;A:isClassA, B:isClassB&#125;, classC ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; isClassA: &quot;A&quot;, isClassB: &quot;B&quot;, classC: &quot;C&quot; &#125;&#125;)&lt;&#x2F;script&gt; 渲染结果为： 123&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :class&#x3D;&quot;A B C&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 绑定组件上的 class 提示：若未了解过组件，请阅读第七节 当你在自定义的组件上绑定 class 时，那些添加的 class 值会添加到组件根元素上，而根元素上已存在的 class 值也不会被覆盖，例如： 1234567891011&lt;div id&#x3D;&quot;example&quot;&gt; &lt;my-component class&#x3D;&quot;classB&quot;&gt;&lt;&#x2F;my-component&gt;&lt;&#x2F;div&gt;&lt;script&gt;Vue.component(&quot;my-component&quot;, &#123; template: &quot;&lt;p class&#x3D;&#39;classA&#39;&gt;Hello Vue&lt;&#x2F;p&gt;&quot;&#125;)var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;,&#125;)&lt;&#x2F;script&gt; 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p class=&quot;classA classB&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 我们同样可以用之前学到的对象语法来绑定 class： 1234567891011121314151617&lt;div id&#x3D;&quot;example&quot;&gt; &lt;my-component class&#x3D;&quot;classC&quot;&gt;&lt;&#x2F;my-component&gt;&lt;&#x2F;div&gt;&lt;script&gt;Vue.component(&quot;my-component&quot;, &#123; template: &quot;&lt;p :class&#x3D;&#39;&#123; classA:isClassA, classB:isClassB &#125;&#39;&gt;Hello Vue&lt;&#x2F;p&gt;&quot;, data: function() &#123; return &#123; isClassA: true, isClassB: true &#125; &#125;&#125;)var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;,&#125;)&lt;&#x2F;script&gt; 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p class=&quot;classA classB classC&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 这种用法仅适用于自定义组件的最外层是一个根元素，否则会无效，当不满足这种条件或需要给具体的子元素设置类名时，应当使用组件的 props 来传递。这些用法也适用于绑定内联样式 style 绑定 Style 在用 v-bind 绑定时，用法其实和绑定 class 大致相同注意 css 的属性命名，可以用驼峰式（camelCase）或短横线分隔（kebab-case，记得用引号括起来） 对象语法用对象绑定 style，例如： 123456789101112&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :style&#x3D;&quot;&#123; color:activeColor, fontSize:fontSize+&#39;px&#39; &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; activeColor: &quot;red&quot;, fontSize: 50 &#125;&#125;)&lt;&#x2F;script&gt; 渲染结果为： 123&lt;div id=&quot;example&quot;&gt; &lt;p style=&quot;color: red; font-size: 50px;&quot;&gt;Hello Vue&lt;/p&gt;&lt;/div&gt; 当然，这同样可以结合计算属性使用，这里就不举例了…… 数组语法用数组语法也可以将多个样式对象应用到同一个元素上，例如： 123456789101112131415161718&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p :style&#x3D;&quot;[styleA, styleB]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; styleA: &#123; color: &quot;red&quot;, fontSize: &quot;50px&quot; &#125;, styleB: &#123; fontWeight: 200, fontFamily: &quot;cursive&quot; &#125; &#125;&#125;)&lt;&#x2F;script&gt; 渲染结果就是： 123&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p style&#x3D;&quot;color: red; font-size: 50px;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 自动加前缀当 v-bind:style 使用需要添加 浏览器引擎前缀 的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀 本节主要介绍了如何绑定 class 与 style，加油！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（四）：过滤器、计算属性与侦听器","slug":"Vue教程（四）：过滤器、计算属性与侦听器","date":"2021-03-20T04:07:19.000Z","updated":"2021-03-20T04:07:33.849Z","comments":true,"path":"ffb8c7466790/","link":"","permalink":"https://ozzienicholas.gitee.io/ffb8c7466790/","excerpt":"","text":"过滤器 Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。 过滤器可以用在两个地方：双花括号插值 和 v-bind 表达式 过滤器应该被添加在 JavaScript 表达式的尾部，由 “管道” 符号指示： 123456&lt;!-- 在双花括号中 --&gt;&lt;!-- &#123;&#123;&#125;&#125;中的 &quot;|&quot; 表示过滤器管道符，过滤器后面的为过滤函数 --&gt;&lt;span&gt;&#123;&#123; 数据 | 过滤器&#125;&#125;&lt;/span&gt;&lt;!-- 在 v-bind 表达式中 --&gt;&lt;div v-bind:id=&quot;数据 | 过滤器&quot;&gt;&lt;/div&gt; 过滤器支持全局定义和组件中定义： 可以在一个组件的选项中定义本地的过滤器： 123456789filters: &#123; test: function(value) &#123; if(!value) &#123; return &#x27;&#x27; &#125; value = value.toString(); return value.charAt(0).toUpperCase() + value.slice(1) &#125;&#125; 也可以在创建 Vue 实例之前全局定义过滤器： 12345678910Vue.filter(&#x27;test&#x27;, function(value) &#123; if(!value) &#123; return &#x27;&#x27; &#125; value = value.toString(); return value.charAt(0).toUpperCase() + value.slice(1)&#125;)new Vue(&#123; // ...&#125;) 当全局过滤器和局部过滤器重名时，会采用局部过滤器。 过滤器函数接收表达式的值作为第一个参数，在上述例子中，过滤器函数 test 将会收到 message 的值作为第一个参数。 过滤器可以串联： 1&#123;&#123; message | filterA | filterB &#125;&#125; filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。 然后将 filterA 的结果传递到 filterB 中，继续调用同样被定义为接收单个参数的过滤器函数 filterB。 过滤器是 JS 函数，因此可以接收参数： 1&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125; 案例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;div id=&quot;app&quot;&gt; &lt;!-- &#123;&#123;&#125;&#125;中的|表示过滤器管道符,过滤器后面的为过滤函数 --&gt; &lt;p&gt;&#123;&#123;msg | msgFormat(&#x27;疯狂+1&#x27;)&#125;&#125;&lt;/p&gt; &lt;!-- 多个过滤函数进行调用 --&gt; &lt;p&gt;&#123;&#123;msg | msgFormat(&#x27;疯狂+1&#x27;) | test&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;time | dateFormat&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; /*过滤器的定义语法： Vue.filter(&#x27;过滤器的名称&#x27;,function () &#123; &#125;) 过滤器中的function,第一个参数data，已经被规定死，永远都是过滤器管道符前面传递过来的数据 从第二个参数开始就是传值 例如：Vue.filter(&#x27;过滤器名称&#x27;,function(data)&#123; return data+123 &#125;);*/ // 定义一个叫做 msgFormat 的 Vue 全局过滤器 Vue.filter(&#x27;msgFormat&#x27;, function(msg, param) &#123; //字符出中的replace方法，第一个参数，出了写一个字符串之外，还可以定义一个正则 return msg.replace(/单纯/g, param) &#125;) Vue.filter(&#x27;test&#x27;, function(msg) &#123; return msg + &#x27;love&#x27; &#125;) //如何定义一个私有过滤器（局部） var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &#x27;Hello World&#x27;, time: new Date(), &#125;, //定义私有过滤器，过滤器有两个条件：&quot;过滤器名称&quot; 和 &quot;处理函数&quot; filters: &#123; /* 过滤器调用的时候，采用的是就近原则， 如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器 */ //param = &#x27;&#x27;;es6的初始化值 dateFormat: function(time, param = &#x27;&#x27;) &#123; var dt = new Date(time); // yyyy-mm-dd var y = dt.getFullYear(); // var m = dt.getMonth()+1; var m = (dt.getMonth() + 1).toString().padStart(2, &#x27;0&#x27;); var d = dt.getDate(); // return y+&#x27;-&#x27;+m+&#x27;-&#x27;+d; //模板字符串 // return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; if (param.toLowerCase() === &#x27;yyyy-mm-dd&#x27;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; var hh = dt.getHours(); var mm = (dt.getMinutes()).toString().padStart(2, &#x27;0&#x27;); var ss = dt.getSeconds(); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;, &#125;)&lt;/script&gt; 概述计算属性和侦听器computed 和 watch 大概是 Vue 里除了 data、methods、props 之外，用的最多的选项了。Vue 中数据变更之所以能更新到页面里，因为对 data 执行 getter/setter 转化，然后进行侦听，而 computed 和 watch 属性都是基于此，我们看看一个 Watcher 是怎样的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950export default class Watcher &#123; vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: SimpleSet; newDepIds: SimpleSet; before: ?Function; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: ?Object, isRenderWatcher?: boolean ) &#123; // 初始化 &#125; // 计算getter，重新收集依赖 get () &#123; //... &#125; // 添加依赖 addDep (dep: Dep) &#123; //... &#125; // 清理依赖集合 cleanupDeps () &#123; //... &#125; // 订阅接口，将在依赖项更新时调用 update () &#123; //... &#125; // 调用接口，将被调配者调用 run () &#123; //... &#125; // 该watcher的所有依赖 depend () &#123; //... &#125; // 从所有依赖项的订户列表中删除自己 teardown () &#123; //... &#125;&#125; 计算属性和侦听器都离不开数据监听。 计算属性 之前我们提到过，模板是可以使用 JS 表达式的，通常使用 JS 表达式、过滤器就可以处理数据，但如果表达式过于复杂，在模板中放入过多的逻辑会导致模板过重且难以维护，此时可以使用计算属性。 初识计算属性 例如下面这段代码，模板就显得很笨重： 123&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;&lt;&#x2F;div&gt; 此时，我们引入了一个叫做 computed 的选项，专门用于处理这些复杂的逻辑： 123456789101112131415161718&lt;div id&#x3D;&quot;example&quot;&gt; &lt;p&gt;正常顺序的字符串：&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt; &lt;p&gt;翻转之后的字符串：&#123;&#123;reverseMessage&#125;&#125;&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; message: &quot;Hello Vue&quot; &#125;, computed: &#123; reverseMessage: function() &#123; &#x2F;&#x2F;this 指向的是 vm 实例 return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125; &#125;&#125;)&lt;&#x2F;script&gt; 渲染结果为： 计算属性支持读取设置： 1234567891011121314151617181920let vm = new Vue(&#123; data: &#123; a: 1 &#125; computed: &#123; // 仅读取 read: function() &#123; return this.a * 2 &#125; // 读取和设置 change: &#123; get: function() &#123; return this.a + 1 &#125; set: function(value) &#123; this.a = value - 1 &#125; &#125; &#125;&#125;) getter 与 setter 我们再看一个例子： 123456789101112131415161718&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; fullName &#125;&#125;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; firstName: &quot;Ozzie&quot;, lastName: &quot;Nicholas&quot; &#125;, computed: &#123; fullName: function() &#123; &#x2F;&#x2F;this 指向的是 vm 实例 return this.firstName + &#39; &#39; + this.lastName &#125; &#125;&#125;)&lt;&#x2F;script&gt; 页面中显示：”Ozzie Nicholas”，这说明我们结果是正确的 现在的逻辑是：我们在 data 中定义了 firstName 和 lastName，通过计算属性计算出 fullName 的值，打开控制台，我们可以明显地看到各个值 我们尝试着在控制台改变 fullName 的值，会报错如下，而且，页面上仍然显示的是 “Ozzie Nicholas” 而非 “change value” 上面的尝试失败，是因为我们没有设置 set 计算属性由两部分组成：get 和 set，默认只有 get，比如上个案例中，函数 reverseMessage 就是计算属性的 get 部分，若要设置 set，则需要我们自己手动添加，例如： 12345678910111213141516171819202122232425262728&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; fullName &#125;&#125;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; firstName: &quot;Ozzie&quot;, lastName: &quot;Nicholas&quot; &#125;, computed: &#123; fullName: &#123; &#x2F;&#x2F;getter get: function() &#123; console.log(&quot;计算了一次&quot;); &#x2F;&#x2F;调用了一次 getter return this.firstName + &quot; &quot; + this.lastName &#125;, &#x2F;&#x2F;setter set: function(value) &#123; &#x2F;&#x2F;注意这里不能直接使用 this const arr &#x3D; value.split(&quot; &quot;) this.firstname &#x3D; arr[0] &#x2F;&#x2F;对它的依赖进行赋值 this.lastName &#x3D; arr[1] &#x2F;&#x2F;对它的依赖进行赋值 &#125; &#125; &#125;&#125;)&lt;&#x2F;script&gt; 我们再次尝试修改，页面如愿地变化了，而且控制台还打印了，这说明了过程大致是：先在 set 中改变 firstName 与 lastName，再调用 getter 将值返回给 fullName 注意，set 设置属性，并不是直接修改计算属性，而是修改它的依赖（fullName 依赖于 firstName 以及 lastName），当依赖发生了变化，computed 就会重新计算，所以 fullName 也会更新 Vue 里数据的变更检测是来自于 getter/setter，从而让 data 的属性能够响应数据变化。Vue 将遍历 data 选项的 JavaScript 对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter： 1234567891011121314151617181920212223242526272829303132333435363738394041// 响应式的变更检测Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, // getter get: function reactiveGetter() &#123; const value = getter ? getter.call(obj) : val; if (Dep.target) &#123; // 依赖检测 dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value; &#125;, // setter，最终更新后会通知 set: function reactiveSetter(newVal) &#123; const value = getter ? getter.call(obj) : val; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return; &#125; if (process.env.NODE_ENV !== &quot;production&quot; &amp;&amp; customSetter) &#123; customSetter(); &#125; if (getter &amp;&amp; !setter) &#123; return; &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); // 会通知 dep.notify(); &#125;&#125;); Vue 会在初始化实例时对属性执行 getter/setter 转化，所以，只有当实例被创建时就已经存在于 data 中的属性才是响应式的，而新增的属性等都不会触发视图的更新，那么，Vue 无法检测到对象属性的添加或删除，也无法检测一些特殊的数组变动： 12345678910111213141516171819202122232425262728293031323334// 只有这些操作会通知变更const methodsToPatch = [ &quot;push&quot;, &quot;pop&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;reverse&quot;];// 拦截上述这些操作方法，然后通知变更methodsToPatch.forEach(function(method) &#123; // cache original method const original = arrayProto[method]; def(arrayMethods, method, function mutator(...args) &#123; const result = original.apply(this, args); const ob = this.__ob__; let inserted; switch (method) &#123; case &quot;push&quot;: case &quot;unshift&quot;: inserted = args; break; case &quot;splice&quot;: inserted = args.slice(2); break; &#125; if (inserted) ob.observeArray(inserted); // notify change ob.dep.notify(); return result; &#125;);&#125;); 所以在更新 data 中绑定的对象或者数组的时候需要注意：除了使用可触发变更检测的特殊方法之外，也可以使用 vm.$set(Vue.set) 实例方法，该方法用于向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新： 12345// 更新数组vm.$set(vm.items, indexOfItem, newValue);// 更新对象vm.$set(vm.someObject, keyOfObject, newValue); 计算属性 VS 方法 我们用 “方法” 也同样可以实现： 1234567891011121314151617181920&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; fullName() &#125;&#125; &#123;&#123; age &#125;&#125;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; firstName: &quot;Ozzie&quot;, lastName: &quot;Nicholas&quot;, age: 20 &#125;, methods: &#123; fullName: function() &#123; console.log(&quot;调用了一次&quot;); return this.firstName + &quot; &quot; + this.lastName &#125; &#125;&#125;)&lt;&#x2F;script&gt; 结果如下： 可以看到，只要页面重新渲染，就会调用方法 而用计算属性的结果如下：（代码略） 也就是说，只要不修改依赖项，计算属性就会使用之前缓存的值，这也就是 计算属性的缓存机制，如果没有缓存机制，那么我们会不可避免地多次执行计算属性的 getter 侦听器认识侦听器 除了计算属性，Vue 还提供了一种更通用的方法来观察和响应数据变动，即侦听属性 watch，侦听属性可以执行任何逻辑，比如函数节流，Ajax 异步获取数据，甚至操作 DOM（不推荐），当需要在数据变化时执行异步操作或者开销大的操作时，使用侦听器往往最有效 我们简单地使用一下侦听器： 123456789101112131415161718192021222324&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; fullName &#125;&#125; &#123;&#123; age &#125;&#125;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; firstName: &quot;Ozzie&quot;, lastName: &quot;Nicholas&quot;, fullname: &quot;Ozzie Nicholas&quot;, &#x2F;&#x2F;不可避免地做这个冗余的初始化 &#125;, watch: &#123; firstName: function() &#123; &#x2F;&#x2F;firstName 改变时，需要重新渲染 fullName console.log(&quot;侦听了一次&quot;); this.fullname &#x3D; this.firstName + &#39; &#39; + this.lastName &#125; lastName: function() &#123; &#x2F;&#x2F;lastName 改变时，需要重新渲染 fullName console.log(&quot;侦听了一次&quot;); this.fullname &#x3D; this.firstName + &#39; &#39; + this.lastName &#125; &#125;&#125;)&lt;&#x2F;script&gt; 与计算属性相同，侦听器也有缓存机制，比如我们改变 age 并不会引起 watch 的重新计算 当依赖项改变时，侦听器会重新执行 侦听器是可以执行异步任务的，例如下面这个例子，效果是用户停止输入 1 秒之后才会更新视图： 12345678910111213141516171819202122232425262728293031&lt;div id&#x3D;&quot;example&quot;&gt; &#123;&#123; fullName &#125;&#125; &lt;div&gt; firstName: &lt;input v-model&#x3D;&quot;firstName&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;div&gt; lastName: &lt;input v-model&#x3D;&quot;lastName&quot; &#x2F;&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script&gt;var vm &#x3D; new Vue(&#123; el: &quot;#example&quot;, data: &#123; firstName: &quot;Ozzie&quot;, lastName: &quot;Nicholas&quot;, fullName: &quot;Ozzie Nicholas&quot; &#125;, watch: &#123; firstName: function(val) &#123; setTimeout(() &#x3D;&gt; &#123; this.fullName &#x3D; val + &quot; &quot; + this.lastName &#125;, 1000) &#125;, lastName: function(val) &#123; setTimeout(() &#x3D;&gt; &#123; this.fullName &#x3D; this.firstName + &quot; &quot; + val &#125;, 1000) &#125; &#125;&#125;)&lt;&#x2F;script&gt; Vue 实例将会在实例化时调用 $watch()，遍历 watch 对象的每一个属性。watch支持的方式有好几种，回调函数得到的参数为新值和旧值： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var vm = new Vue(&#123; data: &#123; a: 1, b: 2, c: 3, d: 4, e: &#123; f: &#123; g: 5 &#125; &#125; &#125;, watch: &#123; a: function(val, oldVal) &#123; console.log(&quot;new: %s, old: %s&quot;, val, oldVal); &#125;, // 方法名 b: &quot;someMethod&quot;, // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深 c: &#123; handler: function(val, oldVal) &#123; /* ... */ &#125;, deep: true &#125;, // 该回调将会在侦听开始之后被立即调用 d: &#123; handler: &quot;someMethod&quot;, immediate: true &#125;, e: [ &quot;handle1&quot;, function handle2(val, oldVal) &#123; /* ... */ &#125;, &#123; handler: function handle3(val, oldVal) &#123; /* ... */ &#125; /* ... */ &#125; ], // watch vm.e.f&#x27;s value: &#123;g: 5&#125; &quot;e.f&quot;: function(val, oldVal) &#123; /* ... */ &#125; &#125;, methods: &#123; someMethod() &#123;&#125; &#125;&#125;);vm.a = 2; // =&gt; new: 2, old: 1 计算属性 VS 侦听器 watch：监测的是属性值，只要属性值变化，就会触发执行回调函数 computed：监测的是依赖值，依赖值不变的情况下会直接读取缓存，否则会重新计算然后重新渲染 注意：计算属性是不能执行异步任务的，计算属性必须同步执行，计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性，watch 也可以检测 computed 属性， 计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑 computed 能做的，watch 都能做，反之则不行 能用 computed 尽量用 computed","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（三）：实例与模板语法","slug":"Vue教程（三）：实例与模板语法","date":"2021-03-20T04:06:42.000Z","updated":"2021-03-20T04:07:00.698Z","comments":true,"path":"f7fd555ae7a3/","link":"","permalink":"https://ozzienicholas.gitee.io/f7fd555ae7a3/","excerpt":"","text":"Vue 实例构造器 每个 Vue 应用都是通过用 Vue 函数创建一个新的 Vue 实例开始的： 123var vm = new Vue(&#123; //选项&#125;) 当创建一个实例时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项，全部的选项可以在 API 文档 中查看 一个 Vue 应用由一个 new Vue 创建的 根 vue 实例，以及众多组件组成 属性与方法 每个 Vue 实例都会代理其 data 对象里所有的属性，例如： 123456789101112var test = &#123;a: 1&#125;;var vm = new Vue(&#123; data: test&#125;)vm.a === test.a //true//设置属性也会影响到原始数据vm.a = 2;test.a //2//反之亦然test.a = 3;vm.a //3 注意，只有这些被代理的属性才是响应的，若在实例创建之后再添加新的属性到实例上，那么这个新属性不会引起视图更新 除了 data 之外，Vue 暴露了一些有用的实例属性与方法，这些属性与方法都有前缀 $，以便与代理的 data 属性区分，例如： 12345678910111213var test = &#123;a: 1&#125;;var vm = new Vue(&#123; el: &quot;#app&quot;, data: test&#125;)vm.$data === test //truevm.$el === document.getElementById(&quot;app&quot;) //true//$watch 是一个实例方法vm.$watch(&#x27;a&#x27;, function(newVal, oldVal) &#123; //这个回调将在 vm.a 改变后调用&#125;) 注意，不要在实例属性或者回调函数中（比如 vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())）使用箭头函数，因为箭头函数绑定上下文，所以 this 没有指向的是 Vue 实例，而是指向未定义的 this.method 实例基本选项 Vue 实例提供了非常丰富的选项（new Vue()时传入的选项），除了生命周期外，最常见的如下： 选项名 说明 类型 el 通过 CSS 选择器或者 HTMLElement 实例的方式，提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标 string / Element template 字符串模板，将会替换挂载的元素 string render 字符串模板的代替方案，该渲染函数接收一个 createElement 方法，作为第一个参数用来创建 VNode (createElement: () =&gt; VNode) =&gt; VNode data Vue 实例的数据对象，用于数据绑定 Object / Function（组件只支持 Function） props 用于接收来自父组件的数据 Array(string) / Object methods Vue 实例的事件，可用于事件绑定 [key: string]: Function computed 计算属性，用于简化模板的复杂数据计算 [key: string]: Function或者{ get: Function, set: Function } watch 观察 Vue 实例变化的表达式或计算属性函数 [key: string] : string或者 Function或者 Object或者 Array directives 自定义指令 Object filters 过滤器 Object components 组件 Object 以上的实例选项，大多可以作为全局实例属性来获取或者访问： 1234567891011121314151617let vm = new Vue(&#123; // ... 选项&#125;)vm.$el; // 获取挂载元素vm.$data; // 获取 datavm.$props; // 获取 propsvm.$refs; // 获取注册过 ref 特性的所有 dom 元素和组件实例vm.$watch; // 观察 vue 实例变量的表达式或者计算属性函数vm.$options; // 获取 vue 实例的初识选项vm.$root; // 获取根实例vm.$parent; // 获取父实例vm.children; // 获取当前实例的直接子组件vm.$set; // 向响应式对象中添加一个响应式的新属性，且触发视图更新vm.$delete; // 删除对象的属性，如果对象是响应式的，删除能触发视图更新 与 DOM 相关的选项： el：在 Vue 实例中，el 选项提供一个页面中已存在的 DOM 元素作为实例的挂载目标。挂载的意思是，在选中的该元素所在的位置进行页面渲染，该元素会被替换成需要渲染的页面内容。我们可以传入一个 CSS 选择器，也可以传入一个 DOM 元素，以下方式都是可以的： 12345678910new Vue(&#123; // 传入 Element 元素方式一 el: document.getElementById(&quot;app&quot;), // 传入 Element 元素方式二 el: document.getElementByTagName(&quot;div&quot;)[0], // 传入 CSS 选择器方式一 el: &quot;#app&quot;, // 传入 CSS 选择器方式二（最好选择唯一的元素，不推荐此方式） el: &quot;div&quot;&#125;) 所谓挂载元素，在实例挂载之后，元素可以用 vm.$el 访问。严谨地追溯到生命周期中，需要在mounted 之后才能获取到： 123456789101112new Vue(&#123; el: &quot;#app&quot;, template: &quot;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&quot;, data() &#123; return &#123; message: &quot;欢迎来到Vue的世界&quot; &#125;; &#125;, mounted() &#123; console.log(this.$el); &#125;&#125;); 如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译，也就是这样： 123456789101112131415let vm = new Vue(&#123; // 注意这里没有 el 选项 template: &quot;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&quot;, data() &#123; return &#123; message: &quot;欢迎来到Vue的世界&quot; &#125;; &#125;, mounted() &#123; console.log(this.$el); &#125;&#125;);// 需要的时候使用vm.$mount(&quot;#app&quot;); 如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 编译器（Compiler） + 运行时（Runtime） 构建的 Vue 库。关于这个库，理解下面这些： 编译器（Compiler）: 我们可以理解为用来将模板字符串编译成为 JavaScript 渲染函数的代码，也就是之前提到的 AST 解析部分。 运行时（Runtime）：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。 一般来说，我们在部署生产代码的时候，已经将需要的代码解析编译好，这个时候我们只需要运行时的 Vue 库。在特殊情况下，有需要运行时解析编译的情况，如在线平台编写代码的时候，我们需要引入编译器的 Vue 库，该部分占完整版（Runtime + Compiler）的 30%。上面说到，如果我们需要使用挂载 DOM 元素的 HTML 作为模板，则需要运行时编译，也就需要编译器了。 template：给 Vue 实例提供字符串模板，该模板将会替换挂载的元素，例如： 1234567891011121314151617181920&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; new Vue(&#123; el: &quot;#app&quot;, template: &quot;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&quot;, data() &#123; return &#123; message: &quot;欢迎来到Vue的世界&quot; &#125; &#125;, beforeMount() &#123; console.log(&quot;beforeMount:&quot;, this.$el) &#125;, mounted() &#123; console.log(&quot;mounted:&quot;, this.$el) &#125; &#125;) &lt;/script&gt;&lt;/body&gt; 这里挂载的元素指的是 &lt;div id=&quot;app&quot;&gt;&lt;/div&gt;，使用了 template 之后，该部分已经被替换成 template 中的 &lt;p&gt;&lt;/p&gt;，并将 message 中的内容替换成绑定的数据了： 查看控制台，在 beforeMount 中，vm.$el 获取的是挂载的元素模板，而在 mounted 后则变成了 template 中的真实 DOM 元素： render：字符串模板 template 的代替方案，该渲染函数接收一个 createElement 方法作为第一个参数用来创建 VNode（createElement 创建的便是虚拟 DOM，在 Vue 里称为 VNode），使用案例如下（实现一个 v-if）： 1234567891011121314151617181920212223242526new Vue(&#123; /*该段实现： &lt;p v-if=&#x27;condition&#x27;&gt;condition work!&lt;/p&gt; &lt;p v-else&gt;condition not work!&lt;/p&gt; */ render: function(createElement) &#123; if(this.condition) &#123; return createElement(&#x27;p&#x27;, &#x27;condition work!&#x27;); &#125; else &#123; return &#123; return createElement(&#x27;p&#x27;, &#x27;condition not work!&#x27;) &#125; &#125; &#125; /*该段实现： &lt;ul&gt; &lt;li v-for=&#x27;item in list&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/ul&gt; */ render: function(createElement) &#123; return createElement(&#x27;ul&#x27;, this.list.map(function(item) &#123; return createElement(&#x27;li&#x27;, item) &#125;)) &#125;&#125;) 一般来说，我们可以结合 JSX 来使用（需要添加 Babel 插件）： 1234567891011import MyComponent from &quot;./MyComponent.vue&quot;;new Vue(&#123; render: function(h) &#123; return ( &lt;MyComponent&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;/MyComponent&gt; ) &#125;&#125;) 实例生命周期 这里只是简单地引入生命周期，之后会详细探讨 每个 Vue 实例在被创建之前都要经过一系列的初始化过程，例如，实例需要配置数据观测、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM，这就给了我们自定义逻辑的机会，例如，created 这个钩子在实例被创建之后被调用，例如： 123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;, created: function() &#123; //this 指向 Vue 实例 console.log(&#x27;a is: &#x27; + this.a) &#125;&#125;) 当然，除了 created 之外，还有一些其他的钩子，这是在实例的生命周期调用的，钩子的 this 指向调用它的 Vue 实例。 注意，不要因为这些生命周期钩子就误以为 Vue 有 “控制器” 的概念，这是没有的，组件的自定义逻辑可以分布在这些钩子中。 模板语法认识模板语法 Vue.js 使用了基于 HTML 的模板语法，允许我们声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。 在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。 如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，直接写渲染（render）函数，使用可选的 JSX 语法。 插值 这里的很多用法在前一节的内置指令一节中已经详细说过，这里就当时复习吧！ 文本：最常见的数据绑定方式就是使用 “Mustache” 语法（双大括号）的文本插值： 1&lt;span&gt;Message: &#123;&#123;msg&#125;&#125;&lt;/span&gt; Mutache 标签会被替换成对应数据上的 msg 属性的值，只要绑定的数据对象上 msg 属性发生改变，插值处的内容都会更新 通过使用 v-once 指令，能实现一次性插值，当数据改变时，插值处的内容不会更新，但请注意这会影响到该节点上所有数据的绑定： 1&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt; 纯 HTML：双大括号会将数据解析成纯文本，而非 HTML，如要输出 HTML，需要使用 v-html： 1&lt;span v-html&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt; 这里的 msg 仍然是绑定在属性上的 被插入的内容都会被当做 HTML —— 数据绑定会被忽略 注意，不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎，组件更适合担任 UI 重用与复合的基本单元 另外，在网站上动态渲染 HTML 是一件很危险的事情，这容易导致 XSS 攻击，请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值 属性：Mutache 语法不能在 HTML 属性中使用，应使用 v-bind 指令，例如： 1&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt; 属性也是可以是布尔值，例如对下面这段来说，isButtonDisabled 的值如果是 null、undefined 或者是 false，那么这个 disabled 属性是不会被包含在 &lt;button&gt; 中的 1&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;&lt;&#x2F;button&gt; 使用 JS 表达式：对于所有的数据绑定，Vue 都提供了完整的 JS 表达式支持，例如： 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;&lt;div v-bind:id&#x3D;&quot;&#39;list: &#39; + id&quot;&gt;&lt;&#x2F;div&gt; 这些表达式会在所属 Vue 实例的数据作用域下作为 JS 被解析 注意，每个限制都只能包含 单个表达式，所以下面的例子都 不会生效： 1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a &#x3D; 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if(ok) &#123; return message &#125; &#125;&#125; 指令 指令（Directives）是带有 v- 前缀的特殊属性，指令属性的值预期是单一 JavaScript 表达式（v-for 是个例外，之后再讨论），指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM，比如： 1&lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你能看到我么？&lt;&#x2F;p&gt; 在这里，v-if 会根据 seen 的值的真假来插入或者移除 &lt;p&gt; 元素 参数：一些指令能够接收一个“参数”，在指令名称之后以冒号表示。 例如，v-bind 指令可以用于响应式地更新 HTML 属性，例如： 1&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt; 这里的 href 是参数，告知 v-bind 指令，将元素的 href 属性与 url 进行绑定 再比如 v-on 指令，它用于监听 DOM 事件： 1&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt; 在这里，参数是监听名 动态参数：从 Vue 2.6.0 开始，可以用方括号括起来的 JS 表达式作为一个指令的参数，例如： 12&lt;!-- 注意，参数表达式的写法存在一些约束，之后会详细探讨 --&gt;&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt; 这里的 attributeName 会作为一个 JS 表达式进行动态求值，求得的值将会作为最终的参数来使用，例如，如果你的实例中的 data 有一个键值对是：attributeName: &quot;href&quot;，那么这个绑定将等价于 v-bind:href 你也可以把动态参数作为一个动态的事件名绑定到处理函数上，例如： 1&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt; 例如，当 eventName=&quot;focus&quot; 时，v-on:[eventName] 也就等价于 v-on:focus 对动态参数的约束：动态参数预期会求出一个字符串，异常情况下为 null。这个特殊的 null 值可以用于移除绑定，例如下面这个 doSomething 事件将移除绑定： 12&lt;button v-on:null&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;button&gt;&lt;!-- 不管 doSomething 事件会触发什么，都不会被绑定到这个 &lt;button&gt; 标签上 --&gt; 对动态参数表达式的约束：动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML 属性名里是无效的，例如： 12&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:[&quot;foo&quot; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt; 解决的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式 在 DOM 中使用模板时（直接在一个 HTML 文件里撰写模板），还需要避免使用大写字符来命名键名，因为浏览器会把属性名全部强制转为小写： 12345&lt;!--在 DOM 中使用模板时这段代码会被转换为 v-bind:[someattr]除非在实例中有一个名为 &quot;someattr&quot; 的 property，否则代码不会工作--&gt;&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt; 修饰符：修饰符是以 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，这里只是引入这个概念在，之后我们会详细说明 v-on 以及 v-for 等等指令的修饰符的具体用法 缩写 v- 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 SPA 时，v- 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写 v-bind 缩写： 12345678&lt;!-- 完整语法 --&gt;&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 缩写 --&gt;&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt; v-on 缩写： 12345678&lt;!-- 完整语法 --&gt;&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 缩写 --&gt;&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt; 本节大概讲了 Vue 实例中的重要选项 以及 模板语法的知识点，加油！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"Vue教程（二）：Vue内置指令详解","slug":"Vue教程（二）：Vue内置指令详解","date":"2021-03-20T04:06:10.000Z","updated":"2021-03-20T04:06:27.235Z","comments":true,"path":"8a495401b398/","link":"","permalink":"https://ozzienicholas.gitee.io/8a495401b398/","excerpt":"","text":"插值表达式 数据绑定最常见的形式就是“Mustache”语法 (双大括号) 的文本插值，Mustache 标签将会被对应数据对象上属性的值替代。只要绑定的数据对象上属性发生了改变，插值处的内容都会更新。 用过 vue 的盆友都清楚，message 是将数据解析成纯文本的，也就是说，就算message 中含有了 html 标签，它也是只看做纯文本的，不能输出真正的 html。 例如: 123456789101112 &lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; message: &#x27;&lt;h1&gt;asc&lt;/h1&gt;&#x27; &#125; &#125;)&lt;/script&gt;&lt;!--页面显示为: &lt;h1&gt;asc&lt;/h1&gt;--&gt; v-text v-text 简介: v-text与插值表达式相同的地方是，它也是将数据解析成纯文本（解释html标签可能导致xss攻击） 但它与花括号的区别是: 使用v-text在页面加载时不会显示**’message’**，解决了插值表达式闪烁问题，因为他是属性而不是插值表达式 例如: 123456789101112&lt;div id=&quot;app&quot;&gt;&lt;p v-text=&quot;msg&quot;&gt;这里的内容会被替换&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;Hello! &lt;h1&gt;v-text&lt;/h1&gt;&quot;, &#125; &#125;)&lt;/script&gt;&lt;!--页面显示为: Hello! &lt;h1&gt;v-text&lt;/h1&gt;--&gt; 注: “页面闪烁” 指的是在加载插值表达式时，会先直接在页面显示**’message’**，然后再编译对应的数据 v-html 简介: 为了输出真正的HTML，可以用v-html指令。它等同于JS的innerHtml属性，会将数据解析成html形式。 例如: 123456789101112&lt;div id=&quot;app&quot;&gt;&lt;p v-text=&quot;msg&quot;&gt;这里的内容会被替换&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; msg: &quot;Hello! &lt;h1&gt;v-html&lt;/h1&gt;&quot;, &#125; &#125;)&lt;/script&gt;&lt;!--页面显示为: Hello! v-html --&gt; 另外，使用 v-html 时请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值，因为它很容易导致 XSS 攻击。 v-if 简介: v-if 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染。 例如: 1234567891011121314&lt;div id=&quot;app&quot;&gt;&lt;p v-if=&quot;true&quot;&gt; v-if 为 true 时显示&lt;/p&gt; &lt;!--页面显示为: v-if 为 true 时显示 --&gt;&lt;p v-if=&quot;false&quot;&gt; v-if 为 false 时显示&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; true: true, false: false, &#125; &#125;)&lt;/script&gt; v-if 是“真正”的条件渲染，因为它会确保在切换过程中 条件块内的事件监听器 和 子组件 适当地被销毁和重建。 v-if 是惰性的，如果初始渲染时条件为 假，那么就什么也不用做，直到第一次条件变为 真，才开始渲染条件块。 v-if 通常用于以下两种情况: 多个元素之间，通过条件判断，来 展示 或者 隐藏 某个或多个元素。 进行两个视图的切换。 例如下面的代码分别实现了: ①type不同值时元素的展示情况；②点击按钮切换视图 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;div style=&quot;color:red&quot;&gt;v-if的简单实用&lt;/div&gt; &lt;template&gt; &lt;div v-if=&quot;type == &#x27;A&#x27;&quot;&gt;A&lt;/div&gt; &lt;div v-else-if=&quot;type==&#x27;B&#x27;&quot;&gt;B&lt;/div&gt; &lt;div v-else&gt;C&lt;/div&gt; &lt;/template&gt; &lt;div&gt; &lt;p&gt;v-if的弹框切换&lt;/p&gt; &lt;/div&gt; &lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt; &lt;label&gt;用户名: &lt;/label&gt; &lt;input placeholder=&quot;Enter your username&quot; key=&quot;username-input&quot;&gt; &lt;/template&gt; &lt;template v-else&gt; &lt;label&gt;密码: &lt;/label&gt; &lt;input placeholder=&quot;Enter your email address&quot; key=&quot;email-input&quot;&gt; &lt;/template&gt; &lt;button @click=&quot;changeloginType&quot;&gt;切换状态&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; type: &#x27;C&#x27;, loginType: &#x27;username&#x27; &#125;, methods: &#123; changeloginType() &#123; let self = this; if (self.loginType == &#x27;username&#x27;) &#123; self.loginType = &#x27;&#x27; &#125; else &#123; self.loginType = &#x27;username&#x27; &#125; &#125; &#125; &#125;)&lt;/script&gt; 拓展了解 — 官方文档: 条件渲染 — Vue.js v-else 简介: 个人感觉 v-else 并不像一个单独功能的指令，而是偏辅助功能的，而且 v-else 必须和 v-if 连用，否则会报错。 例如: 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;msg1&quot;&gt;The msg1 is true&lt;/p&gt; &lt;p v-else&gt;The msg1 is false&lt;/p&gt; &lt;input type=&quot;button&quot; @click=&quot;button&quot; value=&quot;Button&quot;/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg1: true, &#125;, methods: &#123; button: function()&#123; this.msg1 = !this.msg1; &#125; &#125; &#125;)&lt;/script&gt; 上述过程即为 v-if 与 v-else 连用，若去掉 v-if 部分，则报错为: 编译模板时出错![](https://s2.ax1x.com/2019/11/04/KxOMh8.png) v-else-if 简介: 与v-else相同，v-else-if也必须和v-if连用，其实道理很简单，类比 C语言的if、else、else if，这里的v-else-if也是用在v-if和v-else中间，实现多次判断 例如: 12345678910&lt;div id=&quot;app&quot;&gt; &lt;p v-if=&quot;10&gt;20&quot;&gt;v-if 赢了&lt;/p&gt; &lt;p v-else-if=&quot;10&gt;5&quot;&gt;v-else-if 赢了&lt;/p&gt; &lt;p v-else&gt;好吧，v-else 赢了&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, &#125;)&lt;/script&gt; 如果没有v-if，那么也会和上面的v-else一样报错: 编译模板时出错![](https://s2.ax1x.com/2019/11/04/KxO5ge.png) v-show 简介: v-show也是用来 控制元素是否显示 的，其功能与v-if指令相似。 例如: 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-show=&quot;msg&quot;&gt;显示成功&lt;/p&gt; &lt;input type=&quot;button&quot; @click=&quot;show&quot; value=&quot;Do you want to hide it?&quot; /&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: true, &#125;, methods: &#123; show: function()&#123; this.msg = !this.msg; &#125; &#125; &#125;)&lt;/script&gt; 那么，v-show与v-if有什么 联系 呢？ v-show与v-if都是通过 动态地操作DOM 来实现显示与隐藏的 v-show与v-if的 区别 是什么呢？ 手段的不同: v-if是动态地向DOM树内动态地添加或删除DOM元素，如果v-if的值是false就会在DOM中删除，相当于visibility:hidden;，如果是true把元素克隆到相应的DOM树上去，支持加在&lt;template&gt;标签上；而v-show是动态地设置DOM元素的display属性，而不会删除DOM元素，是display:none;，不支持加在&lt;template&gt;标签上。 编译过程的不同: v-if在切换时会有一个局部编译/卸载的过程，在切换时适当地销毁和重建内部的事件监听 和 子组件，因为v-if可能是数据绑定或者子组件；而v-show只是简单地进行 CSS 属性的切换。 编译条件的不同: v-if是真真正正的条件渲染，但它是惰性的，如果初始条件为假，则什么也不用做，只有在第一次条件变为真时才开始局部编译，编译会被缓存，之后等到再切换时再进行局部卸载；而v-show不管其值是否为真，都进行编译，然后编译被缓存，而且DOM元素也保留。 性能消耗不同: v-if有着更高的切换消耗，v-show有着更高的初识渲染消耗由此，就引发出了使用问题: 当组件的某块内容切换很少，那么切换消耗也就很少，此时用v-if来渲染更加合适 如果频繁地切换着条件，那么就用v-show更加合适，实现一次渲染，多次切换 为什么这么说呢，因为频繁操作DOM会很影响性能，如果频繁切换，就意味着频繁地创建、删除DOM，为减少消耗就更该用v-show；如果是要么显示要么隐藏的情况下，那么v-if更加合理，因为借助v-if的惰性，如果一开始它的值即为false，那么甚至都不需要创建DOM，如果其值为true，则效果与v-show完全一样。 补充: display:none 与 visibility:hidden的区别: display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素； visibility:hidden可以理解为透明度为0的效果，它只是视觉上的消失，在文档流中是占位的，浏览器也会解析该元素。 使用visibility:hidden要比display:none性能更好，用display切换时，页面会产生 回流 （当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面需要 重新构建，即为回流。所有页面第一次加载时需要产生一次回流），而用visibility切换时不会产生回流。 补充: 若一个元素在CSS中已设置display:none，则无法通过设置v-if或者v-show来让元素显示，因为切换时只会修改元素 element.style 的“display”属性为“none”或者“block”，并不会覆盖或者修改已经存在的CSS属性v-for v-for循环普通数组: 12345678910111213&lt;div id=&quot;app&quot;&gt;&lt;p v-for=&quot;value in list&quot;&gt;&#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;p v-for=&quot;(value,i) in list&quot;&gt;索引: &#123;&#123;i&#125;&#125; =&gt; 值: &#123;&#123;value&#125;&#125;&lt;/p&gt;&lt;!-- 注意: 值与索引的顺序为 : (value,i) --&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list: [1,2,3,4,5] &#125; &#125;)&lt;/script&gt; v-for循环对象数组: 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(value,i) in list&quot;&gt; 索引: &#123;&#123;i&#125;&#125; —— Id: &#123;&#123;value.id&#125;&#125; —— Name: &#123;&#123;value.name&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list: [ &#123; id: 1, name: &#x27;first&#x27; &#125;, &#123; id: 2, name: &#x27;second&#x27; &#125;, &#123; id: 3, name: &#x27;third&#x27; &#125;, ] &#125; &#125;)&lt;/script&gt; v-for循环对象: 1234567891011121314151617&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;(value,key,i) in student&quot;&gt; 索引: &#123;&#123;i&#125;&#125; —— 键: &#123;&#123;key&#125;&#125; —— 值: &#123;&#123;value&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; student: &#123; id: 0, name: &#x27;Tom&#x27;, gender: &#x27;男&#x27; &#125; &#125; &#125;)&lt;/script&gt; v-for迭代数字: 12345678&lt;div id=&quot;app&quot;&gt; &lt;p v-for=&quot;count in 10&quot;&gt;这是第&#123;&#123;count&#125;&#125;次循环&lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, &#125;)&lt;/script&gt; v-for中的key属性的使用: 123456789101112131415161718192021222324252627282930313233&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;label&gt;Id: &lt;input type=&quot;text&quot; v-model=&quot;id&quot; /&gt; &lt;/label&gt; &lt;label&gt;Name: &lt;input type=&quot;text&quot; v-model=&quot;name&quot; /&gt; &lt;/label&gt; &lt;input type=&quot;button&quot; @click=&quot;add&quot; value=&quot;添加&quot; /&gt; &lt;/div&gt; &lt;p v-for=&quot;item in list&quot; :key=&#x27;item.id&#x27;&gt; &lt;input type=&quot;checkbox&quot; /&gt;&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; id: &#x27;&#x27;, name: &#x27;&#x27;, list: [ &#123; id: 1, name: &#x27;李斯&#x27; &#125;, &#123; id: 2, name: &#x27;嬴政&#x27; &#125;, &#123; id: 3, name: &#x27;赵高&#x27; &#125;, ] &#125;, methods: &#123; add()&#123; this.list.unshift(&#123; id: this.id, name: this.name &#125;); &#125; &#125; &#125;)&lt;/script&gt; v-on 简介: 它是来 绑定事件监听器 的，这样我们就可以进行一下交互。 例如: 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; v-on:click=&quot;click&quot; value=&quot;点此弹出语句&quot;/&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, methods: &#123; click()&#123; alert(&#x27;Hello Vue!&#x27;); &#125; &#125; &#125;)&lt;/script&gt; v-on 可简写为 @ v-bind 简介: v-bind指令主要用于 绑定属性，可以动态地绑定一个或多个属性，比如 class属性、style属性、value属性、href 属性，只要是属性，就可以用v-bind进行绑定。它的语法是: v-bind:属性名 = &quot;变量名&quot;，规定v-bind可以缩写为:，如语法可以缩写为:属性名 = &quot;变量名&quot;。 绑定 HTML Class: 对象语法: 我们可以传给v-bind:class一个对象，以动态地切换 class属性，如: 123456789&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isActive: true //此时可以展示active &#125; &#125;)&lt;/script&gt; 上述表示 active 是否被展现取决于 isActive 是否为真。 此外，可以在对象中传入多个属性来动态地切换 class，例如下面的模板: 1234567891011&lt;div class=&quot;static&quot; v-bind:class=&quot;&#123; A:isA, &#x27;B&#x27;: isB &#125;&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isA: true, isB: false, &#125; &#125;)//结果渲染为: &lt;div class=&quot;static isA&quot;&gt;&lt;/div&gt;&lt;/script&gt; 当然，绑定的对象也不必内联定义在模板里，而是用一个对象名代替: 123456789101112&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; classObject&#123; isA: true, isB: false, &#125; &#125; &#125;)&lt;/script&gt; 我们也可以绑定一个返回对象的计算属性，这是一个强大而且常用的模式: 123456789101112131415161718&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; isA: true, isB: false, &#125;, computed: &#123; classObject: function () &#123; return &#123; active: this.isA &amp;&amp; !this.isB, statiq: this.isB &amp;&amp; this.isB.type === &#x27;fatal&#x27; &#125; &#125; &#125; &#125;)&lt;/script&gt; 数组语法: 我们可以把一个数组传给 v-bind:class，以应用一个 class列表: 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125; &#125;) //渲染为 &lt;div class=&quot;active text-danger&quot;&gt;&lt;/div&gt;&lt;/script&gt; 注：关于v-bind指令详解请参考: 详解v-bind指令 以及 vue.js中的v-bind语法的使用详解 案例集合： 12345678910111213141516171819202122232425&lt;!-- 绑定一个属性 --&gt;&lt;img v-bind:src=&quot;imageSrc&quot; /&gt;&lt;!-- 缩写 --&gt;&lt;img :src=&quot;imageSrc&quot; /&gt;&lt;!-- 最终会生成 `&lt;img src=&quot;$&#123;imageSrc&#125;&quot;&gt;` 这样的模板 --&gt;&lt;!-- 动态特性名 (2.6.0+) --&gt;&lt;button v-bind:[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;&lt;button :[key]=&quot;value&quot;&gt;&lt;/button&gt;&lt;!-- 最终会生成 `&lt;button $&#123;key&#125;=&quot;$&#123;value&#125;&quot;&gt;` 这样的模板 --&gt;&lt;!-- 内联字符串拼接 --&gt;&lt;img :src=&quot;&#x27;/path/to/images/&#x27; + fileName&quot; /&gt;&lt;!-- class 绑定 --&gt;&lt;div :class=&quot;&#123; red: isRed &#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, classB]&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;&gt; &lt;!-- style 绑定 --&gt; &lt;div :style=&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;&gt;&lt;/div&gt; &lt;div :style=&quot;[styleObjectA, styleObjectB]&quot;&gt;&lt;/div&gt; &lt;!-- 绑定一个有属性的对象 --&gt; &lt;div v-bind=&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;&gt;&lt;/div&gt;&lt;/div&gt; v-model 简介: 这个指令用于 在表单上创建双向数据绑定，v-model会忽略所有表单元素的 value、checked、selected特性的初始值，因为v-model选择Vue实例数据来作为具体的值。 例如: 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;input v-model=&quot;somebody&quot;&gt; &lt;p&gt;hello &#123;&#123;somebody&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; somebody: &#x27;小明&#x27; &#125; &#125;)&lt;/script&gt; v-pre 简介: v-pre会 按原样输出，标签中的内容是什么就输出什么，主要用来跳过这个元素以及它的子元素的编译过程，可以用来显示原始的Mustache标签。 例如: 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;p v-pre&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg:&quot;&#x27;v-pre&#x27;是不会管我的...&quot; &#125; &#125;)&lt;/script&gt; v-cloak 简介: 还记得上文中提到的 页面闪烁 吗，我们也可以用v-cloak来解决这一问题。 这个指令用来保持在元素上直到关联实例结束时进行编译。 例如: 12345678910&lt;div id=&quot;app&quot; v-cloak&gt; &#123;&#123;context&#125;&#125; &lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; context:&#x27;Hello Vue!&#x27; &#125; &#125;);//用&#x27;v-cloak&#x27;则不会出现闪烁&lt;/script&gt; v-once v-once 关联的实例 只会渲染一次，执行 一次性地插值，当数据改变时，插值处的内容不会更新，v-once 所定义的元素或组件只会渲染一次，首次渲染后，不再随着数据的改变而重新渲染。若之后牵涉到重新渲染，那么 它关联的实例及其所有子节点 会被视为 静态内容 而被跳过，这可以用来优化更新性能。 例如: 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;p v-once&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; name=&quot;&quot;&gt; &lt;/p&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt; var vm = new Vue(&#123; el: &#x27;#app&#x27;, data: &#123; msg: &quot;hello&quot; &#125; &#125;);&lt;/script&gt; 在 Vue 生命周期钩子中，真实 DOM 挂载发生在 beforeMount 之后、mounted 之前，也就是说，我们可以在 mounted 之前的生命周期中更改 data 中 message 的值，所以关于插值，需要注意：v-once 在 mounted 生命周期之后，不可再更改。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"多角度认识 Vue","slug":"Vue教程（一）：多角度认识 Vue","date":"2021-03-20T04:04:57.000Z","updated":"2021-03-21T13:59:40.063Z","comments":true,"path":"5f4f362d2c70/","link":"","permalink":"https://ozzienicholas.gitee.io/5f4f362d2c70/","excerpt":"","text":"认识 Vue 与 渐进式 渐进式代表的含义大概是：主张最少。 每个框架都会有自己的一些特点，而对使用框架的人会有一定要求，而这种要求就是主张，对于不同的框架来说，主张有强有弱，主张的强弱也会影响在开发中的使用方式。 比如 Angular，它的两个版本都是强主张的，若要使用它，你必须要做到： 使用它的模块机制 使用它的依赖注入 使用它的特殊形式定义的组件（这点其实每个框架都有） 从以上三点可以看出，Angular 有着比较强的排他性，如果你的应用不是从头开始，而是要不断考虑是否要和其他东西集成，这些主张会给你带来一些困扰 又比如 React，它的主张主要是函数式编程的理念，比如说，你使用 React，就需要知道什么是副作用，什么是纯函数，如何隔离副作用等等，它的侵入性看似没有Angular那么强，主要因为它是软性侵入。 当然，实际上你也可以只使用 React 视图层，但是几乎没有人这么做，因为只使用 React 视图层总感觉是比较别扭的，于是你要引入 Flux、Redux、Mbox 中的一个，甚至你在选择了一个之后会再引入更多。 而 Vue.js 是一套构建用户界面的 渐进式框架，核心主要关注视图层，而渐进式框架给予了开发者很多灵活性，如图所示 Vue从设计角度来讲， 虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上 ，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。 声明式渲染 和 组件系统 是Vue的核心库所包含内容，而 客户端路由、状态管理、构建工具 都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起 其实，这些主张性只是有种影响作用，相比个人而言，尤其在团队中会放大，对于不同的人，它的喜好也是不同的，比如对有些人来说，有些人觉得大量的 DSL 学习成本太高，有些人觉得函数式编程很头疼，具体的主张性还和使用者有关。 当然，可能有些方面是不如 React，不如 Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当 JQuery 用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO 和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事。 Vue 渲染一块内容，一般会有以下流程： （1）解析语法生成 AST。 （2）根据 AST 结果，完成 data 数据初始化。 （3）根据 AST 结果和 data 数据绑定情况，生成虚拟 DOM。 （4）将虚拟 DOM 生成真正的 DOM 插入到页面中，此时页面会被渲染。 以上四步会在下面分别提出 其他链接： DSL 概述 Vue2.0 中，“渐进式框架” 和 “自底向上增量开发的设计” 这两个概念是什么？ 模板引擎 模板引擎大概是 Vue 里最主要、最核心的一个能力，在模板引擎还没有出现的时候，前端需要手动更新前端页面的内容，需要维护一大堆的 HTML 和变量拼接的动态内容，虽然 JQuery 的出现提升了 DOM 元素的操作性，但依然难以避免代码的可读性、可维护性上存在的一些问题。 以前更新页面的内容时的大致流程是：监听操作 -&gt; 获取数据变量 -&gt; 使用数据拼接成 HTML 模板 -&gt; 将 HTML 内容塞到页面对应的地方 -&gt; 将 HTML 片段内需要监听的点击等事件进行绑定，如今使用 Vue，就可以方便地在模板里用插值表达式 &#123;&#123;&#125;&#125;、v-bind 绑定变量来展示，同时配合 v-if、v-for 等内置指令即可。 其他了解： 数据绑定 XSS 漏洞填补 解析语法生成 AST 抽象语法树（Abstract Syntax Tree）也称为 AST 语法树，指的是源代码语法所对应的树状结构。 对于一种具体编程语言下的源代码，可以通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。 DOM 结构树也是 AST 的一种，把 HTML DOM 语法解析并生成最终的页面。而模板引擎中常用的，则是将模板语法解析，分别生成 HTML DOM，使用像 HTML 拼接这样的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 DOM 的设计，可以最大化地提升页面的性能。 至于具体的过程，暂时不做仔细探讨，可以查看： 解析语法生成 AST 浅析Vue编译原理—AST语法树 虚拟 DOM 虚拟 DOM 大概可分成三个过程： 用 JS 对象模拟 DOM 树，得到一棵虚拟 DOM 树。 当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。 把差异应用到真正的 DOM 树上。 详细了解请查： 如何理解虚拟DOM? 理解虚拟DOM Vue 核心之虚拟DOM（vdom） 虚拟 DOM MVVM 设计模式 由于MVP、MVVM的兴起，MVC 在 Android 中的应用变得越来越少了，但 MVC 是基础，理解好 MVC才能更好的理解 MVP、MVVM。因为后两种都是基于 MVC 发展而来的。 详细了解请查： MVC、MVP、MVVM，我到底该怎么选？ 廖雪峰：MVVM MVVM框架理解及其原理实现 MVVM模式 声明式渲染 声明式渲染指的是采用简洁的模板语法声明式地将数据渲染进 DOM 现在基本所有的框架都已经认同这个看法 —— DOM 应尽可能是一个函数式到状态的映射。状态即是唯一的真相，而DOM 状态只是数据状态的一个映射 如下图所示，我们可以将声明式渲染理解为： DOM 状态只是数据状态的一个映射 所有的逻辑尽可能在状态的层面去进行 当状态改变了，View 会被框架自动更新到合理的状态，而不是说当你观测到数据变化之后手动选择一个元素，再命令式地去改动它的属性 区别声明式渲染和命令式渲染 命令式：需要以具体代码表达在哪里做什么？它是如何实现的 声明式：只需要声明在哪里需要做什么？不需要关心具体怎么实现的 举例：假设有一个数组，我们要让里面的每个数字乘以2 命令式 123456let arr1 = [1, 2, 3, 4]let arr2 = []for(let i=0; i&lt;arr1.length; i++) &#123; arr2.push(arr1[i]*2)&#125;console.log(arr2) 声明式 123let arr1 = [1, 2, 3, 4]let arr2 = arr1.map( item =&gt; item*2 )console.log(arr2) 详细了解请查： 怎么理解“声明式渲染”？","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"}],"tags":[{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2021-03-20T04:03:28.000Z","updated":"2021-03-20T04:03:49.357Z","comments":true,"path":"1e94d8438000/","link":"","permalink":"https://ozzienicholas.gitee.io/1e94d8438000/","excerpt":"","text":"字符的 Unicode 表示法 注意，JS 是 unicode 编码的，不是 ASCII，所以不要用 ASCII 码值去查对应字符 JavaScript允许采用 \\uxxxx 形式表示一个字符，其中 “xxxx” 表示字符的码点： 12&#x27;\\u0061&#x27;// &quot;a&quot; 但是，这种表示法只限于 \\u0000 到 \\uFFFF 之间的字符，超出这个范围的字符，必须用两个双字节的形式表达。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符： 12345678910&quot;\\u&#123;20BB7&#125;&quot;// &quot;𠮷&quot;&quot;\\u&#123;6F&#125;&quot;&quot;o&quot;let hello = 123;hell\\u&#123;6F&#125; // 123&#x27;\\u&#123;1F680&#125;&#x27; === &#x27;\\uD83D\\uDE80&#x27;// true 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符： 12345678910111213&#x27;\\z&#x27; === &#x27;z&#x27; // true// 八进制的 unicode 编码表对应的值&#x27;\\172&#x27; === &#x27;z&#x27; // true// 十六进制的 unicode 编码表对应的值，&#x27;\\x7a&#x27; = &#x27;\\x7A&#x27;&#x27;\\x7A&#x27; === &#x27;z&#x27; // true// 十六进制的 unicode 编码表对应的值&#x27;\\u007A&#x27; === &#x27;z&#x27; // true// ES6 中的写法&#x27;\\u&#123;7A&#125;&#x27; === &#x27;z&#x27; // true 字符串的遍历器接口 ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 for...of 循环遍历： 12345678for (let str of &#x27;abc&#x27;) &#123; console.log(str)&#125;/*abc*/ 这个遍历器最大的优点是可以识别大于 0xFFFF 的码点，传统的 for 循环无法识别这样的码点： 12345678910111213141516// 普通 for 循环let txt = String.fromCodePoint(0x20BB7);for (let x = 0; x &lt; txt.length; x++) &#123; console.log(text[x])&#125;/*undefinedundefined*/// for...of 循环let txt = String.fromCodePoint(0x20BB7);for (let x of txt) &#123; console.log(x);&#125;// 𠮷 上面代码中，字符串 txt 只有一个字符，但是 for 循环会认为它包含两个字符（都不可打印），而 for…of 循环会正确识别出这一个字符。 includes()、startsWith()、endsWith() JavaScript 只有 indexOf 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法： **includes()**：返回布尔值，表示是否找到了参数字符串。 123let s = &#x27;Hello World&#x27;;s.includes(&#x27;Hello&#x27;); // trues.includes(&#x27;hello&#x27;); // false **startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。 123let s = &#x27;Hello World&#x27;;s.startsWith(&#x27;Hello&#x27;); // trues.startsWith(&#x27;ello&#x27;); // false **endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。 123let s = &#x27;Hello World&#x27;;s.endsWith(&#x27;World&#x27;); // trues.endsWith(&#x27;Hello&#x27;); // false 这三个方法都支持第二个参数，表示开始搜索的位置： 12345let s = &#x27;Hello World!&#x27;;s.startsWith(&#x27;World&#x27;, 6); // trues.endsWith(&#x27;Hello&#x27;, 5); // trues.includes(&#x27;Hello&#x27;, 6); // false 注意：使用第二个参数时： endsWith 是针对前 n 个字符。 startsWith 和 includes 都是针对从第 n 个位置直到字符串结束。 常用 API 总结JS 字符串总结 模板字符串 传统的 JS，输出模板通常是这样写的： 123$(&#x27;#result&#x27;).append( &#x27;My name is &#x27; + name + &#x27; .&#x27;); ES6 的模板字符串解决了这种繁琐的问题： 123$(&#x27;#result&#x27;).append(` My name is $&#123;name&#125; .`) 模板字符串都是用反引号表示，如果需要单独输出反引号，则前面要用反斜杠转义。 使用模板字符串表示的多行字符串，所有的空格和缩进都会被保留在输出之中： 123456$(&#x27;#list&#x27;).html(`&lt;ul&gt; &lt;li&gt;First&lt;/li&gt; &lt;li&gt;Second&lt;/li&gt;&lt;ul&gt;`) 上面代码中的空格和换行都会原封不动地保留下来，再解析为 html，可以用 trim 方法来消除这个换行： 123456$(&#x27;#list&#x27;).html(`&lt;ul&gt; &lt;li&gt;First&lt;/li&gt; &lt;li&gt;Second&lt;/li&gt;&lt;/ul&gt;`.trim()) 在模板字符串中嵌入变量，需要将变量名写在 $&#123;&#125; 之中： 1234function info(name, age) &#123; console.log(`My name is $&#123;name&#125;, my age is $&#123;age&#125;.`);&#125;info(&#x27;ozzie&#x27;, 20); // My name is Ozzie, my age is 20. $&#123;&#125; 之中可以： 嵌入任何的 JS 表达式： 123let x = 1, y = 2;console.log(`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`); // 1 + 2 = 3console.log(`$&#123;x&#125; + $&#123;y*2&#125; = $&#123;x + y*2&#125;`); // 1 + 4 = 5 嵌入对象属性： 123456let obj = &#123; name: &#x27;ozzie&#x27;, age: 20&#125;console.log(`My name is $&#123;obj.name&#125;, my age is $&#123;obj.age&#125;.`);// My name is ozzie, my age is 20. 12let num = [1, 2, 3];console.log(`$&#123;num.length&#125;`); // 3 调用函数： 1234function fun() &#123; return &quot;Hello World&quot;;&#125;console.log(`$&#123;fun()&#125;`); // Hello World $&#123;&#125; 与字符串：由于会将 $&#123;&#125; 中的内容按照 JS 代码来解析执行，所以： 若其中是字符串，那么保持原样地输出： 1console.log(`Hello $&#123;&#x27;World&#x27;&#125;`); // Hello World 若其中不是字符串，则会默认调用 toString() 方法来转为字符串： 1234let str = &#x27;ozzie&#x27;;console.log(`My name is $&#123;str&#125;`); // My name is ozzieconsole.log(`My name is $&#123;value&#125;`); // 报错: value is not defined 模板字符串甚至还能嵌套，也就是模板字符串中再嵌套另一个模板字符串： 123456789101112131415161718192021222324const data = [ &#123;first: &#x27;ozzie&#x27;, last: &#x27;nicholas&#x27;&#125;, &#123;first: &#x27;foo&#x27;, last: &#x27;bar&#x27;&#125;];const tem = arrs =&gt; ` &lt;table&gt; $&#123;arrs.map(arr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;arr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;arr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join(&#x27;&#x27;)&#125; &lt;/table&gt;`; // 另外，注意这里 join() 的作用console.log(tem(data));/*&lt;table&gt; &lt;tr&gt;&lt;td&gt;ozzie&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;nicholas&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;bar&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;*/ 如果需要引用模板字符串本身，在需要时执行，则可以写成： 123456789// 写法一let str = &#x27;return &#x27; + &#x27;`Hello $&#123;name&#125;!`&#x27;;let func = new Function(&#x27;name&#x27;, str);func(&#x27;Jack&#x27;) // &quot;Hello Jack!&quot;// 写法二let str = &#x27;(name) =&gt; `Hello $&#123;name&#125;!`&#x27;;let func = eval.call(null, str);func(&#x27;Jack&#x27;) // &quot;Hello Jack!&quot; 模板编译：这是一个模板字符串生成正式模板的实例： 示例代码： 1234567var template = `&lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 模板规则： 使用 &lt;%...%&gt; 输出 JS 语句 使用 &lt;%= ... %&gt; 输出 JS 表达式 编译模板字符串的规则：其中一种是将其转换为 JS 表达式字符串： 1234567echo(&#x27;&lt;ul&gt;&#x27;);for(var i=0; i &lt; data.supplies.length; i++) &#123; echo(&#x27;&lt;li&gt;&#x27;); echo(data.supplies[i]); echo(&#x27;&lt;/li&gt;&#x27;);&#125;;echo(&#x27;&lt;/ul&gt;&#x27;); 这个转换使用正则表达式即可： 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\\s\\S]+?)%&gt;/g;template = template .replace(evalExpr, &#x27;`); \\n echo( $1 ); \\n echo(`&#x27;) .replace(expr, &#x27;`); \\n $1 \\n echo(`&#x27;);template = &#x27;echo(`&#x27; + template + &#x27;`);&#x27;; 然后将 template 封装在一个函数里面返回： 1234567891011121314let script =`(function parse(data)&#123; var output = &quot;&quot;; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的两步总结到一起：一个模板编译函数 compile： 12345678910111213141516171819202122232425function compile(template)&#123; let evalExpr = /&lt;%=(.+?)%&gt;/g; let expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, &#x27;`); \\n echo( $1 ); \\n echo(`&#x27;) .replace(expr, &#x27;`); \\n $1 \\n echo(`&#x27;); template = &#x27;echo(`&#x27; + template + &#x27;`);&#x27;; let script = `(function parse(data)&#123; var output = &quot;&quot;; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; 使用此函数： 1234567let parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 标签模板： 模板字符串还可以跟在函数名的后面，此时，这个模板字符串会被看作该函数的参数，这被称为 “标签模板” 功能： 123456789// 按照模板字符串的规则alert(123); // 弹出 123 的弹窗// 等同于alert`123`; // 弹出 123 的弹窗// 但是console.log(123); // 打印 123// 却不等同于console.log`123`; // 打印 [&#x27;123&#x27;] 但如果模板字符里面有变量，就会将模板字符串先处理成多个参数，再调用函数： 123let a = 5;let b = 10;alert`Hello $&#123;a+b&#125; world $&#123;a*b&#125;`; // 弹出 &quot;Hello , world ,&quot; 该函数的第一个参数是数组，该数组的成员是原先模板字符串中没有被变量替换的部分，以 $&#123;a+b&#125; 和 $&#123;a*b&#125; 为参考，将 Hello $&#123;a+b&#125; world $&#123;a*b&#125; 划分为四部分，也就是没有被替换掉的部分： &#39;Hello &#39; &#39;&#39; world &#39;&#39; 该函数的其他参数，都是模板字符串各个变量被替换后的值，上面的例子中，模板字符串含有两个变量，因此 alert 会接受到 value1 和 value2 两个参数 综上，该函数的所有参数实际值如下： 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数：15 第三个参数：50 所以，该函数实际上以下面的形式调用： 123let a = 5;let b = 10;alert([&#x27;Hello &#x27;, &#x27;&#x27;, &#x27; world &#x27;, &#x27;&#x27;], 15, 50) 标签模板的作用： 过滤HTML字符串，防止用户输入恶意内容，这也是标签模板的一个重要应用： 1234567891011121314let msg = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for(let i=1; i&lt;arguments.length; i++) &#123; let arg = String(arguments[i]); // 在替换中转义特殊字符 s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;) // 不要在模板中转义特殊字符 s += templateData[i]; &#125; return s;&#125; 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 多语言转换（国际化处理）： 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot; 因为没有条件判断和循环处理功能，所以模板字符串本身并不能取代 Mustache 之类的模板库，但是，通过标签函数，你可以自己添加这些功能： 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数var libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 使用标签模板时，也可以在 JS 语言中嵌入其他语言： 123456789jsx` &lt;div&gt; &lt;input ref=&#x27;input&#x27; onChange=&#x27;$&#123;this.handleChange&#125;&#x27; defaultValue=&#x27;$&#123;this.state.value&#125;&#x27; /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 通过 jsx 函数，将一个 DOM 字符串转为 Reac t对象，在 Github 上找到 JSX 函数的具体实现：JSX Quasi-Literal 模板字符串的限制：标签模板里面可以内嵌其他语言，但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。 尝试在标签模板里面可以嵌入Latex语言： 123456789function latex(strings) &#123; // ...&#125;let document = latex`\\newcommand&#123;\\fun&#125;&#123;\\textbf&#123;Fun!&#125;&#125; // 正常工作\\newcommand&#123;\\unicode&#125;&#123;\\textbf&#123;Unicode!&#125;&#125; // 报错\\newcommand&#123;\\xerxes&#125;&#123;\\textbf&#123;King!&#125;&#125; // 报错Breve over the h goes \\u&#123;h&#125;ere // 报错 上面代码中，变量 document 内嵌的模板字符串，对于 Latex 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\\u00FF和\\u&#123;42&#125;当作Unicode字符进行转义，所以\\unicode解析时报错；而\\x56会被当作十六进制字符串转义，所以\\xerxes会报错。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://ozzienicholas.gitee.io/tags/ES6/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2021-03-20T04:02:54.000Z","updated":"2021-03-20T04:03:11.358Z","comments":true,"path":"89926b1f71ad/","link":"","permalink":"https://ozzienicholas.gitee.io/89926b1f71ad/","excerpt":"","text":"解构赋值的规则：只要等号右边的值不是对象，就先将其转为对象 数组的解构赋值基本用法 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，如： 1234567// ES6 之前var a = 1;var b = 2;var c = 3;// ES6 之后var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于 “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 下面是一些使用嵌套数组进行解构的例子： 12345let [a, [b, [c]]] = [1, [2, [3]]]; // a=1, b=2, c=3let [ , ,str] = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; // str=&quot;c&quot;let [x, , y] = [1, 2, 3]; // x=1, y=3let [head, ...tail] = [1, 2, 3, 4]; // head=1, tail=[2,3,4]let [i, j, ...k] = [&quot;a&quot;]; // i=&quot;a&quot;, j=undefined, k=[] 如果解构不成功，变量的值就等于undefined： 12var [foo] = []; // foo=undefinedvar [bar, foo] = [1]; // bar=1, foo=undefined 另一种情况是不完全解构，即左边的模式只匹配右边的一部分数组（左比右少，匹配过剩）。这种情况下，解构依然可以成功： 12let [x, y] = [1, 2, 3]; // x=1, y=2let [a, [b], c] = [1, [2, 3], 4]; // a=1, b=2, c=4 如果右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》），那么将会报错： 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的表达式都会报错，因为对于等号右边的值，前五个表达式转为对象以后不具备 Iterator 接口，最后一个表达式本身就不具备 Iterator 接口。 解构赋值不仅适用于 var 命令，也适用于 let 和 const 命令。 对于 Set 结构，也可以使用数组的解构赋值： 1let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); // x=&quot;a&quot; 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值： 12345678910function* fibs() &#123; let a = 0, b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();// sixth=5 上面代码中，fibs 是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 默认值 解构赋值允许指定默认值： 1234let [foo=true] = []; // foo=truelet [x, y=&quot;b&quot;] = [&quot;a&quot;]; // x=&quot;a&quot;, y=&quot;b&quot;let [x=&quot;b&quot;, y] = [&quot;a&quot;]; // x=&quot;a&quot;, y=&quot;undefined&quot;let [x, y=&quot;b&quot;] = [&quot;a&quot;, undefined]; // x=&quot;a&quot;, y=&quot;b&quot; 注意，ES6 内部使用严格相等运算符（===）来判断一个位置是否有值。所以，如果一个数组成员不严格等于 undefined，默认值是不会生效的。例如： 12let [x=1] = [undefined]; // x=1let [x=1] = [null]; // x=null 上面代码中，如果一个数组成员是 null，默认值就不会生效，因为 null 不严格等于 undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的（即只有在用到的时候，才会求值）： 1234function f() &#123; console.log(&quot;hello&quot;);&#125;let [x=f()] = [1]; // x=1 上面代码中，因为 x 能取到值（即为1），所以函数 f 根本不会执行。上面的代码其实等价于下面的代码： 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0]&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。如： 1234let [x=1, y=x] = []; // x=1, y=1let [x=1, y=x] = [2]; // x=2, y=2let [x=1, y=x] = [1, 2]; // x=1, y=2let [x=y, y=1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为 x 用到默认值 y 时，y 还没有声明。 对象的解构赋值 对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。例如： 1234let &#123; bar, foo &#125; = &#123; foo: &quot;a&quot;, bar: &quot;b&quot; &#125;;// foo=&quot;a&quot;, bar=&quot;b&quot;var &#123; str &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;// str=undefined 第一个例子中，属性的次序虽然不一致，但是对取值完全没有影响，但第二个例子的变量没有对应的同名属性，就会取不到值。 如果变量名与属性名不一致，必须写成下面这样： 12345let &#123; foo:baz &#125; = &#123; foo: &#x27;aaa&#x27;, bar: &#x27;bbb&#x27; &#125;; // baz=&quot;aaa&quot;let obj = &#123; first: &#x27;hello&#x27;, last: &#x27;world&#x27; &#125;;let &#123; first:f, last:l &#125; = obj;// f=&quot;hello&quot;, l=&quot;world&quot; 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）： 1let &#123; foo:foo, bar:bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。例如： 123let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;console.log(baz); // &quot;aaa&quot;console.log(foo); // foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于 let 和 const 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。例如： 12345let foo;let &#123;foo&#125; = &#123;foo: 1&#125;; // SyntaxError: Duplicate declaration &quot;foo&quot;let baz;let &#123;bar: baz&#125; = &#123;bar: 1&#125;; // SyntaxError: Duplicate declaration &quot;baz&quot; 上面代码中，解构赋值的变量都会重新声明，所以报错了。 但是因为 var 命令允许重新声明，所以这个错误只会在使用 let 和 const 命令时出现。 let 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 和数组一样，解构也可以用于嵌套结构的对象。例如： 123456let obj = &#123; p: [&quot;Hello&quot;, &#123; y: &quot;World&quot; &#125;]&#125; // p 是模式，不是变量，因此不会被赋值。let &#123; p: [x, &#123; y &#125;] &#125; = objconsole.log(x); // Helloconsole.log(y); // World 123456789101112let node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;let &#123; loc: &#123; start: &#123; line &#125; &#125; &#125; = nodeconsole.log(line); // 1console.log(loc); // loc is undefinedconsole.log(start); // start is undefined 下面是嵌套赋值的例子： 12345let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;)console.log(obj); // &#123; prop: 123 &#125;console.log(arr); // [ true ] 对象的解构也可以指定默认值： 12345678910let &#123; x = 3 &#125; = &#123;&#125;; // x=3let &#123; x, y = 5 &#125; = &#123; x: 1 &#125;; // x=1, y=5let &#123; x: y = 3 &#125; = &#123;&#125;; // y=3let &#123; x: y = 3 &#125; = &#123; x: 5 &#125;; // y=5let &#123; message: msg = &#x27;Something went wrong&#x27; &#125; = &#123;&#125;;// msg=&quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于 undefined，例如： 1234let &#123;x=3&#125; = &#123;x:undefined&#125;; // x=3// null 不严格相等于 undefinedlet &#123;x=3&#125; = &#123;x:null&#125;; // x=null 如果解构失败，变量的值等于 undefined： 1let &#123;foo&#125; = &#123;bar: &#x27;baz&#x27;&#125;; // foo=undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错： 1let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: &#x27;baz&#x27;&#125;; // Cannot read property &#x27;bar&#x27; of undefined 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性在解构时会报错。因为 foo 这时等于 undefined，再取子属性就会报错，再例如： 12let tmp = &#123;baz: &#x27;baz&#x27;&#125;;console.log(tmp.foo.bar); // Cannot read property &#x27;bar&#x27; of undefined 如果要将一个已经声明的变量用于解构赋值，必须非常小心。例如： 12let x;&#123;x&#125; = &#123;x: 1&#125;; // SyntaxError: Unexpected token &#x27;=&#x27; JavaScript 引擎会将 &#123;x&#125; 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题，所以我们要加上 ()： 12let x;(&#123; x &#125; = &#123; x: 1 &#125;); // x=1 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许在等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式： 123(&#123;&#125; = [true, false]);(&#123;&#125; = &#x27;abc&#x27;);(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量： 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构： 123let arr = [1, 2, 3];let &#123; 0: first, [arr.length - 1]: last &#125; = arr;// first=1, last=3 上面代码对数组进行对象解构。数组 arr 的 0 键对应的值是 1，[arr.length - 1] 就是 2 键，对应的值是3。 方括号这种写法，属于 “属性名表达式”。 字符串的解构赋值 字符串也可以解构赋值，因为字符串被转换成了一个类似数组的对象： 1234567891011const [a, b, c, d, e] = &#x27;Hello&#x27;;for (let x = 0; x &lt; 5; x++) &#123; console.log([a, b, c, d, e][x])&#125;/*Hello*/ 类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值： 12let &#123;length:len&#125; = &#x27;Hello&#x27;;console.log(len); // 5 数值和布尔值的解构赋值 根据解构赋值的规则，如果等号右边是数值和布尔值，则会先转为对象： 1234567891011// 数值let x = ( &#123;toString:s&#125; = 123 );console.log(s); // [Function: toString]console.log(x); // 123s === Number.prototype.toString // true// 布尔值let x = ( &#123;toString:s&#125; = true );console.log(s); // [Function: toString]console.log(x); // trues === Boolean.prototype.toString // true 数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。 由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错： 1234567let &#123; prop: x &#125; = undefined;console.log(x);// TypeError: Cannot destructure property `prop` of &#x27;undefined&#x27; or &#x27;null&#x27;.let &#123; prop: x &#125; = null;console.log(x)；// TypeError: Cannot destructure property `prop` of &#x27;undefined&#x27; or &#x27;null&#x27;. 函数参数的解构赋值 函数的参数也可以使用解构赋值： 1234function add([x, y]) &#123; console.log(x, y)&#125;add([3, 5]); // 3, 5 传入参数时，数组参数就被解构成变量 x 和 y，对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。 函数参数的解构也可以使用默认值： 1234567function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;console.log(move(&#123; x: 3, y: 8 &#125;)); // [ 3, 8 ]console.log(move(&#123; x: 3 &#125;)); // [ 3, 0 ]console.log(move(&#123;&#125;)); // [ 0, 0 ]console.log(move()); // [ 0, 0 ] 函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。 换一种写法： 1234567function move(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;console.log(move(&#123; x: 3, y: 8 &#125;)); // [ 3, 8 ]console.log(move(&#123; x: 3 &#125;)); // [ 3, undefined ]console.log(move(&#123;&#125;)); // [ undefined, undefined ]console.log(move()); // [ 0, 0 ] 与之前不同的是，上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。 undefined 就会触发函数参数的默认值： 12[1, undefined, 3].map((x = &#x27;yes&#x27;) =&gt; x);// [ 1, &#x27;yes&#x27;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。 编译器并不能从一开始就知道该式子是模式还是表达式，必须解析到（或解析不到）等号才能知道。 那么问题是，该怎么处理模式中的圆括号，ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 因此，只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况有以下： 变量声明语句中，模式不能带有圆括号： 12345let [(a)] = 1; // SyntaxError: Invalid destructuring assignment targetlet &#123;x: (c)&#125; = &#123;&#125;; // SyntaxError: Invalid destructuring assignment targetlet (&#123;x: c&#125;) = &#123;&#125;; // SyntaxError: Invalid destructuring assignment targetlet &#123;(x: c)&#125; = &#123;&#125;; // SyntaxError: Invalid destructuring assignment targetlet &#123;(x): c&#125; = &#123;&#125;; // SyntaxError: Invalid destructuring assignment target 函数参数中，模式不能带有圆括号： 123function f([(x)]) &#123; return x;&#125; // SyntaxError: Invalid destructuring assignment target 赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中： 将整个模式放在圆括号之中： 12345(&#123; x: a &#125;) = &#123; x: 1 &#125;;// SyntaxError: Invalid left-hand side in assignment([x]) = [1];// SyntaxError: Invalid left-hand side in assignment 将嵌套模式的一层放在圆括号之中： 12[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]// SyntaxError: Invalid destructuring assignment target 可以使用圆括号的情况只有一种：就是在赋值语句的非模式部分使用圆括号 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 变量的解构赋值用途 交换变量的值： 1[x, y] = [y, x] 从函数返回多个值：函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回，此时用解构赋值来取出这些值就非常方便。 1234567891011121314151617// 返回一个数组function f() &#123; return [1, 2, 3]&#125;let [a, b, c] = f();console.log(a, b, c); // 1 2 3// 返回一个对象function f() &#123; return &#123; a: 1, b: 2, c: 3 &#125;&#125;let &#123; a, b, c &#125; = f();console.log(a, b, c); // 1 2 3 定义函数参数：解构赋值可以方便地将一组参数与变量名对应起来。 1234567891011// 参数是一组有次序的值function f([x, y, z]) &#123; // ...&#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123; x, y, z &#125;) &#123; // ...&#125;f(&#123; z: 3, y: 2, x: 1 &#125;); 提取 JSON 数据：解构赋值经常应用在对 JSON 对象的提取中。 12345678let jsonData = &#123; id: 001, name: &quot;ozzie&quot;, score: 90, number: [90, 95, 100]&#125;let &#123; id, name, score, number: data &#125; = jsonData;console.log(id, name, score, data); // 1 ozzie 90 [ 90, 95, 100 ] 设置函数参数的默认值： 1234function fun(&#123; a, b = 1, c = true, d = function() &#123;&#125;, e = &#x27;ozzie&#x27; &#125; = &#123;&#125;) &#123; console.log(a, b, c, d, e)&#125;fun(); // undefined 1 true [Function: d] ozzie 指定参数的默认值，就避免了在函数体内部再写 var foo = config.foo || &#39;default foo&#39;; 这样的语句。 遍历 Map 结构：任何部署了Iterator接口的对象，都可以用 for...of 循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 1234567891011let map = new Map();map.set(&#x27;first&#x27;, &#x27;hello&#x27;);map.set(&#x27;second&#x27;, &#x27;world&#x27;);for (let [key, value] of map) &#123; console.log(key + &#x27; is &#x27; + value);&#125;/*first is hello second is world*/ 如果只想获取键名，或者只想获取键值，可以写成下面这样： 12345678910111213141516171819let map = new Map();map.set(&#x27;first&#x27;, &#x27;hello&#x27;);map.set(&#x27;second&#x27;, &#x27;world&#x27;);// 获取键名for (let [key] of map) &#123; console.log(key)&#125;// 获取键值for (let [, value] of map) &#123; // 注意这里有个逗号，否则还是会打印 key 的值 console.log(value)&#125;/*firstsecondhelloworld*/ 输入模块的指定方法：加载模块时，通常需要指定输入的方法。 1const &#123; SourceMapConsumer, SourceNode &#125; = require(&quot;source-map&quot;);","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://ozzienicholas.gitee.io/tags/ES6/"}]},{"title":"var、let、const-及-块级作用域","slug":"var、let、const-及-块级作用域","date":"2021-03-20T03:51:00.000Z","updated":"2021-03-20T03:51:52.163Z","comments":true,"path":"ee1bae1a2f17/","link":"","permalink":"https://ozzienicholas.gitee.io/ee1bae1a2f17/","excerpt":"","text":"var 命令基本用法 可以使用 var 操作符定义变量（注意 var 是一个关键字），后跟变量名（即标识符）： 1var message; 定义了一个名为 message 的变量，可以用它保存任何类型的值。 不初始化的情况下，变 量会保存一个特殊值 undefined。 可以同时定义变量并设置它的值： 12var message = &#x27;Hello World&#x27;;message = 0; // 合法，但不推荐 变量 message 首先被定义为一个保存字符串值 ‘Hello World’ 的变量，然后又被重写为保存了 数值 0。虽然不推荐改变变量保存值的类型，但这在 ECMAScript 中是完全有效的。 声明作用域 使用 var 操作符定义的变量会成为包含它的函数的局部变量，比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁： 12345function fun() &#123; var message = &#x27;Hello World&#x27;;&#125;fun();console.log(message); // message is not defined 但是，如果在函数内部定义变量时省略 var 操作符，就可以创建一个全局变量： 12345function fun() &#123; message = &#x27;Hello World&#x27;;&#125;fun();console.log(message); // Hello World 虽然可以通过省略 var 操作符定义全局变量，但不推荐这么做。在局部作用域中定 义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 var 是不是有意而 为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError： 123456&#x27;use strict&#x27;;function fun() &#123; message = &#x27;Hello World&#x27;;&#125;fun();console.log(message); // message is not defined 在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误。 var 声明提升： 使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部： 12345function foo() &#123; console.log(age); var age = 20;&#125;foo(); // undefined 这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次 使用 var 声明同一个变量也没有问题： 1234567function foo() &#123; var age = 20; var age = 30; var age = 40; console.log(age);&#125;foo(); //40 let 命令基本用法 let 类似于 var，但是声明的变量，只在 ler 所在的代码块内有效 123456&#123; let a = 1; var b = 2;&#125;console.log(a) // ReferenceError: a is not definedconsole.log(b) // 2 结果表明，ket 声明的变量只在自己所在的代码块内有效 所以，for 循环的计数器就很适合 let 命令： 1234for (let i = 0; i &lt; 3; i++) &#123; console.log(i) // 打印 0 1 2&#125;console.log(i) // ReferenceError: i is not defined 计数器只在 for 循环内部有效，循环体外就会报错 观察下面的结果 用 var 声明： 123456789var a = [];for (var i = 0; i &lt; 3; i++) &#123; a[i] = function() &#123; console.log(i) &#125; a[i]() // 分别打印出 0 1 2&#125;a[0]() // 3a[1]() // 3 上述代码中，i 是 var 声明的，在全局范围内都有效，所以全局只有一个变量 i，每次循环，i 的值都在改变，所有数组 a 的成员里面的 i，指的都是同一个 i，所以最后两个结果都是 3 用 let 声明： 123456789var a = [];for (let i = 0; i &lt; 3; i++) &#123; a[i] = function() &#123; console.log(i) &#125; a[i]() // 分别打印出 0 1 2&#125;a[0]() // 0a[1]() // 1 上述的 i 是用 let 声明的，只在该轮循环中有效，所以每一次循环的 i 都是新的变量，至于如何记住上一轮循环的值，是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算 另外，for 循环有个特点：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，例如： 1234for (let i = 0; i &lt; 3; i++) &#123; let i = &quot;abc&quot;; console.log(i) // 打印出 3 次 &quot;abc&quot;&#125; 不存在变量提升var 是有变量提升的，你可以在声明变量前就使用该变量，只不过值为 undefined，但是 let 必须要在声明之后才能使用，例如： 1234567// var：有变量提升console.log(a); // undefinedvar a = 1;// let：没有变量提升console.log(b); // ReferenceError: Cannot access &#x27;b&#x27; before initializatiolet b = 2; 暂时性死区 若块级作用域内存在 let，那么，用 let 声明的变量就会 “绑定” 这个区域，不会受到外部影响，例如： 12345var a = 1;if (true) &#123; console.log(a) // ReferenceError let a;&#125; ES6 规定，若在块级作用域中存在 let 和 const，那么用它们声明的变量，也是被封闭到该作用域内的，在 let 命令声明之前，该变量都不可用，这称为 “暂时性死区” 暂时性死区也意味着 typeof 不再是绝对安全的操作： 12typeof x; // ReferenceError:let x; 若该变量根本没有被声明，typeof 反而不会报错： 1console.log(typeof x) // undefined 这样看来，let 的存在约束了原先的不规范的操作，只要有 let 存在，typeof 就不是绝对安全的 隐蔽的死区： 1234function fun(x = y, y = 2) &#123; console.log(x + y)&#125;fun() // ReferenceError x 的值默认来源于 y，但是 y 还没有声明，属于 “死区”，下面则不会报错： 1234function fun(x = 2, y = x) &#123; console.log(x + y)&#125;fun() // 4 另外，下面的代码也会报错，也是因为暂时性死区： 1234// var：不报错var x = x;// let：报错let y = y; // ReferenceError ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为 不允许重复声明let 不允许在同一作用域内重复声明同一个变量： 12345678910// 报错：SyntaxError: Identifier &#x27;a&#x27; has already been declaredfunction func() &#123; let a = 10; var a = 1;&#125;// 报错：SyntaxError: Identifier &#x27;a&#x27; has already been declaredfunction func() &#123; let a = 10; let a = 1;&#125; 所以要注意，不能在函数内部重复声明参数 块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，带来很多不合理的场景 场景一：内层变量可能会覆盖外层变量： 12345678var a = 1;function fun() &#123; console.log(a); // undefined if (false) &#123; var a = 2; &#125;&#125;fun() 变量提升，导致内层的变量覆盖了外层的变量 场景二：用来计数的循环变量泄露为全局变量： 1234for (var i = 0; i &lt; 3; i++) &#123; console.log(i); // 分别打印出 0 1 2&#125;console.log(i); // 3 变量 i 本身只用来控制循环，但是之后他没有消失，泄漏成了全局变量 ES6 的块级作用域 let 为 JS 新增了块级作用域： 1234567function f() &#123; let n = 5; if(true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 外层代码块不受内层代码块的影响。如果使用 var 定义变量 n，最后输出的值就是10。 ES6允许块级作用域的任意嵌套： 1&#123;&#123;&#123;&#123;&#123; let n = 10; &#125;&#125;&#125;&#125;&#125; 外层作用域无法读取内层作用域的变量： 12345&#123;&#123;&#123;&#123;&#123; let n = 5; &#123; let n = 10; &#125; console.log(n); // 5&#125;&#125;&#125;&#125;&#125; 内层可以定义外层作用域的同名变量： 1234&#123;&#123;&#123;&#123; let n = 5; &#123; let n = 10; &#125;&#125;&#125;&#125;&#125;; 立即执行函数表达式（IIFE）不再必要： 12345678910// IIFE 的写法(function() &#123; var n = 1; // ...&#125;());// 块级作用域&#123; let n = 1;&#125; 块级作用域与函数声明 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明： 12345678// 情况一if(true) &#123; function f()&#123;&#125;;&#125;// 情况二try &#123; function() &#123;&#125;;&#125; catch(e) &#123;&#125;; 上面代码的两种函数声明，根据 ES5 的规定都是非法的。 但是浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式” 下还是会报错。 ES6 明确允许在块级作用域之中声明函数： 123if(true) &#123; function() &#123;&#125;;&#125; 即使在 ES6 严格模式中也不会报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于 let，在块级作用域之外不可引用： 12345678function f() &#123; console.log(&quot;A&quot;); &#125;(function() &#123; if(false) &#123; // 再次声明 f 函数 function f() &#123; console.log(&quot;B&quot;); &#125; &#125; f();&#125;()) 上面代码在 ES5 中运行，会得到 “B”，因为在 if 内声明的函数会被提升到函数头部，实际运行的代码如下： 123456789// ES5function f() &#123; console.log(&quot;A&quot;); &#125;(function() &#123; function f() &#123; console.log(&quot;B&quot;); &#125; if(false) &#123; &#125; f();&#125;) 而 ES6 的运行结果会得到 “A”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下： 12345// ES6function f() &#123; console.log(&quot;A&quot;); &#125;(function() &#123; f();&#125;()) 这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在 附录B 里面规定，浏览器的实现可以不遵守上面的规定，有自己的 行为方式，但是考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 注意，ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错： 1234// 报错&quot;use strict&quot;if(true) function f() &#123;&#125; do 表达式 本质上块级作用域是一个语句，将多个操作封装在一起，没有返回值： 1234&#123; let t = f(); t = t + 1;&#125; 上面代码中，块级作用域将两个语句封装在一起。但在块级作用域以外，没有办法得到 t 的值，因为块级作用域不返回值，除非 t是全局变量。 现在有一个提案：在块级作用域之前加上 do，使它变为 do 表达式。这使得块级作用域可以变为表达式，也就是说可以返回值： 1234let x = do &#123; let t = f(); t = t + 1;&#125; 上面代码中，变量 x 会得到整个块级作用域的返回值。 const 命令 const 声明一个只读的常量，一旦声明，常量的值就不能改变： 1234const PI = 3.1415926;console.log(PI); // 3.1415926PI = 3;console.log(PI); // TypeError: Assignment to constant variable. const 一旦声明变量，就必须立即初始化，不能留到以后赋值： 12const x;// SyntaxError: Missing initializer in const declaration const 的作用域与 let 命令相同 —— 只在声明所在的块级作用域内有效： 1234if(true) &#123; const x = 5;&#125;x // ReferenceError: x is not defined const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用： 1234if(true) &#123; console.log(x); // ReferenceError: Cannot access &#x27;x&#x27; before initialization const x = 5;&#125; const 声明的常量，也与 let 一样不可重复声明。 将一个对象声明为常量必须非常小心：因为，对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址，const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变。如： 1234const f = &#123;&#125;;f.num = 123;console.log(f.num); // 123f = &#123;&#125;; // TypeError: Assignment to constant variable. 上面代码中，常量 f 储存的是一个地址，这个地址指向一个对象，不可变的只是这个地址，即不能把 f 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 例如下面的例子： 12345const a = [];a.push(&quot;hello&quot;);a.length = 0;console.log(a); // []a = [&quot;hello&quot;]; // TypeError: Assignment to constant variable. 常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a，就会报错。 如果想将对象冻结，应使用 Object.freeze 方法： 1234// 常量 f 指向一个冻结的对象，所以添加新属性不起作用const f = Object.freeze(&#123;&#125;);f.num = 123; // 常规模式下不起作用，严格模式下会报错console.log(f); // &#123;&#125; 将对象彻底冻结（冻结对象本身以及对象属性）： 12345678let constance = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, value) =&gt; &#123; if (typeof obj[key] === &quot;object&quot;) &#123; constance(obj[key]) &#125; &#125;)&#125; 顶层对象的属性 顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的： 1234// ES5 中window.a = 1 // window 中的 aa = 2 // 全局的 awindow.a // window 中的 a 就是全局的 a 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题： 首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）； 其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）； 最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 中，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let、const、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。例如： 1234var a = 1;window.a // 1let b = 2;window.b // undefined 全局变量 a 由 var 命令声明，所以它是顶层对象的属性； 全局变量 b 由 let 命令声明，所以它不是顶层对象的属性，返回 undefined。 global 对象 ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的： 浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。 浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。 Node 里面，顶层对象是 global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性： 全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。 函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，this 会返回 undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么 eval、new Function 这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象，以下是两种勉强可以使用的方法： 方法一： 123456(typeof window !== &quot;undefined&quot; ? window : (typeof process === `object` &amp;&amp; typeof require === `function` &amp;&amp; typeof global === `object` ) ? global : this) 方法二： 123456var getGlobal = function() &#123; if (typeof self !== &quot;undefined&quot;) &#123; return self; &#125; if (typeof window !== &quot;undefined&quot;) &#123; return window; &#125; if (typeof global !== &quot;undefined&quot;) &#123; return global; &#125; throw new Error(&quot;unable to locate global object&quot;)&#125; 现在有一个 提案，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。 垫片库 system.global 模拟了这个提案，可以在所有环境拿到 global： 12345// CommonJS的写法require(&#x27;system.global/shim&#x27;)();// ES6模块的写法import shim from &#x27;system.global/shim&#x27;; shim(); 上面代码可以保证各种环境里面，global 对象都是存在的。 将顶层对象放入变量 global： 123456// CommonJS的写法var global = require(&#x27;system.global&#x27;)();// ES6模块的写法import getGlobal from &#x27;system.global&#x27;;const global = getGlobal();","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://ozzienicholas.gitee.io/tags/ES6/"}]},{"title":"JavaScript（五）：数据类型与字面量","slug":"JavaScript（五）：数据类型与字面量","date":"2021-03-20T03:49:57.000Z","updated":"2021-03-20T03:50:34.463Z","comments":true,"path":"623f1f08afb9/","link":"","permalink":"https://ozzienicholas.gitee.io/623f1f08afb9/","excerpt":"","text":"数据类型概述JavaScript 语言的每一个值都属于一种数据类型，最新的 ECMAScript 指出，JavaScript 共有 8种 数据类型，分别是： 七种基本数据类型： 布尔值（Boolean） 有2个值分别是：true 和 false null 一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。 undefined 和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。 数字（Number） 整数或浮点数，例如： 42 或者 3.14159。 任意精度的整数 (BigInt) 可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。 字符串（String） 字符串是一串表示文本值的字符序列，例如：”Hello World” 。 代表（Symbol） 在 ECMAScript 6 中新添加的类型。 一种实例是唯一且不可改变的数据类型。 以及对象（Object） 数据类型的转换JavaScript是一种动态类型语言。这意味着你在声明变量时可以不必指定数据类型，而数据类型会在代码执行时会根据需要自动转换。因此，可以按照如下方式来定义变量： 1let x = 1; 再给同一个变量赋予一个字符串值，例如： 1x = &#x27;Hello World&#x27;; 因为 JavaScript 是动态类型的，这种赋值方式并不会提示出错。 在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串。例如： 1let x = &#x27;The value of x is &#x27; + 1; // The value of x is 1 在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串。例如（译注：第一例是数学运算，第二例是字符串运算）： 1234&#x27;30&#x27; + 10; // &#x27;3010&#x27;&#x27;30&#x27; - 10; // 20&#x27;30&#x27; * 10; // 300&#x27;30&#x27; / 10; // 3 有一些方法可以用于数据类型之间的转换，各种对应类型的转换如下： 补充：强制类型转换JavaScript 中的强制类型转换主要指的是基本数据类型之间值的转换，而基本数据类型转成引用数据类型，则是一种封装，并非实际意义的类型转换。 转换成 String： 规则： 类型 原值 string 值 Boolean true | false ‘true’ | ‘false’ Undefined undefined ‘undefined’ Symbol Symbol(‘name’) ‘Symbol(name)’ Number 22 ‘22’ Null null ‘null’ Object {name:’bob’} ‘[object Object]’ 方法： 原生函数 String()，例如： 1String(true); // &#x27;true&#x27; 利用 + 号运算符，其中只要运算符两侧有一个操作数为字符串，该运算符将是字符串拼接功能，那么另一个操作数就会进行字符串的类型转换 123456var a = &#x27;string&#x27; + 234; // &#x27;string234&#x27;var b = &#x27;string&#x27; + null; // &#x27;stringnull&#x27;var c = &#x27;string&#x27; + &#123;&#125;; //&#x27;string[object Object]&#x27;//实际应用var d = true + &#x27;&#x27;; // &#x27;true&#x27; 除了 undefined、null 数据类型外，其它数据类型都可以使用 toString() 方法 转成 Number： 规则： 类型 原值 number值 Boolean true | false 1 | 0 Undefined undefined NaN Symbol Symbol(‘name’) 不能转换 string ‘22’ | ‘23fds’ | ‘’ 22 | NaN | 0 Null null 0 Object {name:’bob’} NaN 方法： 原生函数 Number()，例如 1Number(&#x27;234&#x27;); // 234 这个需要注意一下将字符串转化为数字：如果传入的不是只包含数字的字符串，如 ‘234fasd’,那么 Number 函数会将其转成 NaN。 parseInt：是全局对象的一个属性，在浏览器中也就是 window 对象的方法。 它看似也实现了数据类型的转换，但实则不是，它是一种数据的解析，并且只能正常解析数字和字符串的数据类型。 当传入上述中既包含数字也包含字母的字符串时，它会判断，当遇到第一个非数字的字符时，那么就会将后面的字符全抛弃掉，然后转化之前全为数字的字符串，该函数第二个参数为进制数，默认以十进制，来解析传入的值。 例如： 12parseInt(&#x27;234fasd&#x27;,10) // 234Number(&#x27;234fasd&#x27;) //NaN 在所要转换的数据前加上 ~~，~ 是一个取反运算法，这种方式的感觉就像负负得正一样，例如： 12~~&#x27;2434&#x27;; // 2434~~null; // 0 + 运算符，这个并不是用来计算数字加减或字符串拼接用的那个，而是直接放在被转换数据的前面，例如： 12+&#x27;123&#x27;; // 123+true; // 1 -、 * 、 / 、 % 运算符，和转字符串的 + 运算符，道理类似，若两侧的操作数中含有非numbe 类型时，会先转换成 number，再运算，例如： 12345var a = &#x27;123&#x27; - &#x27;3&#x27;; // 120var b = &#x27;45&#x27; - 5; // 40var c = 60 - undefined; // NaN//实际使用var c = &#x27;123&#x27; - 0; // 123 转成 Boolean： 规则： 类型 原值 boolean值 Number 非0 | 0 true | false Undefined undefined false Symbol Symbol(‘name’) true string ‘22sd’ | ‘’ true | false Null null false Object {name:’bob’} | {} | [] true | true | true 方法： 原生函数 Boolean()，例如： 1Boolean(&#x27;test&#x27;); // true 在转换的数据前加上 !!，例如： 1!!&#x27;test&#x27;; // true 各种条件判断语句（if()、else if()、while()、?: 左侧的操作数、&amp;&amp;, || 左侧的操作数）都会对传入的数据进行转 Boolean 操作。 转成 Object： 将其它基本数据类型转成引用数据类型，并不是真正的数据转换，而是一种封装。 简单说一下什么是封装：例如，我们通常会写这么一句代码：&#39; thisString &#39;.trim() 来清除字符串左右两侧的空格，但 . 运算符明明是作用在 Object 上，用来访问该对象的属性和方法的，为什么字符串这种基本数据类型也可以这么用，答案就是封装对象。 除了普通的对象外，其实还有四种基本包装对象，分别对应着基本数据类型中的 Number、String 、Boolean、Symbol，除了 Symbol，另外三种我们可以通过 new 来获取到相应的实例对象。 &#39; thisString &#39;.trim() 的详细执行过程是这样的： 12345// 创建对象let str = new String(&#x27; thisString &#x27;);str.trim();// 销毁对象str = null; 也就是它会创建一个基本包装对象，然后调用该对象上的方法，执行完成，销毁这个包装对象。那么这种基本包装对象的生命周期只存在于代码执行的那么一瞬间，之后我们不可以在运行的时候为其添加方法与属性。例如： 12345let s = &#x27; this String &#x27;;s.trim();// 下面的操作无效s.name = &#x27;ozzie&#x27;;console.log(s.name); 封装方法：直接使用js提供的Object原生函数，当传入的是上面那四种基本数据类型时，它会转成对应的基本包装对象： 引用类型转基本数据类型： 与前面封装的操作相反，对象转成基本数据类型，则是拆封。在JavaScript 标准中，规定了 ToPrimitive 函数，来实现拆封。 拆封的方法就是 Number()、String()、Boolean() 这些用来转类型的原生函数 具体的拆封过程，其实是涉及到对象valueOf和toSting函数的调用，当将一个对象转换基本数据类型时，会先调用该对象的valueOf，如果能返回基本数据类型，则进行后续的数据类型转换，否则，就继续调用toString，拿到字符串，然后进行数据类型转换。如果这两个方法都没返回基本数据类型，则抛出异常。案例如下： 先定义一个返回基本数据类型的 valueOf 方法的对象： 1234567891011121314151617// 先定义一个对象，自定义 valueOf 和 toString 方法let obj = &#123; valueOf: function() &#123; console.log(&#x27;调用了 valueOf 方法&#x27;); return &#x27;123&#x27;; &#125;, toString: function() &#123; console.log(&#x27;调用了 toString 方法&#x27;); return &#x27;123&#x27;; &#125;&#125;// 使用之前转 number 的原生函数来拆箱Number(obj);/*调用了 valueOf 方法123*/ 说明只执行了 valueOf 方法。 定义一个返回引用数据类型的 valueOf 方法的对象： 123456789101112131415161718// 先定义一个对象，自定义 valueOf 和 toString 方法let obj = &#123; valueOf: function() &#123; console.log(&#x27;调用了 valueOf 方法&#x27;); return &#123;&#125;; &#125;, toString: function() &#123; console.log(&#x27;调用了 toString 方法&#x27;); return &#x27;123&#x27;; &#125;&#125;// 使用之前转 number 的原生函数来拆箱Number(obj);/*调用了 valueOf 方法调用了 toString 方法123*/ 说明执行了 valueOf 方法以及 toString 方法。 定义一个 valueOf、toString 都返回基本数据类型的对象： 1234567891011121314151617181920// 先定义一个对象，自定义 valueOf 和 toString 方法let obj = &#123; valueOf: function() &#123; console.log(&#x27;调用了 valueOf 方法&#x27;); return &#123;&#125;; &#125;, toString: function() &#123; console.log(&#x27;调用了 toString 方法&#x27;); return &#123;&#125;; &#125;&#125;// 使用之前转 number 的原生函数来拆箱Number(obj);/*调用了 valueOf 方法调用了 toString 方法Uncaught TypeError: Cannot convert object to primitive value at Number (&lt;anonymous&gt;) at &lt;anonymous&gt;:1:1*/ 说明执行了 valueOf 方法以及 toString 方法，之后抛出了错误。 上述的几个过程就是 ToPrimitive 拆箱函数的过程。 但是，有一种特殊情况，如果是使用String()函数，它会直接调用对象的 toString 方法，而不是先 valueOf()。 4种基本包装对象都已经实现了自己的 valueOf 和 toString 方法，因此在拆箱时，能正常返回其基本数据的值。 另外，当我们对普通对象转 String 时，会看到这个东西： 12345let a = &#123;&#125;;a.toString(); // &quot;[object Object]&quot;var b = new Set();b.toString(); // &quot;[object Set]&quot; 其中第二个 Object 和 Set，实际是对象的一个私有属性 [[Class]] 的值，这个值并不能直接访问并且修改，只能通过 Object.prototype.toString() 来获取： 1234Object.prototype.toString.call(&#123;&#125;); //&quot;[object Object]&quot;Object.prototype.toString.call([]); //&quot;[object Array]&quot;Object.prototype.toString.call(new Set()); //&quot;[object Set]&quot;Object.prototype.toString.call(123); //&quot;[object Number]&quot; 字面量 字面量是由语法表达式定义的常量，或通过由一定字词组成的语词表达式定义的常量 在 JavaScript 中，可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。 字面量是常量，其值是固定的，而且在程序脚本运行中不可更改。 数组字面量 数组字面值是一个封闭在方括号对 [] 中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。 当使用数组字面值创建一个数组时，该数组将会以指定的值作为其元素进行初始化，而其长度被设定为元素的个数，例如： 12345var coffees = [&quot;French Roast&quot;, &quot;Colombian&quot;, &quot;Kona&quot;];var a = [3];console.log(a.length); // 1console.log(a[0]); // 3 注意，这里的数组字面值也是一种对象初始化器。 若在顶层（全局）脚本里用字面值创建数组，JavaScript 将会在每次对包含该数组字面值的表达式求值时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时都会被创建一次。 数组字面值同时也是数组对象。 数组字面值中的多余逗号：不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没有被指定的元素，其初始值是undefined，例如： 12let fish = [&quot;Lion&quot;, , &quot;Angel&quot;];console.log(fish[1]); // undefined 如果你在元素列表的尾部添加了一个逗号，它将会被忽略。 布尔字面量 布尔类型有两种字面量：true 和 false。 不要混淆作为布尔对象的真和假与布尔类型的原始值 true 和 false。布尔对象是原始布尔数据类型的一个包装器。 整数 整数可以用十进制（基数为10）、十六进制（基数为16）、八进制（基数为8）以及二进制（基数为2）表示： 十进制整数字面量由一串数字序列组成，且没有前缀0。 八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。 十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 af 或 AF。 二进制整数以0b（或0B）开头，只能包含数字0和1。 严格模式下，八进制整数字面量必须以0o或0O开头，而不能以0开头。 浮点数字面量 浮点数字面值可以有以下的组成部分： 一个十进制整数，可以带正负号（即前缀“+”或“ - ”）； 小数点（“.”）； 小数部分（由一串十进制数表示）； 指数部分。 指数部分以“e”或“E”开头，后面跟着一个整数，可以有正负号（即前缀“+”或“-”）。浮点数字面量至少有一位数字，而且必须带小数点或者“e”（大写“E”也可）。简言之，其语法是： 1[(+|-)][digits][.digits][(E|e)[(+|-)]digits] 例如： 12343.14-.2345789 // -0.23456789-3.12e+12 // -3.12*1012.1e-23 // 0.1*10-23=10-24=1e-24 对象字面量 对象字面值是封闭在花括号对 &#123;&#125; 中的一个对象的零个或多个 &quot;属性名-值&quot;对 的（元素）列表。 不能在一条语句的开头就使用对象字面值，这将导致错误或产生超出预料的行为， 因为此时左花括号 &#123; 会被认为是一个语句块的起始符号。 以下是一个对象字面值的例子： 1234567891011121314151617let Sales = &quot;Toyota&quot;;function CarTypes(name) &#123; return (name === &quot;Honda&quot;) ? name : &quot;Sorry, we don&#x27;t sell &quot; + name + &quot;.&quot; ;&#125;let car = &#123; myCar: &quot;Saturn&quot;, getCar: CarTypes(&quot;Honda&quot;), special: Sales&#125;;console.log(car.myCar); // Saturnconsole.log(car.getCar); // Hondaconsole.log(car.special); // Toyota 也可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值，例如： 12345678910var car = &#123; manyCars: &#123; a: &quot;Saab&quot;, &quot;b&quot;: &quot;Jeep&quot; &#125;, 7: &quot;Mazda&quot;&#125;;console.log(car.manyCars.b); // Jeepconsole.log(car[7]); // Mazda 对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的 javascript 标识符，它必须用 &quot;&quot; 包裹。属性的名字不合法，那么便不能用 . 访问属性值，而是通过类数组标记 [] 访问和赋值，例如： 12345678var unusualPropertyNames = &#123; &quot;&quot;: &quot;An empty string&quot;, &quot;!&quot;: &quot;Bang!&quot;&#125;console.log(unusualPropertyNames.&quot;&quot;); // 语法错误: Unexpected stringconsole.log(unusualPropertyNames[&quot;&quot;]); // An empty stringconsole.log(unusualPropertyNames.!); // 语法错误: Unexpected token !console.log(unusualPropertyNames[&quot;!&quot;]); // Bang! 增强的对象字面量：在ES2015，对象字面值扩展支持在创建时设置原型，简写了 foo: foo 形式的属性赋值，方法定义，支持父方法调用，以及使用表达式动态计算属性名。总之，这些也使对象字面值和类声明更加紧密地联系起来，让基于对象的设计从这些便利中更加受益，例如： 12345678910111213var obj = &#123; // __proto__ __proto__: theProtoObj, // Shorthand for ‘handler: handler’ handler, // Methods toString() &#123; // Super calls return &quot;d &quot; + super.toString(); &#125;, // Computed (dynamic) property names [ &#x27;prop_&#x27; + (() =&gt; 42)() ]: 42&#125;; 需要注意： 12345678910var foo = &#123; a: &quot;alpha&quot;, 2: &quot;two&quot;&#125;;console.log(foo.a); // alphaconsole.log(foo[2]); // two//console.log(foo.2); // SyntaxError: missing ) after argument list//console.log(foo[a]); // ReferenceError: a is not definedconsole.log(foo[&quot;a&quot;]); // alphaconsole.log(foo[&quot;2&quot;]); // two RegExp 字面量一个正则表达式是字符被正斜杠 / 围成的表达式。 下面是一个正则表达式文字的一个例子： 1let re = /ab+c/; 字符串字面量字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符。 字符串被限定在同种引号之间；也就是说，必须是成对单引号或成对双引号。下面的例子都是字符串字面值： 12345&quot;foo&quot;&#x27;bar&#x27;&quot;1234&quot;&quot;one line \\n another line&quot;&quot;John&#x27;s cat&quot; 你可以在字符串字面值上使用字符串对象的所有方法——JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似String.length的属性： 123console.log(&quot;John&#x27;s cat&quot;.length)// 将打印字符串中的字符个数（包括空格）// 结果为：10 在ES2015中，还提供了一种模板字面量，模板字符串提供了一些语法糖来帮你构造字符串。这与Perl、Python还有其他语言中的字符串插值的特性非常相似。除此之外，你可以在通过模板字符串前添加一个tag来自定义模板字符串的解析过程，这可以用来防止注入攻击，或者用来建立基于字符串的高级数据抽象。 除非有特别需要使用字符串对象，否则，最好始终使用字符串字面值。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（七）：正则的扩展","slug":"正则的扩展","date":"2021-03-20T03:49:57.000Z","updated":"2021-03-21T14:05:25.319Z","comments":true,"path":"6a62e21367ac/","link":"","permalink":"https://ozzienicholas.gitee.io/6a62e21367ac/","excerpt":"","text":"RegExp 构造函数 在ES5中，RegExp构造函数的参数有两种情况： 第一种情况：参数是字符串，这时第二个参数表示正则表达式的修饰符。 123var regexp = new RegExp(&#x27;xyz&#x27;, &#x27;i&#x27;);// 等价于var regexp = /xyz/i; 第二种情况：参数是正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regexp = new Regexp(/xyz/i);// 等价于var regexp = /xyz/i; 但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。 12var regexp = new RegExp(/xyz/i, &#x27;i&#x27;);// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 123var regexp = new RegExp(/xyz/ig, &#x27;i&#x27;);console.log(regexp); // /xyz/iconsole.log(regexp.flags); // i source 属性：返回正则表达式的正文。 12var regexp = new RegExp(/xyz/ig);console.log(regexp.source); // xyz flags 属性：ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。 12var regexp = new RegExp(/xyz/ig);console.log(regexp.flags); // gi RegExp.escape()： 字符串必须转义，才能作为正则模式。 12345678function escapeRegExp(str) &#123; return str.replace(/[\\-\\[\\]\\/\\&#123;\\&#125;\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, &#x27;\\\\$&amp;&#x27;);&#125;let str = &#x27;/path/to/resource.html?search=query&#x27;;console.log(escapeRegExp(str));console.log(str);// \\/path\\/to\\/resource\\.html\\?search=query// /path/to/resource.html?search=query 上面代码中，str是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。 有提议将这个需求标准化，作为RegExp对象的静态方法RegExp.escape()，放入ES7。但是 TC39 认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入ES7，但这不失为一个真实的需求。 12345678RegExp.escape(&#x27;The Quick Brown Fox&#x27;);// &quot;The Quick Brown Fox&quot;RegExp.escape(&#x27;Buy it. use it. break it. fix it.&#x27;);// &quot;Buy it\\. use it\\. break it\\. fix it\\.&quot;RegExp.escape(&#x27;(*.*)&#x27;);// &quot;\\(\\*\\.\\*\\)&quot; 字符串转义以后，可以使用RegExp构造函数生成正则模式。 简介正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、matchAll、replace、search 和 split 方法。 创建一个正则表达式你可以使用以下两种方法构建一个正则表达式： 方法一：使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示： 1var re = /ab+c/; 脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能，也就是说，正则表达式字面量适用于该正则表达式不变的情况。 方法二：调用RegExp对象的构造函数，如下所示： 1var re = new RegExp(&quot;ab+c&quot;); 在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式，也就是说，RegExp 构造函数更适用于该正则表达式会变的情况。 编写一个正则表达式的模式 一个正则表达式模式是由简单的字符所构成的，比如 /abc/；或者是简单和特殊字符的组合，比如 /ab*c/ 或 /Chapter (\\d+)\\.\\d*/。 最后的例子中用到了括号，它在正则表达式中常用作记忆设备。即这部分所匹配的字符将会被记住以备后续使用，例如使用括号的子字符串匹配。 使用简单模式 简单模式是由你想直接找到的字符构成。 比如，/abc/ 这个模式就能且仅能匹配 “abc” 字符按照顺序同时出现的情况，例如 “xxxabcxx”。 使用特殊字符 当你需要匹配一个不确定的字符串时，可以在模式中使用特殊字符。 比如，你可以使用 /ab*c/ 去匹配一个单独的 “a” 后面跟了零个或者多个 “b”，同时后面跟着 “c” 的字符串。* 的意思是前一项出现零次或者多次。在字符串 “cbbabbbbcdebc” 中，/ab*c/ 模式匹配到的子字符串是 “abbbbc”。 正则表达式中的特殊字符及其描述如下： \\： 在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解；但如果前面加了 \\，它将不再匹配任何字符，而是表示一个字符边界。 所以，如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。如果你只想表达一个 \\，那就请写成 \\\\，所以，/[a-z]\\s/i 等价于 new RegExp(&#39;[a-z]\\\\s&#39;, &#39;i&#39;)，即匹配到的是：在 a-z 范围内的任意字符并且后面紧跟着空白字符的表达式，这个常用作搜索字符。 若你真的想在 RegExp 构造函数中包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如：/[a-z]:\\\\/i 等价于 new RegExp(&#39;[a-z]:\\\\\\\\&#39;, &#39;i&#39;)，即匹配类似 c:\\ 的字符串。 在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解，意思就是字面意思。 ^： 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。 例如，/^A/ 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。 当 ‘^‘ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。 $： 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。 例如，/t$/ 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。 *： 匹配前一个表达式 0 次或多次。等价于 &#123;0,&#125;。 例如，/bo*/ 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。 +： 匹配前面一个表达式 1 次或者多次。等价于 &#123;1,&#125;。 例如，/a+/ 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。 ?： 匹配前面一个表达式 0 次或者 1 次。等价于 &#123;0,1&#125;。 例如，/e?le?/ 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。 如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 /\\d+/ 将会匹配 “123”，而使用 /\\d+?/ 则只会匹配到 “1”。 还用于先行断言中，如本表的 x(?=y) 和 x(?!y) 条目所述。 .： （小数点）默认匹配除换行符之外的任何单个字符。 例如，/.n/ 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。 如果 s (“dotAll”) 标志位被设为 true，它也会匹配换行符。 (x)： 像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。 模式 /(foo) (bar) \\1 \\2/ 中的 ‘(foo)‘ 和 ‘(bar)‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 \\1 和 \\2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，匹配了原字符串中的后两个单词。注意 \\1、\\2、…、\\n 是用在正则表达式的匹配环节，详情可以参阅后文的 \\n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、…、$n 这样的语法，例如，&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)。$&amp; 表示整个用于匹配的原字符串。 (?:x)： 匹配 ‘x’ 但是不记住匹配项。这种括号叫作非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 /(?:foo)&#123;1,2&#125;/。如果表达式是 /foo&#123;1,2&#125;/，&#123;1,2&#125; 将只应用于 ‘foo’ 的最后一个字符 ‘o’。如果使用非捕获括号，则 &#123;1,2&#125; 会应用于整个 ‘foo’ 单词。 x(?=y)： 匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。 例如，/Jack(?=Sprat)/会匹配到’Jack’仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。 (?&lt;=y)x： 匹配’x’仅当’x’前面是’y’.这种叫做后行断言。 例如，/(?&lt;=Jack)Sprat/会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。/(?&lt;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。 x(?|y)： 仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。 例如，仅仅当这个数字后面没有跟小数点的时候，/\\d+(?!.)/ 匹配一个数字。正则表达式/\\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’。 (?&lt;!y)x： 仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。 例如, 仅仅当这个数字前面没有负号的时候，/(?&lt;!-)\\d+/ 匹配一个数字。 /(?&lt;!-)\\d+/.exec(&#39;3&#39;) 匹配到 “3” /(?&lt;!-)\\d+/.exec(&#39;-3&#39;) 因为这个数字前有负号，所以没有匹配到 x|y： 匹配‘x’或者‘y’。 例如，/green|red/ 匹配 “green apple ”中的 ‘green’ 和 “red apple” 中的 ‘red’。 &#123;n&#125;： n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。 比如，/a&#123;2&#125;/ 不会匹配 “candy” 中的 ‘a’，但是会匹配 “caandy” 中所有的 a，以及 “caaandy” 中的前两个’a’。 &#123;n,&#125;： n是一个正整数，匹配前一个字符至少出现了n次。 例如，/a&#123;2,&#125;/ 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。 &#123;n,m&#125;： n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。 例如，/a&#123;1, 3&#125;/ 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。 [xyz]： 一个字符集合。匹配方括号中的任意字符，包括转义序列。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。 例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\\w.]+/与字符串“test.i.ng”匹配。 [*xyz]： 一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。 例如，[^abc] 和 [^a-c] 是一样的，他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。 [\\b]： 匹配一个退格(U+0008)。 注意，记得不要和 \\b 混淆了。 \\b： 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和 [\\b] 混淆了） 使用”moon”举例： /\\bm/匹配“moon”中的‘m’； /oo\\b/并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。 /oon\\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。 /\\w\\b\\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。 注意： JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。 不在该集合中的任何字符都被认为是一个断词。 这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。 \\B： 匹配一个非单词边界。匹配如下几种情况： 字符串第一个字符为非“字”字符 字符串最后一个字符为非“字”字符 两个单词字符之间 两个非单词字符之间 空字符串 例如，/\\B../ 匹配”noonday”中的’oo’, 而 /y\\B../ 匹配”possibly yesterday”中的’yes‘ \\cX： 当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。 例如，/\\cM/ 匹配字符串中的 control-M (U+000D)。 \\d： 匹配一个数字，等价于 [0-9]。 例如， /\\d/ 或者 /[0-9]/ 匹配”B2 is the suite number.”中的’2’。 \\D： 匹配一个非数字字符，等价于[^0-9]。 例如， /\\D/ 或者 /[^0-9]/ 匹配”B2 is the suite number.”中的’B’ 。 \\f： 匹配一个换页符 (U+000C)。 \\n： 匹配一个换行符 (U+000A)。 \\r： 匹配一个回车符 (U+000D)。 \\s： 匹配一个空白字符，包括空格、制表符、换页符和换行符。 等价于： 1[ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] 例如, /\\s\\w*/ 匹配”foo bar.”中的’ bar’。 \\S： 匹配一个非空白字符。 等价于： 1[^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] 例如，/\\S\\w*/ 匹配”foo bar.”中的’foo’。 \\t： 匹配一个水平制表符 (U+0009)。 \\v： 匹配一个垂直制表符 (U+000B)。 \\w： 匹配一个单字字符（字母、数字或者下划线）。 等价于： 1[A-Za-z0-9_] 例如, /\\w/ 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。 \\W： 匹配一个非单字字符。 等价于： 1[^A-Za-z0-9_] 例如, /\\W/ 或者 /[^A-Za-z0-9_]/ 匹配 “50%.” 中的 ‘%’。 \\n： 在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。 比如 /apple(,)\\sorange\\1/ 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。 \\0： 匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 \\0&lt;digits&gt; 是一个八进制转义序列。 \\xhh： 匹配一个两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhh： 匹配一个四位十六进制数表示的 UTF-16 代码单元。 u&#123;hhhh&#125; 或者 \\u&#123;hhhhh&#125;： （仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。 转义 如果你需要使用任何特殊字符的字面值（例如，搜索字符’*’） 你必须通过在它前面放一个反斜杠来转义它。 例如，要搜索’a’后跟 * 后跟’b’，你应该使用 /a\\*b/- 反斜杠“转义”字符’*’，使其成为文字而非特殊符号。 类似地，如果您正在编写正则表达式文字并且需要匹配斜杠（’/‘），那么需要转义它（否则，斜杠是正则终止符）。 例如，要搜索字符串“/ example /”后跟一个或多个字母字符，您需要使用/\\/example\\/[a-z]+/i——每个斜杠之前使用反斜杠使它们成为普通字符。 要匹配文本符号反斜杠，您需要转义反斜杠。 例如，要匹配字符串“C:\\”，其中“C”可以是任何字母，您将使用/[A-Z]:\\\\/ —— 第一个反斜杠转义后面的那个反斜杠，因此表达式搜索单个普通字符反斜杠。 如果将RegExp构造函数与字符串文字一起使用，请记住反斜杠是字符串文字中的转义，因此要在正则表达式中使用它，您需要在字符串文字级别转义它。 /a\\*b/ 和new RegExp(&quot;a\\\\*b&quot;)创建的表达式是相同的，搜索“a”后跟文字“*”后跟“b”。 将用户输入转义为正则表达式中的一个字面字符串，可以通过简单的替换来实现： 1234function escapeRegExp(string) &#123; return string.replace(/[.*+?^$&#123;&#125;()|[\\]\\\\]/g, &quot;\\\\$&amp;&quot;); // $&amp; 表示整个被匹配的字符串&#125; 正则表达式后的”g”是一个表示全局搜索选项或标记，将在整个字符串查找并返回所有匹配结果。 使用插入语 任何正则表达式的插入语都会使这部分匹配的副字符串被记忆。一旦被记忆，这个副字符串就可以被调用于其它用途。 比如， /Chapter (\\d+)\\.\\d*/ 解释了额外转义的和特殊的字符，并说明了这部分pattern应该被记忆。它精确地匹配后面跟着一个以上数字字符的字符 ‘Chapter ‘ (\\d 意为任何数字字符，+ 意为1次以上)，跟着一个小数点（在这个字符中本身也是一个特殊字符；小数点前的 \\ 意味着这个pattern必须寻找字面字符 ‘.’)，跟着任何数字字符0次以上。 (\\d 意为数字字符， * 意为0次以上)。另外，插入语也用来记忆第一个匹配的数字字符。 此模式可以匹配字符串”Open Chapter 4.3, paragraph 6”，并且’4’将会被记住。此模式并不能匹配”Chapter 3 and 4”，因为在这个字符串中’3’的后面没有点号’.’。 括号中的”?:”，这种模式匹配的子字符串将不会被记住。比如，(?:\\d+)匹配一次或多次数字字符，但是不能记住匹配的字符。 使用正则表达式 正则表达式可以被用于 RegExp 的 exec 和 test 方法以及 String 的 match、replace、search 和 split 方法，如下： 方法 描述 exec 一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。 test 一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。 match 一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。 matchAll 一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。 search 一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。 replace 一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。 split 一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方法。 在接下来的例子中，脚本将使用exec方法在一个字符串中查找一个匹配。 12var myRe = /d(b+)d/g;var myArray = myRe.exec(&quot;cdbbdbsbz&quot;); 总结如下： 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法； 想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。 如果你使用exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象。 如果匹配失败，那么 exec 方法返回 null（也就是false）。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（六）：语句与声明","slug":"流程控制与错误处理","date":"2021-03-20T03:49:57.000Z","updated":"2021-03-21T14:02:13.370Z","comments":true,"path":"2ca46689117e/","link":"","permalink":"https://ozzienicholas.gitee.io/2ca46689117e/","excerpt":"","text":"JavaScript 应用程序是由许多语法正确的语句组成的。单个语句可以跨多行。 如果每个语句用分号隔开，那么多个语句可以在一行中出现。 以下内容按类别分类叙述 流程控制语句block 描述：一个块语句可以用来管理零个或多个语句，该区块是由一对大括号分隔，也可以是 label 语句。 语法： 块声明： 1&#123; StatementList &#125; StatementList：在块语句中分组的语句。 标记声明： 1LabelIdentifier: &#123; StatementList &#125; LabelIdentifier：用于视觉识别的可选 label 或 break 的目标。 块级作用域： 通过 var 声明的变量或者非严格模式下创建的函数声明没有块级作用域。此时，在语句块里声明的变量的作用域不仅是其所在的函数或者 script 标签内，所设置变量的影响会在超出语句块本身之外持续存在。 例如： 12345var x = 1;&#123; var x = 2;&#125;console.log(x); // 2 使用 let 与 const： 与 var 相比，使用 let 和 const 声明的变量是有块级作用域的： 12345let x = 1;&#123; let x = 2;&#125;console.log(x); // 1 12345const x = 1;&#123; const x = 2;&#125;console.log(x); // 1 注意这里的两次 const 声明并没有报错，并没有报出 SyntaxError: Identifier &#39;x&#39; has already been declared 的语法错误提示信息，因为 const 是有块级作用域的，而在它自己的块内，它是唯一被声明的常量。 使用 let 声明的变量在块级作用域内能强制执行更新变量，下面的两个例子对比： 123456789 var a = []; for(var i=0; i&lt;10; i++) &#123;a[i] = function() &#123; console.log(i); &#125; &#125; a[0](); // 10 a[1](); // 10 a[6](); // 10 123456789var a = [];for(let i=0; i&lt;10; i++) &#123; a[i] = function() &#123; console.log(i); &#125;&#125;a[0](); // 0a[1](); // 1a[6](); // 6 使用 function：函数声明同样也被限制在其他的语句块内： 1234567fun(&#x27;ozzie&#x27;); // TypeError: fun is not a function&#123; function fun(name) &#123; console.log(name); &#125; fun(&#x27;nicholas&#x27;); // 打印 nicholas&#125; break 描述：终止当前的循环，例如 switch 或 label 语句，使程序跳到下一个语句执行。 语法： 1break [label]; label：可选，这是与语句标签相关联的标识符。如果 break 语句不在一个循环或 switch 语句中，则该项是必须的。 break语句包含一个可选的标签，可允许程序摆脱一个被标记的语句。break语句需要内嵌在引用的标签中。被标记的语句可以是任何块语句，不一定是循环语句。 break语句不能在function函数体中直接使用，break语句应嵌套在要中断的当前循环、switch或label语句中。 案例： 在 while 语句中： 1234567891011function fun(x) &#123; let i = 0; while(i&lt;10) &#123; if(i == 3) &#123; break; &#125; i += 1; &#125; return i*x;&#125;console.log(fun(10)); // 30 在 switch 语句中： 123456789101112const fruit = &#x27;apple&#x27;;switch(fruit) &#123; case &#x27;apple&#x27;: console.log(&#x27;apple&#x27;); // apple break; case &#x27;orange&#x27;: console.log(&#x27;orange&#x27;); break; default: console.log(&#x27;no answer&#x27;); break;&#125; 在 label 语句中：下面的代码中一起使用 break 语句和被标记的块语句。一个 break 语句必须内嵌在它引用的标记中。注意，inner_block 内嵌在 outer_block 中。 12345678outer_block: &#123; inner_block: &#123; console.log(&#x27;a&#x27;); // a break inner_block; console.log(&#x27;b&#x27;); &#125; console.log(&#x27;c&#x27;); // c&#125; 在 label 语句中使用时发生了异常错误：下面的代码同样使用了 break 语句和被标记的块语句，但是产生了一个语法错误，因为它的 break 语句在 block_1 中，但是引用了 block_2。break 语句必须内嵌在它引用的标签中。 12345678block_1: &#123; console.log(&#x27;a&#x27;); break block_2;&#125;block_2: &#123; console.log(&#x27;b&#x27;);&#125;// SyntaxError: Undefined label &#x27;block_2&#x27; 在函数体中使用时也发生了异常错误：在下面的代码同样会产生SyntaxError，因为它并没被正确的使用在循环、switch或label语句中。 1234567891011121314function fun(x) &#123; let i = 0; while(i&lt;10) &#123; if(i == 3) &#123; (function() &#123; break; &#125;()); &#125; i += 1; &#125; return i*x;&#125;console.log(fun(10));// SyntaxError: Illegal break statement 1234567block_1: &#123; console.log(&#x27;a&#x27;); (function() &#123; break block_1; &#125;)();&#125;// SyntaxError: Undefined label &#x27;block_1&#x27; continue 描述： 与 break 语句的区别在于， continue 并不会终止循环的迭代，而是： 在 while 循环中，控制流跳转回条件判断； 在 for 循环中，控制流跳转到更新语句。 continue 语句可以包含一个可选的标号以控制程序跳转到指定循环的下一次迭代，而非当前循环。此时要求 continue 语句在对应的循环内部。 案例： 在 while 语句中：下述例子展示了一个在 i 为 3时执行continue 语句的 while 循环。最终 n 为 0+1+2+4+5 = 12。 12345678910let i = 0, n = 0;while(i&lt;5) &#123; i ++; if(i == 3) &#123; continue; &#125; n += i;&#125;console.log(n); // 12 在 label 语句中：在下面的例子中，被标记为 check_i_j 的语句包含一个被标记为 check_j 的语句。当遇到 continue 语句时，程序回到 check_j 语句的开始继续执行。每次遇到 continue 时，再次执行 check_j ，直到条件判断返回 false 。之后完成 check_i_j 语句剩下的部分。 1234567891011121314151617181920212223242526let i = 0, j = 8;check_i_j: while(i&lt;4) &#123; console.log(&#x27;i = &#x27; + i, &#x27;j = &#x27; + j); i += 1; check_j: while(j&gt;4) &#123; console.log(&#x27;i = &#x27; + i, &#x27;j = &#x27; + j); j -= 1; if((j%2) == 0) &#123; continue check_j; &#125; console.log(j + &#x27; is odd&#x27;) &#125;&#125;/*i = 0 j = 8i = 1 j = 87 is odd i = 1 j = 7i = 1 j = 65 is odd i = 1 j = 5i = 1 j = 4i = 2 j = 4i = 3 j = 4*/ empty 描述：空语句用来表明没有语句。 语法： 1; 空语句是一个分号（;），表示不会执行任何语句，即使 JavaScript 语法需要一个语句。 相反，当你需要多行语句，但 JavaScript 只允许一个时，可以使用语句块；语句块可以将多条语句合并为一个。 案例： 空语句有时与循环语句一起使用。以下示例使用空循环体： 123let arr = [1, 2, 3];for(let i=0; i&lt;arr.length; arr[i++]=0); // 此处为空语句console.log(arr); // [0, 0, 0] 在使用空语句时，尽量专门为其写上注释，因为不是很容易区分空语句和普通的分号。 if...else 语句不带花括号（&#123;&#125;）。如果three为true, 不会发生任何事，four不会执行，同时else从句中的launchRocket()函数也不会执行： 12345678910if(one) doOne();else if(two) doTwo();else if(three) ;else if(four) doFour();else launchRocket(); if…else 描述：当指定条件为真，if 语句会执行一段语句。如果条件为假，则执行另一段语句。 语法： 1234if (condition) statement1[else statement2] condition：值为真或假的表达式 statement1：当 condition 为真时执行的语句。 可为任意语句，包括更深层的内部 if 语句。 要执行多条语句，使用块语句（{ … }）将这些语句分组； 若不想执行语句，则使用空语句。 statement2：如果 condition 为假且 else 从句存在时执行的语句。 可为任意语句，包括块语句和嵌套的 if 语句。 说明： 多层 if...else 语句可使用 else if 从句。注意：在 Javascript 中没有 elseif （一个单词）关键字。 123456789if (condition1) statement1else if (condition2) statement2else if (condition3) statement3/* ... */else statementN 要看看它如何工作，可以调整下嵌套的缩进： 12345678if (condition1) statement1else if (condition2) statement2 else if (condition3)/* ... */ 要在一个从句中执行多条语句，尽量使用语句块（&#123; ... &#125;： 12345if (condition) &#123; statements1&#125; else &#123; statements2&#125; 不要将原始布尔值的true和false与Boolean对象的真或假混淆。任何一个值，只要它不是 undefined、null、 0、NaN或空字符串（&quot;&quot;），那么无论是任何对象，即使是值为假的Boolean对象，在条件语句中都为真。例如： 12let x = new Boolean(false);if(x) // 表达式的值为true 案例： 使用 if…else： 12345if(1 == 1) &#123; console.log(&#x27;yes&#x27;)&#125; else &#123; console.log(&#x27;no&#x27;)&#125; 使用 else…if： 1234567if(1 &gt; 2) &#123; console.log(&#x27;1 &gt; 2&#x27;);&#125; else if (1 == 2) &#123; console.log(&#x27;1 == 2&#x27;);&#125; else &#123; console.log(&#x27;1 &lt; 2&#x27;);&#125; // 1 &lt; 2 注意，Javascript中没有elseif语句。但可以使用else和if中间有空格的语句。 关于条件表达式中的赋值运算：建议不要在条件表达式中单纯的使用赋值运算，因为粗看下赋值运算的代码很容易让人误认为是等性比较。比如，不要使用下面示例的代码： 123if (x = y) &#123; /* do the right thing */&#125; 如果需要在条件表达式中使用赋值运算，用圆括号包裹赋值运算。例如： 123if ((x = y)) &#123; /* do the right thing */&#125; switch 描述：switch 语句评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句。 语法： 123456789101112131415switch (expression) &#123; case value1: // 当 expression 的结果与 value1 匹配时，执行此处语句 [break;] case value2: // 当 expression 的结果与 value2 匹配时，执行此处语句 [break;] ... case valueN: // 当 expression 的结果与 valueN 匹配时，执行此处语句 [break;] [default: // 如果 expression 与上面的 value 值都不匹配，执行此处语句 [break;]]&#125; expression：一个用来与 case 子语句匹配的表达式。 case valueN：用于匹配 expression 的 case 子句。如果 expression 与给定的 valueN 相匹配，则执行该 case 子句中的语句，直到该 switch 语句结束或遇到一个 break 。 default：一个 default 子句；如果给定，这条子句会在 expression 的值与任一 case 语句均不匹配时执行。 说明： 一个 switch 语句首先会计算其 expression 。然后，它将从第一个 case 子句开始直到寻找到一个其表达式值与所输入的 expression 的值所相等的子句（使用 严格运算符 ===）并将控制权转给该子句，执行相关语句。（如果多个 case 与提供的值匹配，则选择匹配的第一个 case，即使这些 case 彼此间并不相等。） 如果没有 case 子句相匹配，程序则会寻找那个可选的 default 子句，如果找到了，将控制权交给它，执行相关语句。若没有 default 子句，程序将继续执行直到 switch 结束。按照惯例，default 子句是最后一个子句，不过也不需要这样做。 可选的 break 语句确保程序立即从相关的 case 子句中跳出 switch 并接着执行 switch 之后的语句。若 break 被省略，程序会继续执行 switch 语句中的下一条语句。 案例： 使用 switch： 1234567891011121314151617181920let x = 1;switch(x) &#123; case true: console.log(true); break; case 0: console.log(0); break; case 1: console.log(1); case 2: console.log(2); break; case 3: console.log(3); default: console.log(&#x27;无&#x27;);&#125;// 1// 2 匹配到 1 之后，因为没有 break，就继续执行之后的语句，直到遇到第一个 break，如果之后一个 break 都没有，那么就全部都执行。 注意，匹配 case 中的语句，使用的是严格运算符 ===，所以 case true 之后的语句并不会执行，因为 1 并不全等于 true。 如果忘记 break 会怎么样？如果忘记添加 break，那么代码将会从值所匹配的 case 语句开始运行，然后持续执行下一个 case 语句而不论值是否匹配。例子如下： 123456789101112131415161718let x = 1;switch(x) &#123; case 0: console.log(0); break; case 1: // x 的值为 1 所以匹配这里所以这一块会运行 console.log(1); // 注意：那个没写的 break 原本在这儿 case 2: // &#x27;case 1:&#x27; 里没有 break 语句所以这个 case 也会运行 console.log(2); break; // 遇到了 break，所以不会再继续进入 &#x27;case 3:&#x27; 了 case 3: console.log(3); default: console.log(&#x27;无&#x27;);&#125;// 1// 2 能把 default 放到 case 之间吗？可以啊，比如，我们根据 case 能否匹配成功分开讨论一下： 如果能在 case 中匹配成功，那就看 default 的位置 以及有没有 break 语句的情况，假设全部不设 break 语句，那么，如果 default 在匹配成功之前，就不执行，如果在匹配成功之后，就执行，对比以下几种情况： 12345678910111213141516// 一般习惯，我们会这样写，即 default 在最后面let x = 1;switch(x) &#123; case 1: // 匹配成功 console.log(1); // 这里没有 break，继续执行之后的语句 case 2: // 执行 console.log(2); // 这里没有 break，继续执行之后的语句 default: // 执行 console.log(&#x27;无&#x27;); // 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch&#125;// 1// 2// 无 123456789101112131415let x = 1;switch(x) &#123; case 1: // 匹配成功 console.log(1); // 这里没有 break，继续执行之后的语句 default: // 执行 console.log(&#x27;无&#x27;); // 这里没有 break，继续执行之后的语句 case 2: // 执行 console.log(2); // 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch&#125;// 1// 无// 2 1234567891011121314let x = 1;switch(x) &#123; default: // 后面能匹配成功，default 语句不在匹配成功的语句之后，就不执行 console.log(&#x27;无&#x27;); break; // 这里虽然有 break，但是这个 break 压根没有用 case 1: // 匹配成功 console.log(1); // 这里没有 break，继续执行之后的语句 case 2: // 执行 console.log(2); // 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch&#125;// 1// 2 当然，如果有 break 出现，那就先看 break 的情况了。 如果在 case 中匹配不成功，那么也会跳转到 default，对比以下几种情况： 123456789101112// 一般习惯，我们会这样写，即 default 在最后面let x = 1;switch(x) &#123; case 0: // 匹配不成功 console.log(0); case 2: // 匹配不成功 console.log(2); default: // 之前匹配都不成功，这里就默认执行 console.log(&#x27;无&#x27;); // 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch&#125;// 无 123456789101112131415let x = 1;switch(x) &#123; default: // 下面匹配都不成功，这里就默认执行 console.log(&#x27;无&#x27;); // 这里没有 break，所以会继续执行下面的语句 case 0: // 执行 console.log(0); // 这里没有 break，继续执行之后的语句 case 2: // 执行 console.log(2); // 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch&#125;// 无// 0// 2 使用多准则 case 的方法：（此技术来自于：Stack Overflow | Switch statement multiple cases in JavaScript ） 多 case —— 单一操作（这种方法是基于：如果 case 语句之下没有 break ，它将继续执行下一个 case 语句，而不管 case 是否符合条件）：下面是一个单操作顺序的 switch 语句，其中四个不同的值的执行结果完全一样： 1234567891011let num = 1;switch(num) &#123; case 0: case 1: // 匹配成功 console.log(&#x27;匹配成功&#x27;); break; case 2: default: console.log(&#x27;匹配失败&#x27;);&#125;// 匹配成功 多 case —— 关联操作：下面是一个关联操作顺序的 switch 语句，其中，根据所输入的整数，你会得到不同的输出。这表示它将以你放置 case 语句的顺序遍历，并且不必是数字顺序的。在 JavaScript 中，你甚至可以将字符串定义到这些 case 语句里。 123456789101112131415161718192021222324let num = 1;let output = &#x27;Output: &#x27;;switch(num) &#123; case 0: output += &#x27;So &#x27;; case 1: // 匹配成功 output += &#x27;What &#x27;; output += &#x27;Is &#x27;; case 2: output += &#x27;Your &#x27;; case 3: output += &#x27;Name &#x27;; case 4: output += &#x27;?&#x27;; console.log(output); break; case 5: output += &#x27;!&#x27;; console.log(output); break; default: console.log(&#x27;Over&#x27;);&#125;// Output: What Is Your Name ? 这个例子的输出是： num 输出 foo is NaN or not 1, 2, 3, 4, 5 or 0 Over 0 Output: So What Is Your Name ? 1 Output: What Is Your Name ? 2 Output: Your Name ? 3 Output: Name ? 4 Output: ? 5 Output: ! switch 语句内的块级作用域：随着绝大多数现代浏览器已支持 ECMAScript 2015 (ES6)，在某些场景下您可能需要使用 let 和 const 语句，以在块级作用域内声明变量。例如： 12345678910111213const num = 1;switch(num) &#123; case 0: let message = &#x27;The value is 1&#x27;; console.log(message); break; case 1: let message = &#x27;The value is 1&#x27;; break; default: console.log(&#x27;No answer&#x27;);&#125;// 报错：SyntaxError: Identifier &#x27;message&#x27; has already been declared 这是因为第一个 let message 与第二个 let message 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 case 0: 和 case 1:。导致这一问题的根本原因在于两个 let 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明。 因为 let、const 都是有块作用域的，所以我们可以把 case 语句包装到括号里面： 1234567891011121314151617const num = 1;switch(num) &#123; case 0: &#123; let message = &#x27;The value is 1&#x27;; console.log(message); break; &#125; case 1: &#123; let message = &#x27;The value is 1&#x27;; console.log(message); break; &#125; default: &#123; console.log(&#x27;No answer&#x27;); &#125;&#125;// The value is 1 throw 描述：throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。 语法： 1throw expression; 使用 throw 语句来抛出一个异常。当你抛出异常时，expression 指定了异常的内容。下面的每行都抛出了一个异常： 123throw &quot;Error2&quot;; // 抛出了一个值为字符串的异常throw 42; // 抛出了一个值为整数42的异常throw true; // 抛出了一个值为true的异常 注意throw语句同样受到自动分号插入（ASI）机制的控制，在throw关键字和值之间不允许有行终止符。也就是说，不可以写成： 123throw&quot;Error&quot;;// SyntaxError: Illegal newline after throw 案例： 你可以在抛出异常时指定一个对象，然后可以在 catch 块中引用对象的属性。 下面创建了一个类型为UserException的对象，并在throw语句中使用它： 123456789101112131415161718192021function UserException(message) &#123; this.message = message; this.name = &#x27;UserException&#x27;; &#125; function getMonthName(month) &#123; month -= 1; // 调整月份数字到数组索引 (1=Jan, 12=Dec) let months = [&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;]; if(months[month] !== undefined) &#123; return months[month]; &#125; else &#123; throw new UserException(&#x27;InvalidMonth&#x27;) &#125; &#125; try &#123; let myMonth = 15; // 15 超出边界并引发异常 let monthName = getMonthName(month); &#125; catch (e) &#123; let monthName = &#x27;unknown&#x27;; console.log(e.message, e.name); &#125; 下面的示例中测试一个字符串是否是美国邮政编码。如果邮政编码是无效的，那么throw语句将会抛出一个类型为 ZipCodeFormatException的异常对象实例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * 创建 ZipCode 示例. * * 可被接受的邮政编码格式: * 12345 * 12345-6789 * 123456789 * 12345 6789 * * 如果构造函数参数传入的格式不符合以上任何一个格式，将会抛出异常。 */function ZipCode(zip) &#123; zip = new String(zip); pattern = /[0-9]&#123;5&#125;([- ]?[0-9]&#123;4&#125;)?/; if(pattern.test(zip)) &#123; // zip 将会匹配 pattern 规则 this.value = zip.match(pattern)[0]; // 返回匹配的结果 this.valueOf = function() &#123; return this.value; &#125; this.toString = function() &#123; return String(this.value); &#125; &#125; else &#123; // 匹配不成功时，则抛出异常 throw new ZipCodeFormatException(zip); &#125;&#125;function ZipCodeFormatException(zip) &#123; this.zip = zip; this.message = &#x27;不是正确的邮政编码&#x27;; this.toString = function() &#123; return this.zip + this.message; &#125;&#125;const ZIPCODE_INVALID = -1;const ZIPCODE_UNKNOWN_ERROR = -2;function verifyZipCode(zip) &#123; try &#123; zip = new ZipCode(zip); &#125; catch (error) &#123; if(error instanceof ZipCodeFormatException) &#123; return ZIPCODE_INVALID; &#125; else &#123; return ZIPCODE_UNKNOWN_ERROR; &#125; &#125; return zip;&#125;console.log(verifyZipCode(9560)); // -1console.log(verifyZipCode(95060)); // ZipCode &#123; value: &#x27;95060&#x27;, valueOf: [Function], toString: [Function] &#125;console.log(verifyZipCode(&#x27;a&#x27;)); // -1console.log(verifyZipCode(&#x27;95060&#x27;)); // ZipCode &#123; value: &#x27;95060&#x27;, valueOf: [Function], toString: [Function] &#125;console.log(verifyZipCode(&#x27;95060 1234&#x27;)); // ZipCode &#123; value: &#x27;95060 1234&#x27;, valueOf: [Function], toString: [Function] &#125; 下面的例子捕捉了一个异常值为数字的异常，并在其值大于50后重新抛出异常。重新抛出的异常传播到闭包函数或顶层，以便用户看到它： 12345678910try &#123; throw num; // 抛出一个数值异常&#125; catch (error) &#123; if(error &lt;= 50) &#123; // 异常在 1-50 之间时，直接处理 &#125; else &#123; // 异常无法处理，重新抛出 throw error; &#125;&#125; try…catch 描述：**try...catch** 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。 语法： 12345678910111213try &#123; try_statements&#125;[catch (exception_var_1 if condition_1) &#123; // non-standard catch_statements_1&#125;]...[catch (exception_var_2) &#123; catch_statements_2&#125;][finally &#123; finally_statements&#125;] try_statements：需要被执行的语句。 catch_statements_1, catch_statements_2：如果在 try 块里有异常被抛出时执行的语句。 exception_var_1, exception_var_2：用于保存关联catch子句的异常对象的标识符。 condition_1：一个条件表达式。 finally_statements：在try语句块之后执行的语句块。无论是否有异常抛出或捕获这些语句都将执行。 说明： try语句包含了由一个或者多个语句组成的try块, 和至少一个catch块或者一个finally块的其中一个，或者两个兼有， 下面是三种形式的try声明： try...catch try...finally try...catch...finally catch子句包含try块中抛出异常时要执行的语句。也就是，你想让try语句中的内容成功， 如果没成功，你想控制接下来发生的事情，这时你可以在catch语句中实现。 如果在try块中有任何一个语句（或者从try块中调用的函数）抛出异常，控制立即转向catch子句。如果在try块中没有异常抛出，会跳过catch子句。 finally子句在try块和catch块之后执行但是在下一个try声明之前执行。无论是否有异常抛出或捕获它总是执行。 你可以嵌套一个或者更多的try语句。如果内部的try语句没有catch子句，那么将会进入包裹它的try语句的catch子句。 无条件的 catch 块：当使用单个无条件catch子句时，抛出的任何异常时都会进入到catch块。例如，当在下面的代码中发生异常时，控制转移到catch子句。 1234567try &#123; throw &#x27;myException&#x27;; // 生成一个异常&#125; catch (error) &#123; // 语句来处理任何异常 console.log(error); // 将异常对象传递给错误处理程序&#125;// myException catch块指定一个标识符（在上面的示例中为 error），该标识符保存由throw语句指定的值。 catch块是唯一的，因为当输入catch块时，JavaScript 会创建此标识符，并将其添加到当前作用域；标识符仅在catch块执行时存在；catch块执行完成后，标识符不再可用。 条件 catch 块： 此特性是非标准的，请尽量不要在生产环境中使用它。 你也可以用一个或者更多条件catch子句来处理特定的异常。在这种情况下，当异常抛出时将会进入合适的catch子句中。在下面的代码中，try块的代码可能会抛出三种异常：TypeError，RangeError和EvalError。当一个异常抛出时，控制将会进入与其对应的catch语句。如果这个异常不是特定的，那么控制将转移到无条件catch子句。 当用一个无条件catch子句和一个或多个条件语句时，无条件catch子句必须放在最后。否则当到达条件语句之前所有的异常将会被非条件语句拦截。 提醒：这个功能不符合 ECMAscript 规范。 例如： 123456789101112try &#123; myroutine(); // 下面这种 catch 写法，可能抛出三种类型的异常&#125; catch (error if error instanceof TypeError) &#123; // 处理TypeError异常的语句&#125; catch (error if error instanceof RangeError) &#123; // 处理RangeError异常的语句&#125; catch (error if error instanceof EvalError) &#123; // 处理EvalError异常的语句&#125; catch (error) &#123; // 用于处理任何未指定异常的语句 console.log(error); // 将异常对象传递给错误处理程序&#125; 下面用符合 ECMAscript 规范的简单的 JavaScript 来编写相同的“条件catch子句”（显然更加冗长的，但是可以在任何地方运行）： 123456789try &#123; myRoutine();&#125; catch (error) &#123; if (error instanceof RangeError) &#123; // 语句来处理这个非常常见的预期错误 &#125; else &#123; throw error; // 不变地重新抛出错误 &#125;&#125; 异常标识符：当try块中的抛出一个异常时， *exception_var*（如catch (error)中的error）用来保存被抛出声明指定的值。你可以用这个标识符来获取关于被抛出异常的信息。这个标识符是catch子语句内部的。换言之，当进入catch子语句时标识符创建，catch子语句执行完毕后，这个标识符将不再可用。例如： 12345678function isValidJSON(text) &#123; try &#123; JSON.parse(text); return true; &#125; catch (error) &#123; return false; &#125;&#125; finally 块：finally块包含的语句在try块和catch之后，try..catch..finally块后的语句之前执行。请注意，无论是否抛出异常finally子句都会执行。此外，如果抛出异常，即使没有catch子句处理异常，finally子句中的语句也会执行。 一个简单的例子： 12345678910try &#123; let x = 1; console.log(x);&#125; catch (error) &#123; console.log(error);&#125; finally &#123; console.log(&#x27;即使没有抛出异常，finally 中的语句也会被执行&#x27;);&#125;// 1// 即使没有抛出异常，finally 中的语句也会被执行 以下示例打开一个文件，然后执行使用该文件的语句（服务器端 JavaScript 允许您访问文件）。如果文件打开时抛出异常，则finally子句会在脚本失败之前关闭该文件。finally中的代码最终也会在try或catch block显式返回时执行。 123456openMyFile();try &#123; writeMyFile(theData); // 执行文件中的语句&#125; finally &#123; closeMyFile(); // 关闭文件&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（四）：String对象","slug":"JavaScript（四）：String对象","date":"2021-03-20T03:48:34.000Z","updated":"2021-03-20T03:49:05.214Z","comments":true,"path":"025e8cf7d9f8/","link":"","permalink":"https://ozzienicholas.gitee.io/025e8cf7d9f8/","excerpt":"","text":"初识js字符串 JavaScript 字符串用于存储和处理文本 字符串的创建： 通常，JavaScript 字符串是原始值，通过字面方式创建，但是字符串也可通过关键词 new 定义为对象： 1234567891011121314// 通过字面量创建var x = &quot;Bill&quot;;console.log(typeof x); // string// 通过关键字创建var y = new String(&quot;Bill&quot;);console.log(typeof y); // object// 请不要把字符串创建为对象，它会拖慢执行速度，new 关键字会使代码复杂化，也可能产生意外的结果console.log(x == y); // true，因为值相等console.log(x === y); // false，因为类型不相同var z = new String(&quot;Bill&quot;);consolellog(y === z); // false，因为 y 与 z 是不用的对象consolellog(y == z); // false，因为 y 与 z 是不用的对象 字符串是插入到单引号或双引号中的任何内容，其索引与数组相同 引号间，嵌套引号时，单双引号要交替使用 字符串默认只能写在一行内，分成多行将会报错12var str = &#x27;ac&#x27; // SyntaxError: Unexpected token ILLEGAL 若要分行，可以采用以下几种方法： 在每一行的尾部使用 \\（但是 \\ 后面只能跟换行符，否则会报错）12var str = &#x27;a\\c&#x27;; // str == &#x27;ac&#x27; 连接运算符 + 可以连接多个运算符123var x = &#x27;a&#x27; + &#x27;b&#x27;// x = &#x27;ab&#x27; 转义字符： 代码 结果 \\‘ ‘（单引号） \\‘’ ‘’（双引号） \\\\ \\（反斜杠） \\b 退格键 \\f 换页 \\n 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 字符串与数组 字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符 若方括号中的数字超过字符串的长度，或者方括号中的根本不是数字，则返回 undefined 12var s = &#x27;abc&#x27;;// 则 s[3] 、s[-1] 、s[&#x27;x&#x27;] 均返回 undefined 但是，数组可以改变元素，字符串不可以改变单个字符 字符串的属性与方法属性 length 属性：12var str = &quot;abcd&quot;;console.log(str.length); // 4 方法 字符串的方法较多，先总览一下： 在此，我们只列举一些常用的方法 输出下标位置的字符1str.charAt(0); // &#x27;a&#x27; 输出下标位置的字符的编码值1str.charCodeAt(0); // 97 把 Unicode 编码转换成对应的文字1String.fromCharCode(10000); // &quot;✐&quot; 输出拼接后的字符串1str.concat(&#x27;e&#x27;); // &#x27;abcde&#x27; 输出指定字符的下标位置1str.indexOf(&#x27;c&#x27;); // 2 从后向前搜索输出指定字符的下标位置1str.lastIndexOf(&#x27;c&#x27;); // 2 输出字符串的长度1str.length; // 4 按照字母表的顺序规则进行比较，输出比较结果，靠前为1，靠后为0，相等为0123str.localeCompare(&#x27;aacd&#x27;); // 1str.localeCompare(&#x27;efg&#x27;); // -1str.localeCompare(&#x27;abcd&#x27;); // 0 输出指定字符从下标位置1str.search(&#x27;a&#x27;); 输出指定返回“切片”后的结果（左含右不含）1str.slice(1,3); // &#x27;bc&#x27; 输出该字符串以指定字符分割为的数组123str.split(); // [&#x27;abcd&#x27;]str.split(&#x27;&#x27;); // [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]str.split(&#x27;b&#x27;); // [&#x27;a&#x27;,&#x27;cd&#x27;] 输出指定下标后面指定长度的字符串123str.substr(1,2); // &#x27;bc&#x27;str.substr(0,2); // &#x27;ab&#x27;str.substr(2,3); // &#x27;cd&#x27; 输出从指定左下标到右下标的所有字符串12345str.substring(); // &#x27;abcd&#x27;str.substring(0); // &#x27;abcd&#x27;str.substring(-1); // &#x27;abcd&#x27;str.substring(2); // &#x27;cd&#x27;str.substring(0,2); // &#x27;ab&#x27; 将字符串所有的字符转换为小写再输出1str.toLowerCase(); // &#x27;abcd&#x27; 12var s = &#x27;ABCD&#x27;;s.toLowerCase(); // &#x27;abcd&#x27; 将字符串所有的字符转换为大写再输出1str.toUpperCase(); // &#x27;ABCD&#x27; 将其他类型的数据转换为字符串类型输出12var x = [1,2,3];x.toString(); // &#x27;123&#x27;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（三）：Array对象","slug":"JavaScript（三）：Array对象","date":"2021-03-20T03:47:50.000Z","updated":"2021-03-20T03:48:10.833Z","comments":true,"path":"2d32849ebe03/","link":"","permalink":"https://ozzienicholas.gitee.io/2d32849ebe03/","excerpt":"","text":"初识JS数组 数组的定义 下标从0开始1var arr = [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;] 也可以先定义后赋值1234var arr = [];arr[0] = &#x27;a&#x27;;arr[1] = &#x27;b&#x27;;arr[2] = &#x27;c&#x27;; 任何类型的数据，都可以放入数组，因为数组是一种特殊的对象，所以数组元素可以是不同类型的，但是最好不要这么做12345var arr = [ &#123;a: 1&#125;, // arr[0] -&gt; 对象：Object &#123;a: 1&#125; [1,2,3], // arr[1] -&gt; 数组：array [1,2,3] function() &#123;return true;&#125; // arr[2] -&gt; 函数：function() &#123;return true;&#125;]; 注意：请不要数组的最后一个元素之后写逗号，因为这可能存在跨浏览器兼容性问题 如果数组里面仍然嵌套着数组，那就形成了多维数组12345var arr = [ [1,2],[3,4] ];/*arr[0][1] == 2arr[1][1] == 4*/ 使用 JavaScript 关键词 New12var arr = new Array(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;); // 一种定义数组的方法， 但最好不要使用这种// 比较麻烦，一般也不用 数组的访问： 我们通过引用索引号（下标号）来引用某个数组元素12var cars = new Array(&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;);console.log(cars); // [ &#x27;Saab&#x27;, &#x27;Volvo&#x27;, &#x27;BMW&#x27; ] 这条语句修改 cars 中的首个元素：12cars[0] = &quot;Opel&quot;;console.log(cars); // [ &#x27;Opel&#x27;, &#x27;Volvo&#x27;, &#x27;BMW&#x27; ] 实例：访问整个数组12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JavaScript 数组&lt;/h1&gt; &lt;p id=&quot;demo&quot; style=&quot;color: red&quot;&gt;&lt;/p&gt; &lt;script&gt; var cars = [&quot;Audi&quot;, &quot;BMW&quot;, &quot;porsche&quot;]; document.getElementById(&quot;demo&quot;).innerHTML = cars; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 改变数组元素 123456&lt;p id=&quot;demo&quot;&gt;&lt;/p&gt;&lt;script&gt; var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]; arr[0] = &#x27;A&#x27;; document.getElementById.innerHTML(&#x27;demo&#x27;) = arr[0];&lt;/script&gt; 数组的本质 本质上，数组属于一种现象。typeof运算符会返回任一数组的类型都是object1typeof [1,2,3]; //&quot;Object&quot; 数组的特殊性在于，它的键名是按次序排列的一组整数123var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Object.keys(arr); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]//Object.keys方法返回数组的所有键名 对比 — 数组与对象的键名： 数组的键名是固定的(0、1、2…..) 对象的每个成员都必须指定键名 JS规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串 之所以可以用数值读取，是因为非字符串的键名会被转为字符串 12var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];// arr[0] == arr[&#x27;0&#x27;] == &#x27;a&#x27; 注意，这点在赋值时也成立，一个值总是先转成字符串，再作为键名进行赋值123var arr = [];arr[1.00] = 6;// arr[1] == 6 -&gt; 原因: 1.00转成字符串是1，所以数字键1可以读取值 关联数组 很多编程元素支持命名索引的数组，具有命名索引的数组被称为关联数组（或散列），但是，JavaScript 不支持 命名索引的数组，也就是说，在 JavaScript 中，数组只能使用 数字索引 123456var person = [];person[&quot;firstName&quot;] = &quot;Bill&quot;;person[&quot;lastName&quot;] = &quot;Gates&quot;;person[&quot;age&quot;] = 62;console.log(person.length); // 0console.log(person[0]); // undefined 当然，这也是数组与对象的一个区别：数组使用数字索引，对象使用命名索引 识别数组 Array.isArray() 方法：12var fruits = [&quot;Banana&quot;, &quot;Apple&quot;];console.log(Array.isArray(fruits)); // true 这是 ES5 定义的方法，不支持版本较老的浏览器 创建 isArray() 函数：12345var fruits = [&quot;Banana&quot;, &quot;Apple&quot;];function isArray(myArray) &#123; return myArray.constructor.toString().indexOf(&quot;Array&quot;) &gt; -1;&#125;console.log(isArray(fruits)); // true 假如参数为数组，则上面的函数始终返回 true，更准确地说，如果对象原型包含 “Array” 这个单词，则说明它是数组，返回 true. 数组的属性与方法判断 判断长度：length 属性：返回数组的长度 123var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];console.log(arr.length); // 4console.log(arr[arr.length-1]); // 访问最后一个元素:&#x27;c&#x27; 判断数组是否包含某个元素 添加 添加到最后面 12var arr = [1,2,3];arr.push(&#x27;x&#x27;); // arr = [1,2,3,&#x27;x&#x27;] 添加到最前面： 12var arr = [1,2,3];arr.unshift(&#x27;x&#x27;); // arr = [&#x27;x&#x27;,1,2,3] 删除与切分 删除数组最后一项：12var arr = [1,2,3];arr.pop(); // arr = [1,2] 删除数组第一项：12var arr = [1,2,3];arr.shift(); // arr = [2,3] 截取数组的一部分：123456// 下标:左算右不算// -1指最后一个元素，一次类推var arr = [1,2,3];arr.slice(1,2) // [2]arr.slice(-3,1) // [1,2]arr.slice() // [1,2,3] 拷贝与衔接 数组的深拷贝和浅拷贝：1var arr = [1,2,3]; 浅拷贝 : 浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用 用 Arr.slice() 1var newArr1 = arr.slice(); 用 Arr.concat() 1var newArr2 = arr.concat(); 深拷贝：深拷贝是拷贝多层，每一级别的数据都会拷贝出来 用 Arr.copyWithin()1var newArr3 = arr.copyWithin(); 其余的方法参考博客…… 数组的填充：Arr.fill()方法 合并两个数组：123var arr1 = [1,2,3];var arr2 = [4,5,6];var newArr = arr1.concat(arr2); // newArr = [1,2,3,4,5,6] 排序 数组排序： Arr.sort() sort() 以字母顺序对数组进行排序：12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.sort()); // [ &#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Mango&#x27;, &#x27;Orange&#x27; ] reverse() 反转数组12var fruits = [&quot;Banana&quot;, &quot;Orange&quot;, &quot;Apple&quot;, &quot;Mango&quot;];console.log(fruits.reverse()); // [ &#x27;Mango&#x27;, &#x27;Apple&#x27;, &#x27;Orange&#x27;, &#x27;Banana&#x27; ]","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（二）：词法与变量","slug":"JavaScript（二）：词法与变量","date":"2021-03-20T03:47:04.000Z","updated":"2021-03-20T03:47:18.973Z","comments":true,"path":"df656e604d75/","link":"","permalink":"https://ozzienicholas.gitee.io/df656e604d75/","excerpt":"","text":"基础了解 JavaScript 是区分大小写的。 JavaScript 使用的是 unicode 字符集，例如，可以将单词 Früh （在德语中意思是“早”）用作变量名： 1let Früh = &quot;Good Moring&quot;; 关于字符集与字符编码，请查： 维基百科 | 字符编码 百度百科 | 字符集 字符、字符集、字符编码的基础知识科普 Unicode字符集的字符编码方式 Unicode 转义序列：Unicode 转义序列要求在\\u之后至少有四个字符： 1&#x27;\\u00A9&#x27; // &#x27;©&#x27; Unicode 编码转义：ECMAScript 6新增特性。使用Unicode编码转义，任何字符都可以被转义为十六进制编码。最高可以用到0x10FFFF。使用单纯的Unicode转义通常需要写成分开的两半以达到相同的效果： 1234&#x27;\\u&#123;2F804&#125;&#x27;// 使用单纯 Unicode 转义&#x27;\\uD87E\\uDC04&#x27; 与此类似的方式是 String.fromCodePoint 和 String.prototype.codePointAt() 在 JavaScript 中，指令被称为语句 （Statement），并用分号（;）进行分隔，ECMAScript 规定了在语句的末尾自动插入分号。Javascript 源码从左往右被扫描并转换成一系列由 token 、控制字符、行终止符、注释和空白字符组成的输入元素。空白字符指的是空格、制表符和换行符等。 注释：Javascript 注释的语法和 C++ 或许多其他语言类似： 单行注释： 1// 单行注释 多行注释： 1234/* 这是一个 多行注释*/ 不能嵌套注释，否则会报错： 1/* 然而, 你不能, /* 嵌套注释 */ 语法错误 */ 多行注释也可以用于行内注释，但这样会使代码可读性变差，所以要谨慎使用： 1234function comment(x) &#123; console.log(&#x27;Hello &#x27; + x /*引入的值*/ + &#x27;!&#x27;);&#125;comment(&#x27;World&#x27;); hashbang 注释： 专门的第三个注释语法，hashbang 注释正在 ECMAScript 中标准化。 Hashbang 注释的行为与单行（//）注释完全相同，但它以 #! 开头且仅在脚本或模块的绝对开头有效。 注意，在 #! 之前不允许有任何类型的空格。 注释由 #! 之后的所有字符组成直到第一行的末尾；只允许有一条这样的注释。 hashbang 注释指定特定 JavaScript 解释器的路径要用于执行脚本，例如： 12#!/usr/bin/env nodeconsole.log(&#x27;Hello world&#x27;); 注意：JavaScript 中的 hashbang 注释模仿 Unix 中的 shebangs，用于指定适当的解释器运行文件。 在 hashbang 注释之前的 BOM 在浏览器中能工作，但是不建议在具有 hashbang 的脚本中使用 BOM，因为若在 Unix/Linux 中运行脚本，则有些 BOM 将不工作，因此，如果要直接从 shell 运行脚本，请使用没有 BOM 的 UTF-8。 注意，只能使用 #! 注释样式以指定 JavaScript 解释器。在所有其他情况下，只需使用 // 注释或 /**/ 多行注释。 词法文法ECMAScript 源码文本会被从左到右扫描，并被转换为一系列的输入元素，包括 token、控制符、行终止符、注释和空白符。 ECMAScript 定义了一些关键字、字面量以及行尾分号补全的规则。 标识符 代码中用来标识变量、函数、或属性的字符序列。 在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。 标识符与字符串不同之处在于字符串是数据，而标识符是代码的一部分。 在 JavaScript 中，无法将标识符转换为字符串，但有时可以将字符串解析为标识符。 关键字以下是 ES6 中保留的关键字，共 33 个： break case catch class const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield 未来保留关键字在 ECMAScript 规格中，以下这些关键字被当成关键字保留。目前它们没有特殊功能，但是在未来某个时间可能会加上。所以这些关键字不能当成标识符使用。 enum 关键字在严格模式和非严格模式中均不能使用。 以下关键字只在严格模式中被当成保留关键字： implements interface let package private protected public static await 关键字只在模块代码中被当成保留关键字。 之前标准中的保留关键字以下是之前版本中的 ECMAScript（1到3）中的保留关键字： abstract boolean byte char double final float goto int long native short synchronized transient volatile 另外，直接量 null、true、false 同样不能被当成标识使用。 保留字的使用保留字是仅针对标识符（Identifier）的文法定义而言的（而不是标识符名（IdentifierName）的文法定义）。如 es5.github.com/#A.1中所描述的，这些都是不排斥保留字的标识符名。 1234567a.importa[&#x27;import&#x27;]a = &#123; import: &#x27;test&#x27;&#125; 但如下用法是不允许的，因为它是一个标识符，而标识符的文法定义是除保留字以外的标识符名，标识符用于函数声明式和函数表达式。 1function import() &#123;&#125; // Illegal 直接量空直接量 null 是空直接量 布尔直接量 true、false 是布尔直接量 数值直接量 十进制、二进制、八进制、十六进制的数字是数值直接量 对象直接量 例如： 1let obj = &#123;a: &#x27;a&#x27;, b: &#x27;b&#x27;, c: &#x27;c&#x27;&#125;; 数组直接量 例如： 1let arr = [1, 2, 3]; 字符串直接量 例如： 1let str = &#x27;Hello World&#x27;; 正则表达式直接量 例如： 12345678/ab+c/g/*一个空的正则表达式直接量必须有一个空的非捕获分组以避免被当成是行注释符号*//(?:)/ 模板直接量 例如： 12345678`string text``string text line 1string text line 2``string text $&#123;expression&#125; string text`tag `string text $&#123;expression&#125; string text` 自动分号补全一些 JavaScript 语句必须用分号结束，所以会被自动分号补全（ASI）影响： 空语句 let、const、变量声明 import、export、模块定义 表达式语句 debugger continue、break、throw return 三个规则ECMAScript 规格中有自动分号补全的三个规则： 当出现一个不允许的行终止符或 &#125; 时，会在其之前插入一个分号： 1234&#123; 1 2 &#125; 3// 将会被 ASI 转换为&#123; 1 2 ;&#125; 3; 当捕获到标识符输入流的结尾，并且无法将单个输入流转换为一个完整的程序时，将在结尾插入一个分号。例如在下面这段中，由于在 b 和 ++ 之间出现了一个行终止符，所以 ++ 未被当成变量 b 的后置运算符： 12345678910a = b++c// 将被 ASI 转换为a = b;++c;// 而不是a = b++;c; 当语句中包含语法中的限制产品后跟一个行终止符的时候，将会在结尾插入一个分号，例如： 123456returna + b// 将被 ASI 转换为return;a + b; 而带有 “这里没有行终止符” 规则的语句有： 后置运算符（++ 和 --） continue break return yield、yield* module 声明与变量声明方式JavaScript有三种声明方式： var：声明一个变量，可选初始化一个值。 let：声明一个块作用域的局部变量，可选初始化一个值。 const：声明一个块作用域的只读常量。 变量在应用程序中，使用变量来作为值的符号名。变量的名字又叫做标识符，其需要遵守一定的规则。 一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从 “A” 到 “Z” 的大写字母和从 “a” 到 “z” 的小写字母。 可以使用大部分 ISO 8859-1 或 Unicode 编码的字符作标识符，例如 å 和 ü，也可以使用 Unicode 转义字符 作标识符。 声明变量可以用以下三种方式声明变量：（注意，const 声明的不是变量而是常量） 使用关键词 var。例如 var x = 42。这个语法可以用来声明局部变量和全局变量。 使用关键词 let 。例如 let y = 13。这个语法可以用来声明块作用域的局部变量。 直接赋值。例如x = 42。在函数外使用这种形式赋值，会产生一个全局变量。在严格模式下会产生错误。因此最好不要使用这种方式来声明变量。 变量求值用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined 。 如果访问一个未声明的变量会导致抛出一个引用错误（ReferenceError）异常： 12345var a;console.log(a); // undefinedlet b;console.log(b); // undefined 因此，可以使用 undefined 来判断一个变量是否已赋值。在以下的代码中，变量input未被赋值，因此 if 条件语句的求值结果是 true ： 123456let input;if(input === undefined)&#123; doThis();&#125; else &#123; doThat();&#125; 其实，若之前就定义 let input = undefined，结果也等同于未赋值。 变量作用域在函数之外声明的变量，能被当前文档中的任何其他代码所访问，叫做全局变量。 在函数内部声明的变量，只能在当前函数的内部访问，叫做局部变量。 ECMAScript 6 之前的 JavaScript 没有语句块作用域；相反，语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量。例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。 1234if (true) &#123; var x = 5;&#125;console.log(x); // 5 如果使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。 1234if (true) &#123; let y = 5;&#125;console.log(y); // ReferenceError: y 没有被声明 变量提升JavaScript 中，可以先使用变量稍后再声明变量而不会引发异常，这一概念称为变量提升。 JavaScript 变量感觉上是被 “提升” 或 “移到” 了函数或语句的最前面。 但是，提升后的变量将返回 undefined 值。 因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。 12345678910111213141516/** * 例子1 */var x;console.log(x === undefined); // truex = 3;/** * 例子2 */var myvar = &#x27;my value&#x27;;(function() &#123; var myvar; console.log(myvar); // undefined myvar = &#x27;local value&#x27;;&#125;)(); 由于存在变量提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。 在 ECMAScript 6 中，let（const）同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 12console.log(x); // ReferenceErrorlet x = 3; 函数提升对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 123456789101112/* 函数声明 */foo(); // &quot;bar&quot;function foo() &#123; console.log(&quot;bar&quot;);&#125;/* 函数表达式 */baz(); // 类型错误：baz 不是一个函数var baz = function() &#123; console.log(&quot;bar2&quot;);&#125;; 全局变量实际上，全局变量是全局对象的属性。在网页中，全局对象是 window ，所以你可以用形如 window.variable 的语法来设置和访问全局变量。 因此，可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 phoneNumber 的变量，那么你就可以在子框架里使用 parent.phoneNumber 的方式来引用它。 常量可以用关键字 const 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线，例如： 1const PI = 3.14; 常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明，它必须被初始化为某个值。 在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如： 123456789// 这会报错function f() &#123;&#125;;const f = 5;// 这也会报错function f() &#123; const g = 5; var g;&#125; 然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。 12345const obj = &#123; key: &#x27;value&#x27;&#125;;obj.key = &#x27;otherValue&#x27;;console.log(obj); // &#123;key: &quot;otherValue&quot;&#125; 同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。 123const arr = [1, 2, 3];arr.push(4);console.log(arr);","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"JavaScript（一）：了解 JavaScript","slug":"JavaScript（一）：了解-JavaScript","date":"2021-03-20T03:46:06.000Z","updated":"2021-03-20T03:46:47.442Z","comments":true,"path":"b378fba5d5f4/","link":"","permalink":"https://ozzienicholas.gitee.io/b378fba5d5f4/","excerpt":"","text":"什么是 JavaScript JavaScript 是一门跨平台、面向对象的脚本语言。 它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等），还有高级的服务端Javascript版本，例如Node.js。 在宿主环境（例如 web 浏览器）中， JavaScript 能够通过其所连接的环境提供的编程接口进行控制。 JavaScript 内置了一些对象的标准库，比如数组（Array），日期（Date），数学（Math）和一套核心语句，包括运算符、流程控制符以及声明方式等。 JavaScript 的核心部分可以通过添加对象来扩展语言以适应不同用途；例如： 客户端的 JavaScript 通过提供对象，控制浏览器及其文档对象模型（DOM），来扩展语言核心。 例如：客户端的拓展代码允许应用程序将元素放在某个 HTML 表单中，并且支持响应用户事件，比如鼠标点击、表单提交和页面导航。 服务端的 JavaScript 则通过提供有关在服务器上运行 JavaScript 的对象来可扩展语言核心。 例如：服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。 因为能通过添加对象来扩展语言以适应不同的用途，所以，在浏览器中，JavaScript 可以改变网页（DOM）的外观与样式；在服务器上，Node.js 中的 JavaScript 可以对浏览器上编写的代码发出的客户端请求做出响应。 JavaScript 与 Java JavaScript 和 Java 有一些共性但是在另一些方面有着根本性区别。 JavaScript语言类似 Java 但是并没有 Java 的静态类型和强类型检查特性。 JavaScript 遵循了 Java 的表达式语法，命名规范以及基础流程控制，这也是 JavaScript 从 LiveScript 更名的原因。 Java 是通过声明的方式构建类的编译时系统的，但是 JavaScript 采用基于少量的数据类型如数字、布尔、字符串值的运行时系统。 JavaScript 拥有基于原型的对象模型提供的动态继承；也就是说，独立对象的继承是可以改变的。 JavaScript 支持匿名函数，函数也可以作为对象的属性被当做宽松的类型方式执行。 Java 是基于类的编程语言，设计的初衷就是为了确保快速执行和类型安全。JavaScript 传承了 HyperTalk 和 dBASE 语句精简、动态类型等精髓，这些脚本语言为更多开发者提供了一种语法简单、内置功能强大以及用最小需求创建对象的编程工具。与 Java 相比，Javascript 是一门形式自由的语言。你不必声明所有的变量，类和方法。你不必关心方法是否是公有、私有或者受保护的，也不需要实现接口。无需显式指定变量、参数、方法返回值的数据类型。 JavaScript 和 Java 的简单对比： JavaScript Java 面向对象 面向对象 基于少量数据类型的运行时系统 基于类的编译时系统 不区分对象类型 分为类和实例，通过类层级的定义实现继承 通过原型机制继承，任何对象的属性和方法均可以被动态添加 不能动态增加对象或类的属性或方法 变量类型不需要提前声明（动态类型） 变量类型必须提前声明（静态类型） 不能直接自动写入硬盘 可以直接自动写入硬盘","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"}]},{"title":"koa2入门（三）：骨架知识","slug":"koa2入门（三）：骨架知识","date":"2021-03-20T03:44:34.000Z","updated":"2021-03-20T03:44:59.160Z","comments":true,"path":"02458ea63da4/","link":"","permalink":"https://ozzienicholas.gitee.io/02458ea63da4/","excerpt":"","text":"中间件中间件的认识 中间件是 Koa 一个重要的概念，它是一个执行的链条，整个链条组成了一个运行的周期 理解上述说的 “链条”，案例如下： 12345678910111213141516171819202122const Koa = require(&quot;koa&quot;)const app = new Koa()// 访问权限中间件app.use(async(ctx, next) =&gt; &#123; console.log(&quot;权限验证成功...&quot;) await next() // 执行下一个中间件 &#125;)// 日志记录app.use(async(ctx, next) =&gt; &#123; console.log(&quot;日志记录成功...&quot;) await next() // 执行下一个中间件 &#125;)// 响应处理app.use(async(ctx, next) =&gt; &#123; ctx.response.status = 200 ctx.response.body = &quot;Hello World&quot; await next() // 执行下一个中间件&#125;)app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 打开 http://localhost:3000/，控制台打印如下： 123Starting at 3000...权限验证成功...日志记录成功... 可以看到，每个中间件都只负责一小部分，互相配合而组合成一条完整的业务通道，而中间件的功能也为 koa 提供了很大的便利性，因为一个特定成熟的功能可以抽象成一个个模块共享出来，例如路由模块、模板引擎……我们可以直接在项目中导入这些成熟的模块 koa 是一个中间件框架，有两种不同的方法来实现中间件： async function common function 下面是用两种不同方法实现一个日志中间件的示例： async function 12345678const Koa = require(&quot;koa&quot;)const app = new Koa()app.use(async(ctx, next) =&gt; &#123; const start = Date.now() await next() const result_ms = Date.now() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125; ms`)&#125;) common function 123456789const Koa = require(&quot;koa&quot;)const app = new Koa()app.use((ctx, next) =&gt; &#123; const start = Date.now() return next().then(() =&gt; &#123; const result_ms = Date.now() - start console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125; ms`) &#125;)&#125;) 中间件通常带有两个参数（ctx，next），ctx 是一个请求的上下文（context），而 next 是调用执行下游中间件的函数，在代码执行完成后通过 then 方法返回一个 promise 中间件的开发与使用示例 generator 中间件开发可以在 koa v1 和 v2 中使用，但是 async await 中间件只能在 koa v2 中使用，这里只说 koa v2 的使用： generator 中间件开发： 123456789101112131415// 返回的应该是function * () 函数// ./generator.jsfunction log(ctx) &#123; console.log(ctx.method, ctx.header.host + ctx.url)&#125;module.exports = function() &#123; return function*(next) &#123; // 执行中间件的操作 log(this) if (next) &#123; yield next &#125; &#125;&#125; generator 中间件在 koa v2 中需要用 koa-convert 封装一下才能使用： 12345678910const Koa = require(&quot;koa&quot;)const koaConvert = require(&quot;koa-convert&quot;)const loggerGenerator = require(&quot;./generator.js&quot;)const app = new Koa()app.use(koaConvert(loggerGenerator()))app.use((ctx) =&gt; &#123; ctx.body = &quot;Hello World!&quot;&#125;)app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 启动项目，并打开 http://localhost:3000/，控制台报告信息如下： 123Starting at 3000...GET localhost:3000/GET localhost:3000/favicon.ico async 中间件开发： 1234567891011// ./async.jsfunction log(ctx) &#123; console.log(ctx.method, ctx.header.host + ctx.url)&#125;module.exports = function() &#123; return async function(ctx, next) &#123; log(ctx) await next() &#125;&#125; async 中间件只能在 koa v2 中使用： 123456789const Koa = require(&quot;koa&quot;)const loggerAsync = require(&quot;./async.js&quot;)const app = new Koa()app.use(loggerAsync())app.use((ctx) =&gt; &#123; ctx.body = &quot;Hello World&quot;&#125;)app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 启动项目，并打开 http://localhost:3000/，控制台报告信息如下： 123Starting at 3000...GET localhost:3000&#x2F;GET localhost:3000&#x2F;favicon.ico 中间件的应用 中间件配合路由可以完成一系列的操作，下面这些都是例子 添加应用：主要通过 app.use 添加或者启动一些应用，例如一些常见的第三方中间件的使用 12345678910111213141516171819202122const Koa = require(&quot;koa&quot;)const Router = require(&quot;koa-router&quot;)()const app = new Koa()// 应用级中间件app.use(async(ctx, next) =&gt; &#123; // 匹配路由之前打印一下信息 console.log(&quot;开始匹配路由...&quot;) // 匹配路由完成之后继续向下匹配 // 若无next()，则匹配成功后会自动终止 await next()&#125;)Router.get(&quot;/index&quot;, async(ctx) =&gt; &#123; ctx.body = &quot;首页&quot;&#125;)// 启动路由app.use(Router.routes())// 监听端口app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 打开 http://localhost:3000/index，控制台输入如下： 12Starting at 3000...开始匹配路由... 匹配路由：主要通过 next() 完成多级路由的匹配，例如： 1234567891011121314151617181920const Koa = require(&quot;koa&quot;)const Router = require(&quot;koa-router&quot;)()const app = new Koa()// 路由级中间件Router.get(&quot;/index&quot;, async(ctx, next) =&gt; &#123; console.log(&quot;开始匹配首页路由...&quot;) // 匹配到路由之后继续向下匹配 await next()&#125;)Router.get(&quot;/index&quot;, async(ctx) =&gt; &#123; ctx.body = &quot;首页&quot;&#125;)// 启动路由app.use(Router.routes())// 监听端口app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 打开 http://localhost:3000/index，控制台输入如下： 12Starting at 3000...开始匹配首页路由... 增加错误处理：若一直匹配不成功，则可以通过中间件给出错误响应 12345678910111213141516171819202122232425const Koa = require(&quot;koa&quot;)const Router = require(&quot;koa-router&quot;)()const app = new Koa()// 错误处理中间件app.use(async(ctx, next) =&gt; &#123; console.log(&quot;这是包含路由匹配错误处理的中间件&quot;) console.log(&quot;开始匹配首页路由...&quot;) await next() if (ctx.status == 404) &#123; ctx.body = &quot;这是一个404页面&quot; &#125; else &#123; console.log(ctx.url) &#125;&#125;)Router.get(&quot;/index&quot;, async(ctx) =&gt; &#123; ctx.body = &quot;首页&quot;&#125;)// 启动路由app.use(Router.routes())// 监听端口app.listen(3000)console.log(&quot;Starting at 3000...&quot;) 打开 http://localhost:3000/index： 匹配成功，浏览器会显示 “首页”，控制台会打印： 1234Starting at 3000...这是包含路由匹配错误处理的中间件开始匹配首页路由...&#x2F;index 匹配不成功，浏览器会显示 “这是一个404页面”，控制台会打印： 12这是包含路由匹配错误处理的中间件开始匹配首页路由... 另附链接 关于中间件的学习就到这里，中间件的原理之后再详细探讨 50行代码学会koa2中间件原理 koa中间件总结 Koa2第二篇：中间件 Koa2 中间件原理解析 Koa v2.7.0 中文文档 — 中间件 koa 中文文档 — 应用 Request &amp; Response 在 koa 官方文档 中，许多都在介绍 HTTP 的请求和响应，这里举例一些 Koa Request1234567891011121314151617181920212223242526272829303132// headerctx.request.headers ctx.request. protocolctx.request.typectx.request.charset// methodctx.request.methodctx.request.query // getctx.request.body // post | 依赖 koa-bodyparse 第三方模块，后面章节有描述// pathctx.request.url // path/?get=ctx.request.path // path// hostctx.request.host // hostname:portctx.request.hostname // hostnamectx.request.ipcrx.request.subdomains // cookiectx.cookies.get(&#x27;name&#x27;) // 获取 cookiectx.cookies.set(name, value, &#123; // 设置 cookie &#x27;expires&#x27;: new Date() // 时间 &#x27;path&#x27; : &#x27;/&#x27; // 路径 &#x27;domain&#x27;: &#x27;0.0.0.0&#x27; // 域 &#x27;httpOnly&#x27;: false // 禁止js获取&#125;)// errorctx.throw(404, &#x27;Not found&#x27;) Koa Response1234567891011// headerctx.set(&#123;&#125;)// statusctx.response.status = 200// typectx.response.type = &#x27;text/html; charset=utf-8&#x27; // defaule// redirectctx.response.redirect(url)","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://ozzienicholas.gitee.io/tags/koa/"}]},{"title":"koa2入门（二）：知识回顾—异步处理","slug":"koa2入门（二）：知识回顾—异步处理","date":"2021-03-20T03:43:54.000Z","updated":"2021-03-20T03:45:18.890Z","comments":true,"path":"c926936fceae/","link":"","permalink":"https://ozzienicholas.gitee.io/c926936fceae/","excerpt":"","text":"Async/Await 和 Promise 的使用 async 方法以及 Promise 都来自 koa 的底层，可以让你编写非阻塞序列代码。 async 是让方法变为异步，例如： 12345async function testAsync() &#123; return &quot;Hello Async&quot;&#125;const result = testAsync()console.log(result) // Promise &#123; &#x27;Hello Async&#x27; &#125; await 会等待 async 执行完毕，await 等待的是一个表达式，在官方文档中即 promise 对象，但是它也可以接受普通值。注意，await 必须在 async 方法中才能使用，因为 await 访问本身就会造成程序阻塞停止，所以必须在异步方法中才能使用。例如： 123456789101112131415function ordinaryGetData() &#123; return &quot;ordinaryGetData()&quot;&#125;async function asyncGetData() &#123; return &quot;asyncGetData()&quot;&#125;async function result() &#123; //await 返回普通值 const result_1 = await ordinaryGetData() console.log(result_1) // ordinaryGetData //await 返回 promise 对象 const result_2 = await asyncGetData() console.log(result_2) // asyncGetData&#125;result() 综上所述，async 用于申明一个 function 是异步的，它会将其后的函数返回值封装成一个 promise 对象，而 await 用于等待一个异步方法（即 promise）执行完成，并将其 resolve 的结果返回出来 案例理解 执行下面这段代码： 123456789101112131415161718192021222324252627function getSyncTime() &#123; return new Promise((resolve, reject) =&gt; &#123; try &#123; let startTime = new Date().getTime() setTimeout(() =&gt; &#123; let endTime = new Date().getTime() let data = endTime - startTime resolve(data) &#125;, 500) &#125; catch (srr) &#123; reject(err) &#125; &#125;)&#125;async function getSyncData() &#123; let time = await getSyncTime() let data = `endTime - startTime = $&#123;time&#125;.` return data&#125;async function getData() &#123; let data = await getSyncData() console.log(data)&#125;getData() 得出结论： 可以用同步的写法实现异步逻辑 最底层的 await 返回需要 Promise 对象 可以用多层 async function 的写法代替传统的回调嵌套","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://ozzienicholas.gitee.io/tags/koa/"}]},{"title":"koa2入门（一）：初识-koa2","slug":"koa2入门（一）：初识-koa2","date":"2021-03-20T03:43:09.000Z","updated":"2021-03-20T03:45:13.973Z","comments":true,"path":"b11a35911dc2/","link":"","permalink":"https://ozzienicholas.gitee.io/b11a35911dc2/","excerpt":"","text":"简介koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 Koa 通过 node.js 实现了一个十分具有表现力的 HTTP 中间件框架，力求让 Web 应用开发和 API 使用更加地愉快。Koa 的中间件之间按照编码顺序在栈内依次执行，允许您执行操作并向下传递请求（downstream），之后过滤并逆序返回响应（upstream）。 几乎所有 HTTP 服务器通用的方法都被直接集成到 Koa 大约570行源码的代码库中。其中包括内容协商，节点不一致性的规范化，重定向等等操作。 另外，Koa 没有捆绑任何中间件。 koa2 特性 只提供已经封装好了的 http 上下文、请求、响应，以及基于 async/await 的中间件容器 利用 ES7 的 async/await 来处理传统的回调嵌套问题以及代替 koa v1 中的 generator，不过要注意，需要在 node7.x 的 harmony 模式下才能支持 async/await 中间件只支持 async/await 封装，如果要使用基于 koa v1 中 generator 的中间件，需要用中间件 koa-convert 封装一下才行 koa2 快速开始安装1npm install koa 此时我的版本是：&quot;koa&quot;: &quot;^2.13.0&quot; 测试代码123456789const Koa = require(&quot;koa&quot;)const app = new Koa()app.use(async(ctx) =&gt; &#123; ctx.body = &quot;Hello Koa2&quot;&#125;)app.listen(3000)console.log(&quot;listening...&quot;) 打开 http://localhost:3000/，查看结果","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"koa","slug":"koa","permalink":"https://ozzienicholas.gitee.io/tags/koa/"}]},{"title":"Express 入门","slug":"Express-入门","date":"2021-03-20T03:42:13.000Z","updated":"2021-03-20T03:42:39.261Z","comments":true,"path":"51ef113f0712/","link":"","permalink":"https://ozzienicholas.gitee.io/51ef113f0712/","excerpt":"","text":"安装 创建一个目录，并将此目录作为当前的工作目录 12$ mkdir myapp$ cd myapp 初始化项目 1npm init -y 打开 package.json，注意 “main” 为 index.js，这是它默认的入口文件，将其修改为 app.js 关于 package.json 的作用，请参考：Specifics of npm’s package.json handling 安装 express 1$ npm install express --save 安装 Node 模块时，如果指定了 --save 参数，那么此模块将被添加到 package.json 文件中 dependencies 依赖列表中。 然后通过 npm install 命令即可自动安装依赖列表中所列出的所有模块 如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 --save 参数即可： 1$ npm install express Hello World 注意，这里创建的是一个最简单的应用，并且只有一个文件，这和 Express 应用生成器 创建的完全不一样，Express 应用生成器所创建的应用框架包含多个 JavaScript 文件、Jade 模板 和 针对不同用途的子目录 进入 myapp 目录，创建 app.js（这里的命名源于之前 package.json 修改的命名） 12345678910111213// app.jsvar express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello World!&#x27;);&#125;);var server = app.listen(3000, function() &#123; var host = server.address().address; var port = server.address().port; console.log(&#x27;Example app listening at http://%s:%s&#x27;, host, port);&#125;) 命令行启动 1node app.js 打开 http://localhost:3000/ 就可以看到结果了 单独的文件 当路由过多时，需要单独建立一个文件来存放路由，在根目录下新建一个 routes 目录，再在其目录中新建 index.js 修改 myapp/app.js 与 myapp/routes/index.js 的内容如下： 1234567891011// myapp/app.jsvar express = require(&#x27;express&#x27;);var app = express();var routes = require(&#x27;./routes&#x27;)(app);var server = app.listen(3000, function() &#123; var host = server.address().address; var port = server.address().port; console.log(&#x27;Example app listening at http://%s:%s&#x27;, host, port);&#125;) 123456// myapp/routes/index.jsmodule.exports = function(app) &#123; app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello World&#x27;); &#125;)&#125; 运行原理 底层：http 模块 Express 框架建立在 Node 内置的 http 模块的基础上，http 模块生成服务器的的原始代码如下： 12345678var http = require(&quot;http&quot;);var app = http.createServer(function(request, response) &#123; response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text/plain&quot;&#125;); response.end(&quot;Hello world!&quot;);&#125;);app.listen(3000, &quot;localhost&quot;); 上述代码中的 createServer 方法便表示生成一个服务器， 该方法接受一个回调函数，即 function(request, response)&#123; ... &#125;，这两个参数 request 与 response 分别代表 HTTP 的请求和回应 express 的核心是对 http 模块的再包装，上述代码用 express 可以简写为如下： 12345678var express = require(&#x27;express&#x27;);var app = express();app.get(&#x27;/&#x27;, function(req, res) &#123; res.send(&#x27;Hello World!&#x27;);&#125;);app.listen(3000); 比较上面两段代码，之前是用 http.createServer 创建一个实例，之后用的是 Express的构造方法 生成一个实例。两者的回调函数是相同的，express 相当于在 http 模块上加了一个中间层 什么是中间件 简单说，中间件（middleware）就是处理 HTTP 请求的函数 它最大的特点，就是一个中间件处理完，再传递给下一个中间件，app 实例在运行过程中，会调用一系列的中间件 中间件作为处理 http 请求的函数，每一个中间件都可以从 app 实例中获得三个参数： request 对象：代表 HTTP 请求 response 对象：代表 HTTP 回应 next 回调函数：代表下一个中间件 每个中间件都能对 http 请求（即 resquest 对象）进行加工，并且决定是否调用 next 方法，并将 request 对象传给下一个中间件 一个不进行任何操作，只传递 request 对象的中间件，就如同以下： 123function uselessMiddleware(req, res, next) &#123; next();&#125; 上述代码的 next 就是下一个中间件， 如果它带有参数，就代表着已经抛出错误，参数一般为错误文本 123function uselessMiddleware(req, res, next) &#123; next(&#x27;出错了！&#x27;);&#125; 抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止 use 方法 use 是 express 注册中间件的方法，它返回一个函数，下面的代码中使用了两个 app.use 方法，注册了两个中间件，然后连续调用两个中间件 12345678910111213141516var http = require(&quot;http&quot;);var express = require(&quot;express&quot;);var app = express();app.use(function(request, response, next) &#123; console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url); next();&#125;);app.use(function(request, response) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Hello world!\\n&quot;);&#125;);http.createServer(app).listen(3000); 上述代码中，HTTP 收到请求之后，先调用第一个中间件，在控制台输出一行信息，然后通过 next 方法，将执行权传给第二个中间件，输出 HTTP 回应 由于第二个中间件没有调用 next 方法，所以 request 对象就不再向后传递了 use 方法内部可以对访问进行判断，即根据不同的请求网址返回不同的网页内容，这能实现简单的路由，如： 12345678910111213141516171819202122232425262728var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.use(function(request, response, next) &#123; if (request.url == &quot;/&quot;) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Welcome to the homepage!\\n&quot;); &#125; else &#123; next(); &#125;&#125;);app.use(function(request, response, next) &#123; if (request.url == &quot;/about&quot;) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); &#125; else &#123; next(); &#125;&#125;);app.use(function(request, response) &#123; //注意，判断 404 没有判断 url response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;404 error!\\n&quot;);&#125;);http.createServer(app).listen(3000); 上述代码通过 app.use 方法注册了三个中间件，再通过 request.url，根据请求的网址判断执行的内容，只要路径匹配，就不会将执行权交给下一个中间件，因此，在代码中，最后的 else 部分即为无效匹配时的返回内容 除了在回调函数中判断请求网址，use 方法也可在第一个参数中判断匹配，如： 1app.use(&#x27;/path&#x27;, someMiddleware); 这表示仅仅在网址匹配成功的情况下才执行之后的中间件 因此，上个案例中的代码可以改写为： 123456789101112131415161718192021var express = require(&quot;express&quot;);var http = require(&quot;http&quot;);var app = express();app.use(&quot;/&quot;, function(request, response, next) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Welcome to the homepage!\\n&quot;);&#125;);app.use(&quot;/about&quot;, function(request, response, next) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;Welcome to the about page!\\n&quot;);&#125;);app.use(function(request, response) &#123; //注意，判断 404 没有判断 url response.writeHead(404, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); response.end(&quot;404 error!\\n&quot;);&#125;);http.createServer(app).listen(3000); Express 方法 HTTP 动词方法 之前使用了很多次 get 方法，除此之外，Express 还提供了 post、put、delete 等方法，即 HTTP 动词都是 express 方法 这些方法的第一个参数都是请求的路径，除了绝对匹配之外（如之前的 if 判断），express 允许匹配模式，例如： 123app.get(&quot;/hello/:who&quot;, function(req, res) &#123; res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);&#125;); 上面的代码将匹配诸如 /hello/xxx 此类的网址，网址中的 xxx 将作为 req.params.who 属性的值 注意，捕获后需要对网址进行安全性检查，以过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值 如果在参数模式后面加上问号，表示该参数可选，如： 12345678app.get(&quot;/hello/who?&quot;, function(req, res) &#123; if(req.params.id) &#123; res.end(&quot;Hello, &quot; + req.params.id + &quot;.&quot;); &#125; else &#123; res.end(&quot;Hello Guest.&quot;); &#125;&#125;) 更复杂的匹配规则如下 123456789app.get(&#x27;/forum/:fid/thread/:tid&#x27;, middleware);// 匹配 &quot;/commits/71dbb9c&quot;// 或 &quot;/commits/71dbb9c..4c084f9&quot; 这样的 git 格式的网址app.get(/^\\/commits\\/(\\w+)(?:\\.\\.(\\w+))?$/, function(req, res)&#123; var from = req.params[0]; var to = req.params[1] || &#x27;HEAD&#x27;; res.send(&#x27;commit range &#x27; + from + &#x27;..&#x27; + to);&#125;); all 方法 之前的 app.get 方法中，第一个参数可以指定匹配的网址，app.all 方法则表示所有的请求都要执行该中间件，如： 12345678910111213141516171819202122var http = require(&quot;http&quot;);var express = require(&quot;express&quot;);var app = express();app.all(&quot;*&quot;, function(request, response, next) &#123; response.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); next();&#125;);app.get(&quot;/&quot;, function(request, response) &#123; response.end(&quot;Welcome to the homepage!&quot;);&#125;);app.get(&quot;/about&quot;, function(request, response) &#123; response.end(&quot;Welcome to the about page!&quot;);&#125;);app.get(&quot;*&quot;, function(request, response) &#123; response.end(&quot;404!&quot;);&#125;);http.createServer(app).listen(3000); 上述代码的 all 方法表示，所有请求都必须通过该中间件，参数中的 * 表示对所有的路径都有效，同时你会注意到，我们在 app.get 方法中也同样用到了 *，但这与 app.all 不同的是，app.get 是针对 HTTP 请求的，表示所有 HTTP 请求都需通过该中间件，而 app.all 指的是所有请求 set 方法 app.set 方法用于指定变量的值，如： 12app.set(&quot;views&quot;, __dirname + &quot;views&quot;);app.set(&quot;view engine&quot;, &quot;jade&quot;); 上述代码使用 set 方法，分别为 “views” 和 “view engine” 指定值 request 对象 request 对象表示 HTTP 请求，包含了请求查询字符串、参数、内容、HTTP 头部等属性，常见属性如下： Express 生成器 通过应用生成器工具 express-generator 可以快速构建一个应用的框架 1$ npm install express-generator -g 在终端中使用 -h 参数可以列出所有可用的命令行参数 创建名为 example 的应用 1$ express example 安装依赖文件 12$ cd example$ npm install 启动项目 1$ npm start 打开 http://localhost:3000/ 即可查看结果 注：该生成器创建的应用一般有： 1234567891011121314151617.├── app.js├── bin│ └── www├── package.json├── public│ ├── images│ ├── javascripts│ └── stylesheets│ └── style.css├── routes│ ├── index.js│ └── users.js└── views ├── error.pug ├── index.pug └── layout.pug 简单路由案例 对 Express 路由做一个简单的介绍 路由（Routing）是由一个 URL（或者叫路径） 和一个 特定的 HTTP（如 GET、POST） 方法，涉及到应用如何响应客户端对某个网站节点的访问 每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这些函数将被执行 路由的定义由如下结构组成：**app.METHOD(PATH, HANDLER)** app 是一个 express 实例 METHOD 是请求方式中的一个 PATH 是服务器端的路径 HANDLER 是当路径匹配成功时需要执行的函数 下面展示几个简单的路由案例： 打开 routes 之中的 index.js，并将下面的代码修改 1234// index.jsrouter.get(&#x27;/&#x27;, function(req, res, next) &#123; res.render(&#x27;index&#x27;, &#123; title: &#x27;Express&#x27; &#125;);&#125;); 修改为： 12345678910111213141516171819// 对网站首页的访问返回 &quot;Hello World!&quot; 字样router.get(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Hello World!&#x27;);&#125;);// 网站首页接受 POST 请求router.post(&#x27;/&#x27;, function (req, res) &#123; res.send(&#x27;Got a POST request&#x27;);&#125;);// /user 节点接受 PUT 请求router.put(&#x27;/user&#x27;, function (req, res) &#123; res.send(&#x27;Got a PUT request at /user&#x27;);&#125;);// /user 节点接受 DELETE 请求router.delete(&#x27;/user&#x27;, function (req, res) &#123; res.send(&#x27;Got a DELETE request at /user&#x27;);&#125;); 托管静态文件 通过 express 内置的 express.static 可以托管静态文件，比如 JavaScript 文件、CSS 文件、图片等 将静态文件资源所在的目录作为参数传递给 express.static 中间件就可以提供静态资源文件的访问了 托管案例 在 example/public/images 目录下存放一个如下的图片（命名为 logo.png）： 打开 example/app.js，添加上使用中间件的代码： 12// app.jsapp.use(express.static(&#x27;public&#x27;)); 现在，public 目录下面的文件就可以访问了，打开 http://localhost:3000/images/logo.png，即可查看图片 注：所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中 如果你的静态资源存放在多个目录下面，你可以多次调用 express.static 中间件，需添加上使用中间件的代码： 123// app.jsapp.use(express.static(&#x27;public&#x27;));app.use(express.static(&#x27;files&#x27;)); 若要想通过 express.static 访问的文件都存放在一个 虚拟（virtual）目录 （即目录根本不存在）下面，可以通过静态资源目录指定一个挂在路径方式，如下所示： 12// app.jsapp.use(&#x27;/static&#x27;, express.static(&#x27;public&#x27;)); 现在，你就可以通过带有 /static 前缀的地址来访问 public 目录下面的文件了 可将之前的 http://localhost:3000/images/logo.png 改为 http://localhost:3000/static/images/logo.png","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"expres","slug":"expres","permalink":"https://ozzienicholas.gitee.io/tags/expres/"}]},{"title":"规范","slug":"Node（二）：模块，包，与 CommonJS 规范","date":"2021-03-20T03:40:48.000Z","updated":"2021-03-20T03:41:31.777Z","comments":true,"path":"190a6fec0e4b/","link":"","permalink":"https://ozzienicholas.gitee.io/190a6fec0e4b/","excerpt":"","text":"模块模块介绍 模块的介绍：为了编写可维护的代码，我们会将代码模块化，在 node 中，我们将代码分别拆分到不同的 JS 文件中，一个文件就是一个模块（module） 在前面一节中，我们创建了 test.js，其实这个 test.js 就是一个模块，模块名就是文件名，所以我们把这个 test.js 叫做 test 模块 使用模块的好处： 大大提高了代码的可维护性 避免函数名与变量名冲突，相同名字的函数和变量完全可以存在于不同的模块中，降低了命名冲突的风险 创建模块 Node.js 提供了 exports和require 两个对象 其中 exports 是模块公开的接口，require 用来外部获取一个模块的接口，即所获取模块的exports对象 我们将创建两个文件，分别用于创建模块和使用模块，如下： 创建一个文件 module.js，用于创建模块： 1234567//创建一个叫做&quot;Hello1&quot;与&quot;Hello2&quot;两个模块，两个模块的功能是打印内容exports.Hello1 = function()&#123; console.log(&#x27;Hello NodeJs 1&#x27;);&#125;;exports.Hello2 = function()&#123; console.log(&#x27;Hello NodeJs 2&#x27;);&#125;; 在同级目录下再创建一个文件getmodule.js，来使用模块 1234var x = require(&#x27;./module&#x27;); //获取文件，因为该模块在文件中//现在x已经可以调用&quot;module.js&quot;中的模块x.Hello1(); //x调用Hello1模块x.Hello2(); //x调用Hello2模块 运行getmodule.js： 1node getmodule.js 分析一下： 上述程序中，module.js 通过 exports 对象把 Hello1 和 Hello2 作为模块的访问接口， 在getmodule.js 中通过 require(&#39;./module&#39;) 加载这个模块 然后就可以直接访问module.js 中 exports对象的成员函数了 单次加载与覆盖 上面这个例子有点类似于创建一个对象，但实际上和创建对象有本质的区别，因为 require 不会重复加载模块， 也就是说无论调用多少次 require，获得的模块都是同一个，这就是单次加载 我们将两个文件修改如下： module.js 123456exports.Name = function(str)&#123; Name = str;&#125;;exports.NameOutput = function()&#123; console.log(&#x27;Hello &#x27; + Name);&#125; getmodule.js 12345var x = require(&#x27;./module&#x27;);x.Name(&#x27;My&#x27;);var y = require(&#x27;./module&#x27;);y.Name(&#x27;You&#x27;);x.NameOutput(); //Hello You 用 node 运行 getmodule.js 结果呢？并不是打印的 Hello You，为什么呢？虽然我们通过模块调用，两次地改变Name，通过 x 改变 Name 为 My，通过 y 改变 Name 为 You，但是，我们在用 x 调用 NameOutput 方法时，为什么不是 x 之前修改的 My 呢？这是因为x与y是指向的是同一个实例，因此My会被You覆盖，最终输出结果是由后者决定的 有的时候我们想的只是把对象封装到一个模块中，比如我们重写 module.js： 123456789function Hello()&#123; var name; this.setName = function(thyName)&#123; name = thyName; &#125;; this.sayHello = function()&#123; console.log(&quot;Hello &quot; + name); &#125;;&#125;; 如果我们需要使用 module.js 中的 Hello 函数，那么，我们通过 require(&#39;module.js&#39;).Hello 来获取 Hello 对象，这显然很麻烦，我们可以简化如下： 我们新建一个hello.js 12345678910function Hello()&#123; //定义一个函数对象，函数名为Hello var name; this.setName = function(thyName)&#123; //定义一个改变name的方法 name = thyName; &#125;; this.sayHello = function()&#123; //定义一个打印name的方法 console.log(&#x27;Hello &#x27; + name); &#125;;&#125;;module.exports = Hello; //暴露接口，导出模块 这样，我们就可以直接获得这个hello对象了 我们新建一个 getHello.js 1234var Hello = require(&#x27;./module&#x27;); //获取module.js文件，导入文件中的模块x = new Hello(); //实例化Hello对象x.setName(&#x27;Ozzie&#x27;); //调用方法，改变name的值x.sayHello(); //调用方法,打印name的值 执行 node getHello.js 的结果是：Hello Ozzie 上述程序中，模块接口的唯一变化就是用 module.exports = Hello 代替了之前的exports.Hello = Hello 其实，exports 本身仅仅只是一个普通的空对象，即 &#123; &#125;，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口本质上它没有任何的特殊性，所以我们也可以用其他东西来代替`exports` 不可以通过对 exports 直接赋值代替对 module.exports 赋值`exports`实际上只是一个和 `module.exports` 指向同一个对象的变量，它本身会在模块执行结束后释放，但`module`不会，因此只能通过指定 `module.exports` 来改变访问接口 创建包 Node.js 中的包类似于 C/C++ 的函数库，将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制，Node.js根据CommonJS规范实现了包机制，用 npm 来解决包的发布和获取需求 Node.js 的包是一个目录，其中包含一个 package.json 文件，用与对此包的说明，虽然 CommonJs 对 Node.js 中的包有很多规范要求，但其实在平时可以不严格遵守该规范… 建立最简单的包 前面也说过，模块与文件是一一对应的，当然，文件不仅可以是 JavaScript代码或二进制代码，还可以是一个文件夹，而最简单的包，就是一个以文件夹的形式建立的 我们创建一个名为somepackage的文件夹，在其中创建index.js，内容如下： 123exports.Hello = function()&#123; console.log(&#x27;Hello Node.js&#x27;);&#125; 在somepackage之外创建一个getSomepackage.js，内容如下： 12var somPackage = require(&#x27;./somepackage&#x27;); //导入包中的模块var x = somPackage.Hello(); //调用方法打印结果 执行 node getSomepackage.js，打印结果 为Hello Node.js 上述方法可以把文件夹封装为一个模块，即所谓的包","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ozzienicholas.gitee.io/tags/node/"}]},{"title":"Node（一）：初识","slug":"Node（一）：初识","date":"2021-03-20T03:37:20.000Z","updated":"2021-03-20T03:40:04.391Z","comments":true,"path":"8eddf70a83b2/","link":"","permalink":"https://ozzienicholas.gitee.io/8eddf70a83b2/","excerpt":"","text":"引言 使用 Node.js 时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的 在创建应用前，需要知道的是，创建 Node 应用需要： 引入 require 模块：我们可以使用 require 命令来载入 node 模块 创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器 接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或者终端发送 HTTP 请求，服务器接收请求后返回响应数据 创建应用 引入 require 模块： 1var http = require(&#x27;http&#x27;) 创建服务器：一方面，我们使用 http.createServer 方法创建服务器，并使用 listen 方法监听 3000 端口；另一方面，我们通过 request 和 response 函数来接收和响应数据，创建名为 test.js 的实例如下： 1234567var http = require(&#x27;http&#x27;);http.createServer(function(request, response) &#123; response.writeHead(200, &#123;&#x27;Content-Type&#x27;: &#x27;text/plain&#x27;&#125;) response.end(&#x27;Hello World!&#x27;)&#125;).listen(3000)// 终端打印如下信息console.log(&#x27;Server running at http://127.0.0.1:3000/&#x27;) response.writeHead 表示向请求的客户端发送响应头 HTTP 状态码为 200 表示成功处理了请求，这也是最常见的返回状态码 Content-Type 用于定义用户的浏览器或相关设备如何显示将要加载的数据，或者如何处理将要加载的数据，而 text/plain 的意思是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理，另外， text/html 的意思是浏览器在获取到这种文件时会自动调用 html 的解析器对文件进行相应的处理 response.end 表示发送响应的数据 打开终端，输入： 1node test.js 再打开浏览器的 3000 端口，你就会看到 Hello World!，这就表明你创建应用成功啦！","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://ozzienicholas.gitee.io/tags/node/"}]},{"title":"HTML+CSS+JS：写出动态滑动登录框","slug":"HTML-CSS-JS：写出动态滑动登录框","date":"2021-03-20T03:35:02.000Z","updated":"2021-03-20T03:35:23.995Z","comments":true,"path":"1a595785865c/","link":"","permalink":"https://ozzienicholas.gitee.io/1a595785865c/","excerpt":"","text":"前言 一段时间没有写一些静态网页样式了，今天在 B 站看了一个视频，准备每天都练练手 B站视频：[HTML+CSS+Js]十分钟写出动态滑动登录框 源码index.html： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./index.css&quot;&gt; &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;show-login-btn&quot;&gt; -&gt; Show Login Form &lt;/div&gt; &lt;div class=&quot;login-box&quot;&gt; &lt;div class=&quot;hide-login-btn&quot;&gt; + &lt;/div&gt; &lt;form action=&quot;index.html&quot; method=&quot;POST&quot; class=&quot;login-form&quot;&gt; &lt;h1&gt;Welcome&lt;/h1&gt; &lt;input class=&quot;txtb&quot; type=&quot;text&quot; name=&quot;&quot; placeholder=&quot;Username&quot; /&gt; &lt;input class=&quot;txtb&quot; type=&quot;password&quot; name=&quot;&quot; placeholder=&quot;Password&quot; /&gt; &lt;input class=&quot;login-btn&quot; type=&quot;submit&quot; name=&quot;&quot; value=&quot;Login&quot; disabled /&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var loginBox = document.getElementsByClassName(&#x27;login-box&#x27;) var showBtn = document.getElementsByClassName(&#x27;show-login-btn&#x27;) var hideBtn = document.getElementsByClassName(&#x27;hide-login-btn&#x27;) function hasClass(element, clssname) &#123; return element.className.match(new RegExp(&#x27;(\\\\s|^)&#x27; + clssname + &#x27;(\\\\s|$)&#x27;)) &#125; function addClass(element, clssname) &#123; if (!this.hasClass(element, clssname)) element.className += &#x27; &#x27; + clssname &#125; function removeClass(element, clssname) &#123; if (hasClass(element, clssname)) &#123; var reg = new RegExp(&#x27;(\\\\s|^)&#x27; + clssname + &#x27;(\\\\s|$)&#x27;) element.className = element.className.replace(reg, &#x27; &#x27;) &#125; &#125; function toggleClass(element, clssname) &#123; if (hasClass(element, clssname)) &#123; removeClass(element, clssname) &#125; else &#123; addClass(element, clssname) &#125; &#125; showBtn[0].addEventListener(&#x27;click&#x27;, function() &#123; toggleClass(loginBox[0], &#x27;showed&#x27;) &#125;) hideBtn[0].addEventListener(&#x27;click&#x27;, function() &#123; toggleClass(loginBox[0], &#x27;showed&#x27;) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788* &#123; font-family: &#x27;montserrat&#x27;, sans-serif;&#125;body &#123; margin: 0; padding: 0; background: #333;&#125;.login-box &#123; position: absolute; top: 0; left: -100%; width: 100%; height: 100vh; /* vh 视口高度 viewport height 百分比单位*/ background-image: linear-gradient( 45deg, #9fbaa8, #31354c); /*设置颜色渐变 方向(0deg垂直向上) 起点颜色 终点颜色*/ transition: 0.4s; /*过度效果 property duration timing-function delay 默认属性:all 0 ease 0*/&#125;.login-form &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); /*定义 2D 转换8 */ color: white; text-align: center;&#125;.login-form h1 &#123; font-weight: 400; margin-top: 0;&#125;.txtb &#123; display: block; box-sizing: border-box; width: 240px; background: #ffffff28; border: 1px solid white; padding: 10px 20px; color: white; outline: none; margin: 10px 0; border-radius: 6px; text-align: center;&#125;.login-btn &#123; width: 240px; background: #2c3e50; border: 0; color: white; padding: 10px; border-radius: 6px; cursor: pointer;&#125;.hide-login-btn &#123; color: #000; position: absolute; top: 40px; right: 40px; cursor: pointer; font-size: 30px; opacity: 0.7; transform: rotate(45deg); /*定义 2D 转换8 */&#125;.show-login-btn &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; border: 2px solid; padding: 10px; cursor: pointer;&#125;.showed &#123; left: 0;&#125; 效果图","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ozzienicholas.gitee.io/tags/css/"}]},{"title":"CSS-Demo：精美的输入框","slug":"CSS-Demo：精美的输入框","date":"2021-03-20T03:34:27.000Z","updated":"2021-03-20T03:34:27.780Z","comments":true,"path":"74c04119a77b/","link":"","permalink":"https://ozzienicholas.gitee.io/74c04119a77b/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"pyecharts 笔记","slug":"pyecharts 笔记","date":"2021-03-20T03:29:30.000Z","updated":"2021-04-28T01:41:23.396Z","comments":true,"path":"e47d03da829b/","link":"","permalink":"https://ozzienicholas.gitee.io/e47d03da829b/","excerpt":"","text":"前述 pyecharts 是一款将 python 与 echarts 结合的强大的数据可视化工具。 之前做一些可视化项目时，用到了百度开源的一个可视化 JS 库 —— Echarts，这里就需要说一下了，可视化类型非常多，其中，使用 echart 时，可以通过从官网上获得源码文件之后再放到项目文件中，也可以通过 npm 获取（获取的命令是 npm install echarts --save），但是大多数都是用 js 完成的 web 开发，比如，https://echarts.apache.org/zh/tutorial.html 这上面的所有案例，都是通过 js 获取，然后在 html 文件里面引入或者在 js 文件中引入，再配置，最后渲染结果。 而这次的项目是基于 python 开发的，也就是没法在 python 项目中进行上述操作，那么很可能要用到 python 自己的可视化库，实际上，python 有很多很多可视化库，我粗略地看了一下，都有十多种，比如 matplotlib、Seaborn、HoloViews、Altair、PyQtGraph，这些可视化库只是对应的用法以及应用场景有些差别，其他的差别不是很大。关于不同的库以及不同的应用场景，这里得好好说一下。 python 是很强大的，不仅仅可以做工程上的项目开发，比如 Django 可以做网站，最主要的功能还是进行数据分析方面，比如大数据应用、人工智能、深度学习、机器学习等，这些都基本上基于 python 的，除了少部分罕见的是基于自己开发的封装性的语言。 那么，如此广的应用场景，也就有许多不同的需求，而 python 官方在最开始是没有为这些需求来提供库的，所以，之后就有了越来越多的开源项目，来开发不同的库，甚至，有些公司，为了安全性考虑，有些公用库或者说公用框架中难免有些 bug，特别是安全性的 bug，比如，npm 这个已经是世界上最大的依赖集成地了，也有非常强大的团队在开发维护，但是都经常在 github 的 issue 上报出一些某个依赖包的漏洞，许多公司出于安全性的考虑，都会开发出自己的专用库甚至是专用框架，有些是开源出来的，有些是仅限内部使用的，所以有时候也会看到，比如 Google 团队，Microsoft 团队 会开源一些项目，他们最开始都是为了填补某一项的空白，往往是功能或性能上的空白。 说回来，我们大致介绍一下 python 的可视化库的一些区别： matplotlib：通过 matplotlib 你可以很轻松地画一些或简单或复杂地图形，几行代码即可生成线图、直方图、功率谱、条形图、错误图、散点图等等，对于一些简单的绘图，特别是与IPython结合使用时，pyplot模块提供了一个matlab接口。你可以通过面向对象的接口或通过一些 matlab 的函数来更改控制行样式、字体属性、轴属性等。 seaborn：seaborn 是基于 matplotlib 产生的一个模块，专攻于统计可视化，可以和pandas进行无缝链接，使初学者更容易上手。相对于 matplotlib，seaborn 语法更简洁，两者关系类似于numpy 和 pandas之间的关系。 HoloViews：HoloViews是一个开源的Python库，可以用非常少的代码行中完成数据分析和可视化，除了默认的matplotlib后端外，还添加了一个Bokeh后端。Bokeh提供了一个强大的平台，通过结合Bokeh提供的交互式小部件，可以使用HTML5 canvas和WebGL快速生成交互性和高维可视化，非常适合于数据的交互式探索。 假如，我之前做过基于 echarts 的项目，现在又想在 python 中使用 echarts，该怎么办呢？Google后，找到一个国人开发的一个Echarts与Python结合的轮子：pyecharts，下面就来简述下pyecharts一些使用细则。 安装 pyecharts 通常用的都是 Win 环境，首先打开命令行(win+R),输入： 1pip install pyecharts 由于墙的原因，下载时会出现断线和速度过慢的问题导致下载失败，所以建议通过清华镜像来进行下载： 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyecharts 出现上方的信息，即代表下载成功，我们可以来进行下一步的实验了！ 使用之前我们要强调一点：就是 python2.x 和 python3.x 的编码问题，在 python3.x 中你可以把它看做默认是 unicode 编码，但在 python2.x 中并不是默认的，原因就在它的 bytes 对象定义的混乱，而 pycharts 是使用 unicode 编码来处理字符串和文件的，所以如果你是使用的是 python2.x，那么请务必在上方插入此代码： 1from future import unicode_literals 现在我们来开始正式使用 pyecharts，这里我们直接使用官方的数据。 使用 pyecharts柱状图 —— Bar12345678910111213141516171819# 导入柱状图-Barfrom pyecharts import Bar# 设置行名columns = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;]# 设置数据data1 = [2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3]data2 = [2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3]# 设置柱状图的主标题与副标题bar = Bar(&quot;柱状图&quot;, &quot;一年的降水量与蒸发量&quot;)# 添加柱状图的数据及配置项bar.add(&quot;降水量&quot;, columns, data1, mark_line=[&quot;average&quot;], mark_point=[&quot;max&quot;, &quot;min&quot;])bar.add(&quot;蒸发量&quot;, columns, data2, mark_line=[&quot;average&quot;], mark_point=[&quot;max&quot;, &quot;min&quot;])# 生成本地文件（默认为.html文件）bar.render() 运行结果如下： 简单的几行代码就可以将数据进行非常好看的可视化，而且还是动态的，在这里还是要安利一下jupyter，pyecharts 在 v0.1.9.2 版本开始，在 jupyter 上直接调用实例（例如上方直接调用bar）就可以将图表直接表示出来，非常方便。 目前 pyecharts 上的图表大概支持到二十多种，接下来，我们再用上方的数据来生成几个数据挖掘常用的图表示例： 饼图 —— Pie1234567891011121314# 导入饼图Piefrom pyecharts import Pie# 设置主标题与副标题，标题设置居中，设置宽度为900pie = Pie(&quot;饼状图&quot;, &quot;一年的降水量与蒸发量&quot;,title_pos=&#x27;center&#x27;,width=900)# 加入数据，设置坐标位置为【25，50】，上方的colums选项取消显示pie.add(&quot;降水量&quot;, columns, data1 ,center=[25,50],is_legend_show=False)# 加入数据，设置坐标位置为【75，50】，上方的colums选项取消显示，显示label标签pie.add(&quot;蒸发量&quot;, columns, data2 ,center=[75,50],is_legend_show=False,is_label_show=True)# 保存图表pie.render() 生成结果如下： 箱体图 —— Boxplot12345678910# 导入箱型图Boxplotfrom pyecharts import Boxplot boxplot = Boxplot(&quot;箱形图&quot;, &quot;一年的降水量与蒸发量&quot;)x_axis = [&#x27;降水量&#x27;,&#x27;蒸发量&#x27;]y_axis = [data1,data2]# prepare_data方法可以将数据转为嵌套的 [min, Q1, median (or Q2), Q3, max]yaxis = boxplot.prepare_data(y_axis) boxplot.add(&quot;天气统计&quot;, x_axis, _yaxis)boxplot.render() 折线图 —— Line1234567from pyecharts import Lineline = Line(&quot;折线图&quot;,&quot;一年的降水量与蒸发量&quot;)# is_label_show是设置上方数据是否显示line.add(&quot;降水量&quot;, columns, data1, is_label_show=True)line.add(&quot;蒸发量&quot;, columns, data2, is_label_show=True)line.render() 雷达图 —— Rader12345678910111213141516171819202122from pyecharts import Radarradar = Radar(&quot;雷达图&quot;, &quot;一年的降水量与蒸发量&quot;)# 由于雷达图传入的数据得为多维数据，所以这里需要做一下处理radar_data1 = [[2.0, 4.9, 7.0, 23.2, 25.6, 76.7, 135.6, 162.2, 32.6, 20.0, 6.4, 3.3]]radar_data2 = [[2.6, 5.9, 9.0, 26.4, 28.7, 70.7, 175.6, 182.2, 48.7, 18.8, 6.0, 2.3]]# 设置column的最大值，为了雷达图更为直观，这里的月份最大值设置有所不同schema = [ (&quot;Jan&quot;, 5), (&quot;Feb&quot;,10), (&quot;Mar&quot;, 10), (&quot;Apr&quot;, 50), (&quot;May&quot;, 50), (&quot;Jun&quot;, 200), (&quot;Jul&quot;, 200), (&quot;Aug&quot;, 200), (&quot;Sep&quot;, 50), (&quot;Oct&quot;, 50), (&quot;Nov&quot;, 10), (&quot;Dec&quot;, 5)]# 传入坐标radar.config(schema)radar.add(&quot;降水量&quot;,radar_data1)# 一般默认为同一种颜色，这里为了便于区分，需要设置item的颜色radar.add(&quot;蒸发量&quot;,radar_data2,item_color=&quot;#1C86EE&quot;)radar.render() 散点图 —— scatter123456from pyecharts import Scatterscatter = Scatter(&quot;散点图&quot;, &quot;一年的降水量与蒸发量&quot;)# xais_name是设置横坐标名称，这里由于显示问题，还需要将y轴名称与y轴的距离进行设置scatter.add(&quot;降水量与蒸发量的散点分布&quot;, data1,data2,xaxis_name=&quot;降水量&quot;, yaxis_name=&quot;蒸发量&quot;, yaxis_name_gap=40)scatter.render() 图表布局 —— Grid由于标题与图表是属于两个不同的控件，所以这里必须对下方的图表Line进行标题位置设置，否则会出现标题重叠的bug。 123456789101112from pyecharts import Grid# 设置折线图标题位置line = Line(&quot;折线图&quot;,&quot;一年的降水量与蒸发量&quot;,title_top=&quot;45%&quot;)line.add(&quot;降水量&quot;, columns, data1, is_label_show=True)line.add(&quot;蒸发量&quot;, columns, data2, is_label_show=True)grid = Grid()# 设置两个图表的相对位置grid.add(bar, grid_bottom=&quot;60%&quot;)grid.add(line, grid_top=&quot;60%&quot;)grid.render() 柱状图-折线图合并12345678from pyecharts import Overlapoverlap = Overlap()bar = Bar(&quot;柱状图-折线图合并&quot;, &quot;一年的降水量与蒸发量&quot;)bar.add(&quot;降水量&quot;, columns, data1, mark_point=[&quot;max&quot;, &quot;min&quot;])bar.add(&quot;蒸发量&quot;, columns, data2, mark_point=[&quot;max&quot;, &quot;min&quot;])overlap.add(bar)overlap.add(line)overlap.render() 踩坑预警pyecharts 是一个十分强大的python绘图库，但是使用过程中或多或少遇到一些问题，在使用 pyecharts 导入 options 包时，如果遇到了无法导入的问题，那么原因多半是 pyecharts 版本不匹配，比如，你使用的是 pyecharts0.1.9.4 的版本，然而 options 包是在 pyecharts1.x 以上的版本才有的。通过查看官方文档发现，pyecharts v0.5.X 和 v1 版本之间是不兼容的。下图是官方文档给版本简介。 所以如果你安装了旧的版本，又想使用 options 包，只能卸载当前版本，重新安装 V1 以上的版本。 使用总结关于 pyecharts，还有很多可视化的用法，这里不一一列举，可以去官网上面查看，因为是国人开发的，所以直接有中文文档：https://pyecharts.org/#/zh-cn/intro 大致的使用步骤就是： 导入相关图表包。 进行图表的基础设置，创建图表对象。 利用 add() 方法进行数据输入与图表设置（可以使用 print_echarts_options() 来输出所有可配置项）。 利用 render() 方法来进行图表保存。 相关的样式对照，可以查看：https://gallery.pyecharts.org/#/Line/README 项目补充 导入包： 1234567891011121314# 导入 柱状图、折线图、地图、词云图from pyecharts.charts import Bar, Line, Map, WordCloud# 从 pyecharts 的组件中，导入表格from pyecharts.components import Table# 踩坑预警：版本问题from pyecharts import options as opts# Component 是用于配置通用配置项，比如主标题样式、副标题样式from pyecharts.options import ComponentTitleOpts# collections 这个模块实现了特定目标的容器，比如一些集合from collections import Counter 绘图： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 国内趋势分析def get_china_trend(): china_day_list_df.loc[:, &#x27;timedate&#x27;] = china_day_list_df[&#x27;year&#x27;] + &#x27;/&#x27; + china_day_list_df[&#x27;date&#x27;] china_day_list_df[&#x27;timedate&#x27;] = china_day_list_df[&#x27;timedate&#x27;].map(lambda x: x.replace(&#x27;.&#x27;, &#x27;/&#x27;)) china_day_list_df[&#x27;timedate&#x27;] = pd.to_datetime(china_day_list_df[&#x27;timedate&#x27;]) china_day_list_df.set_index(china_day_list_df[&#x27;timedate&#x27;], inplace=True) x_data = china_day_list_df.index.tolist() line1 = ( Line() # 折线图上，所有的折线的横坐标是统一的，不同的是纵坐标 # .add_xaxis 是配置横坐标的，一张折线图只有一个 # .add_yaxis 是配置纵坐标的，有多少个折线就有多少个这种函数 .add_xaxis(xaxis_data=x_data) .add_yaxis( # 系列名称，用于 tooltip 的显示，legend 的图例筛选。 series_name=&quot;国内累计确诊&quot;, # 数据堆叠，同个类目轴上系列配置相同的 stack 值可以堆叠放置。 stack=&quot;总量&quot;, areastyle_opts=&quot;&quot;, y_axis=china_day_list_df[&#x27;confirm&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) # 其中一条名为 “国内死亡病例” 的折线 .add_yaxis( series_name=&quot;国内死亡病例&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;&quot;, y_axis=china_day_list_df[&#x27;dead&#x27;].values.tolist(), # 标签配置项 label_opts=opts.LabelOpts(is_show=False), ) .add_yaxis( series_name=&quot;国内治愈病例&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;&quot;, y_axis=china_day_list_df[&#x27;heal&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) .add_yaxis( series_name=&quot;境外输入病例&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;&quot;, y_axis=china_day_list_df[&#x27;importedCase&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) .add_yaxis( series_name=&quot;本地新增病例&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;&quot;, y_axis=china_day_list_df[&#x27;localConfirm&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) .add_yaxis( series_name=&quot;无症状感染者&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;yellow&quot;, y_axis=china_day_list_df[&#x27;noInfect&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) .add_yaxis( series_name=&quot;现有确诊病例&quot;, stack=&quot;总量&quot;, areastyle_opts=&quot;red&quot;, y_axis=china_day_list_df[&#x27;now_confirm&#x27;].values.tolist(), label_opts=opts.LabelOpts(is_show=False), ) .set_global_opts( title_opts=opts.TitleOpts(title=&quot;&quot;), tooltip_opts=opts.TooltipOpts(trigger=&quot;axis&quot;), yaxis_opts=opts.AxisOpts( type_=&quot;value&quot;, axistick_opts=opts.AxisTickOpts(is_show=True), splitline_opts=opts.SplitLineOpts(is_show=True), ), xaxis_opts=opts.AxisOpts(type_=&quot;category&quot;, boundary_gap=False), legend_opts=opts.LegendOpts(pos_right=&#x27;top&#x27;), datazoom_opts=opts.DataZoomOpts(range_start=40, range_end=80) ) ) return line1 1234567891011121314151617181920212223def get_contient_compare_bar() -&gt; Bar: df = world_data_list_df.groupby(&#x27;continent&#x27;).agg( &#123;&quot;confirm&quot;: &quot;sum&quot;, &quot;dead&quot;: &quot;sum&quot;, &quot;heal&quot;: &quot;sum&quot;&#125; ) bar = ( Bar() .add_xaxis(df.index.tolist()) .add_yaxis(&quot;确诊&quot;, df[&#x27;confirm&#x27;].to_list()) .add_yaxis(&quot;死亡&quot;, df[&#x27;dead&#x27;].to_list()) .add_yaxis(&quot;治愈&quot;, df[&#x27;heal&#x27;].to_list()) # set_global_opts 是列表配置项 # def set_global_opts( # 标题配置项，参考 `ComponentTitleOpts` # title_opts: Union[ComponentTitleOpts, dict, None] = None # ) .set_global_opts(title_opts=opts.TitleOpts(title=&quot;&quot;), legend_opts=opts.LegendOpts(pos_right=&#x27;top&#x27;), datazoom_opts=opts.DataZoomOpts(range_start=40, range_end=80), ) ) return bar","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://ozzienicholas.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"CSS-盒模型","slug":"CSS-盒模型","date":"2021-03-20T03:21:42.000Z","updated":"2021-03-20T03:33:32.637Z","comments":true,"path":"0c170b8a39ed/","link":"","permalink":"https://ozzienicholas.gitee.io/0c170b8a39ed/","excerpt":"","text":"对一个文档进行布局的时候，浏览器的渲染引擎会根据CSS基础框盒模型将所有元素表示为一个个矩形盒，CSS决定这些盒子的大小、位置以及属性。 可以认为，HTML 的每个标签都是一个方块，这个方块又包着几个小方块，如同盒子一样，一层一层包裹着，这就是盒模型。 盒模型分为IE盒模型和W3C标准盒模型。两者区别如下： IE盒模型：属性 width与height 包含 content、border 和 padding： 123width &#x3D; content(内容的宽度) + border(边框) + padding(内边距)height &#x3D; content(内容的高度) + border(边框) + padding(内边距)注意，这里是只加 border 和 padding，不加 margin(外边距) W3C标准盒模型：属性 width 与 height 只包含 content： 12width &#x3D; 内容的宽度height &#x3D; 内容的高度 在 IE6、IE7 中，docutype 缺失则会触发 IE 模式。在 IE8 中，可以通过CSS新增的属性 box-sizing 来选择使用哪一个盒模型，默认为 content-box，即标准盒模型，若设置为 border-box，则为IE盒模型。 当前的 W3C 标准中，盒模型可以通过 box-sizing 自由切换。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"css","slug":"前端/css","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://ozzienicholas.gitee.io/tags/css/"}]},{"title":"Echarts 使用笔记","slug":"Echarts笔记","date":"2021-03-20T03:20:30.000Z","updated":"2021-04-21T01:27:50.832Z","comments":true,"path":"6f021f452db4/","link":"","permalink":"https://ozzienicholas.gitee.io/6f021f452db4/","excerpt":"","text":"介绍Echarts 是一个基于 JavaScript 的开源可视化图表库 使用如何获取 echarts 在 echarts 官网获取官方源码包后构建。 或者通过 npm 下载依赖包，该命令是 npm install echarts --save。 如何引入 echarts通过标签方式直接引入构建好的 echarts 文件 12345678&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 引入 ECharts 文件 --&gt; &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 如何绘制图表 为 echarts 准备一个具备高宽的 dom 容器。 1234&lt;body&gt; &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;&lt;/body&gt; 然后通过 echarts.init 方法初始一个 echarts 实例，并通过 echarts 内置的方法，构建图表，比如，通过 setOption 方法绘制一个柱状图，如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入 echarts.js --&gt; &lt;script src=&quot;echarts.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt; &lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.init(document.getElementById(&#x27;main&#x27;)); // 指定图表的配置项和数据 var option = &#123; title: &#123; text: &#x27;ECharts 入门示例&#x27; &#125;, tooltip: &#123;&#125;, legend: &#123; data:[&#x27;销量&#x27;] &#125;, xAxis: &#123; data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;] &#125;, yAxis: &#123;&#125;, series: [&#123; name: &#x27;销量&#x27;, type: &#x27;bar&#x27;, data: [5, 20, 36, 10, 10, 20] &#125;] &#125;; // 使用刚指定的配置项和数据显示图表。 myChart.setOption(option); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如何按需引入 echart 图表和组件从官网上获取的源码或者从 npm 下载的依赖包都包含了 echarts 中所有的图表和组件， 但是如果不想引入所有组件，比如，我只需要绘制一个柱状图，那么我只需要引入 echarts 中的柱状图的组件即可。 按需引入的方法如下： 123456789101112131415161718192021222324252627282930// 引入 echarts 核心模块，核心模块提供了 echarts 使用必须要的接口。import * as echarts from &#x27;echarts/core&#x27;;// 引入柱状图图表，图表后缀都为 Chartimport &#123; BarChart&#125; from &#x27;echarts/charts&#x27;;// 引入提示框，标题，直角坐标系组件，组件后缀都为 Componentimport &#123; TitleComponent, TooltipComponent, GridComponent&#125; from &#x27;echarts/components&#x27;;// 引入 Canvas 渲染器，注意引入 CanvasRenderer 或者 SVGRenderer 是必须的一步import &#123; CanvasRenderer&#125; from &#x27;echarts/renderers&#x27;;// 注册必须的组件echarts.use( [TitleComponent, TooltipComponent, GridComponent, BarChart, CanvasRenderer]);// 接下来的使用就跟之前一样，初始化图表，设置配置项var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));myChart.setOption(&#123; ...&#125;); 基础概念echarts 实例一个网页中可以创建多个 echarts 实例。每个 echarts 实例 中可以创建多个图表和坐标系等等（用 option 来描述）。准备一个 DOM 节点（作为 echarts 的渲染容器），就可以在上面创建一个 echarts 实例。每个 echarts 实例独占一个 DOM 节点。 系列（series）在 echarts 中，不仅表示数据，也表示数据映射成为的图。 一个 系列 包含的要素至少有：一组数值、图表类型（series.type）、以及其他的关于这些数据如何映射成图的参数。 如下图，右侧的 option 中声明了三个 系列（series）：pie（饼图系列）、line（折线图系列）、bar（柱状图系列），每个系列中有他所需要的数据（series.data）。 组件（component）例如，echarts 中至少有这些组件：xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）、angleAxis（极坐标系角度轴）、radiusAxis（极坐标系半径轴）、polar（极坐标系底板）、geo（地理坐标系）、dataZoom（数据区缩放组件）、visualMap（视觉映射组件）、tooltip（提示框组件）、toolbox（工具栏组件）、series（系列）、… 如下图，右侧的 option 中声明了各个组件（包括系列），各个组件就出现在图中。 用 option 描述图表我们使用 option 来描述其对图表的各种需求，包括：有什么数据、要画什么图表、图表长什么样子、含有什么组件、组件能操作什么事情等等。简而言之，option 表述了：数据、数据如何映射成图形、交互行为。 123456789101112131415161718192021222324252627282930313233// 创建 echarts 实例。var dom = document.getElementById(&#x27;dom-id&#x27;);var chart = echarts.init(dom);// 用 option 描述 `数据`、`数据如何映射成图形`、`交互行为` 等。// option 是个大的 JavaScript 对象。var option = &#123; // option 每个属性是一类组件。 legend: &#123;...&#125;, grid: &#123;...&#125;, tooltip: &#123;...&#125;, toolbox: &#123;...&#125;, dataZoom: &#123;...&#125;, visualMap: &#123;...&#125;, // 如果有多个同类组件，那么就是个数组。例如这里有三个 X 轴。 xAxis: [ // 数组每项表示一个组件实例，用 type 描述“子类型”。 &#123;type: &#x27;category&#x27;, ...&#125;, &#123;type: &#x27;category&#x27;, ...&#125;, &#123;type: &#x27;value&#x27;, ...&#125; ], yAxis: [&#123;...&#125;, &#123;...&#125;], // 这里有多个系列，也是构成一个数组。 series: [ // 每个系列，也有 type 描述“子类型”，即“图表类型”。 &#123;type: &#x27;line&#x27;, data: [[&#x27;AA&#x27;, 332], [&#x27;CC&#x27;, 124], [&#x27;FF&#x27;, 412], ... ]&#125;, &#123;type: &#x27;line&#x27;, data: [2231, 1234, 552, ... ]&#125;, &#123;type: &#x27;line&#x27;, data: [[4, 51], [8, 12], ... ]&#125; &#125;]&#125;;// 调用 setOption 将 option 输入 echarts，然后 echarts 渲染图表。chart.setOption(option); 组件的定位基于 top / right / down / left / width / height 绝对定位。 这种绝对定位的方式，类似于 CSS 的绝对定位（position: absolute）。 个性化设置阴影ECharts 中有一些通用的样式，诸如阴影、透明度、颜色、边框颜色、边框宽度等，这些样式一般都会在系列的 itemStyle 里设置。例如： 12345678910itemStyle: &#123; // 阴影的大小 shadowBlur: 200, // 阴影水平方向上的偏移 shadowOffsetX: 0, // 阴影垂直方向上的偏移 shadowOffsetY: 0, // 阴影颜色 shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;&#125; itemStyle的emphasis是鼠标 hover 时候的高亮样式。这个示例里是正常的样式下加阴影，但是可能更多的时候是 hover 的时候通过阴影突出。 123456itemStyle: &#123; emphasis: &#123; shadowBlur: 200, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27; &#125;&#125; 深色背景和浅色标签背景色是全局的，所以直接在 option 下设置 backgroundColor 123setOption(&#123; backgroundColor: &#x27;#2c343c&#x27;&#125;) 文本的样式可以设置全局的 textStyle。 12345setOption(&#123; textStyle: &#123; color: &#x27;rgba(255, 255, 255, 0.3)&#x27; &#125;&#125;) 也可以每个系列分别设置，每个系列的文本设置在 label.textStyle。 12345label: &#123; textStyle: &#123; color: &#x27;rgba(255, 255, 255, 0.3)&#x27; &#125;&#125; 饼图的话还要将标签的视觉引导线的颜色设为浅色。 12345labelLine: &#123; lineStyle: &#123; color: &#x27;rgba(255, 255, 255, 0.3)&#x27; &#125;&#125; 扇形扇形的颜色也是在 itemStyle 中设置： 123456itemStyle: &#123; // 设置扇形的颜色 color: &#x27;#c23531&#x27;, shadowBlur: 200, shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;&#125; 每个扇形颜色的可以通过分别设置 data 下的数据项实现。 1234567data: [&#123; value:400, name:&#x27;搜索引擎&#x27;, itemStyle: &#123; color: &#x27;#c23531&#x27; &#125;&#125;, ...] 调色盘调色盘，可以在 option 中设置。它给定了一组颜色，图形、系列会自动从其中选择颜色。 可以设置全局的调色盘，也可以设置系列自己专属的调色盘。 12345678910111213141516option = &#123; // 全局调色盘。 color: [&#x27;#c23531&#x27;,&#x27;#2f4554&#x27;, &#x27;#61a0a8&#x27;, &#x27;#d48265&#x27;, &#x27;#91c7ae&#x27;,&#x27;#749f83&#x27;, &#x27;#ca8622&#x27;, &#x27;#bda29a&#x27;,&#x27;#6e7074&#x27;, &#x27;#546570&#x27;, &#x27;#c4ccd3&#x27;], series: [&#123; type: &#x27;bar&#x27;, // 此系列自己的调色盘。 color: [&#x27;#dd6b66&#x27;,&#x27;#759aa0&#x27;,&#x27;#e69d87&#x27;,&#x27;#8dc1a9&#x27;,&#x27;#ea7e53&#x27;,&#x27;#eedd78&#x27;,&#x27;#73a373&#x27;,&#x27;#73b9bc&#x27;,&#x27;#7289ab&#x27;, &#x27;#91ca8c&#x27;,&#x27;#f49f42&#x27;], ... &#125;, &#123; type: &#x27;pie&#x27;, // 此系列自己的调色盘。 color: [&#x27;#37A2DA&#x27;, &#x27;#32C5E9&#x27;, &#x27;#67E0E3&#x27;, &#x27;#9FE6B8&#x27;, &#x27;#FFDB5C&#x27;,&#x27;#ff9f7f&#x27;, &#x27;#fb7293&#x27;, &#x27;#E062AE&#x27;, &#x27;#E690D1&#x27;, &#x27;#e7bcf3&#x27;, &#x27;#9d96f5&#x27;, &#x27;#8378EA&#x27;, &#x27;#96BFFF&#x27;], ... &#125;]&#125; 直接的样式设置ECharts 的 option 中，很多地方可以设置 itemStyle、lineStyle、areaStyle、label 等等。这些的地方可以直接设置图形元素的颜色、线宽、点的大小、标签的文字、标签的样式等等。 高亮的样式在鼠标悬浮到图形元素上时，一般会出现高亮的样式。默认情况下，高亮的样式是根据普通样式自动生成的。但是高亮的样式也可以自己定义，主要是通过 emphasis 属性来定制。emphsis 中的结构，和普通样式的结构相同，例如： 1234567891011121314151617181920212223242526272829option = &#123; series: &#123; type: &#x27;scatter&#x27;, // 普通样式。 itemStyle: &#123; // 点的颜色。 color: &#x27;red&#x27; &#125;, label: &#123; show: true, // 标签的文字。 formatter: &#x27;This is a normal label.&#x27; &#125;, // 高亮样式。 emphasis: &#123; itemStyle: &#123; // 高亮时点的颜色。 color: &#x27;blue&#x27; &#125;, label: &#123; show: true, // 高亮时标签的文字。 formatter: &#x27;This is a emphasis label.&#x27; &#125; &#125; &#125;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"Axios-笔记","slug":"Axios-笔记","date":"2021-03-20T03:19:30.000Z","updated":"2021-03-20T03:19:49.790Z","comments":true,"path":"e5f790a29ad3/","link":"","permalink":"https://ozzienicholas.gitee.io/e5f790a29ad3/","excerpt":"","text":"Axios 介绍 基于 promise 的，用于浏览器和 NodeJs 的 HTTP 客户端 特点： 支持浏览器和 Node.js 支持 promise 能拦截请求和响应 能转换请求和响应数据 能取消请求 自动转换 JSON 数据 浏览器端支持防止 CSRF（跨站请求伪造） 官网： axios中文文档|axios中文网 Axios 中文说明 安装 axios： CSD 引入： 1&lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; Npm 安装： 1npm install axios Bower 安装： 1bower install axios Axios 使用使用案例 发送一个 get 请求： 123axios.get(&#x27;/user?ID=12345&#x27;) .then(res =&gt; console.log(response)) .then(error =&gt; console.log(error)) 以上请求也可以变式为： 1234567axios.get(&#x27;/user&#x27;, &#123; params: &#123; ID:12345 &#125;&#125;).then(res =&gt; console.log(response)).then(error =&gt; console.log(error)) 发送一个 post 请求： 123456axios.get(&#x27;/user&#x27;, &#123; firstName: &#x27;Ozzie&#x27;, lastName: &#x27;Nicholas&#x27;&#125;).then(res =&gt; console.log(response)).then(error =&gt; console.log(error)) 同时发起多个请求： 123456let getUserAccout = () =&gt; &#123; axios.get(&#x27;/user?ID=12345&#x27;); &#125;let getUserPermissions = () =&gt; &#123; axios.get(&#x27;/user/12345/permissions&#x27;); &#125;axios.all([getUserAccout(), getUserPermissions()]).then(axios.spread(function (acct, perms)) &#123; // 两个请求完成时，触发此函数，acct 与 perms 分别代表两个请求返回的结果&#125;) Axios API 可以通过设置 axios 的配置来创建请求 axios(config)： 123456789// 发送 post 请求axios.post(&#123; method: &#x27;POST&#x27;, url: &#x27;/user/12345&#x27;, data: &#123; firstName: &#x27;Ozzie&#x27;, lastName: &#x27;Nicholas&#x27; &#125;&#125;) axios(url[,config])： 1234// 发送 get 请求axios.get(&#x27;/user/12345&#x27;).then(res =&gt; console.log(res))// 如果不指明何种请求，则默认 getaxios(&#x27;/user/12345&#x27;).then(res =&gt; console.log(res)) 请求方法的别名： 12345678910111213axios.get(url[,config])axios.post(url[,data,[,config]])axios.put(url[,data[,config]])axios.delete(url[,config])axios.head(url[,config])axios.patch(url,[,data[,config]])axios.request(config) 在使用方法名时，url、method、data 这些属性都可以不在配置（config）中指定，也不用在config 中重复声明。 同时发生的请求（以下两个是用来处理同时发生多个请求的辅助函数）： 12345// iterable 是一个可迭代的参数，比如数组axios.all(iterable);// callback 要等到所有请求都完成才会执行axios.spread(callback); 创建实例（可以用自定义配置来新建一个 axios 实例，自定义配置需要用到 axios.create([config])）： 1234567let instance = axios.create(&#123; baseURL: &#x27;https://some-domain.com/api/&#x27;, timeout: 1000, headers: &#123; &#x27;X-Custom-Header&#x27;: &#x27;foobar&#x27; &#125;&#125;) 实例方法（以下是可用的实例方法，指定的配置将与实例的配置合并，即额外声明的配置会和axios.create 创建的实例的配置合并）： 12345678910111213axios#get(url[,config])axios#post(url[,data,[,config]])axios#put(url[,data[,config]])axios#delete(url[,config])axios#head(url[,config])axios#patch(url,[,data[,config]])axios#request(config) 请求的配置 这些是创建请求时可以用的配置选项，其中只有 url 是必需的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&#123; // url 是用于请求服务器的 url url: &#x27;/user&#x27;, // method 是创建请求所使用的方法 method: &#x27;get&#x27;, // 若没有指定 method，则默认请求为 get // baseURL 的值会自动加在 url 前面，除非 url 是一个绝对的 url // 通过设置一个 baseURL 便于为 axios 实例方法传递相对 url baseURL: &#x27;https://some-domain.com/api/&#x27;, // transformRequest 允许在向服务器发送请求前修改请求数据 // 只能用在 put、post、patch 这几个请求方法上面 transformRequest: [function(data) &#123; // 数组中的函数必须返回一个字符串，或者 ArrayBuffer，或者 Stream return data; // 对 data 进行任意转换处理 &#125;], // transformResponse 允许在传递 then/catch 之前修改响应数据 transformResponse: [function(data) &#123; return data; // 对 data 进行任意转换处理 &#125;], // headers 是即将被发送的自定义请求头 headers: &#123; &#x27;X-Request-With&#x27;: &#x27;XMLHttpRequest&#x27; &#125;, // params 是即将与请求一起发送的 url 参数 // 必须是一个无格式对象（plain object）或者 URLSearchParams 对象 params: &#123; ID: 12345 &#125;, // paramsSerializer 是一个负责 params 序列化的函数 paramsSerializer: function(params) &#123; return Qs.stringify(params, &#123; arrayFormat: &#x27;brackets&#x27; &#125;) &#125;, // data 是作为请求主体被发送的数据 // 适用的请求方法只有：put、post、patch /* 若没有设置 transformRequest，则必须是以下类型之一： string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams 浏览器专属：FormData, File, Blob Node 专属：Stream */ data: &#123; firstName: &#x27;Ozzie&#x27;, lastName: &#x27;Nicholas&#x27; &#125;, // timeout 指定了请求超时的毫秒数（0 表示无超时时间），请求超时则会中断 timeout: 1000, // 默认值为0，即默认永不超时 // withCredentials 表示跨域请求时是否需要凭证 withCredentials: false, // 不指定值则默认为 false // adapter 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 adapter: function(config) &#123; // ... &#125;, // auth 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 Authorization 头，覆写掉现有的任意使用 header 设置的自定义 Authorization 头 auth: &#123; username: &#x27;Alice&#x27;, password: &#x27;123456&#x27; &#125;, // responseType 表示服务器响应的数据类型 // 数据类型可选值：&#x27;arrayBuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27; responseType: &#x27;json&#x27;, // 默认值为 &#x27;json&#x27; // xsrfCookieName 是用作 xsrf token 的值的 HTTP 头的名称 xsrfCookieName: &#x27;X-XSRF-TOKEN&#x27;, //默认值为 &#x27;X-XSRF-TOKEN&#x27;, // onUploadProgress 允许为上传处理进度事件 onUploadProgress: function(progressEvent) &#123; // 对原生进度事件的处理 &#125;, // onDownloadProgress 允许为下载处理进度事件 onDownloadProgress: function(progressEvent) &#123; // 对原生进度事件的处理 &#125;, // maxContentLength 的值会定义允许的响应内容的最大尺寸 maxContentLength: 2000, // validateStatus 定义对于给定 HTTP 的响应状态码是 resolve 或 reject promise // 若 validateStatus 返回 true (或者设置为 null 或 undefined)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function(status) &#123; return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认为此 &#125;, // httpAgent 和 httpsAgent 分别在 node 中用于定义在执行 http 和 https 时使用的自定义代理 // 允许像如下的配置选项（keepAlive 默认没有启用）： httpAgent: new http.Agent(&#123; keepAlive: true &#125;), httpsAgent: new http.Agent(&#123; keepAlive: true &#125;), // proxy 定义代理服务器的主机名称和端口 // auth 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 Proxy-Authorization 头，覆写掉已有的通过使用 header 设置的自定义Proxy-Authorization 头 proxy: &#123; host: &#x27;127.0.0.1&#x27;, port: 8000, auth: &#123; username: &#x27;Jack&#x27;, password: &#x27;000000&#x27; &#125; &#125;, // cancelToken 指定用于取消请求的 cancel token cancelToken: new CancelToken(function(cancel) &#123; // ... &#125;)&#125; 关于配置参数 params 中提到的 “无格式对象或 URLSearchParams”：axios的参数必须是：无格式对象(plain object)或 URLSearchParams 对象是什么意思？ 关于序列化函数 paramsSerializer： Configure custom paramsSerializer axios get传递数组 paramsSerializer序列化 jQuery.param() qs - npm 响应的结构 请求的响应内容如下： 123456789101112&#123; // 服务端返回的数据 data: &#123;&#125;, // 服务端返回的状态码 status: 200, // 服务端返回的状态信息 statusText: OK, // 响应头（所有的响应头名称都是小写） headers: &#123;&#125;, // axios 配置信息 config: &#123;&#125;&#125; 使用 then 方法接收响应： 12345678axios.get(&#x27;/user/12345&#x27;) .then(response =&gt; &#123; console.log(response.data); console.log(response.status); console.log(response.statusText); console.log(response.headers); console.log(response.config); &#125;); 使用 catch 方法或者传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象被使用。 配置默认值 在各个配置参数上，都可以指定各个请求的配置默认值 全局的 axios 配置默认值： 123axios.default.baseURL = &#x27;https://api.example.com&#x27;;axios.default.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN;axios.default.headers.post[&#x27;Content-Type&#x27;] = &#x27;application/x-www-form-urlencoded&#x27;; 自定义的实例默认值： 创建实例时就设置配置的默认值： 123let instance = axios.create(&#123; baseURL: &#x27;https://api.example.com&#x27;&#125;) 实例创建之后修改默认值： 1instance.default.headers.common[&#x27;Authorization&#x27;] = AUTH_TOKEN; 配置的先后顺序：配置会按照优先级的顺序进行合并，优先级为：设置请求的 config 值 &gt; 实例的 default 属性 &gt; lib/default.js 中的默认值（库的默认值） 案例： 123456789101112// 使用由库提供的配置的默认值来创建实例// 此时超时配置的默认值是 `0`let instance = axios.create();// 覆写库的超时默认值// 现在，在超时前，所有请求都会等待 2.5 秒instance.defaults.timeout = 2500;// 为已知需要花费很长时间的请求覆写超时设置instance.get(&#x27;/longRequest&#x27;, &#123; timeout: 5000&#125;); 拦截器 在请求或者响应被 then 或者 catch 方法处理之前，你可以拦截它们： 添加一个请求拦截器： 1234567axios.interceptors.request.use(config =&gt; &#123; // 发送请求之前需要做的事情 return config;&#125;, error =&gt; &#123; // 对请求发送错误做的事情 return Promise.reject(error);&#125;) 添加一个响应拦截器： 1234567axios.interceptors.response.use(response =&gt; &#123; // 发送响应数据之前需要做的事情 return response;&#125;, error =&gt; &#123; // 对响应错误做的事情 return Promise.reject(error);&#125;) 当然，也可以移除拦截器： 12let myInterceptor = axios.interceptors.request.use(() =&gt; &#123;/*...*/&#125;);axios.interceptors.request.eject(myInterceptor); 也可以为自定义的 axios 实例添加对应的拦截器： 12let instance = axios.create(/*...*/);instance.interceptors.request.use(() =&gt; &#123;/*...*/&#125;); 错误处理 之前我们用 catch 方法简单地处理过错误发生的情况，但若发生错误，那么我们仍然可以打印出更详细的错误信息： 123456789101112131415axios.get(&#x27;/user/12345&#x27;).catch(error =&gt; &#123; if(error.response) &#123; 请求已经发出，但是服务器响应的状态码不在 2xx 范围内 console.log(error.response.data); console.log(error.response.status); console.log(error.response.headers); &#125; else if(error.request) &#123; // 请求发生错误要做的事情 console.log(error.request); &#125; else &#123; // 其他错误 console.log(error.message); &#125; console.log(error.config);&#125;) 可以配置 validateStatus 选项来定义一个 http 状态码的错误范围： 12345axios.get(&#x27;/user/12345&#x27;, &#123; validateStatus: status =&gt; &#123; return status&lt;500; // 状态码（status）在大于或者等于500时，才会拒绝 &#125;&#125;) 取消请求可以通过 cancel token 来取消已发送的请求： 通过 CancelToken.source 工厂函数来创建一个 cancel token： 1234567891011121314let CancelToken = axios.CancelToken;let Source = CancelToken.source();axios.get(&#x27;/user/12345&#x27;, &#123; CancelToken: Source.token&#125;).catch(thrown =&gt; &#123; if(axios.isCancel(thrown)) &#123; console.log(&#x27;Request canceled&#x27;, thrown.message); &#125;else &#123; // 处理错误 &#125;&#125;)// 取消请求Source.cancel(&#x27;Chrome canceled by the user.&#x27;); 还可以给 CancelToken 的构造函数传递一个 executor 函数来创建 cancel token： 1234567891011let CancelToken = axios.CancelToken;let cancel;axios.get(&#x27;/user/12345&#x27;, &#123; cancelToken: new CancelToken(function executor(c) &#123; // executor 函数接收一个 cancel 函数作为参数 cancel = c; &#125;)&#125;)// 取消请求cancel(); 可以用同一个 cancel token 取消多个请求","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"npm开发技巧","slug":"npm-开发技巧","date":"2021-03-20T03:18:51.000Z","updated":"2021-03-20T03:19:13.670Z","comments":true,"path":"6ec7fd968a3a/","link":"","permalink":"https://ozzienicholas.gitee.io/6ec7fd968a3a/","excerpt":"","text":"前言每天，数以百万计的开发人员使用 npm 或者 yarn 来构建项目。无论是为客户端或服务器端，还是桌面应用程序，运行 npm init 或者 npx create-response-app 等命令来构建项目几乎是首选方式。 但是，npm 不仅仅用来初始化项目或者安装包，这里将介绍 13 个技巧来最大限度地利用 npm 从简单的快捷方式到自定义脚本。 本次内容是： 快捷方式 设置默认 npm init 属性 让脚本跨平台兼容 并行运行脚本 在不同的目录中运行脚本 延迟运行脚本直到端口准备就绪 列出并选择可用脚本 运行前后脚本 控制应用程序版本 从命令行编辑 package.json 自动设置和打开你的 github 库 自定义 npm init 脚本 使用自定义 npm init 脚本将你的第一个 Commit 提交到 GitHub 快捷方式基本快捷方式 安装： 常规：npm install 简写：npm i 测试： 常规：npm test 简写：npm t 帮助： 常规：npm --help 简写：npm -h 全局标志： 常规：--global 简写：-g 保存为开发依赖： 常规：--save-dev 简写：-D npm init 默认值： 常规：npm init --yes 或者 npm init --force 简写：npm init -y 或者 npm init -f 另外，用 --save（或者 -S）来保存包已经是默认值，若你需要安装一个包但是不保存它，可以使用 no -save 标志 不太常见的快捷键 安装包信息将加入到 optionalDependencies（可选阶段的依赖）： 常规：--save-optional 简写：-O 如果需要在本地保存一个 npm 包，或者通过单个文件下载一组可用的包，可以使用 --save-bundle（简写为 -B）来将它们捆绑在一起，并使用 npm pack 或者捆绑包 根的快捷方式. 符号通常用于表示应用程序的根目录，npm 中的应用程序入口点，就是 package.json 中指定为 &quot;main&quot; 的值： 123&#123; &quot;main&quot;: &quot;index.js&quot;&#125; 这个快捷方式也可以用于像 npx create-react-app 这样的命令。因此，可以运行 npx create-react-app，而不是使用 npx create-react-app my-app 去创建一个新的 my-app 目录 设置默认 npm init 属性 当开始一个新的项目时，你可能会一次又一次地输入配置细节，我们可以为这些字段设置默认值，例如： 1234npm config set init.author.name &quot;ozzie&quot;npm config set init.author.email &quot;ozzie@gmail.com&quot;npm config set init.author.url &quot;ozzie.com&quot;npm config set init.license &quot;MIT&quot; 要检查是否正确添加了这些属性，在终端输入 npm config edit 查看配置文件信息。当然也j可以通过直接在打开的配置文件编辑信息。 如果要编辑全局 npm 设置，使用 npm config edit -g 若要重新初始化默认设置，可以使用以下脚本： 12echo &quot;&quot; &gt; $(npm config get userconfig)npm config edit 第一行用空字符串替换配置文件 第二行用默认设置重新填充配置文件 上面的脚本将重置用户默认值，下面的脚本将重置全局默认值 12echo &quot;&quot; &gt; $(npm config get globalconfig)npm config --global edit 让脚本跨平台兼容 任何在命令上运行的代码都有兼容性问题的风险，特别是在 Windows 和基于 unix 的系统（包括 Mac 和 Linux）之间，如果你只处理特定的项目，那么这不是问题，但许多情况下，跨平台兼容性是很有必要的，即任何开源代码或者协作项目，以及示例和教程项目，都应该能够工作，而不管操作系统是什么。 解决方案很简单，有几个选项可供选择，但效果最好的是 cross-env，使用 npm i -D cross-env 将其作为开发依赖项来安装，然后在任何环境变量之前包括关键字 cross-env，例如： 12345&#123; &quot;scripts&quot;: &#123; &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot; &#125;&#125; cross-env 是实现跨平台兼容性的最无缝的方法，但还有其他两个流行的 工具，它们可以帮助实现跨平台兼容性： rimraf：可以安装在全球运行跨平台脚本 ShellJS：是Unix shell命令在 node 的 api 上的可移植实现 并行运行脚本 我们知道，可以使用 &amp;&amp; 来依次运行两个或多个进程，但是并行运行脚本呢？ 我们可以从各种 npm 包中进行选择，concurrent 和 npm-run-all 是最流行的解决方案。 首先通过 npm i -D concurrently 安装开发依赖，然后按照以下格式将其添加到脚本中： 123&#123; &quot;start&quot;: &quot;concurrently \\&quot;command1 arg\\&quot; \\&quot;command2 arg\\&quot;&quot;&#125; 在不同的目录中运行脚本 有时，在不同的文件夹中拥有一个包含多个 package.json 文件的应用程序，从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作： 手动 cd 并运行对应的命令： 1cd folder &amp;&amp; npm start &amp;&amp; cd .. 还有一个更好的解决方案，即使用 --prefix 标志指定路径： 1npm start --prefix path&#x2F;to&#x2F;your&#x2F;folder 下面是一个工作应用程序中此解决方案的示例，我们希望在前端（在客户机目录中）和后端（在服务器目录中）运行 npm start： 1&quot;start&quot;: &quot;concurrently \\&quot;(npm start --prefix client)\\&quot; \\&quot;(npm start --prefix server)\\&quot;&quot;, 延迟运行脚本直到端口准备就绪 通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。wait-on 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。 例如，这是我在使用 react 前端的 Electron 项目中使用的 dev 脚本。同时使用，脚本并行加载表示层和 Electron 窗口。但是，使用 wait-on，只有在 http://localhost:3000 启动好，才会打开Electron窗口。 1&quot;dev&quot;: &quot;concurrently \\&quot;cross-env BROWSER=none npm run start\\&quot; \\&quot;wait-on http://localhost:3000 &amp;&amp; electron .\\&quot;&quot;, 此外，react 默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量 BROWSER=none 来禁用此行为。 列出并选择可用脚本 列出 package.json 文件中可用的脚本很简单：只需转到项目的根目录并在终端中输入 npm run。 但是有一种更方便的方法可以获得脚本列表，可以立即运行该列表，为此，全局安装 NTL（npm任务列表）模块： 1npm i -g ntl 然后在项目文件夹中运行 ntl 命令，可以获得一个可用脚本列表，并可以选择其中一个运行： 运行前后脚本 你可能熟悉 prebuild 和 postbuild 这样的脚本，它们允许你定义在构建脚本之前或之后运行的代码。但事实上，pre 和 post可以在任何脚本之前添加，包括自定义脚本。 这不仅使你的代码更干净，而且还允许你单独运行 pre 和 post脚本。 控制应用程序版本 与手动更改应用程序的版本相比，npm 提供了一些有用的快捷方式来完成这一点。要增加版本，请在运行 npm version 加上 major，minor 或 patch： 1234567&#x2F;&#x2F; 1.0.0npm version patch&#x2F;&#x2F; 1.0.1npm version minor&#x2F;&#x2F; 1.1.0npm version major&#x2F;&#x2F; 2.0.0 根据更新应用程序的频率，可以通过在每次部署时增加版本号来节省时间，使用以下脚本： 123&#123; &quot;predeploy&quot;: &quot;npm version patch&quot;&#125; 从命令行编辑 package.json package.json 是一个常规的 json 文件，因此可以使用工具库 json 从命令行进行编辑。这在修改package.json 提供另外一种新的方式，允许w你q创建超出默认值的快捷方式。全局安装： 1npm install -g json 然后，可以使用它来使用-I进行就地编辑。例如，要添加值为 “bar” 的新脚本 “foo”，这样写： 1json -I -f package.json -e &#x27;this.scripts.foo=&quot;bar&quot;&#x27; 自动设置和打开你的 github 库 如果 package.json 文件中有 “repository”，则可以通过输入 npm repo 在默认浏览器中打开它。 如果你的项目已经连接到远程存储库，并且已经在命令行上安装了 git，那你可以使用这个命令找到你的连接存储库： 1git config --get remote.origin.url 更好的是，如果你按照上面的提示并安装了 json 模块，可以使用下面的脚本自动将正确的存储库添加到 package.json： 1json -I -f package.json -e &quot;this.repository=\\&quot;$(git config --get remote.origin.url)\\&quot;&quot; 自定义 npm init 脚本 让我们更进一步，使用我们自己的 npm init 脚本，它接受 GitHub 存储库 URL 并自动推送我们的第一个提交。在本技巧中，我们将讨论如何创建自定义 npm init 脚本。在下一个(也是最后一个)技巧中，我们将合并 git。 可以通过重定向到主目录中的 .npm-init.js 文件来编辑 npm init 脚本 在Windows上，通常是 c/Users/&lt;用户名&gt;，在 Mac 上，它是 /Users/&lt;用户名&gt; 让我们首先在我们的主目录中创建一个 .nmm-init.js 文件。为了确保 npm init 被指向正确的文件，可以运行: 1npm config set init-module ~\\.npm-init.js 在集成 git 之前，这里有一个简单的 .npm-init.js 文件，它模拟了默认 npm init 的问题： 12345678910module.exports = &#123; name: prompt(&#x27;package name&#x27;, basename || package.name), version: prompt(&#x27;version&#x27;, &#x27;0.0.0&#x27;), decription: prompt(&#x27;description&#x27;, &#x27;&#x27;), main: prompt(&#x27;entry point&#x27;, &#x27;index.js&#x27;), repository: prompt(&#x27;git repository&#x27;, &#x27;&#x27;), keywords: prompt(function (s) &#123; return s.split(/\\s+/) &#125;), author: prompt(&#x27;author&#x27;, &#x27;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#x27;), license: prompt(&#x27;license&#x27;, &#x27;ISC&#x27;)&#125; 每个问题都遵循 nameInPackage 模式：prompt(&#39;nameInPrompt&#39;,&#39;defaultValue&#39;)。要在缺省情况下设置值而不带问题，只需删除 prompt 方法，如果要返回默认设置，只需删除.npm-init.js。 自定义npm init 脚本将你的第一个 Commit 提交到 GitHub 为了将 git 命令合并到 .npm-init.js 文件中，需要一种方法来控制命令行。为此，我们可以使用child_process 模块。在文件的顶部引入它，因为我们只需要 execSync 函数，所以可以使用析构赋值语法自己获取它： 1const &#123; execSync &#125; &#x3D; require(&#39;child_process&#39;); 我还创建了一个 helper 函数，它将函数的结果打印到控制台： 123function run(func) &#123; console.log(execSync(func).toString())&#125; 最后，我们将提示输入 GitHub 存储库 URL，如果提供，我们将生 README.md 文件，并启动我们的第一次提交。 1234567891011repository: prompt(&#x27;github repository url&#x27;, &#x27;&#x27;, function (url) &#123; if (url) &#123; run(&#x27;touch README.md&#x27;); run(&#x27;git init&#x27;); run(&#x27;git add README.md&#x27;); run(&#x27;git commit -m &quot;first commit&quot;&#x27;); run(`git remote add origin $&#123;url&#125;`); run(&#x27;git push -u origin master&#x27;); &#125; return url;&#125;) 总的来说，.npm-init.js 文件大概如下： 1234567891011121314151617181920212223242526const &#123; execSync &#125; = require(&#x27;child_process&#x27;);function run(func) &#123; console.log(execSync(func).toString())&#125;module.exports = &#123; name: prompt(&#x27;package name&#x27;, basename || package.name), version: prompt(&#x27;version&#x27;, &#x27;0.0.0&#x27;), decription: prompt(&#x27;description&#x27;, &#x27;&#x27;), main: prompt(&#x27;entry point&#x27;, &#x27;index.js&#x27;), keywords: prompt(function (s) &#123; return s.split(/\\s+/) &#125;), author: prompt(&#x27;author&#x27;, &#x27;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#x27;), license: prompt(&#x27;license&#x27;, &#x27;ISC&#x27;), repository: prompt(&#x27;github repository url&#x27;, &#x27;&#x27;, function (url) &#123; if (url) &#123; run(&#x27;touch README.md&#x27;); run(&#x27;git init&#x27;); run(&#x27;git add README.md&#x27;); run(&#x27;git commit -m &quot;first commit&quot;&#x27;); run(`git remote add origin $&#123;url&#125;`); run(&#x27;git push -u origin master&#x27;); &#125; return url; &#125;),&#125; package.json 文件： 1234567891011121314151617&#123; &quot;name&quot;: &quot;Custom npm init&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;decription&quot;: &quot;A test project, to demonstrate a custom npm init script.&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;keywords&quot;: [], &quot;author&quot;: &quot;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;repository&quot;: &#123; &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;git+https://github.com/JoeBloggs/custom.git&quot; &#125;, &quot;bugs&quot;: &#123; &quot;url&quot;: &quot;https://github.com/JoeBloggs/custom/issues&quot; &#125;, &quot;homepage&quot;: &quot;https://github.com/JoeBloggs/custom#readme&quot;&#125; 你也可以通过合并 GitHub API 进一步实现这一点，这样就不需要创建一个新的存储库，这部分留给你们自己完成。 结语希望这篇文章能够让你了解 npm 可以实现的目标，并展示了一些提高工作效率的方法 - 无论是你知道常见的快捷方式，还是通过充分利用脚本 package.json，或编写自定义版本的 npm init","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"nodemon 的认识与使用","slug":"nodemon-的认识与使用","date":"2021-03-20T03:18:13.000Z","updated":"2021-03-20T03:18:31.153Z","comments":true,"path":"91ea3a24f4bd/","link":"","permalink":"https://ozzienicholas.gitee.io/91ea3a24f4bd/","excerpt":"","text":"简介 在开发环境下，通常都需要一个工具来自动重启项目，之前我们每次更改文件时都需要手动输入命令启动，nodemon 可以随时监听文件的变更，自动重启服务，以提升我们的开发效率 实现此功能的工具还有很多，比较热门的有：forever，nodemon，node-dev，这里只讲 nodemon，它们之间的对比请查阅：Comparison: Tools to Automate Restarting Node.js Server After Code Changes 使用与配置 我们在目录下创建了一个 app.js 安装 nodemon： 全局安装： 1npm install -g nodemon 开发环境安装： 1npm install --save-dev nodemon 查看 nodemon 使用命令： 启动 node 服务： 1nodemon app.js 指定端口启动（如指定 8080 端口） 1nodemon app.js localhost 8080 延迟启动： 1nodemon -delay 10 app.js 当你修改该文件后，会延迟 10 秒才启动修改后的文件 配置：nodemon 比较流行的原因之一就是它的可配置性比较高，官网给出的配置示例如：Sample nodemon.json，开发环境建议可以把每个参数都写上备用，生产环境就把没有必要的参数去掉，有些字段是可以在命令行模式以参数形式给出的，可以通过 -h 查看，下面逐个解释： 12345678910111213141516171819202122232425&#123; &quot;restartable&quot;: &quot;rs&quot;, &quot;ignore&quot;: [ &quot;.git&quot;, &quot;node_modules/**/node_modules&quot; ], &quot;verbose&quot;: true, &quot;execMap&quot;: &#123; &quot;&quot;: &quot;node&quot;, &quot;js&quot;: &quot;node --harmony&quot; &#125;, &quot;events&quot;: &#123; &quot;restart&quot;: &quot;osascript -e &#x27;display notification \\&quot;App restarted due to:\\n&#x27;$FILENAME&#x27;\\&quot; with title \\&quot;nodemon\\&quot;&#x27;&quot; &#125;, &quot;watch&quot;: [ &quot;test/fixtures/&quot;, &quot;test/samples/&quot; ], &quot;env&quot;: &#123; &quot;NODE_ENV&quot;: &quot;development&quot;, &quot;PORT&quot;: &quot;3000&quot; &#125;, &quot;ext&quot;: &quot;js, json&quot;, &quot;legacy-watch&quot;: false&#125; &quot;restartable&quot;：重启的命令，默认是 rs，当你用 nodemon 启动应用时，可以直接键入 rs 来重启服务，你也可以不使用 rs 而去自定义一个字符串，除去字符串外，还可以设置 false 值，意思是当 nodemon 影响了你自己的终端命令时，设置为 false 则不会在 nodemon 运行期间监听 rs 的重启命令 &quot;ignore&quot;：设置要忽略的文件后缀名或者要忽略的文件夹，文件路径的书写用相对于 nodemon.json 所在位置的相对路径 暂时写到这里，其他的配置项我暂且用不到，之后再更新吧(#^.^#) 参考文档： nodemon 基本配置与使用 npm — nodemon 官方文档 nodemon 入门介绍","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"npm命令总结","slug":"Npm命令总结","date":"2021-03-20T03:17:34.000Z","updated":"2021-03-20T03:17:55.752Z","comments":true,"path":"6f79ae89aaf9/","link":"","permalink":"https://ozzienicholas.gitee.io/6f79ae89aaf9/","excerpt":"","text":"npm adduser 添加用户 npm access 设置包的权限 npm bugs 打开包的bugs 报告页面 npm bin [—-global] 查看npm 可执行文件的目录 npm config get registry 获取 npm 仓库地址 npm config list [—-json] 获取 npm 配置信息 npm config edit 编辑 npm 的配置信息 npm config delete 删除某个配置 npm c 是 npm config 别名 npm cache add 通过 git 地址添加某个 tar 包到缓存 npm cache clean —force 清除缓存文件 npm@5 后必须使用强制符 npm cache verify 清理无用的缓存文件和校验缓存数据完整性 npm completion &gt;&gt; ~/.zsh npm 开启自动补全命令，设置后，按住 tab 键能自动提示 npm 命令 npm deprecate [@] 添加对某个包的某个版本的反对信息。只有 owner 才可以，安装此包能看到这些反对信息 npm dist-tag add @ [] 为某个版本添加 tag，如果添加的 tag 为 latest，这个 tag 版本将成为最新版本。用户下载最新的时候会直接下载到该版本 npm dist-tag rm 移除tag npm dist-tag ls [] 查看 tag 清单 npm doctor npm 诊断命令，npm 会对 npm 运行的环境进行检测诊断，包括 npm 的版本，git 版本，npm 使用的文件权限，npm ping 等等 npm docs 打开包的文档地址 npm dedupe 通过一些算法 将多个依赖包中重复依赖的包移除，只保留一个 该命令别名为：**npm ddp** npm explore [ – ] 进入指定的包里执行一些命令，比如执行更新源代码，执行重新编译等 npm edit 修改包内容 npm get key val 获取某个配置 npm init 初始化当前目录为一个包，会生成一个 package.json 的文件 npm install 不带任何参数，会按照根目录下的 package.json 里的依赖包 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下自动生成该目录 会把该包安装到 node_modules 目录中，不会修改 package.json，之后运行 npm install 命令时，不会自动安装该包 npm install [&lt;@scope&gt;/] 局部安装某个包，默认安装最新版本 npm install [&lt;@scope&gt;/]@ 局部安装指定版本的某个包（按照tag） 该命令的别名是：**npm i** npm install [&lt;@scope&gt;/] --save 简写为：**npm install [&lt;@scope&gt;/] -S** 会在 package.json 的 dependencies 属性下添加该包的名称及版本号，之后运行 npm install 命令时，会自动安装模块依赖到 node_modules 目录中 运行 npm install --production 或者注明 NODE_ENV 变量值为 production 时，会自动下载模块到 node_modules 目录中 npm install [&lt;@scope&gt;/] --save-dev 简写为 npm install [&lt;@scope&gt;/] -D 与 npm install [&lt;@scope&gt;/] --save 的区别是： --save-dev 会将模块依赖写入 devDependencies 节点，而 --save 是将模块依赖写入 dependencies 节点 运行 npm install --production 或者注明 NODE_ENV 变量值为 production 时，npm install [&lt;@scope&gt;/] --save-dev 不会自动下载模块到 node_modules 目录中 package.json 文件里面的 devDependencies 和 dependencies 对象的区别是什么呢； –save-dev 对应的 devDependencies 里面的插件只用于开发环境，不用于生产环境，而 –save 对应的 dependencies 是需要发布到生产环境的 devDependencies 节点下的模块是开发时候需要的，如构建工具 glup、webpack，预处理器less、sass这些只在开发环境有用，所以使用 –save-dev 安装 dependencies 节点下的模块是线上代码运行需要的，如 axios、vue-router、vuex，所以需要使用 –-save 安装 npm install-test 它和 npm install 的区别是执行完 npm install 后立马执行 npm test npm install [&lt;@scope&gt;/] -g 全局安装某个包，默认安装最新版本 npm install [&lt;@scope&gt;/] --save npm help 查看某个命令的帮助信息 npm help-search 在帮助文档中查找包含关键词的文档列表 npm link [&lt;@scope&gt;/][@] 将 npm 包创建快捷方式到全局 npm 的路径下 npm login 登陆用户 npm logout 退出当前登陆的 npm 账号 npm ls、npm list、npm la、npm ll 查看当前 npm 包的依赖包列表 npm ls 是 npm list 的简写 npm outdated 查看当前安装的包里版本是否过期的信息 npm owner add [&lt;@scope&gt;/] 添加某个用户作为某个包的管理者 npm owner rm [&lt;@scope&gt;/] 移除某个用户作为某个包的管理者 npm owner ls [&lt;@scope&gt;/] 查看某个包的管理者 npm ping 验证 registry 的连通性和身份验证 npm pack 将当前 npm 包文件打成一个压缩包 npm prune 移除没有定义在package.json 依赖配置上的包 npm publish [|] [–tag ] [–access &lt;public|restricted&gt;] 发布一个包 用户个人信息管理 npm profile get [–json|–parseable] [] 获取个人信息 npm profile set [–json|–parseable] 设置个人信息 npm profile set password 设置密码 npm profile enable-2fa [auth-and-writes|auth-only] 设置开启双重验证 npm profile disable-2fa 关闭开启双重验证 npm prefix [-g] 查看最靠近 package.json 的父级目录 npm root [-g] 查看本地或者全局 node-module 目录的位置 npm repo [] 打开包的源文件管理地址 比如 github 地址 npm restart 运行当前目录下的 package.json 里的 scripts 里的 restart 命令，如果没有，则执行 npm stop 再执行 npm start npm run-script [-- …] 运行当前目录下的 package.json 里的 scripts 里的命令 该命令的别名是：**npm run** npm rebuild [[&lt;@scope&gt;/]…] 执行编译某个包 该命令的别名是：**npm rb** npm search [–long] [search terms …] 从远程仓库中搜索某个包的信息 npm set key val 设置某个配置 npm stop 运行当前目录下的 package.json 里的 scripts 里的 top 命令，如果有的话 npm start 运行当前目录下的 package.json 里的 scripts 里的 start 命令，如果有的话 npm star […] 将某个包加入当前用户的感兴趣的清单 npm stars [] 列出该用户所有感兴趣的包 npm shrinkwrap 生成当前项目确定的依赖版本，类似 package-lock.json，但是还是有略微区别 npm test [-- ] 运行当前目录下的 package.json 里的 scripts 里的 test 命令，如果有的话 npm team 管理所属团队或者添加团队成员等 npm token 身份令牌管理 npm uninstall 卸载某个包 该命令的别名是：**npm un** npm update [-g] […] 更新包 该命令的别名是：**npm up [-g] […]** npm unpublish [&lt;@scope&gt;/][@] 取消发布包，将发布的包从远程仓库中删除 npm unstar […] 将某个包移除当前用户清单 npm version 查看各个依赖的版本 npm whoami npm 当前登陆用户 npm -l 查看所有命令的用例信息 npm -h 查看某个命令的用法","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"从 Git 到 Github：上传、更新及常见命令集","slug":"从-Git-到-Github：上传、更新及常见命令集","date":"2021-03-20T03:16:46.000Z","updated":"2021-03-20T03:17:05.453Z","comments":true,"path":"80bb98e6730f/","link":"","permalink":"https://ozzienicholas.gitee.io/80bb98e6730f/","excerpt":"","text":"将项目上传到 Github 关于下载安装 git，注册 github 账号等操作，此处略过 进入 github 并创建一个仓库： 这里我准备了一个待提交的 peoject 项目文件夹，如下： 在文件夹处右键，并用 Git Bush 打开 创建 git 仓库： 1$ git init 将所有文件添加到仓库中： 1$ git add . 将项目提交到本地仓库中： 1$ git commit -m &quot;注释内容&quot; 虽然没有强制要写注释内容，可以不写，但为了防止莫名其妙的报错，最好写上 将本地仓库关联到 github 上的仓库： 1$ git remote add origin git@github.com:OzzieNicholas&#x2F;test.git “origin” 后面跟着的就是创建的仓库的地址 关联好之后我们就把本地仓库的所有内容推送到 github 仓库上： 1$ git push -u origin master 由于新建的仓库是空的，所以需要加上 -u 参数，若 github 仓库中已经有了内容，再从本地上传到远程仓库中时就直接： 1$ git push origin master 我们的仓库如下： 最后增加上 README.md 即可 将项目更新到 Github 假设项目更新了，需要我们再次提交到同一个的仓库中 将 origin 上的 master 分支 merge 到当前的 branch 上： 1$ git merge origin&#x2F;master 重新向仓库中添加文件（由于我们已经在第一次提交时就创建了仓库，所以这里直接把添加）： 1$ git add . 向本地仓库中提交文件： 1$ git commit -m &quot;第二次提交&quot; 将本地仓库中的所有文件推送到 github 仓库上： 1$ git push origin master 由于远程仓库并不为空，所以不需要加 -u 参数 查看 github 仓库效果：我们已经完成了仓库更新 另附：git merge origin master 和 git merge origin/master的区别在哪里？ git 常用命令 查看、添加、提交、删除、找回，重置修改文件： 1234567891011121314151617181920212223242526272829git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件 diff： 123456789101112131415161718192021222324252627git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看提交记录： 1234567git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 本地分支管理：查看、切换、创建和删除分支： 1234567891011121314151617181920212223git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co &lt;branch&gt; # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d &lt;branch&gt; # 删除某个分支 git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并 和 reba： 1234567git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt;# 将 master rebase 到 branch# 相当于 git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; 存储管理： 1234567git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 远程分支管理： 123456789101112131415161718192021222324git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin&#x2F;master # 将远程主分支合并到本地当前分支git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push 所有分支git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt;# 先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 远程仓库管理： 1234567891011121314151617181920212223242526git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin&#x2F;robbin_site.git # 添加远程仓库地址 git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git# 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库git remote remove origin # 断开已连接的远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 命令设置跟踪远程库和本地库： 123git branch --set-upstream master origin&#x2F;master git branch --set-upstream develop origin&#x2F;develop","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"Git：从安装到操作","slug":"Git-从安装到操作","date":"2021-03-20T03:15:51.000Z","updated":"2021-03-20T03:16:19.199Z","comments":true,"path":"36409b32e950/","link":"","permalink":"https://ozzienicholas.gitee.io/36409b32e950/","excerpt":"","text":"将项目上传到 Github 关于下载安装 git，注册 github 账号等操作，此处略过 进入 github 并创建一个仓库： 这里我准备了一个待提交的 peoject 项目文件夹，如下： 在文件夹处右键，并用 Git Bush 打开 创建 git 仓库： 1$ git init 将所有文件添加到仓库中： 1$ git add . 将项目提交到本地仓库中： 1$ git commit -m &quot;注释内容&quot; 虽然没有强制要写注释内容，可以不写，但为了防止莫名其妙的报错，最好写上 将本地仓库关联到 github 上的仓库： 1$ git remote add origin git@github.com:OzzieNicholas&#x2F;test.git “origin” 后面跟着的就是创建的仓库的地址 关联好之后我们就把本地仓库的所有内容推送到 github 仓库上： 1$ git push -u origin master 由于新建的仓库是空的，所以需要加上 -u 参数，若 github 仓库中已经有了内容，再从本地上传到远程仓库中时就直接： 1$ git push origin master 我们的仓库如下： 最后增加上 README.md 即可 将项目更新到 Github 假设项目更新了，需要我们再次提交到同一个的仓库中 将 origin 上的 master 分支 merge 到当前的 branch 上： 1$ git merge origin&#x2F;master 重新向仓库中添加文件（由于我们已经在第一次提交时就创建了仓库，所以这里直接把添加）： 1$ git add . 向本地仓库中提交文件： 1$ git commit -m &quot;第二次提交&quot; 将本地仓库中的所有文件推送到 github 仓库上： 1$ git push origin master 由于远程仓库并不为空，所以不需要加 -u 参数 查看 github 仓库效果：我们已经完成了仓库更新 另附：git merge origin master 和 git merge origin/master的区别在哪里？ git 常用命令 查看、添加、提交、删除、找回，重置修改文件： 1234567891011121314151617181920212223242526272829git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci -am &quot;some comments&quot; git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件 diff： 123456789101112131415161718192021222324252627git help &lt;command&gt; # 显示command的help git show # 显示某次提交的内容 git show $id git co -- &lt;file&gt; # 抛弃工作区修改 git co . # 抛弃工作区修改 git add &lt;file&gt; # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm &lt;file&gt; # 从版本库中删除文件 git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件 git reset &lt;file&gt; # 从暂存区恢复到工作文件 git reset -- . # 从暂存区恢复到工作文件 git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci --amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看提交记录： 1234567git log git log &lt;file&gt; # 查看该文件每次提交记录 git log -p &lt;file&gt; # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log --stat #查看提交统计信息 本地分支管理：查看、切换、创建和删除分支： 1234567891011121314151617181920212223git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br --merged # 查看已经被合并到当前分支的分支 git br --no-merged # 查看尚未被合并到当前分支的分支 git co &lt;branch&gt; # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d &lt;branch&gt; # 删除某个分支 git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并 和 reba： 1234567git merge &lt;branch&gt; # 将branch分支合并到当前分支 git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master &lt;branch&gt;# 将 master rebase 到 branch# 相当于 git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; 存储管理： 1234567git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 远程分支管理： 123456789101112131415161718192021222324git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin&#x2F;master # 将远程主分支合并到本地当前分支git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上git push # push 所有分支git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt;# 先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 远程仓库管理： 1234567891011121314151617181920212223242526git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin&#x2F;robbin_site.git # 添加远程仓库地址 git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git# 设置远程仓库地址(用于修改远程仓库地址)git remote rm &lt;repository&gt; # 删除远程仓库git remote remove origin # 断开已连接的远程仓库git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 命令设置跟踪远程库和本地库： 123git branch --set-upstream master origin&#x2F;master git branch --set-upstream develop origin&#x2F;develop","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"}]},{"title":"Postman 使用教程","slug":"Postman-使用教程","date":"2021-03-20T03:14:57.000Z","updated":"2021-03-20T03:15:15.680Z","comments":true,"path":"c853069b0fd0/","link":"","permalink":"https://ozzienicholas.gitee.io/c853069b0fd0/","excerpt":"","text":"介绍 Postman 官网：https://www.postman.com/ 背景介绍：postman 不仅可以调试简单的 html、css、以及一些脚本等简单的网页信息，它还能发送几乎所有的 Http 请求，而 postman 在发送网络请求方面可以说是 Chrome 插件类产品哒代表作之一 postman 的操作环境：Mac、Windows X32、Windows X64、Linux 系统，还支持 postman 浏览器扩展程序，postman chrome 应用程序等等 使用参考文档： 英文官方文档 Postman API 中文白皮书文档 安装 postman 安装地址： For Mac For Win64 浏览器插件安装： postman 是谷歌浏览器的插件，所以安装的前提是有谷歌浏览器 地址：http://extb.cqttech.com/search/postman 设置基础设置 补充 除了以上的基础设置外，我们还有以下设置 有时候需要在不同的环境下测试，此时我们可以通过环境变量来动态选择 此时，我们没有设置环境，点击最后边的 “设置” 按钮 使用这些键值的时候需要加上两个花括号引用 key 1&#123;&#123;base_url&#125;&#125;&#x2F;username #解析之后就是：https:&#x2F;&#x2F;www.test.com&#x2F;username 添加之后，我们就可以选择这个新增的环境 Headers 设置 key:value 值 有些 headers 和 cookies 是保密的，如： 1234567891011121314151617181920211.Accept-Charset2.Accept-Encoding3.Access-Control-Request-Headers4.Access-Control-Request-Method5.Connection6.Content-Length7.Cookie8.Cookie 29.Content-Transfer-Encoding10.Date11.Expect12.Host13.Keep-Alive14.Origin15.Referer16.TE17.Trailer18.Transfer-Encoding19.Upgrade20.User-Agent21.Via Body 中的参数格式： form-data：mutipart/form-data 是网页表单用来传输数据的默认格式。可以模拟填写并提交表单。可以上传一个文件作为 key 的 value 提交（如上传文件）。但该文件不会作为历史保存，只能在每次需要发送请求的时候，重新添加文件 urlencoded：同前面一样，注意,你不能上传文件通过这个编码模式，该模式和表单模式会容易混淆，urlencoded 中的 key-value 会写入URL，form-data 模式的 key-value 不明显写入URL，而是直接提交 raw：raw request 可以包含任何东西，所有填写的 text 都会随着请求发送。 binary：支持 image、audio 、video files 以及 text files，也不能保存历史，每次选择文件，提交。 身份验证（Authentication） Basic Auth：基础的验证，比较简单，会直接把用户名、密码的信息放在请求的 Header 中 Digest Auth：比 Basic Auth 复杂很多。使用当前填写的值生成 authorization header。所以在生成 header 之前要确保设置的正确性。如果当前的 header 已经存在，postman 会移除之前的 header OAuth 1.0：postman 的 OAuth helper 让你签署支持 OAuth。1.0 是基于身份验证的请求，OAuth 不用获取access token，你需要去API提供者获取的。OAuth 1.0 可以在 header 或者查询参数中设置 value。 OAuth 2.0：postman 支持获得 OAuth 2.0 token 并添加到 requests 中。 暂时介绍到这里，还有更多的功能，，，以后用到再说啦 (#^.^#)","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://ozzienicholas.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"Windows神器：Cmder","slug":"Windows神器：Cmder","date":"2021-03-20T03:14:23.000Z","updated":"2021-03-20T03:14:41.083Z","comments":true,"path":"3acab0f3d61b/","link":"","permalink":"https://ozzienicholas.gitee.io/3acab0f3d61b/","excerpt":"","text":"引言 cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。 cmder不是一个独立的工具，应该说是一系列工具包的集合，包括Conemu、clink、git for windows 等，足够简单好用，且支持多栏显示，多个tab运行，功能十分强大 安装 官网下载地址：cmder 如下： 官网上的有 min 版 和 full 版，我们下载后者 最后可以打开 Cmder.exe 检验一下，会出现 Cmder 界面 配置配置环境变量 打开控制面板，再打开系统环境变量配置 新建环境变量，之后将 Cmder.exe 所在的文件夹添加进 Path 中，例如： 配置右键快捷启动 以管理员的身份打开 Cmder.exe，输入： 1Cmder.exe /REGISTER ALL 这会设置在任何地方都可以鼠标启动 Cmder 现在你对任何一个文件夹右键，都会有一个 Cmder Here 选项，点开即为该路径下的命令行界面 界面效果的设置 神奇当然支持自定义，打开 Cmder.exe，右键右下角进入设置 语言与设置 上一次设置我将语言改为了中文，现在可以设置其他的了… 常用快捷键 这里介绍一下关于 Cmder 的一些常用快捷键 12345678910111213Tab 自动路径补全Ctrl+T 建立新页签Ctrl+W 关闭页签Ctrl+Tab 切换页签Alt+F4 关闭所有页签Alt+Shift+1 开启cmd.exeAlt+Shift+2 开启powershell.exeAlt+Shift+3 开启powershell.exe (系统管理员权限)Ctrl+1 快速切换到第1个页签Ctrl+n 快速切换到第n个页签(n值无上限)Ctrl+r 历史命令搜索Alt+enter 切换到全屏状态Win+Alt+P 开启工具选项视窗 附链 GitHub地址：GitHub — cmder 推荐阅读：cmder使用简介","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://ozzienicholas.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"}]},{"title":"向Github提交代码报错：Updates were rejected because a pushed branch tip is behind its remote...","slug":"向Github提交代码报错：Updates-were-rejected","date":"2021-03-20T03:12:31.000Z","updated":"2021-03-20T03:13:42.613Z","comments":true,"path":"9e88e9aa8fda/","link":"","permalink":"https://ozzienicholas.gitee.io/9e88e9aa8fda/","excerpt":"","text":"问题在向 github 上传代码时，给我报错： 关键的就是黄色的第一行：Updates were rejected because a pushed branch tip is behind its remote. 翻译过来就是：由于推送的分支提示位于其远程后面，因此更新被拒绝。 好吧，看看连接的远程仓库有哪些： 1$ git remote -v 结果： 12origin git@github.com:OzzieNicholas&#x2F;Travel.git (fetch)origin git@github.com:OzzieNicholas&#x2F;Travel.git (push) 我想断开所有连接的远程仓库，打算重新连接 1$ git remote remove origin 可是……好像并没有什么用 解决百度了一波，我承认我还是没看懂什么操作，被 git 支配的恐惧确实有点……先记录下解决办法 连接远程仓库，并输入 12$ git remote add origin git@github.com:OzzieNicholas&#x2F;Travel.git$ git push -u origin master -f 令人迷惑操作，就这样 OK 了…… 参考链接github上的版本和本地版本冲突的解决方法 github中non-fast-forward错误的解决","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"向Github提交代码报错：Permanently added the RSA host key for IP address...","slug":"向Github提交代码报错：Permanently-added","date":"2021-03-20T03:11:51.000Z","updated":"2021-03-20T03:12:08.634Z","comments":true,"path":"24035baedd34/","link":"","permalink":"https://ozzienicholas.gitee.io/24035baedd34/","excerpt":"","text":"问题在准备向 github 提交代码时，给我报错： 1Warning: Permanently added the RSA host key for IP address &#39;13.229.188.59&#39; t 谷歌翻译了一下：”警告：永久添加了IP地址“ 13.229.188.59”的RSA主机密钥” 百度到的一种方法是说这是缺少 SSH 公钥导致的，我用 ssh -T git@github.com 测试了一下，发现我并非缺少公钥 百度到的第二种方法是说这是一个警告，无伤大雅，在 C:\\Windows\\System32\\drivers\\etc\\hosts 文件中添加 github 的 IP 地址即可，可是我发现需要权限才能修改，就暂时跳过这个方法了 解决我觉得尝试一下更新 SSH，神奇地可行了，emm，至于之前提到的第二种方法，现在也先记录下来，或许之后会遇到 更新 SSH： 1ssh-keygen -t rsa -C &quot;GitHub账号&quot; 然后一直 Enter 下去即可生成新的公钥 复制 id_rsa.pub 文件中的内容，用于在 github 上的 Settings 部分更新公钥，之后就OK了 参考： 关于Github遇到”Permanently added the RSA host key for IP address ‘192.30.255.113’ to the list of known hosts.”的问题 Permanently added the RSA host key for IP address ‘13.250.177.223’ to t he list of known hosts.","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"向Github提交代码报错：failed to push some refs to....","slug":"向Github提交代码报错：failed-to-push","date":"2021-03-20T03:10:55.000Z","updated":"2021-03-20T03:11:25.308Z","comments":true,"path":"6df9b860828c/","link":"","permalink":"https://ozzienicholas.gitee.io/6df9b860828c/","excerpt":"","text":"问题在向 github 上传代码时，给我报错： 即那一行：error: failed to push some refs to.... 翻译过来就是：无法将代码推送到该仓库 解决这是本地库与远程库不一致导致的，解决办法就是将远程库同步到本地库，输入： 1git pull --rebase origin master 之后就可以上传了 说明该指令的意思是将远程库之中的更新合并到本地库中，–rebase 的作用是取消本地库中之前的 commit，并把他们接到更新后的版本库之中 请参考：【github】git push错误failed to push some refs to的解决","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"巨坑！node-sass 安装的痛","slug":"巨坑！node-sass-安装的痛","date":"2021-03-20T03:09:57.000Z","updated":"2021-03-20T03:10:17.262Z","comments":true,"path":"c37fbf8ee648/","link":"","permalink":"https://ozzienicholas.gitee.io/c37fbf8ee648/","excerpt":"","text":"问题在安装项目依赖的时候，突然发现，总是报错： 1Node Sass could not find a binding for your current environment: Windows 64-bit with Node.js 12.x 最后 npm run dev 尝试启动时总是说：”Cannot find module ‘node-sass’” 这也就是说，我没有成功安装 node-sass，难受o(╥﹏╥)o 我百度了很多解决办法，例如： 第1种：npm cache clean --force 清除缓存，再升级 node 版本，再重新安装 第2种：npm rebuild node-sass 重新添加依赖，再用 npm update 更新，再重启 第3种：删除之前的安装，使用 cnpm 在淘宝镜像上安装 node-sass 好像，，，都没什么用 解决接下来说一下我的最终解决办法： 报错原因：windows 平台缺少编译环境 解决步骤： 执行：npm install -g node-gyp 打开 cmd，以管理员的身份执行 npm install --global --production windows-build-tools 这个的作用是可以自动安装跨平台的编译器 执行 npm uninstall node-sass 来删除之前的安装包（未安装可忽略） 执行 npm install node-sass 重新安装","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"Unexpected end of JSON input while...","slug":"Unexpected-end-of-JSON","date":"2021-03-20T03:09:08.000Z","updated":"2021-03-20T03:09:39.059Z","comments":true,"path":"7f065221428f/","link":"","permalink":"https://ozzienicholas.gitee.io/7f065221428f/","excerpt":"","text":"报错 解决 这种情况一般是受到 npm 缓存的影响，清除缓存即可 使用命令： 1npm cache clean --force","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"React-App：npm start 报错","slug":"React-App：npm-start-报错","date":"2021-03-20T03:08:09.000Z","updated":"2021-03-20T03:08:42.839Z","comments":true,"path":"6ffba565cd57/","link":"","permalink":"https://ozzienicholas.gitee.io/6ffba565cd57/","excerpt":"","text":"问题 在读《React学习之道》时，我按照步骤输入了如下代码： 123npx create-react-app my-appcd my-appnpm start 结果，报错如下： 解决 原文链接：Cannot uninstall webpack from react-script 步骤： 在项目根目录下新建 .env 文件 输入： 1SKIP_PREFLIGHT_CHECK&#x3D;true 重新启动项目 附上：Create React App 中文文档","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"npm ERR! A complete log of this run can be found in","slug":"npm-ERR-A-complete-log-of-this-run-can-be-found-in","date":"2021-03-20T03:07:17.000Z","updated":"2021-03-20T03:07:39.599Z","comments":true,"path":"cda94e503d2e/","link":"","permalink":"https://ozzienicholas.gitee.io/cda94e503d2e/","excerpt":"","text":"问题在使用 npm 下载某些包的时候，总是出现如下所示的情况： 解决 百度一波之后，发现这是 npm 版本的问题，更新 npm 就可解决，步骤如下. 删除项目目录中的 node_modules 在项目目录下输入以下内容来清除缓存： 1npm cache clean --force 将 npm 升级到最新版本： 1npm install npm@latest -g 重新安装 1npm install","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"Webpack（四）：回滚","slug":"Webpack（四）：回滚","date":"2021-03-20T03:04:56.000Z","updated":"2021-03-20T03:05:15.706Z","comments":true,"path":"29cd2b494840/","link":"","permalink":"https://ozzienicholas.gitee.io/29cd2b494840/","excerpt":"","text":"初识 Webpack关于 webpack 官网 对 webpack 的介绍 ： 本质上，webpack是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个bundle。 在官网的图片介绍中， modules 经过 webpack 打包处理成了各种静态资源。 简单来说，webpack 就是一个 JavaScript 的打包器，将各种模块（module）打包成资源文件；还可以通过代码拆分来把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件；webpack 可以使用 loader 来预处理文件，这允许你打包除了JavaScript 之外的任何静态资源。 核心概念： 入口（entry） 出口（output） loader 插件（plugins） 入口（entry） 入口指示着 webpack 应该使用哪个模块，来开始构建其内部依赖。进入入口后，webpack 会找出有哪些模块和库是与入口相依赖的。 我们在 webpack 配置中配置 entry 属性，来设置一个或多个入口起点。以下是一个简单的entry配置： 123456const config = &#123; entry: &#123; main: &#x27;./index.js&#x27; &#125;&#125;module.exports = config 出口（output） 设置output是为了告诉webpack要在哪里输出其创建的bundle，并且可以对bundle命名。 我们通过 output.filename 来设置输出 bundle 的文件名，通过 output.path 来设置 bundle 的输出路径 ，例如： 1234567891011const path = require(&#x27;path&#x27;);const config = &#123; entry: &#123; main: &#x27;./index.js&#x27; &#125;, output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;./dist&#x27;) &#125;&#125;modules.exports = config path 也是 node 的核心模块，用来处理项目中的路径 loader 由于 webpack 只认识 JavaScript 代码，因此就需要借助其他方法来处理那些非 JavaScript 文件，如 css、image、font 等。而 loader 可以将所有类型的文件处理成 webpack 能够识别的有效模块，然后再对其进行处理。 loader 中有两个重要的属性： test 属性：用于标识出应该被对应的 loader 进行转换的某个或某些文件，通常是一个正则表达式 use属性：表示进行转换时，应该使用哪个 loader 案例： 12345678910111213141516171819const path = require(&#x27;path&#x27;);const config = &#123; entry: &#123; main: &#x27;./index.js&#x27; &#125;, output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;./dist&#x27;) &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;] &#125; ] &#125;&#125;module.exports = config 以上示例中 loader 的配置告诉 webpack：在遇到 .css 的文件时，在打包之前先用 css-loader 转换一下。 webpack 的 loader 集合地：loaders 插件（plugins） loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。 要使用一个插件，只需要 require() 它，然后把它添加到 plugins 数组中。 多数插件可以通过选项(option)自定义。 例如，插件 HtmlWebpackPlugin 将为你生成一个 HTML5 文件， 其中包括使用script标签的 body 中的所有 webpack 包， 案例如下： 12345678910111213141516171819202122232425const path = require(&#x27;path&#x27;);const config = &#123; entry: &#123; main: &#x27;./index.js&#x27; &#125;, output: &#123; filenae: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;./dist&#x27;) &#125;, module: &#123; loaders: [ &#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;] &#125; ] &#125;, pligins: [ new HTMLWebpackPlugin(&#123; title: &#x27;webpack demo&#x27;, template: path.join(__dirname, &#x27;./index.html&#x27;) &#125;) ]&#125;module.exports = config webpack 提供提供了许多功能强大的插件，查阅 插件列表 获取更多插件的使用方法。 开始上手 Webpack打包第一个 JS 文件 创建 test 目录，安装依赖： 12npm init -ynpm install webpack webpack-cli --save-dev 创建相关目录以及文件，最终结构如下： 12345|-index.html|-src |-index.js|-webpack.config.js|-package.json 文件内容分别如下： index.html： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=&#x27;dist/main.bundle.js&#x27;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js： 1alert(&#x27;Hello World&#x27;); webpack.config.js： 123456789101112const path = require(&#x27;path&#x27;);const config = &#123; mode: &#x27;none&#x27;, entry: &#123; main: path.join(__dirname, &#x27;./src/index.js&#x27;) &#125;, output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;./dist&#x27;) &#125;&#125;module.exports = config 各项解析： webpack4中，我们需要设置 mode 属性，用来决定当前是development还是production 环境，webpack 会根据此值来进行一些默认操作，两种环境的不同配置后面的博文会详解，这里我们设置为 ‘none’ ，来避免默认操作。 path 是 nodeJs 中用来操作路径的核心模块，__dirname 表示文件的当前路径（此时为根路径） output 中 的 filename 属性，[name] 表示入口的名称，此处就是 main 打开 package.json，编写一条命令来执行 webpack 打包，在 scripts 中添加： 1&quot;build&quot;: &quot;webpack --config webpack.config.js --progress --colors&quot; webpack –config path/to/your/file/file.js 表示执行某个配置文件 –progress 可以让我们看到打包的进度 –colors 开启命令行颜色显示 （更多的 webpack 命令参数大家可以另行查阅） 控制台执行 npm run build， 我们可以看到，在根目录下多了一个 dist 文件夹 并有一个 main.bundle.js 文件，这就是 webpack 为我们打包出来的静态资源，而文件路径就是我们在 output 中设置的值。 打开 index.html，即可查看结果，此 demo 也就成功了。 自动生成项目中的 HTML 文件 webpack 中的 CommonJS 和 ES Mudule 规范： CommonJs 规范： 制定规定的出发点：JS 没有模块系统、标准库较少、缺乏包管理工具；为了让 JS 可以在任何地方运行，以达到 Java、PHP 这些后台语言具备开发大型应用的能力，制定了 CommonJs 规范。 在规范中： 一个文件就是一个模块，拥有单独的作用域； 普通方式定义的变量、函数、对象都属于该模块内； 通过 require 来加载模块； 通过 exports 和 modul.exports 来暴露模块中的内容； ES Mudule 规范： ES6 在语言标准的层面上，实现了模块功能，基本特点如下： 每一个模块只加载一次， 每一个 JS 文件内容只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取； 每一个模块内声明的变量都是局部变量， 不会污染全局作用域； 模块内部的变量或者函数可以通过 export 导出； 一个模块可以导入别的模块； 模块功能主要由两个命令构成：export 和 import export 命令用于规定模块的对外接口 import 命令用于输入其他模块提供的功能 在上一个打包 js 文件的 demo 中， 我们为了演示打包好的 main.bundle.js ，在根目录下创建了一个 index.html ，并引入main.bundle.js。而在实际项目中，我们可以通过 webpack 的一个插件：HtmlWebpackPlugin 来自动生成HTML文件并引入我们打包好的JS和CSS文件。 加载插件： 1npm install html-webpack-plugin --save-dev 在根目录稍作修改，结果如下： 12345678|-index.html|-src |-index.js|-dist |-main.bundle.js|-config |-webpack.config.js|-package.json 修改 webpack.config.js 如下： 1234567891011121314151617181920212223const path = require(&#x27;path&#x27;);const HTMLWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const config = &#123; mode: &#x27;none&#x27;, entry: &#123; main: path.join(__dirname, &#x27;../src/index.js&#x27;) &#125;, output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;../dist&#x27;) &#125;, plugins: [ new HTMLWebpackPlugin(&#123; template: path.join(__dirname, &#x27;../index.html&#x27;), inject: true, minify: &#123; removeComments: true &#125; &#125;) ]&#125;module.exports = config 各项解析如下： template：模版文件的路径，这里使用根目录下的 index.html 文件； inject：设为 true 表示把 JS 文件注入到 body 结尾，CSS 文件注入到 head 中； minify：removeComments: true 表示删除模版文件中的注释 minify 还有很多配置可选请查阅：html-webpack-plugin#minification 然后，更改 index.html 如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;/&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;script src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 由于我们改动了 webpack.config.js 文件的位置，所以要修改 package.json 文件： 1&quot;build&quot;: &quot;webpack --config config/webpack.config.js --progress --colors&quot; 不改动的话，之后 npm run build 会报错 npm run build 启动项目， 可以看到，dist 目录下多了一个 index.html，这就是通过 HtmlWebpackPlugin 生成的文件，打开 dist/index.html，已经自动引入了 main.bundle.js并且注释已被删除。 清理 /dist 文件夹：每次执行 npm run build 打包时，都会有上次的代码遗留下来，导致我们的 /dist 文件夹相当杂乱。最好在每次构建前清理 /dist 文件夹。 clean-webpack-plugin 是一个比较普及的管理插件，让我们安装和配置下： 在 webpack.config.js 中使用： 1const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;); 在 plugins 中加入： 123plugins: [ new CleanWebpackPlugin()] 处理项目中的资源文件（一）loader 的使用：尝试处理 ejs 之前已经介绍了 Loader 的概念以及用法，webpack 可以使用 loader 来预处理文件，这允许你打包除 JavaScript 之外的任何静态资源， 甚至允许你直接在 JavaScript 模块中通过 import 来导入 CSS 文件。 在 src 目录下新建 components 文件夹……最后整个目录具体内容是： 12345678910111213|-index.html|-src |-index.js |-components |-modal |-modal.ejs |-modal.css |-modal.js|-dist |-main.bundle.js|-config |-webpack.config.js|-package.json modal.ejs： 1234567891011&lt;div class&#x3D;&quot;modal-parent&quot;&gt; &lt;div class&#x3D;&quot;modal-header&quot;&gt; &lt;h3 class&#x3D;&quot;modal-title&quot;&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h3&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;modal-body&quot;&gt; &lt;%&#x3D; content %&gt; &lt;&#x2F;div&gt; &lt;div class&#x3D;&quot;modal-footer&quot;&gt; &lt;%&#x3D; footer %&gt; &lt;&#x2F;div&gt;&lt;&#x2F;div&gt; modal.js： 12345678import template from &#x27;./modal.ejs&#x27;export default function modal() &#123; return &#123; name: &#x27;modal&#x27;, template: template &#125;&#125; 修改 index.js 如下： 1234567891011121314import Modal from &#x27;./components/modal/modal&#x27;const App = function() &#123; let div = document.createElement(&#x27;div&#x27;) div.setAttribute(&#x27;id&#x27;, &#x27;app&#x27;) document.body.appendChild(div) let dom = document.getElementById(&#x27;app&#x27;) let modal = new Modal() dom.innerHTML = modal.template(&#123; title: &#x27;标题&#x27;, content: &#x27;内容&#x27;, footer: &#x27;底部&#x27; &#125;)&#125;const app = new App() 如果此时打包，那么会报错，因为 webpack 还无法解析 ejs 文件，所以我们需要对应的 loader 来打包： 安装 loader： 1npm install --save-dev ejs-loader 修改 webpack.config.js： 12345678910111213141516171819202122232425262728293031const path = require(&#x27;path&#x27;);const HTMLWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)const config = &#123; mode: &#x27;none&#x27;, entry: &#123; main: path.join(__dirname, &#x27;../src/index.js&#x27;) &#125;, output: &#123; filename: &#x27;[name].bundle.js&#x27;, path: path.join(__dirname, &#x27;../dist&#x27;) &#125;, module: &#123; rules: [ &#123; test: /\\.ejs$/, use: [&#x27;ejs-loader&#x27;] &#125; ] &#125;, plugins: [ new HTMLWebpackPlugin(&#123; template: path.join(__dirname, &#x27;../index.html&#x27;), inject: true, minify: &#123; removeComments: true &#125; &#125;) ]&#125;module.exports = config 再次执行 npm run build 就不会报错了，打开 dist/index.html 即可查看结果。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"前端/webpack","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ozzienicholas.gitee.io/tags/webpack/"}]},{"title":"Webpack（三）：loader案例.md","slug":"Webpack（三）：loader案例","date":"2021-03-20T03:03:50.000Z","updated":"2021-03-20T03:04:21.714Z","comments":true,"path":"3553fa75c021/","link":"","permalink":"https://ozzienicholas.gitee.io/3553fa75c021/","excerpt":"","text":"什么是webpack 文档： webpack webpack中文文档 可以将 webpack 看做是一个 模块打包机，它做的事情是：分析你的项目结构，找到 JavaScript模块 以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用 Webpack 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（比如index.js），webpack 将从这个主文件开始找到你的项目的所有依赖文件 使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件 安装webpack 首先你得先安装好 Node.js（最好版本够新），因为 webpack 是基于 Node.js 的一个开发工具，webpack 的很多新功能更是基于新的 Node.js 版本的 Node.js 官网如下：Node.js 可以在终端输入 node -v 以及 npm -v 来确定是否已经安装正确 建立一个新的文件夹，我假设为webpack-demo 初始化： 打开终端，输入：1npm init -y 注：你将会创建一个 package.json 文件，这是一个标准的 npm 说明文件，如果需要自定义一些内容，你也可以使用 npm init 来指定 安装 webpack： 在终端输入：1npm install webpack webpack-cli -D 注：-D 即代表 --save-dev，此处为局部安装，当然也可以通过 npm install webpack webpack-cli-g 来全局安装，但是强烈推荐局部安装 另外，此处是直接连同 webpack-cil 一起安装的，网上也有安装其他的方式，此处仅供参考 验证 webpack 版本：1npx webpack -v 安装步骤已经结束啦，现在你的文件夹目录应该如下： 123|- node_modules|- package.json|- package-lock.json loader及其使用 现在我们的目标是：将一个图片打包，并且在网页上显示出来 新建一个 src 文件夹，来存放我们的资源文件 在 src 文件夹中新建文件 index.js，此文件将会作为我们之前提到过的 主文件，webpack 页将从这个主文件开始找到这个项目的所有依赖文件 在 src 文件夹中保存 avatar.jpg 图片，图片如下： 新建一个 dist 文件夹，来作为即将容纳我们的 html 文件以及打包后的文件： 在文件夹中新建 index.html，作为要访问的网页，并在文件中输入： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./bundle.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;!-- 注：这个 `bundle.js` 即为我们打包好的文件 --&gt; &lt;/body&gt;&lt;/html&gt; 1 指定主文件： 我们在 src 中新建了 index.js，但是 webpack 默认是在根目录下找 index.js，所以我们需要单独设定 打开 package.json，将其中的 &quot;main&quot; 改为：&quot;main&quot;: &quot;./src/index.js&quot; 配置文件 webpack.config.js 在根目录下新建 webpack.config.js 在其中输入：1234567891011121314const path = require(&#x27;path&#x27;);module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, path: path.resolve(__dirname, &#x27;dist&#x27;) &#125;, module: &#123; rules: [&#123; test: /\\.jpg$/, use: &#123; loader: &#x27;file-loader&#x27; &#125; &#125;] &#125;&#125; 注：这里只强调 module，对其它的配置项不清楚请查阅官方文档的概念部分 我们已经安装的 webpack 其实并不会知道如何打包图片文件，所以我们在这里引入另一个工具：file-loader 来专门解决图片文件 关于该 loader 的链接如下： webpack file-loader 安装 file-loader：1npm install --save-dev file-loader 入口与出口： 在 webpack.config.js 中，我们可以通过 entry 来指定打包的入口文件 同样，也可以通过 output 来指定我们的出口文件 打包 文件已经配置好啦，现在我们现在终端输入： 1npx webpack 结果如下： 打开 index.html，就会看到图片。 补充 我们之前是用 npx webpack 来打包文件，当然我们也可以自定义命令： 在 package.json 文件中，指定 &quot;scripts&quot; 如下：123&quot;scripts&quot;: &#123; &quot;bundle&quot;: &quot;webpack&quot;&#125; 这样我们就可以输入 npm run bundle，结果当时也相同 此处我们打包的是 .jpg 文件，其实我们安装了 file-loader 之后，我们也可以打包 .png、.gif等等，详情请查文档","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"前端/webpack","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ozzienicholas.gitee.io/tags/webpack/"}]},{"title":"Webpack（二）：Loader与Plugin","slug":"Webpack（二）：Loader与Plugin","date":"2021-03-20T03:03:02.000Z","updated":"2021-03-20T03:03:17.126Z","comments":true,"path":"e00b596958a5/","link":"","permalink":"https://ozzienicholas.gitee.io/e00b596958a5/","excerpt":"","text":"预处理器（loader）loader 概述 每一个 loader 本质上都是一个函数，在 webpack4 之前，loader 函数的输入输出都必须为字符串，但在 webpack4 之后，loader 也同时支持 抽象语法树（AST） 的传递，以此来减少代码的重复解析 用公式可以表示为：output = loader(input) 在此，我们来看一下 loader 的源码结构，以此阐释 loader 是如何工作的： 12345678910module.exports = function loader (content, map, meta) &#123; var callback = this.async(); var result = handler(content, map, meta); callback&#123; null, // error result.content, // 转换后的内容 result.map, // 转换后的 source-map result.meta, // 转换后的 AST &#125;;&#125;; 从代码中可以看出，loader 本身就是一个函数，将函数中接收到的内容进行转换，然后返回转换后的结果 （可能包含 sourcr map 和 AST 对象） loader 的配置 webpack 只认识 JavaScript，对于其他类型的资源，比如 CSS、图片等等，必须预先定义一个或多个 loader 来进行转译，经过 loader 输出为 webpack 能够接受的形式再继续进行 因此，loader 做的实际上是一个预处理的工作 loader 的引入： 假设在我们的目录中，有以下两种文件： 12|-app.js|-style.css 我们要做的是将 css 文件引入到 js 文件中使用，那么跟着我开始吧！ 安装第三方模块 webpack 本身并不含有任何的 loader，而所有的 loader 都是第三方 npm 模块，所以我们必须先安装它1npm install --save-dev css-loader 引入到工程中 在 webpack.config.js 中配置： 123456789module.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;css-loader&#x27;], &#125;], &#125;,&#125;; 配置项的说明： module.rules 代表着模块的处理规则，每条规则都包含着许多配置项，这里我们只用最重要的两项：test 和 use test 接受一个正则表达式或者元素为正则表达式的数组，如果匹配这条正则表达式，那么就会使用与之对应的规则，比如这里的 /\\.css$/ 用来匹配所有的 .css 结尾的文件 use 接受一个数组，数组中包含着对应 test 会使用到的所有 loader，比如这里的 css 文件会使用到 css-loader ，如果只有一个 loader，那么也可以省略数组，只写成字符串 链式 loader： 上述的案例是不成功的，因为我们还差一样东西：style-loader 每一个 loader 的功能都是独特而局限的，也就是说，一种类型的模块可以需要多种 loader 共同完成，在处理 css 文件时同样如此，需要 style-loader 和 css-loader 共同完成 安装 1npm install --save-dev style-loader 添加配置 12345678910// webpack.config.jsmodule.exports = &#123; // ... module: &#123; rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], &#125;], &#125;,&#125;; 在 webpack 打包时，是按照数组从后往前的顺序将资源交给 loader 处理的，因此要把最后生效的 style-loader 放在最前面 exclude 与 include 在项目中我们经常会用到 babel-loader 来处理 ES6+ 语言特性，将其编译为 ES5 来适应浏览器，但是对于 node_modules 中的 js 文件来说，很多都是已经编译为 ES5 的，因此没必要再使用 babel-loader 来进行额外的处理 exclude 与 include 就是用来排除规则的，他们可接收正则表达式或者字符串（字符串即文件的绝对路径），以及由他们组成的数组，如： 12345rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/,&#125;], 这里的含义是：对于匹配到正则表达式的模块，若在 exclude 指定的目录中（此处为 node_modules 目录），则不会执行该 use 规则 除了 exclude 之外，使用 include 配置也能达到相同的效果，如： 12345rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], include: /src/,&#125;], 值得注意的是，include 的逻辑似乎与 exclude 是相反的，对于匹配到正则表达式的模块，若在 include 指定的目录中（此处为 src 目录），才执行该 use 规则 exclude 与 include 同时存在时，exclude 的优先级更高，如： 123456rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, include: /node_modules\\/awesome/,&#125;] 此时，exclude 使得 node_modules 目录已经被排除了，虽然 include 之后想要让该 use 规则对 node_modules 中的某一个模块生效，也是无济于事的，因为 include 是无法覆盖 exclude 的 要实现原本的需求，我们可以改为： 123456rules: [&#123; test； /\\.css/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], // 用 exclude 排除 node_modules 中除了 foo 和 bar 以外的所有模块 exclude: /node_modules\\/(?!(foo|bar)\\/).*/,&#125;] 另外，由于 exclude 的优先级跟高，所以我们可以对 include 的子目录进行排除，如： 123456rules: [&#123; test； /\\.css/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /src\\/lib/, include: /src/,&#125;] 此处的结果就是：该 use 规则只对 src 目录生效，同时排除 src 目录中的 lib 目录 注：exclude 与 include 的配置项往往是必须考虑的，也是常加的，否则可能会拖慢整体的打包速度 resource 与 issuer resource 与 issuer 可以用于更加精确地确定模块规则的作用范围，如： 12// index.jsimport &#x27;./style.css&#x27; 在 webpack 中，被加载模块是 resource，而加载者是 issuer，在上面的例子中，resource 是 style.css，加载者是 index.js。 前面介绍的 test、exclude、include 在本质上就是对 resource 的配置，如果想要对 issuer 增加条件的话，需要额外地写配置，比如，我们只想让 /src/pages 目录下的 js 文件可以引用 css，本质想就是改变加载者的范围，配置如下： 12345678910rules: [&#123; test: /\\.css$/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], exclude: /node_modules/, issuer: &#123; test: /\\.js$/, include: /src/pages/, &#125;,&#125;],// 只有 /src/pages/ 下面的 js 文件引用 css 文件才能使此 use 规则生效 事实上，上述代码的可读性较差，我们可以改为： 1234567891011rules: [&#123; use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;], resource: &#123; test: /\\.css$/, exclude: /node_modules/, &#125;, issuer: &#123; test: /\\.js$/, exclude: /node_modules/, &#125;,&#125;], 注：此风格和上面的代码风格无法并存的，只能选择一种风格配置 enforce webpack 中的 loader 按照执行顺序可分为：pre、inline、normal、post四种，之前我们直接定义的 loader 都属于 normal 类型，官方已不推荐 inline 形式，而 pre 和 post 形式则需我们使用 enforce 指定，如： 123456rules: [&#123; test: /\\.css$/, enforce: &#x27;pre&#x27;, use: &#x27;eslint-loader&#x27;, // eslint-loader 的功能是对源代码进行质量检测，这种检测工作往往在其他 loader 之前执行&#125;] 这段代码的解释为：对于所有匹配正则表达式的模块，首先使用的 loader 规则就是 eslint-loader 概述起来就是，enforce 可以强制指定 loader 的执行顺序 pre 能强制 loader 首先执行 post 能强制 loader 最后执行 常用 loader 介绍 loader 官方文档 中文：loaders 原文：Loaders 下载源 awesome-webpack:loader 模板 loader： html-loader : 将HTML文件导出编译为字符串，可供js识别的其中一个模块 pug-loader : 加载pug模板 jade-loader : 加载jade模板(是pug的前身，由于商标问题改名为pug) ejs-loader : 加载ejs模板 handlebars-loader : 将Handlebars模板转移为HTML 样式 loader： css-loader : 解析css文件中代码 style-loader : 将css模块作为样式导出到DOM中 less-loader : 加载和转义less文件 sass-loader : 加载和转义sass/scss文件 postcss-loader : 使用postcss加载和转义css/sss文件 脚本转换编译 loader： script-loader : 在全局上下文中执行一次javascript文件，不需要解析 babel-loader : 加载ES6+ 代码后使用Babel转义为ES5后浏览器才能解析 typescript-loader : 加载Typescript脚本文件 coffee-loader : 加载Coffeescript脚本文件 JSON加载 loader： json-loader : 加载json文件（默认包含） json5-loader : 加载和转义JSON5文件 Files文件 loader： raw-loader : 加载文件原始内容(utf-8格式) url-loader : 多数用于加载图片资源,超过文件大小显示则返回data URL file-loader : 将文件发送到输出的文件夹并返回URL(相对路径) jshint-loader : 检查代码格式错误 加载框架 loader： vue-loader : 加载和转义vue组件 angualr2-template–loader : 加载和转义angular组件 react-hot-loader : 动态刷新和转义react组件中修改的部分,基于webpack-dev-server插件需先安装,然后在webpack.config.js中引用react-hot-loader 插件篇（Plugins）初识 Plugin 我们从最简单的情况说起：处理纯 CSS，之前接触 loader 的时候提及到 style-loader 与 css-loader，确实，通过 js 引用 css 的方式来打包样式很清晰地可以描述模块间的打包关系 然鹅，我们之前如果是通过 &lt;style&gt;...&lt;/style&gt; 来引入的 css 的，那么如何输出单独的 css 文件呢，在生产环境下，关于样式的代码我们更希望存在于 css 文件中，因为这样更有利于客户端进行缓存 当然，这个问题在 webpack 中已经有了答案，webpack 有专门的 插件 ：extract-text-webpack-plugin（适用于 webpack4 之前的版本）以及 mini-css-extract-plugin（适用于 webpack4 及以上的版本），这些就是专门用于提取样式到 css 文件中的 使用 Plugin 我们先通过一个简单的例子来认识插件是怎么工作的吧，这里使用的是 mini-css-extract-plugin（毕竟要跟上版本嘛） 当然最直接的方式就是查看文档：mini-css-extract-plugin 不过不熟悉的话还是跟着下面流程走吧 安装： 1npm install --save-dev mini-css-extract-plugin","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"前端/webpack","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ozzienicholas.gitee.io/tags/webpack/"}]},{"title":"Webpack（一）：初识 Webpack","slug":"Webpack（一）：初识 Webpack","date":"2021-03-20T03:00:30.000Z","updated":"2021-03-20T03:02:16.566Z","comments":true,"path":"fb2d6a527e7c/","link":"","permalink":"https://ozzienicholas.gitee.io/fb2d6a527e7c/","excerpt":"","text":"初识Webpack模块打包工具 模块打包工具的任务：解决模块之间的依赖，使其打包后能运行在浏览器上 模块打包工具的工作方式（主要分为以下两种） 将存在依赖关系的模块按照特定的规则合并为单个的 JS 文件，一次全部加载进入页面中 在页面初始时加载一个入口模块，其他模块异步地进行加载 有哪些模块打包工具？ Webpack Parcel Rollup 为什么选择 Webpack ？ 支持多种模块标准，如 AMD 规范 、Commonjs 规范、 ES6 模块规范 等等 完备的代码分割方案，通俗地说，就是首屏只加载必要的部分，不太重要的部分放到后面动态地加载 处理各种类型的资源，除了能处理 JavaScript 文件，还能处理样式、模板、甚至图片 庞大的社区支持 安装 注意：确保已经安装了 Node.js，并且该 Node 的版本要尽量新 初始化项目 新建 MyWebpack 文件夹，并输入： 1npm init -y 安装 webpack： 我们采用局部安装的方式，输入： 1npm install webpack webpack-cli --save-dev 注：webpack 是核心模块，webpack-cli 是命令行工具，在这里是需要的 检验安装 由于我们将 webpack 安装在了本地，所以这里无法使用 “webpack” 指令， 工程内部只能使用 npx webpack &lt;command&gt; 的方式，所以我们输入以下命令检验版本： 12npx webpack -vnpx webpack-cli -v 打包第一个应用 在根目录下添加以下几个文件： 新建 index.js 并输入： 123import addContent from &#x27;./addContent&#x27;document.write(&#x27;My first Webpack app &lt;br/&gt;&#x27;)addContent() 新建 addContent.js 并输入： 123export default function()&#123; document.write(&#x27;Hello World&#x27;)&#125; 新建 index.html 并输入： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 在命令行中输入： 1npx webpack --entry&#x3D;.&#x2F;index.js --output-filename&#x3D;bundle.js --mode&#x3D;development 浏览器打开 index.html 即可看到内容 回顾刚才的命令： entry 资源打包的入口，Webpack 将从这里开始进行模块依赖的查找，webpack 便知道了项目中包含 index.js 和 addContent.js 两个模块，通过他们来生成产物 output-filename 打包后的文件名 mode=development 打包模式，Webpack 提供了 development、production、none 三种模式 当选择 development 和 production 模式时，它会自动添加适用于当前模式下的一系列配置，一般在开发环境下，我们选择 development 就行了 使用 npm scripts： 在 package.json 中添加一下命令： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --entry=./index.js --output-filename=bundle.js --mode=development&quot;&#125; 现在不需要像刚才那样输入冗长的命令，直接输入： 1npm run build 使用默认目录配置 通常情况下，我们会设置两个目录，分别为源代码目录和资源输出目录 工程源代码放在 /src 中，输出资源放在 /dist 中 Webpack 默认的源代码入口就是 src/index.js ，所以现在我们可以省略掉 entry 的配置，编辑 package.json 如下： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack --output-filename=bundle.js --mode=development&quot;&#125; 使用配置文件 webpack 有非常多的配置项以及相应的命令行参数，我们可以通过以下命令查看： 1npx webpack -h 新建 webpack.config.js，输入如下： 1234567module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;bundle.js&#x27;, &#125;, mode: &#x27;development&#x27;&#125; 现在我们可以去掉 package.json 中配置的打包参数了： 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;webpack&quot;&#125; 输入 npm run build 即可重新打包 webpack-dev-server 由于我们现在每次更新内容都需要重新打包一次，比较麻烦，我们可以使用 Webpack 社区提供的一个开发工具 —— webpack-dev-server 安装工具 1npm install webpack-dev-server --save-dev 在 package.json 中添加一项： 123&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;&#125; 最后，我们需要对 webpack.config.js 进行配置，如下： 12345678910module.exports = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; filename: &#x27;./bundle.js&#x27;, &#125;, mode: &#x27;development&#x27;, devServer: &#123; publicPath: &#x27;/dist&#x27;, &#125;,&#125; webpack.config.js 的 devServer对象 是专门配置 webpack-dev-server 的，webpack-dev-server 主要工作就是接受浏览器的请求，然后将资源返回 当服务启动时，会先让 webpack 进行模块打包，当 webpack-dev-server 接收到 浏览器的资源请求时，它会首先进行 URL 地址校验，如果地址是资源服务地址（即配置中的 publicPath），那么就从 webpack 将打包结果返回给浏览器，否则直接从硬盘读取源文件并返回 总结 webpack-dev-server 的职能： 令 webpack 进行模块打包，并处理打包结果的资源请求 作为 web server，处理静态资源文件请求 输入命令，并打开 http://localhost:8080/： 1npm run dev 注意事项 直接用 webpack 开发和使用 webpack-dev-server 有一个很大的区别：前者每次都会生成 bundle.js，而后者只是将打包结果放在内存中，并没有实际写入 bundle.js 中，每次都是将内存中的打包结果返回给浏览器，可以通过删除 dist 目录来检验此区别 当然，还需说明的一点是，webpack-dev-server 中的很便捷的的特点就是 live-reloading，来保持本地服务启动以及浏览器打开的状态 再谈模块打包各种模块规范 此处不再叙述 CommonJs，ES6 Module 等规范标准以及它们之间的区别，详情清查： Javascript模块化编程 CommonJS, AMD, CMD是什么及区别–简单易懂有实例 CommonJS规范 模块打包原理 新建两个文件，内容分别如下： index.js 123const mod = require(&#x27;./mod.js&#x27;)const sum = mod.add(2,3)console.log(&#x27;sum&#x27;,sum) mod.js 12345module.exports = &#123; add: function(a, b)&#123; return a + b; &#125;&#125; 打包之后的 JS 文件如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(function(modules) &#123; var installedModules = &#123;&#125;; function __webpack_require__(moduleId) &#123; if (installedModules[moduleId]) &#123; return installedModules[moduleId].exports; &#125; var module = installedModules[moduleId] = &#123; i: moduleId, l: false, exports: &#123;&#125; &#125;; modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); module.l = true; return module.exports; &#125; __webpack_require__.m = modules; __webpack_require__.c = installedModules; __webpack_require__.d = function(exports, name, getter) &#123; if (!__webpack_require__.o(exports, name)) &#123; Object.defineProperty(exports, name, &#123; enumerable: true, get: getter &#125;); &#125; &#125;; __webpack_require__.r = function(exports) &#123; if (typeof Symbol !== &#x27;undefined&#x27; &amp;&amp; Symbol.toStringTag) &#123; Object.defineProperty(exports, Symbol.toStringTag, &#123; value: &#x27;Module&#x27; &#125;); &#125; Object.defineProperty(exports, &#x27;__esModule&#x27;, &#123; value: true &#125;); &#125;; __webpack_require__.t = function(value, mode) &#123; if (mode &amp; 1) value = __webpack_require__(value); if (mode &amp; 8) return value; if ((mode &amp; 4) &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; value &amp;&amp; value.__esModule) return value; var ns = Object.create(null); __webpack_require__.r(ns); Object.defineProperty(ns, &#x27;default&#x27;, &#123; enumerable: true, value: value &#125;); if (mode &amp; 2 &amp;&amp; typeof value != &#x27;string&#x27;) for (var key in value) __webpack_require__.d(ns, key, function(key) &#123; return value[key]; &#125;.bind(null, key)); return ns; &#125;; __webpack_require__.n = function(module) &#123; var getter = module &amp;&amp; module.__esModule ? function getDefault() &#123; return module[&#x27;default&#x27;]; &#125; : function getModuleExports() &#123; return module; &#125;; __webpack_require__.d(getter, &#x27;a&#x27;, getter); return getter; &#125;; __webpack_require__.o = function(object, property) &#123; return Object.prototype.hasOwnProperty.call(object, property); &#125;; __webpack_require__.p = &quot;&quot;; return __webpack_require__(__webpack_require__.s = &quot;./index.js&quot;);&#125;)(&#123; &quot;./index.js&quot;: (function(module, exports, __webpack_require__) &#123; eval( &quot;const mod = __webpack_require__(/*! ./mod.js */ \\&quot;./mod.js\\&quot;)\\r\\nconst sum = mod.add(2,3)\\r\\nconsole.log(&#x27;sum&#x27;,sum)\\r\\n\\n\\n//# sourceURL=webpack:///./index.js?&quot; ); &#125;), &quot;./mod.js&quot;: (function(module, exports) &#123; eval( &quot;module.exports = &#123;\\r\\n\\tadd: function(a, b)&#123;\\r\\n\\t\\treturn a + b;\\r\\n\\t&#125;\\r\\n&#125;\\n\\n//# sourceURL=webpack:///./mod.js?&quot; ); &#125;)&#125;); 上述这个结果可以很清晰地展示它是如何将具有依赖关系的模块串联在一起的，此文件可以分为以下几个部分： 最外层立即执行匿名函数，用来包裹整个文件，并形成自己的作用域 installedModules对象：每个模块只在第一次被加载的时候执行，然后导出的值就存在这个对象里面，当再次被加载的时候直接从里面取值，而不会重新执行 __webpack_require__函数：对于模块加载的实现，在浏览器中可以通过 __webpack_require__(module.id) 来完成模块的导入 module对象：工程中所有产生了依赖关系的文件都会以 key-value 的形式存放在这里 key 可以理解为一个模块的 id，由数字或者很短的 hash 字符串组成 value 是一个匿名函数包裹的模块实体，匿名函数的每个参数赋予了模块的导入和导出的功能 打包后的文件在浏览器中的执行过程： 最外层的匿名函数初始化浏览器的执行环境，为模块的加载和执行做准备工作，比如定义 installedModules 对象、__webpack_require__ 函数等等 加载入口模块，每个打包后的文件都有一个入口模块，上述实例中，index.js 是入口模块，浏览器即从入口模块开始执行 执行模块代码： 如果执行到了 module.exports，则记录下模块的导出值 如果执行时遇到了 __webpack_require__，则会暂时交出执行权，进入 __webpack_require__ 函数体内加载其他模块的内容 在 __webpack_require__ 中判断即将加载的模块是否存在于 installedModules 中，如果存在则直接取值，否则返回上一步 —— 执行模块代码获取导出值 当所有依赖的模块均已执行完毕，则最后的执行权显然又会回到入口模块，当入口模块的代码执行结束，也就标致着整个模块打包过程结束 资源输入与输出资源处理流程 在一切工作开始之前，我们需要指定一个或者多个 入口（entry） 来让 webpack 知晓应该从哪里开始打包，如果把各个模块的依赖关系比喻成一颗树，那么入口文件显然就是树根，如图： 这些存在依赖关系的模块，在打包时会被封装成一个 chunk，chunk 的字面意思是代码块，在 webpack 中，可以理解为被封装和抽象过后的一些模块，根据配置不同，webpack可能会形成一个或多个 chunk 由这个 chunk 得到的打包产物我们称为 bundle。entry、chunk、bundle的关系如下： 在工程中可以定义多个入口，每个入口都会产生一个结果，比如我们有两个入口文件 index.js 和 lib.js，那么打包的结果就会生成 dist/bundle.js 和 dist/lib.js，如图： 配置资源入口 webpack 通过 context 和 entry 两个配置项来共同决定入口文件的路径，在配置时，实际上做了两件事： 确定入口模块的位置，告诉 webpack 从哪里开始打包 定义 chunk name ，如果该工程只有唯一入口，那么默认为 main，若有多个入口，那么分别定义对应的 chunk name。 context与entry context context 可以理解为资源入口的路径前缀，在配置时要求使用绝对路径的形式，比如下面两个例子： 12345678910// 指定路径为：&lt;工程根路径&gt;/src/home/index.jsmodule.exports = &#123; context: path.join(__dirname, &#x27;./src&#x27;), entry: &#x27;./home/index.js&#x27;&#125;;// 等同于下面这种方式module.exports = &#123; context: path.join(__dirname, &#x27;./src/home&#x27;), entry: &#x27;./index.js&#x27;&#125; 配置 context 的目的主要是让 entry 的编写更加简洁，这种作用在多入口的情况下尤其突出，此外，context 是可以省略的，则默认值为当前工程的根目录 context 的配置形式只能为字符串 entry 首先，entry 的配置形式可以有多种：字符串、数组、对象、函数，可以根据不同的需求场景来选择 字符串类型入口 直接传入路径123module.exports = &#123; entry: &#x27;./src/index.js&#x27;,&#125; 数组类型入口： 传入一个数组的作用是将多个资源先合并，在打包时 webpack 会将数组中的最后一个元素作为实际的入口路径，如：123module.exports = &#123; entry: [&#x27;babel-polyfill&#x27;, &#x27;./src/index.js&#x27;],&#125; 以上配置等同于：123456// webpack.config.jsmodule.exports = &#123; entry: &#x27;./src/index.js&#x27;,&#125;// index.jsimport &#x27;babel-polyfill&#x27; 对象类型入口： 如果想要定义多个入口，则必须要使用对象地形式，对象的属性名（key）是 chunk name，属性值（value）是入口路径，如：12345678module.exports = &#123; entry: &#123; // chunk name 为 index，入口路径为 ./src/index.js index: &#x27;./src/index.js&#x27;, // chunk name 为 lib，入口路径为 ./src/lib.js lib: &#x27;./src/lib.js&#x27;, &#125;&#125; 当然，对象的属性值也可以为字符串或者数组，如：1234module.exports = &#123; index: [&#x27;babel-polyfill&#x27;, &#x27;./src/index.js&#x27;], lib: &#x27;./src/lib.js&#x27;&#125; 函数类型入口： 用函数定义入口时，只需要返回字符串、数组或者对象中的任何一种配置形式即可，如：1234567891011// 返回字符串型的入口module.exports = &#123; entry: () =&gt; &#x27;./src/index.js&#x27;,&#125;// 返回对象型的入口module.exports = &#123; entry: () =&gt; (&#123; index: [&#x27;babel-polyfill&#x27;, &#x27;./src/index.js&#x27;], lib: &#x27;./src/lib.js&#x27; &#125;)&#125; 使用函数的优势是我们可以在函数体内添加一些动态的逻辑来获取入口，而且，函数也支持返回一个 Promise 对象 来进行异步操作，如：12345678module.exports = &#123; entry: () =&gt; new Promise((resolve) =&gt; &#123; // 模拟异步操作 setTimeout(() =&gt; &#123; resolve(&#x27;./src/index.js&#x27;); &#125;, 1000); &#125;),&#125;; 注：使用字符串或数组定义单入口时，没有办法更改 chunk name，只能为默认的 “main” 使用对象来定义多入口时，则必须为每一个入口定义 chunk name 实例 —— 单页与多页 单页应用 对于 单页应用（SPA） 来说，一般定义单一入口即可： 123module.exports = &#123; entry: &#x27;./src/index.js&#x27;,&#125; 这样做的好处是只会产生一个 JS 文件，依赖关系清晰，而弊端就是所有的模块都打包到一个文件中，可能会导致该输出文件体积过大，降低页面的渲染速度 在 webpack 的默认配置中，一个输出文件大于 250KB 时，会认为这个文件已经过大了，在打包时会发出警告 提取 vendor 假如工程产生的 JS 文件体积很大，那么一旦代码更新，输出文件也要响相应地更新，这对页面的性能影响是比较大的，我们可以通过 vendor 来解决这个问题 在 webpack 中，vendor 一般指的是工程所使用的库、框架等第三方模块集中打包产生的输出文件，如： 1234567module.exports = &#123; context: path.join(__dirname, &#x27;./src&#x27;), entry: &#123; index: &#x27;./src/index.js&#x27;, vendor: [&#x27;react&#x27;, &#x27;react-dom&#x27;, &#x27;react-router&#x27;], &#125;,&#125;; 在上述的例子中，我们添加了一个新的 chunk name 作为 vendor 的入口，通过数组的形式将工程所需的第三方模块放了进去 多页应用 我们希望每个页面都只加载各自必要的逻辑，而不是把所有的内容都打包到一个输出文件中，因此每个页面都需要有一个独立的输出文件，如： 12345678module.exports = &#123; entry: &#123; pageA: &#x27;./src/pageA.js&#x27;, pageB: &#x27;./src/pageB.js&#x27;, // 提取 vendor 来对公共模块打包 vendor: [&#x27;react&#x27;, &#x27;react-dom&#x27;], &#125;&#125; 配置资源出口 所有与出口相关的配置都集中在 output 对象 中，此部分最好的学习当然是去查文档啦，给出链接： 原文档：Output 中文文档：输出(output)","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"webpack","slug":"前端/webpack","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/webpack/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ozzienicholas.gitee.io/tags/webpack/"}]},{"title":"反转字符串","slug":"反转字符串","date":"2021-03-20T02:59:34.000Z","updated":"2021-03-20T02:59:46.816Z","comments":true,"path":"58b54336770f/","link":"","permalink":"https://ozzienicholas.gitee.io/58b54336770f/","excerpt":"","text":"题目 链接：https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/ 题面： 个人方法 分析：由于每个单词反转后的顺序不变，所以我们将该字符串，按照空格分割成独立单词，再反转单词，再拼接 代码： 12345678910var reverseWords = function(s) &#123; // 将字符串按空格分成单词，并存入数组中 let arr = s.split(&#x27; &#x27;) // 遍历数组，将每个单词拆成字母存入数组，再反转，再拼接成单词 let result = arr.map(item =&gt; &#123; return item.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;) // 将所有单词用空格连成字符串 return result.split(&#x27; &#x27;)&#125; 优化： 123456var reverseWords = function(s) &#123; return s.split(&#x27; &#x27;).map(item =&gt; &#123; return item.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;).join(&#x27; &#x27;)&#125;;// 这样就没有了 arr 和 result，节省了时间和空间 大佬启示 之前是先分割成独立单词，再反转单词，再拼接，可是我们用到的 map 方法是比较耗时的，所以优化如下： 123var reverseWords = function(s) &#123; return s.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;).split(&#x27; &#x27;).reverse().join(&#x27; &#x27;)&#125; 进一步优化为： 1234// split 的参数也可以是正则表达式，所以用 /\\s+/ 来代替原先的空格字符var reverseWords = function(s) &#123; return s.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;).split(/\\s+/).reverse().join(&#x27; &#x27;)&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"数组中重复的数字","slug":"数组中重复的数字","date":"2021-03-20T02:59:02.000Z","updated":"2021-03-20T02:59:18.110Z","comments":true,"path":"5e668cf71402/","link":"","permalink":"https://ozzienicholas.gitee.io/5e668cf71402/","excerpt":"","text":"题面链接https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 描述 思路（一） 转化为集合时，会自动去除重复的元素； 如果集合的长度小于原数组的长度，那么原数组就有重复的元素； 题目只要求返回任一重复的元素，那么就边转化边比较长度； 如果将原数组的元素增加到集合中时，集合的长度没有增加，就返回该元素，结束过程。 题解（一）12345678910111213/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findRepeatNumber = function(nums) &#123; let s = new Set(); for(let i in nums) &#123; s.add(nums[i]); if(s.size-i &lt; 1) return nums[i]; &#125; return null;&#125;; 结果（一）执行用时：100 ms 内存消耗：45.9 MB 思路（二） 先把数组排序，再遍历数组； 若相邻元素相同，那就返回该元素。 题解（二）1234567891011121314/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findRepeatNumber = function(nums) &#123; nums.sort(); let cnt = nums.length - 2; for(let i=0; i&lt;=cnt; i++) &#123; if(nums[i] == nums[i+1]) &#123; return nums[i]; &#125; &#125; return null;&#125;; 结果（二）执行用时：92 ms 内存消耗：44.2 MB","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"只出现一次的数字","slug":"只出现一次的数字","date":"2021-03-20T02:58:14.000Z","updated":"2021-03-20T02:58:29.862Z","comments":true,"path":"c326c1ec9705/","link":"","permalink":"https://ozzienicholas.gitee.io/c326c1ec9705/","excerpt":"","text":"题目 链接：https://leetcode-cn.com/problems/single-number/ 题面： 个人方法 分析： 出现两次的元素的第一次下标和最后一次下标肯定不同 那么，对于元素 x，若 nums.indexOf(x) == nums.lastIndexOf(x)，则肯定是只出现一次的元素 代码： 12345678910/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var singleNumber = function(nums) &#123; for(let i=0; i&lt;nums.length; i++) &#123; if(nums.indexOf(nums[i]) == nums.lastIndexOf(nums[i])) return nums[i] &#125;&#125;; 大佬启示法一：哈希 分析： 建立哈希表，空间复杂度为 O(n) 遍历一次并用数组存储所有数的出现次数 遍历第二次找到次数为 1 的元素 最后返回该元素 代码： 123456789var singleNumber = function(nums) &#123; let ret = &#123;&#125;; for(let i=0; i &lt; nums.length; i++) &#123; if (ret[nums[i]]) delete ret[nums[i]]; else ret[nums[i]] = 1; &#125; return Object.keys(ret)[0];&#125;; 法二：先排序后暴力 分析： 将整数数组排序，若相邻项有相同的，则肯定是出现两次的 这比直接暴力的时间复杂度要低很多 代码： 1234567var singleNumber = function(nums) &#123; nums = nums.sort(); for(let i=1; i&lt;nums.length; i++) &#123; if(nums[i]!=nums[i+1] &amp;&amp; nums[i]!=nums[i-1]) return nums[i] &#125;&#125; 法三：位运算 —— 异或 分析： 异或运算的性质： 一个数和 0 异或运算等于本身：a ⊕ 0 = a 一个数和其本身异或运算等于 0：a ⊕ a = 0 异或运算满足交换律和结合律：a ⊕ b ⊕ a = ( a ⊕ a ) ⊕ b = 0 ⊕ b = b 所以，将所有的数字按照顺序做异或运算，最后剩下的结果即为唯一的数字 算法如下： 定义 ret=0，用于对每一个数组元素做异或运算 遍历数组，与 ret 异或运算，且结果赋值给 ret 例如，若 nums = [2, 3, 2, 4, 4]，则按照算法执行结果即为 2^3^2^4^4，运用交换律和结合律得知，结果即为唯一的奇数项： 3 代码： 123456var singleNumber = function(nums) &#123; let ret = 0; for (let i = 0; i &lt; nums.length; i++) ret ^= nums[i]; return ret;&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"旋转数组","slug":"旋转数组","date":"2021-03-20T02:57:34.000Z","updated":"2021-03-20T02:58:00.006Z","comments":true,"path":"9e617b7862e8/","link":"","permalink":"https://ozzienicholas.gitee.io/9e617b7862e8/","excerpt":"","text":"题目 链接：https://leetcode-cn.com/problems/rotate-array/ 题面 个人方法 分析：旋转 k 次，也就是每次都把最后一个元素放到最前面，执行 k 次 代码 12345678910/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) &#123; for (let i = 0; i &lt; k; i ++) &#123; nums.unshift(nums.pop()); &#125;&#125;; 优化：若 k&gt;nums.length，则应该将 k 对 nums.length 求余 1234567var rotate = function(nums, k) &#123; if(k &gt;= nums.length) k = k%nums.length for (let i = 0; i &lt; k; i ++) &#123; nums.unshift(nums.pop()); &#125;&#125;; 大佬启示 分析：旋转 k 次，也就是将最后 k 个元素提到最前面 代码： 12345var rotate = function(nums, k) &#123; if(k &gt;= nums.length) k = k%nums.length nums.splice(0, 0, ...nums.splice(nums.length - k));&#125;;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"删除排序数组中的重复项","slug":"删除排序数组中的重复项","date":"2021-03-20T02:46:42.000Z","updated":"2021-03-20T02:57:11.740Z","comments":true,"path":"637def054a12/","link":"","permalink":"https://ozzienicholas.gitee.io/637def054a12/","excerpt":"","text":"题目 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/ 题面： 个人方法 分析： 给出的是已经排好序的数组，那么重复的元素肯定相邻 题目中要求的是要在给出的数组上操作，而我们如果不使用深拷贝，就需要一些能操作原始数组的方法， Array.splice() 也就是此次用到的核心方法 算法：遍历数组，如果第 i 项与第 i+1 项重复，那么就删除第 i 项，再用 i-- 更新下标 代码： 12345678910var removeDuplicates = function(nums) &#123; // 遍历数组 for (var i=0; i&lt;nums.length-1; i++) &#123; if (nums[i] == nums[i + 1]) &#123; // 若重复 nums.splice(i,1); // 删除第i项 i--; // 更新下标 &#125; &#125; return nums.length;&#125;; 大佬启示法一 对于返回的长度，很明显，等于 原数组的长度 － 重复元素的个数 对于返回的数组，由题干以及两个示例可以得出：只是重复的部分被不重复的部分所替代 如，对于 [1, 2, 3, 3, 4, 5, 6, 6, 7]，经过操作后应该是 [1, 2, 3, 4, 5, 6, 7, 6, 7]，而返回的数组是前7个不重复的元素，即 [1, 2, 3, 4, 5, 6, 7]，返回的长度为7 所以，算法如下： 定义 count 来记录重复的元素 用 i(1 ≤ i ≤ n) 循环下标来遍历原数组 若 nums[i] 与 nums[i-1] 相同，则 count + 1，表示这是第几个重复的元素， 若 nums[i] 与 nums[i-1] 不同，则 nums[i] 应该向前移动 count 个下标来替换 num[i-count] 例如：对于 [1, 2, 3, 3, 4, 5, 6, 6, 7]，1 ≤ i ≤ 2 时 count=0，这段区间的 num[i] 不需要移动，而 i=3 时，num[i]等于num[i-1]，此时 count应该+1，i=4 时，num[i] 就应该替换 num[i-count]，也就是 num[4] 要替换 num[3] 代码： 12345678910var removeDuplicates = function(nums) &#123; var count = 0; for(var i=1,len=nums.length; i&lt;len; i++)&#123; if(nums[i] == nums[i-1]) count ++; else nums[i-count] = nums[i] &#125; return len-count;&#125;; 法二（双指针法） 顾名思义，我们将会用到两个指针，分别是遍历数组的 i，和记录重复元素第一次出现位置的 r 算法如下： 用 i(1 ≤ i ≤ n) 遍历数组，并初始化 r=0 若 nums[i]不等于nums[i-1]，则 r++且i++ ，且执行 nums[r] = num[i]（这是为了之后遇到不重复元素做铺垫），两个指针将同步循环 若 nums[i]等于nums[i-1]，则 r 不变，而只是 i++，此时的 r 将记录下重复元素的首次下标 因为 r 是索引值，所以最后返回的长度是 r+1 代码： 12345678910var removeDuplicates = function(nums) &#123; var r = 0; for(var i=1,len=n.length; i&lt;len; i++) &#123; if(nums[i] != nums[i-1]) &#123; r ++; nums[r] = nums[i] &#125; &#125; return r+1;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"选课","slug":"选课","date":"2021-03-20T02:44:18.000Z","updated":"2021-03-20T02:45:54.970Z","comments":true,"path":"8a2e1e17351c/","link":"","permalink":"https://ozzienicholas.gitee.io/8a2e1e17351c/","excerpt":"","text":"题面 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define pii pair&lt;int,int&gt;#define ll long long#define cl(x,y) memset(x,y,sizeof(x))#define loop(x,y,z) for(x=y;x&lt;=z;x++)#define reve(x,y,z) for(x=y;x&gt;=z;x--)#define ct cerr&lt;&lt;&quot;Time elapsed:&quot;&lt;&lt;1.0*clock()/CLOCKS_PER_SEC&lt;&lt;&quot;s.\\n&quot;;#define mp make_pair#define pb push_back#define fi first#define se second#define all(x) x.begin(),x.end()#define lson x&lt;&lt;1,l,mid#define rson x&lt;&lt;1|1,mid+1,r#define INF 1e18const int N=1e6+10;const int mod=1e9+7;const int inf=0x3f3f3f3f;const double eps=1e-8;const double pi=acos(-1);using namespace std;int w[N],len=0,in[N];vector&lt;int&gt; e[N];int main() &#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, m, k, i; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; map&lt;string,int&gt; ma; for(i=1; i&lt;=n; i++) &#123; string s; cin&gt;&gt;s&gt;&gt;w[i]; ma[s]=i; &#125; for(i=1; i&lt;=m; i++) &#123; string s, t; cin&gt;&gt;s&gt;&gt;t; int k1=ma[s], k2=ma[t]; in[k2]++; e[k1].pb(k2); &#125; priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; q; for(i=1; i&lt;=n; i++) &#123; if(in[i]==0) &#123; q.push(mp(w[i],i)); &#125; &#125; int ans = 0; while(!q.empty()) &#123; pii pre = q.top(); q.pop(); ans += pre.fi; k--; if(k&lt;=0) &#123; break; &#125; for(i=0; i&lt;e[pre.se].size(); i++) &#123; int v = e[pre.se][i]; in[v]--; if(in[v]==0) &#123; q.push(mp(w[v],v)); &#125; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"选拔继承人","slug":"选拔继承人","date":"2021-03-20T02:43:56.000Z","updated":"2021-03-20T02:45:45.411Z","comments":true,"path":"a1f5becdb664/","link":"","permalink":"https://ozzienicholas.gitee.io/a1f5becdb664/","excerpt":"","text":"题面 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;using namespace std;const int N=5e5+5;const double eps = 1e-6;const int inf = 0x7fffffff;typedef long long ll;#define fi first#define se second#define pii pair&lt;int,int&gt;#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);//#define int long long#define endl &#x27;\\n&#x27;int n, m, s, fa[N][30], deep[N], lg[N];int head[N&lt;&lt;1], nex[N&lt;&lt;1], to[N&lt;&lt;1], tot=0;void add(int a, int b) &#123; to[++tot] = b; nex[tot] = head[a]; head[a] = tot;&#125;void dfs(int x,int y) &#123; deep[x] = deep[y]+1; fa[x][0] = y; for(int i=1; (1&lt;&lt;i)&lt;=deep[x]; i++) &#123; fa[x][i] = fa[fa[x][i-1]][i-1]; &#125; for(int i=head[x]; i; i=nex[i]) &#123; if(to[i]!=y) &#123; dfs(to[i],x); &#125; &#125;&#125;int LCA(int x, int y) &#123; if(deep[x]&lt;deep[y]) &#123; swap(x,y); &#125; while(deep[x]&gt;deep[y]) &#123; x=fa[x][lg[deep[x]-deep[y]]]; &#125; if(x==y) &#123; return x; &#125; for(int i=lg[deep[x]]; i&gt;=0; i--) &#123; if(fa[x][i]!=fa[y][i]) &#123; x = fa[x][i]; y = fa[y][i]; &#125; &#125; return fa[x][0];&#125;int in[N] = &#123;0&#125;;signed main() &#123; IOS; cin&gt;&gt;n; int a, b; while(cin&gt;&gt;a&gt;&gt;b &amp;&amp; (a+b)) &#123; add(a,b); add(b,a); in[a]++; &#125; for(int i=1; i&lt;=n; i++) &#123; if(in[i]==0) &#123; s=i; &#125; &#125; dfs(s,0); for(int i=2;i&lt;=n;i++) &#123; lg[i]=lg[i&gt;&gt;1]+1; &#125; int m,ans=0; cin&gt;&gt;m; while(m--) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; int k=LCA(a,b); if(k==a || k==b) &#123; ans++; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"混合排序","slug":"混合排序","date":"2021-03-20T02:43:47.000Z","updated":"2021-03-20T02:45:35.250Z","comments":true,"path":"6ba5c394a3c6/","link":"","permalink":"https://ozzienicholas.gitee.io/6ba5c394a3c6/","excerpt":"","text":"题面 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;using namespace std;float eps = 0.000001; // 定义0的精度int n, m;void A(int arr[], float brr[], int n) &#123; // 按月薪输出成绩 int i, j, k; for(i=0; i&lt;n-1; i++) &#123; for(j=0; j &lt;n-i-1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; std::swap(arr[j], arr[j+1]); std::swap(brr[j], brr[j+1]); &#125; &#125; &#125; for(k=n-1; k&gt;n-1-m; k--) &#123; cout&lt;&lt;brr[k]&lt;&lt;&#x27; &#x27;; &#125; printf(&quot;\\n&quot;);&#125;void B(float arr[], string brr[], int n) &#123; // 按成绩输出学号 int i, j, k; for(i=0; i&lt;n-1; i++) &#123; for(j=0; j&lt;n-i-1; j++) &#123; if(arr[j]-arr[j+1]&gt;eps) &#123; std::swap(arr[j], arr[j+1]); std::swap(brr[j], brr[j+1]); &#125; &#125; &#125; for(k=n-1; k&gt;n-1-m; k--) &#123; cout&lt;&lt;brr[k]&lt;&lt;&#x27; &#x27;; &#125; printf(&quot;\\n&quot;);&#125;void C(int arr[], string brr[], int n) &#123; // 按年薪输出名称 int i, j, k; for(i=0; i&lt;n-1; i++) &#123; for(j=0; j &lt;n-i-1; j++) &#123; if(arr[j] &gt; arr[j+1]) &#123; std::swap(arr[j], arr[j+1]); std::swap(brr[j], brr[j+1]); &#125; &#125; &#125; for(k=n-1; k&gt;n-1-m; k--) &#123; cout&lt;&lt;brr[k]&lt;&lt;&#x27; &#x27;; &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; // 输入N，M，分别表示N行输入，M行判断 scanf(&quot;%d%d&quot;, &amp;n, &amp;m); // N行输入6条数据，分别存入对应数组，外加年薪计算 int i, j; // 数据数组，以及数组复制 string xm[1002], xh[1002], mc[1002], xh_2[1002], mc_2[1002]; float cj[1002], cj_2[1002]; int ys[1002], yx[1002], nx[1002]; // 输入数据 string xingming, xuehao, mingcheng; float chengji; int yueshu, yuexin; for(i=0; i&lt;n; i++) &#123; cin&gt;&gt;xingming&gt;&gt;xuehao&gt;&gt;chengji&gt;&gt;mingcheng&gt;&gt;yuexin&gt;&gt;yueshu; xm[i] = xingming; xh[i] = xuehao; xh_2[i] = xuehao; cj[i] = chengji; cj_2[i] = chengji; mc[i] = mingcheng; mc_2[i] = mingcheng; yx[i] = yuexin; ys[i] = yueshu; nx[i] = yuexin*yueshu; &#125; // 对月薪、成绩、年薪分别排序，输出前M个判断数据 A(yx, cj_2, n); B(cj, xh_2, n); C(nx, mc_2, n); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"偶数求和","slug":"偶数求和","date":"2021-03-20T02:38:52.000Z","updated":"2021-03-20T02:45:05.165Z","comments":true,"path":"6c7433ceebd6/","link":"","permalink":"https://ozzienicholas.gitee.io/6c7433ceebd6/","excerpt":"","text":"题面有一个长度为n(0&lt;n&lt;=100)的数列，该数列定义为从2开始的递增有序偶数（公差为2的等差数列），现在要求你按照顺序每m个数求出一个平均值，如果最后不足m个，则以实际数量求平均值。编程输出该平均值序列。 输入：输入数据有多组，每组占一行，包含两个正整数n和m，n和m的含义如上所述。 输出：对于每组输入数据，输出一个平均值序列，每组输出占一行。 样例输入： 123 24 2 样例输出： 123 63 7 思路（一） 先分析样例输入：输入3、2： 说明 n=3，m=2； 也就是：在数列 2, 4, 6 中，以2位单位分组求平均值，剩余的分开求平均值 2, 4 为1组，平均值为3，6 单独一组，平均值为6 则输出就为：3 6 也就是，我们分成两部分：“能分组的” 和 “剩余的” 能分组的部分：这部分是有规律的，规律就是：在等差数列中，等间距地分组求和所构成的新数列也是等差数列，其平均值也同样是等差数列。 剩余的部分：求出剩余多少元素，再求出这些元素的和的平均值即可。 还需注意： n&lt;m 时：没有“能分组的”，只有“剩余的”。 n%m==0 时：只有“能分组的”，没有“剩余的”。 所以，在求平均值时，还要再加一些判断。 解题（一）12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int main () &#123; int n, m; // 输入n,m int arr[100]; // 输出数组 while(~scanf(&quot;%d%d&quot;, &amp;n, &amp;m)) &#123; int cnt = 0; // 数组下标 // n个数，每m个一组 int a = n/m; // 分为多少组 int b = n%m; // 分组后还剩余多少 int ret = 0; // 平均值初始为0 // 若n&gt;m，则有第一个数 if(a &gt; 0) &#123; for(int i=2; i&lt;=2*m; i+=2) &#123; ret += i; &#125; ret /= m; // 保存元素 arr[cnt] = ret; cnt ++; &#125; // 分组数大于2，则循环存入已分组的数 if(a &gt; 1) &#123; for(int i=1; i&lt;=(a-1); i++) &#123; ret += 2*m; arr[cnt] = ret; cnt ++; &#125; &#125; // 若有剩余，则再加未分组的平均值 if(b != 0) &#123; ret = 0; // 清零 int k = a*m*2; for(int i=1; i&lt;=b; i++) &#123; ret += (k + i*2); &#125; arr[cnt] = ret/b; cnt ++; &#125; // 输出 for(int i=0; i&lt;cnt; i++) &#123; printf(&quot;%d &quot;, arr[i]); &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125; 思路（二） 这次借助数组，把需要的数列元素先存入数组； 先按照m的值，分开遍历每个组，如果已经遍历完数组或者遍历了一个分组，就计算平均值。 解题（二）123456789101112131415161718192021222324#include&lt;stdio.h&gt;int main() &#123; int n, m; while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF) &#123; int i, j; // 遍历数组 int a[100] = &#123;0&#125;; // 数列初始化 int sum = 0; // 求和 for(i=0; i&lt;n; i++)&#123; // 将数列存入数组 a[i] = 2+i*2; &#125; for(j=0; ;j++)&#123; for(i=m*j; i&lt;m*(j+1); i++) &#123; if(a[i] == 0) // 遍历完数组，则退出循环 break; sum += a[i]; // 求和 &#125; printf(&quot;%d &quot;, sum/(i-m*j)); if(a[i] == 0) // 遍历完数组，则退出循环 break; &#125; printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"高次方数的尾数","slug":"高次方数的尾数","date":"2021-03-20T02:37:57.000Z","updated":"2021-03-20T02:38:25.010Z","comments":true,"path":"5e7a7d126d68/","link":"","permalink":"https://ozzienicholas.gitee.io/5e7a7d126d68/","excerpt":"","text":"继续水题。。。 题面求13的13次方的最后三位数 思路最直接的方法是：将13累乘13次方截取最后三位即可。 但是由于计算机所能表示的整数范围有限，用这种“正确”的算法不可能得到正确的结果。事 实上，题目仅要求最后三位的值，完全没有必要求13的13次方的完整结果。 研究乘法的规律发现：乘积的最后三位的值只与乘数和被乘数的后三位有关，与乘数和被乘 数的高位无关。 解题12345678910111213#include&lt;stdio.h&gt;int main() &#123; int x, y; // 输入x、y来表示x的y次方 scanf(&quot;%d%d&quot;, &amp;x, &amp;y); int mul = 1; // 表示乘积 int i; for(i=1; i&lt;=y; i++) &#123; // 每增加一个次方，都只需要后三位 mul = (mul*x)%1000; &#125; printf(&quot;%d的%d次方的后三位为：%d\\n&quot;, x, y, mul); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"密码","slug":"密码","date":"2021-03-20T02:20:25.000Z","updated":"2021-03-20T02:21:40.650Z","comments":true,"path":"7f6d9db2fdc1/","link":"","permalink":"https://ozzienicholas.gitee.io/7f6d9db2fdc1/","excerpt":"","text":"题面题目描述12345678910网上流传一句话：&quot;常在网上飘啊，哪能不挨刀啊～&quot;。其实要想能安心地上网其实也不难，学点安全知识就可以。首先，我们要设置一个安全的密码。那什么样的密码才叫安全的呢？一般来说，比较安全的密码至少应该满足下面两个条件：(1)密码长度大于等于8，且不要超过16。(2)密码中的字符应该来自下面“字符类别”中四组中的至少三组。这四个字符类别分别为：1.大写字母：A,B,C...Z;2.小写字母：a,b,c...z;3.数字：0,1,2...9;4.特殊符号：~,!,@,#,$,%,^;给你一个密码，你的任务就是判断它是不是一个安全的密码。 输入1输入数据第一行包含一个数M，接下有M行，每行一个密码（长度最大可能为50），密码仅包括上面的四类字符。 输出1对于每个测试实例，判断这个密码是不是一个安全的密码，是的话输出YES，否则输出NO。 样例输入12343a1b2c3d4Linle@ACM^~^@^@!% 样例输出123NOYESNO 思路输入，判断每个元素符合的条件即可 解题123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;int main() &#123; int n; while(~scanf(&quot;%d&quot;, &amp;n)) &#123; // 输入测试组数 for(int i=0; i&lt;n; i++) &#123; char s[50]; scanf(&quot;%s&quot;, s); // 输入字符串 int len = strlen(s); // 求出长度 if(len&gt;=8 &amp;&amp; len&lt;16) &#123; // 满足长度要求 int A=0, B=0, C=0, D=0; // A,B,C,D分别代表4个条件判断 for(int j=0; j&lt;len; j++) &#123; char c = s[j]; if(c&gt;=65 &amp;&amp; c&lt;=90) A = 1; if(c&gt;=97 &amp;&amp; c&lt;=122) B = 1; if(c&gt;=48 &amp;&amp; c&lt;=57) C = 1; if(c==&#x27;~&#x27; || c==&#x27;!&#x27; || c==&#x27;@&#x27; || c==&#x27;#&#x27; || c==&#x27;$&#x27; || c==&#x27;%&#x27; || c==&#x27;^&#x27;) D = 1; &#125; if(A+B+C+D &gt;= 3) // A,B,C,D总和不小于3则满足 printf(&quot;YES\\n&quot;); else printf(&quot;NO\\n&quot;); &#125; else &#123; // 不满足长度要求 printf(&quot;NO\\n&quot;); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"阶乘尾数零的个数","slug":"阶乘尾数零的个数","date":"2021-03-20T02:16:38.000Z","updated":"2021-03-20T02:21:48.077Z","comments":true,"path":"514d0a0e69a7/","link":"","permalink":"https://ozzienicholas.gitee.io/514d0a0e69a7/","excerpt":"","text":"心情不好，水了好几个题了。。。 题面给定一个正整数 n，请计算 n 的阶乘 n!末尾所含有 “0” 的个数。例如： 5! = 120，其末尾所含有的 “0” 的个数为 1； 10! = 3628800，其末尾所含有的 “0” 的个数为 2； 20! = 2432902008176640000，其末尾所含有的 “0” 的个数为 4。 思路（一） 两个大数字相乘，都可以拆分成多个质数相乘，而质数相乘结果尾数为0的，只可能是 2*5。 所以，两个数相乘尾数0的个数其实就是依赖于2和5因子的个数。 例如，对于 10!，有 10! = 1*2*3*4*5*6*7*8*9*10，遍历 1-10 这10个数分别求其质因数，那么 10! = (2)*(3)*(2*2)*(5)*(2*3)*(7)*(2*2*2)*(3*3)*(2*5) 找到质因数为2和5的分别有多少个，对 10! 质因数分解后，质因数为2的有8个，质因数为5的有2个，那么所有的2和所有的5一共能组合为2个10，也就是尾数中0的个数为2 解题（一）12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;stdio.h&gt;int main() &#123; int cnt; // 输入阶乘数cnt scanf(&quot;%d&quot;, &amp;cnt); // 存在多少个&#123;2,5&#125;，就有多少个0 // 将num分解质因数，2的个数为cnt_2，5的个数为cnt_5 int cnt_2 = 0; int cnt_5 = 0; // 用ret遍历cnt，对每个ret都求其质因数 int ret; for(ret=1; ret&lt;=cnt; ret++) &#123; // 由于求质因数时要改变原数，所以要单独赋值 int num = ret; // 求质因数，并计数 int i; for(i=2; i&lt;=num; i++) &#123; while(i != num) &#123; if(num%i == 0) &#123; if(i == 2) cnt_2 += 1; if(i == 5) cnt_5 += 1; num = num/i; &#125; else &#123; break; &#125; &#125; &#125; if(num == 2) cnt_2 += 1; if(num == 5) cnt_5 += 1; &#125; // 取较小的作为10的个数 if(cnt_2 &lt; cnt_5) printf(&quot;阶乘尾数中0的个数为：%d\\n&quot;, cnt_2); else printf(&quot;阶乘尾数中0的个数为：%d\\n&quot;, cnt_5); return 0;&#125; 思路（二） 因为每两个连续数字就会有一个因子2，个数非常充足，所以此时只需要关心5因子的个数就行了。 我们只需要循环每个阶乘数，并判断该数含有多少个因子5即可。 解题（二）12345678910111213141516#include&lt;stdio.h&gt;int main() &#123; int num; // 输入阶乘数num scanf(&quot;%d&quot;, &amp;num); int ret = 0; // 最后的结果初始化为0 int i; for(i=5; i&lt;=num; i+=5) &#123; // 以5为单位循环num，计算每个i中含有因子5的个数 int j = i; // i要变化，所以赋值给j while(j%5 == 0) &#123; ret += 1; // 每含有一个5，结果都+1 j /= 5; &#125; &#125; printf(&quot;阶乘尾数中0的个数为：%d\\n&quot;, ret); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"模拟原生态的前端请求","slug":"模拟原生态的前端请求","date":"2021-03-20T02:11:56.000Z","updated":"2021-03-20T04:32:11.048Z","comments":true,"path":"75a17178196e/","link":"","permalink":"https://ozzienicholas.gitee.io/75a17178196e/","excerpt":"","text":"如果想模拟原生态的前端请求，还有跨域问题，那就最好不用一些工具，因为那不是客户端请求了，就用浏览器。 在浏览器的 Console 里面的上下文都是跟浏览器共享的，比如百度有使用 jquery 来进行网络请求，可以尝试一下以下代码： 1$.get(&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;, resp =&gt; console.log(resp)); 结果如下： 打开浏览器控制台，打开 Sources -&gt; Snippets -&gt; New snippet，新建一个用来测试的脚本： 我新建了一个 test 的测试脚本，内容如下： 123456789101112131415161718192021222324function getReq(url) &#123; return new Promise(function (resolve) &#123; $.get(url, function (resp) &#123; resolve(resp); &#125;); &#125;);&#125;function postReq(url) &#123; return new Promise(function (resolve) &#123; $.post(url, function (resp) &#123; resolve(resp); &#125;); &#125;);&#125;// 主函数，在这里封装你的接口测试方法var main = async () =&gt; &#123; let resp = await getReq(&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;); console.log(&#x27;resp&#x27;, resp);&#125;// 执行测试main(); 按下 Ctrl+Enter，接口返回的情况结果如下： 如果接口有跨域限制，代码如下： 123456789101112131415161718192021222324252627function getReq(url) &#123; return new Promise(function (resolve) &#123; $.get(url, function (resp) &#123; resolve(resp); &#125;); &#125;);&#125;function postReq(url) &#123; return new Promise(function (resolve) &#123; $.post(url, function (resp) &#123; resolve(resp); &#125;); &#125;);&#125;// 主函数，在这里封装你的接口测试方法var main = async () =&gt; &#123; let resp = await getReq(&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;); console.log(&#x27;resp&#x27;, resp); // 请求有跨域限制的接口 resp = await getReq(&#x27;https://www.bilibili.com/&#x27;); console.log(&#x27;resp&#x27;, resp);&#125;// 执行测试main(); 接口返回情况结果如下： 最后，再封装一些方法，用 github 把测试脚本管理起来，这就是你的专属前端测试框架了。 其他了解： 在浏览器的调试器控制台手写 fetch：使用 Fetch","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"随笔漫谈","slug":"前端/随笔漫谈","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E9%9A%8F%E7%AC%94%E6%BC%AB%E8%B0%88/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"细解浏览器缓存","slug":"细解浏览器缓存","date":"2021-03-20T01:59:42.000Z","updated":"2021-03-20T04:32:17.909Z","comments":true,"path":"1d7ac5a99202/","link":"","permalink":"https://ozzienicholas.gitee.io/1d7ac5a99202/","excerpt":"","text":"前言 在开发中，我们总会提到 “合理设置缓存”，缓存机制非常普遍，有客户端缓存、服务器缓存、代理服务器缓存等等，在 HTTP 中，具有缓存功能的是浏览器缓存。 HTTP 缓存是作为web 性能优化的重要手段。 HTML5 引入了应用程序缓存，在没有网络的情况下也能进行访问，同时，还引入了 storage 本地存储，这些都属于应用缓存，本文主要是和浏览器缓存相关的，也可以说是 HTTP 缓存。 什么是浏览器缓存？ MDN 的解释是： A browser cache holds all documents downloaded via HTTP by the user … without requiring an additional trip to the server. 意思就是，浏览器缓存保存着用户通过 HTTP 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求，简单说，就是在你访问过某网站之后，这个站点的文字、图片等所有资源都被下载到本地了，下次再党文该网站时，会判断是否满足缓存条件，如果满足，则不用再花时间去等待资源的获取了。 浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的所以在分析浏览器缓存机制之前，我们待会儿得先简单介绍一下 HTTP 报文。 HTTP 报文 HTTP 报文分两种： HTTP 请求（Resquest）报文，报文格式为：请求行 — HTTP 头（通用信息头、请求头、实体头）— 请求报文主体（只有 POST 才有报文主体），如图： HTTP 响应（Response）报文，报文格式为：状态行 — HTTP头（通用信息头、请求头、实体头）— 响应报文主体，如图： 注意： 通用信息头指的是请求和响应报文都支持的头域，分别为：Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via 实体头则是实体信息的实体头域，分别为：Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header 之前是为了方别理解，而将通用信息头、响应头/请求头、实体头都归为了 HTTP 头 缓存的优点 减少了冗余的数据传递，节省宽带流量 减少了服务器的负担，大大提高了网站性能 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因 缓存过程分析 浏览器与服务器通信的方式是应答模式，即为：浏览器发起 HTTP 请求 — 服务器响应该请求，那么，浏览器第一次向服务器发起该请求后拿到结果，会根据响应报文中的 HTTP 头的缓存标识，决定是否缓存结果，若是，则将请求结果和缓存标识存入浏览器缓存中，如图： 由上图可知： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，下面开始理解浏览器缓存的使用规则 缓存的规则缓存的分类 一般来说，浏览器缓存可以分为： 强缓存 协商缓存（对比缓存） 浏览器在加载资源时，会先判断是否命中强缓存，再验证是否命中协商缓存 强缓存 浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中，则直接使用缓存中的资源，而不会再向服务器发送请求，如图： 从图中可以看出，强缓存的一般流程是： 查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则 如果满足规则，就返回缓存的数据 如果不满足规则，就向服务器发送请求 服务器返回数据 将新数据存入缓存 接下来我们主要就关注 Expire 和 Cache-control 这两个字段 Expire： Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，当客户端的时间小于 Expires 的值时，直接使用缓存结果。 再看看 MDN 中如何解释这个字段： The Expires header contains the date/time after which the response is considered stale. 这个字段包含了一个时间，过了这个时间，响应将会失效。也就是说，Expire 这个字段表示缓存到期时间，我们来打开一个网站并查看 Response Header 看看这个字段： 1Expires:Fri, 27 Oct 2017 07:55:30 GMT 可能在你查看这的时候发现时间都已经是过去了 ~，GMT 表示的是格林威治时间，和北京时间相差8小时，上面的这个时间表示的是 2017年10月27日15:55:30。 通过设置 Expire 来设置缓存有一个缺点：这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。 Expires 是 HTTP/1.0的字段，但是现在浏览器默认使用的是 HTTP/1.1，那么在HTTP/1.1 中网页缓存还是否由 Expires 控制？ 到了 HTTP/1.1，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。接下来我们开始认识 Cache-Control。 Cache-Control： 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。 承接上面的例子，既然不能设置绝对时间，那就设置相对时间吧 在 HTTP/1.1 中，增加了一个字段 Cache-Control ，它包含一个 max-age 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间： 1Cache-Control:max-age&#x3D;600 这个表示的就是最大有效时间是 600s ，对的，它的单位是秒。 Cache-Control 除了 max-age 属性之外还有一些属性： no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。 no-store：禁止使用缓存，每一次都要重新请求数据。 public：默认设置。 private：不能被多用户共享。 接下来，我们直接看一个例子，如下： 由上面的例子我们可以知道： HTTP 响应报文中 Expires 的时间值，是一个绝对值 HTTP响应报文中 Cache-Control 为 max-age=600，是相对值 由于 Cache-Control 的优先级比 Expires，那么直接根据 Cache-Control 的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于Expires 是更好的选择，所以同时存在时，只有 Cache-Control生效。了解强制缓存的过程后，我们拓展性的思考一下：浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ 我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size值则代表该缓存存放的位置，分别为 from memory cache 和 from disk cache： 那么 from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？ from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk 对于上个结论，我们需要了解内存缓存（from memory cache）和硬盘缓存（from disk cache），如下: 内存缓存（from memory cache）：内存缓存具有两个特点，分别是快速读取和时效性。 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存（from disk cache）：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache） 现在基本上都会同时设置 Expire 和 Cache-Control ，Cache-Control 的优先级别更高。 协商缓存 当强缓存没有命中的时，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304，如下： 协商缓存失效，返回200和请求结果结果，如下： 协商缓存整体流程图： 从图中可以看出，协商缓存一般是这样一个流程： 把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新 如果资源未更新，请求响应返回的http状态为 304 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存 如果资源已经更新，返回新的数据 将新数据存入缓存 Last-Modified / If-Modified-Since： Last-Modified 是浏览器第一次请求资源的时候，服务器返回的 header 上会带有一个 Last-Modified 字段，服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下： 同样的，这是一个 GMT 的绝对时间。 If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下： 当然，这个方法也是有缺点的： 最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化； 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。 所以，后来又引入一个 Etag Etag： Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下： If-None-Matchc是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下： 它一般是由文件内容 hash 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 Etag发生改变。 同样地，在浏览器第一次请求资源时，服务器会返回一个 Etag 标识。当再次请求该资源时， 会通过 If-no-match 字段将 Etag 发送回服务器，然后服务器进行比较，如果相等，则返回 304 表示未修改。 Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304。 Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since，同时存在则只有 Etag / If-None-Match 生效。 总结 强制缓存优先于协商缓存进行，若强制缓存（Expires和Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match）， 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存 总结的主要过程如下： 即，当浏览器再次访问一个已经访问过的资源时，它会这样做： 看看是否命中强缓存，如果命中，就直接使用缓存了； 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存； 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存； 否则，返回最新的资源。 用户对缓存的影响若是问到用户进行一些操作的时候，对缓存是有什么影响的，答案如下： 用户操作 Expires/Cache-Control Last-Modified/Etag 地址栏回车 √ √ 页面链接跳转 √ √ 新开窗口 √ √ 前进回退 √ √ F5 刷新 × √ Ctrl+F5 强制刷新 × × 不同刷新的请求执行过程 URL（最快）：浏览器地址栏中写入URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。 F5：告诉浏览器去服务器看看这个文件是否有过期了。于是浏览器就发送一个请求带上 If-Modify-since。 Ctrl+F5：让浏览器先把缓存中的文件删了，然后再去服务器请求个完整的资源文件下来，于是客户端就完成了强行更新的操作。","categories":[{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"随笔漫谈","slug":"前端/随笔漫谈","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E9%9A%8F%E7%AC%94%E6%BC%AB%E8%B0%88/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]},{"title":"数据库（二）：数据库的设计与操作","slug":"数据库（二）：数据库的设计与操作","date":"2021-03-20T01:54:41.000Z","updated":"2021-03-20T01:54:58.483Z","comments":true,"path":"7635befe4d5a/","link":"","permalink":"https://ozzienicholas.gitee.io/7635befe4d5a/","excerpt":"","text":"数据库设计概述 在实际项目开发中，如果系统的数据存储量较大，设计的表较多，表与表之间的关系比较复杂，就必须先规范的设计数据库，然后再创建数据库、表等工作。 糟糕的数据库设计表现在以下几个方面： 访问数据效率低下 存在大量的数据冗余，浪费存储空间 更新和检索数据时会出现许多问题 良好的数据库设计表现在以下几方面： 访问效率高 减少数据冗余，节省存储空间，便于进一步扩展 可以使应用程序的开发变得更容易 数据库设计的基本步骤在了解数据库设计步骤之前，我们先来了解一下软件项目的开发周期，如下： 需求分析： 需求分析是数据库设计的第一步，是最困难、最耗费时间的一步，也是整个设计过程的基础。 本阶段的主要任务是对现实世界中要处理的对象（公司、部门及企业，也可以理解成客户）进行详细调查，然后通过分析，逐步明确客户/用户对系统的需求，包括数据需求和业务处理需求。 需求分析是否做的充分和准确，直接决定了在其上构建数据库大厦的速度与质量。需求分析做的不好，会导致整个数据库设计返工重做。 概要设计： 概要设计是数据库设计的关键，通过综合、归纳与抽象用户需求，形成一个具体 DBMS 的概念模型，也就是绘制数据库的 E-R 图。 E-R 图主要用于在项目团队内部，设计人员和客户之间进行沟通，确认需求信息的正确性和完整性。 逻辑设计/详细设计： 将 E-R 图转换为多张表，进行逻辑设计，确认各表的主外键，并应用数据库设计的三大范式进行审核，对其优化。 在这阶段，E-R 图非常重要。所以要学会根据各个实体定义的属性来画出总体的 E-R 图。 确定 E-R 图后，根据项目的技术实现，团队开发能力及项目的成本预算，选择具体的数据库（如 MySQL 或 Oracle 等）进行物理实现。 数据库实施：运用 DBMS 提供的数据语言（例如 SQL）、工具及宿主语言（例如 Java），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。 数据库运行和维护阶段：数据库应用系统经过试运行后即可投入正式运行。在运行过程中必须不断地对其进行评价、调整与修改。 SQL 语句的基本书写规则 SQL 语句要以分号 ; 结尾 在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。 大小写问题：（不区分大小写的意思是，全部大写或者全部小写或者大小写混合都是一样的） SQL 不区分关键字的大小写（例如，SELECT 等价于 select 等价于 SeLecT）； SQL 不区分表名和列名的大小写； SQL 区分插入到表中的数据的大小写。 常数的书写方式是固定的：（在 SQL 语句中直接书写的字符串、日期或者数字等称为常数） SQL 语句中含有字符串的时候，需要像 ‘abc’ 这样，使用英文单引号&#39;将字符串括起来，用来标识这是一个字符串。 SQL 语句中含有日期的时候，同样需要使用英文单引号将其括起来。日期的格式有很多种（’26 Jan 2010’ 或者’10/01/26’ 等）。 在 SQL 语句中书写数字的时候，不需要使用任何符号标识，直接写成 1000 这样的数字即可。 列名不是字符串，不能使用单引号，在 MySQL 中可以用倒引号`把表名和列名括起来。 MySql 的注释单行注释 方式一：# 1# 这是单行注释内容 方式二：-- 1-- 这是单行注释内容 多行注释唯一方式：/**/ 1234&#x2F;* 第一行注释内容 第二行注释内容*&#x2F; 数据库的操作查看数据库（show database …）语法： 1show databases [like &#39;数据库名&#39;]; 案例： 查看全部的数据库： 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 可以发现，在上面的列表中有 6 个数据库，它们都是安装 MySQL 时系统自动创建的，其各自功能如下： information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。 mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。 performance_schema：主要用于收集数据库服务器性能参数。 sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。 使用 like 从句： 1234567891011121314151617181920212223242526272829303132333435363738# 创建 test_db、db_test、db_test_db 三个数据库mysql&gt; create database test_db; mysql&gt; create database db_test; mysql&gt; create database db_test_db; # 使用 like 从句，查看与 test_db 完全匹配的数据库mysql&gt; show databases like &#39;test_db&#39;;+--------------------+ | Database (test_db) | +--------------------+ | test_db | +--------------------+ # 用 like 从句，查看名字中包含 test 的数据库mysql&gt; show databases like &#39;%test%&#39;; +-------------------+ | Database (%test%) | +-------------------+ | db_test | | db_test_db | | test_db | +-------------------+ # 用 like 从句，查看名字以 test 开头的数据库mysql&gt; show databases like &#39;test%&#39;; +------------------+ | Database (test%) | +------------------+ | test_db | +------------------+ # 用 like 从句，查看名字以 test 结尾的数据库mysql&gt; show databases like &#39;%test&#39;; +------------------+ | Database (%test) | +------------------+ | db_test | +------------------+ 创建数据库（create database …）语法： 123create database [if not exists] &lt;数据库名&gt;[[default] character set &lt;字符集名&gt;][[default] collate &lt;校对规则名&gt;]; [if not exists]：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [default] character set：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。 [default] collate：指定字符集的默认校对规则。 案例： 使用 if not exists： 123456789mysql&gt; create database test;Query OK, 1 row affected (0.20 sec)# 直接创建会报错mysql&gt; create database test;ERROR 1007 (HY000): Can&#39;t create database &#39;test&#39;; database existsmysql&gt; create database if not exists test;Query OK, 1 row affected, 1 warning (0.11 sec) 指定字符集： 123mysql&gt; create database test_db -&gt; default character set utf8;Query OK, 1 row affected, 1 warning (0.13 sec) 用 show create database &#39;数据库名&#39; 来查看该数据库的定义声明 1234567# 查看该数据库的定义声明mysql&gt; show create database test_db; +----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+------------------------------------------------------------------+ 注意： MySQL 的字符集（character）和校对规则（collate）是两个不同的概念。字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。 MySQL 不允许在同一系统下创建两个相同名称的数据库。 修改数据库（alter database …）语法： 123alter database [数据库名] &#123;[default] character set &lt;字符集名&gt; |[default] collate &lt;校对规则名&gt;&#125; alter database 用于更改数据库的全局特性。 使用 alter database 需要获得数据库 alter 权限。 数据库名称可以忽略，此时语句对应于默认数据库。 character set 子句用于更改默认的数据库字符集。 案例： 查看 test_db 的定义声明： 123456mysql&gt; show create database test_db;+----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+------------------------------------------------------------------+ 将数据库 test_db 的指定字符集修改为 gb2312： 123456789mysql&gt; alter database test_db -&gt; default character set gb2312;Query OK, 1 row affected (0.23 sec)mysql&gt; show create database test_db;+----------+--------------------------------------------------------------------+| Database | Create Database |+----------+--------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gb2312 *&#x2F; | 删除数据库（drop database ….）语法： 1drop database [if exists] &lt;数据库名&gt;; &lt;数据库名&gt;：指定要删除的数据库名。 if exists：用于防止当数据库不存在时发生错误。 drop database：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 drop database，需要获得数据库 drop 权限。 案例： 删除数据库 test： 12mysql&gt; drop database test;Query OK, 0 rows affected (0.06 sec) 再次删除时，会报错，之后使用 if exists 从句，可以防止系统报此类错误： 12345mysql&gt; drop database test;ERROR 1008 (HY000): Can&#39;t drop database &#39;test&#39;; database doesn&#39;t existmysql&gt; drop database if exists test;Query OK, 0 rows affected, 1 warning (0.02 sec) 注意： MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。 使用 drop database 命令时要非常谨慎，在执行该命令后，MySQL 不会给出任何提示确认信息。drop database 删除数据库后，数据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。因此最好在删除数据库之前先将数据库进行备份 选择数据库（ues database …）语法： 1use &lt;数据库名&gt;; 注意： 在操作数据库之前就必须要确定是哪一个数据库。 在 MySQL 中，USE 语句用来完成一个数据库到另一个数据库的跳转。 当用 create database 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。 该语句可以通知 MySQL 把&lt;数据库名&gt;所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。 只有使用 USE 语句来指定某个数据库作为当前数据库之后，才能对该数据库及其存储的数据对象执行操作。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库（三）：mysql命令行基本操作","slug":"数据库（三）：MySQL 命令行基本操作","date":"2021-03-20T01:50:59.000Z","updated":"2021-03-20T01:53:28.166Z","comments":true,"path":"6ec4d66625a2/","link":"","permalink":"https://ozzienicholas.gitee.io/6ec4d66625a2/","excerpt":"","text":"前序窗口启动 mysql 服务1net start mysql 登录1mysql -u root -p 导出数据库1mysqldump -u 用户名 -p –default-character-set&#x3D;latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1) 导出一个表1mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 例如： 1mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql 导入数据库 常用 source 命令： 123mysql -u root -pmysql&gt;use 数据库mysql&gt;source x.sql # 后面参数为脚本文件(如这里用到的.sql) 使用 mysqldump 命令： 1mysqldump -u 用户名 -p 密码 &lt; x.sql 使用 mysql 命令： 1mysql -u 用户名 -p -D 密码 &lt; x.sql 建议使用 Navicat 工具操作 mysql SQL 语句的分类 数据定义语言（DDL）：create、drop、alter 数据操作语言（DML）：insert、delete、update、truncate 数据查询语言（DQL）：select、show 数据控制语言：grant、revoke 操作数据库查看所有数据库：1SHOW DATABASES; 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 创建活跃连接：1SHOW PROCESSLIST; 123456789mysql&gt; show processlist;+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+| 4 | event_scheduler | localhost | NULL | Daemon | 25324 | Waiting on empty queue | NULL || 14 | root | localhost:52760 | NULL | Query | 0 | starting | show processlist |+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+ 创建数据库：1CREATE DATABASE &lt;数据库名&gt;; 123456789101112131415# 创建一个名为 ozzie 的数据库mysql&gt; create database ozzie;Query OK, 1 row affected (0.44 sec)# 查看所有的数据库（此时应该多出了 ozzie）mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || ozzie || performance_schema || sys |+--------------------+ 查看数据库的默认字符集：1SHOW CREATE DATABASE &lt;数据库名&gt;; 123456mysql&gt; show create database ozzie;+----------+----------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------+| ozzie | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+----------------------------------------------------------------+ 选择数据库：1USE 数据库名; 12mysql&gt; use ozzie;Database changed 查看当前使用的数据库：1SELECT DATABASES(); 123456mysql&gt; select database();+------------+| database() |+------------+| ozzie |+------------+ 修改数据库：1ALTER DATABASE &lt;数据库名&gt; DEFAULT CHARACTER SET GBK; 12345678910mysql&gt; alter database ozzie default character set gbk; Query OK, 1 row affected (0.47 sec) # 此时字符集由 utf8 变成了 gbkmysql&gt; show create database ozzie; +----------+---------------------------------------------------------------+| Database | Create Database |+----------+---------------------------------------------------------------+| ozzie | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gbk *&#x2F; |+----------+---------------------------------------------------------------+ 删除数据库：1DROP DATABASE 数据库名; 123456789101112mysql&gt; drop database ozzie;Query OK, 0 rows affected (0.19 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 操作表创建表1CREATE TABLE 数据表名(&lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 12345678910111213141516171819202122232425262728293031323334353637383940# 查看所有数据库mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql || performance_schema | | sys | +--------------------+ # 创建一个名为 ozzie 的数据库mysql&gt; CREATE DATABASE ozzie;Query OK, 1 row affected (0.23 sec) # 查看数据库（此时会多出一个 ozzie）mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | ozzie | | performance_schema | | sys | +--------------------+ # 使用 ozziemysql&gt; USE ozzie;Database changed# 创建一个名为 student 的表mysql&gt; CREATE TABLE student -&gt; ( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; sex char(4) not null default &#39;男&#39;, -&gt; degree double(16, 2) -&gt; );Query OK, 0 rows affected (1.77 sec) 查看表结构 方式一： 1DESC &lt;表名&gt;; 123456789mysql&gt; DESC student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+ 方式二： 1SHOW COLUMNS from &lt;表名&gt;; 123456789mysql&gt; SHOW COLUMNS FROM student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+ 查看所有表：1SHOW TABLES; 123456mysql&gt; SHOW TABLES;+-----------------+| Tables_in_ozzie |+-----------------+| student |+-----------------+ 插入数据：1INSERT INTO &lt;表名&gt; [(&lt;字段名&gt;[,..&lt;字段名n&gt;])] values (值)[,(值n)] 现在向表中插入两条记录，这两条记录分别表示： id 为 1，name 为 ‘Tom’，sex 为 ‘男’，degree 为 99.45 id 为 2，name 为 ‘Alice’，sex 为 ‘女’，degree 为 82.64 12345mysql&gt; insert into student values &gt; (1, &#39;Tom&#39;, &#39;男&#39;, 99.45), &gt; (2, &#39;Alice&#39;, &#39;女&#39;, 82.64);Query OK, 2 rows affected (0.91 sec)Records: 2 Duplicates: 0 Warnings: 0 查询数据：1SELECT &lt;字段, 字段, ...&gt; FROM &lt;表名&gt; WHERE &lt;表达式&gt;; 查看前两行的所有数据： 1234567mysql&gt; select * from student order by id limit 0,2;+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 1 | Tom | 男 | 99.45 || 2 | Alice | 女 | 82.64 |+----+-------+-----+--------+ 查看所有的 name： 1234567mysql&gt; select name from student;+-------+| name |+-------+| Tom || Alice |+-------+ 查看前两行的 degree： 1234567mysql&gt; select degree from student order by id limit 0,2;+--------+ | degree | +--------+ | 99.45 | | 82.64 | +--------+ 查看 id 为 1 的 sex： 123456mysql&gt; select sex from student where id&#x3D;1;+-----+| sex |+-----+| 男 |+-----+ 删除数据：1DELETE &lt;字段, 字段, ...&gt; FROM &lt;表达式&gt;; 删除 id 为 1 的记录： 12345678910111213141516171819202122232425262728# 先查看所有数据mysql&gt; select * from student+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 1 | Tom | 男 | 99.45 || 2 | Alice] | 女 | 82.64 |+----+-------+-----+--------+# 删除 id 为 1 的记录mysql&gt; delete from student where id&#x3D;1;Query OK, 1 row affected (0.79 sec)# 再次查看所有数据（此时应该只剩下 id&#x3D;2 的记录）mysql&gt; select * from student;+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 2 | Alice | 女 | 82.64 |+----+-------+-----+--------+# 删除 name 为 Alice 的记录mysql&gt; delete from student where name&#x3D;&#39;Alice&#39;;Query OK, 1 row affected (0.47 sec)# 再次查看所有数据（此时应该没有记录）mysql&gt; select * from student;Empty set (0.00 sec) 在表中增加字段：1ALTER TABLE &lt;表名&gt; add &lt;字段&gt; &lt;类型&gt; &lt;其他&gt;; 123456789101112131415161718192021222324252627# 查看表中原先字段mysql&gt; desc student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+# 增加一条叫做 birthday 的字段，类型为 date，默认值为 &#39;2000-01-01&#39;mysql&gt; alter table student add birthday date default &#39;2000-01-01&#39;;Query OK, 0 rows affected (1.20 sec)Records: 0 Duplicates: 0 Warnings: 0# 现在多了一条 dirthday 字段mysql&gt; desc student;+----------+--------------+------+-----+------------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+------------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | || degree | double(16,2) | YES | | NULL | || birthday | date | YES | | 2000-01-01 | |+----------+--------------+------+-----+------------+----------------+ 删除表：1DROP TABLE &lt;表名&gt;; 12345mysql&gt; drop table student;Query OK, 0 rows affected (1.15 sec)mysql&gt; show tables;Empty set (0.00 sec) 更改表名：1RENAME TABLE &lt;原表名&gt; to &lt;新表名&gt;； 12345678910mysql&gt; rename table student to new_student;Query OK, 0 rows affected (0.70 sec)# 由 student 变为了 new_studentmysql&gt; show tables;+-----------------+| Tables_in_ozzie |+-----------------+| new_student |+-----------------+ 更改字段名字：1ALTER TABLE &lt;表名&gt; CHANGE &lt;字段名&gt; &lt;字段新名&gt; &lt;字段类型&gt;; 12345678910111213141516# 把名为 id 的字段改名称为 studentIdmysql&gt; alter table new_student change id studentId int(4);Query OK, 0 rows affected (0.79 sec)Records: 0 Duplicates: 0 Warnings: 0# 此时 id 应改为了 studentIdmysql&gt; desc new_student;+-----------+--------------+------+-----+------------+-------+| Field | Type | Null | Key | Default | Extra |+-----------+--------------+------+-----+------------+-------+| studentId | int(4) | NO | PRI | NULL | || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | || degree | double(16,2) | YES | | NULL | || birthday | date | YES | | 2000-01-01 | |+-----------+--------------+------+-----+------------+-------+","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库（一）：数据库入门了解","slug":"数据库（一）：数据库入门了解","date":"2021-03-20T01:48:42.000Z","updated":"2021-03-20T01:50:09.505Z","comments":true,"path":"0c221b96c236/","link":"","permalink":"https://ozzienicholas.gitee.io/0c221b96c236/","excerpt":"","text":"了解数据库： 数据库（DataBase）：数据库是一个以某种有组织的方式存储的数据集合，并不能用数据库来代表数据库软件，数据库软件应称为 DBMS（数据库管理系统），数据库 是通过DBMS创建和操纵的容器，简单来说，你使用的是DBMS，它替你访问数据库。 表（Table）：某种特定类型数据的结构化清单。每个表的名字（表名）在同一数据库中是唯一的，但在不同的数据库中可以使用相同的表名。 模式（Schema）：关于数据库和表的布局及特性的信息。有时，模式用作数据库的同义词，但模式的含义通常在上下文中并不是很清晰。 列（Column）：表由列组成，一列就是表中的一个字段。数据库中的每个列都有相应的数据类型，列可以存储的数据种类是有规定的。 行（Row）：表中的数据是按行存储的，一行就是表中的一个记录。所保存的每个记录存储在自己的行内。 如果将表想象为网格，网格中垂直的列为表列，水平行为表行。 可以将 “行” 称为 数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，“行” 才是正确的术语。 主键（Primary Key）：一列（或一组列），其值能够唯一区分表中每个行，唯一标识表中每行的这个列（或这组列）称为主键。例如用每个人的身份证号来标识每个人。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许 NULL 值）。 主键通常定义在表的一列上，但也可以使用多个列（组列）作为主键。 一些关于主键的约定： 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键）。 DBMS（Data Base Management System，数据库管理系统）：是位于用户与操作系统之间的一层数据管理软件，是数据库系统的核心。数据的所有存储、检索、管理和处理实际上都是由数据库软件 —— DBMS 完成的。 DBMS 可分为两类： 基于共享文件系统的DBMS：例如 Microsoft Access 和 FileMaker，用于桌面用途，通常不用于高端或更关键的应用。 基于客户机—服务器的DBMS：例如 MySQL、Oracle 以及 Microsoft SQL Server 等数据库。客户机—服务器 应用分为两个不同的部分： 客户机是与用户打交道的软件，客户机软件通过网络把用户的请求提交给服务器软件。 服务器部分是负责所有数据访问和处理的一个软件，这个软件运行在 “数据库服务器” 上面，与数据文件打交道的只有服务器软件，关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。 客户机和服务器软件可能安装在两台计算 机或一台计算机上。不管它们在不在相同的计算机上，为进行 所有数据库交互，客户机软件都要与服务器软件进行通信。 DBA（Data Base Administrator，数据库用户）：是从事管理和维护数据库管理系统的相关工作人员。 DBS（Data Base System，数据库系统）：采用了数据库技术的计算机系统。 数据库的大致分类 数据库有两种类型，分别是关系型数据库和非关系型数据库。 关系型数据库：关系型数据库是建立在关系模型基础上的数据库，是由多张能互相连接的表组成的数据库。 优点： 都使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 数据存储在磁盘中，比较安全。 缺点： 读写性能比较差，不能满足海量数据的高效率读写。 不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。 固定的表结构，灵活度较低。 常见的关系型数据库：Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL。 非关系型数据库：非关系型数据库又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 优点： 缺点： 常见的非关系型数据库：Neo4j、MongoDB、Redis、Memcached、MemcacheDB 和 HBase 等。 了解 SQL SQL（Structured Query Language）：是结构化查询语言，是一种专门用来与数据库通信的语言，用于存取数据以及查询、更新和管理关系数据库系统。 SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS（数据管理系统）都支持 SQL，所以，学习此语言使你几乎能与所有数据库打交道。 SQL不是一种专利语言，而且存在一个标准委员会，但是，任意两个 DBMS 实现的 SQL 都不完全相同，也就是，不同的 DBMS 对应的 SQL 语法不是完全可移植的。 与其他程序设计语言（如 C语言、Java 等）不同的是，SQL 由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。 SQL 的优点： 一体化：SQL 集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。 使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。 非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”，存储路径的选择和操作的执行由数据库管理系统自动完成。 语言简洁、语法简单：该语言的语句都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL 包含以下 4 部分： 数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令： SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 实例如下： 上述实例的吓你详细过程如下： 下面的 SQL 语句声明创建一个名叫 students 的表： 1234567CREATE TABLE students ( student_id INT UNSIGNED, name VARCHAR(30), sex CHAR(1), birth DATE, PRIMARY KEY(student_id)); 该表包含 4 个字段，分别为 student_id、name、sex、birth，其中 student_id 定义为表的主键。 现在只是定义了一张表格，但并没有任何数据，接下来这条 SQL 声明语句，将在 students 表中插入一条数据记录： 12INSERT INTO students (student_id, name, sex, birth)VALUES (201803666, &#39;洛伊&#39;, &#39;1&#39;, &#39;2018-09-03&#39;) 上述 SQL 语句执行之后，students 表中就会增加一行新记录，在该记录中： student_id 字段的值为：201803666 name 字段的值为：”洛伊” sex 字段的值为：”1” birth 字段值为：”2018-09-03” 再使用 SELECT 查询语句获取刚才插入的数据，如下： 1234567SELECT name FROM students WHERE student_id&#x3D;201803666;+------+| name |+------+| 洛伊 |+------+1 row in set (0.00 sec) 标准 SQL 是指符合国际标准的 SQL，而非某个数据库厂商的 SQL 语法（如：Microsoft SQL Server 的 T-SQL，Oracle 的 PL/SQL，MySQL）。标准 SQL 可以在任何数据库中使用，而数据库厂商的 SQL 只适合它们对应的数据库，如 T-SQL 只适合 Microsoft SQL Server。 了解 MySQL MySQL 是一种 DBMS，它是一种数据库软件。 对于 MySQL： 客户机可以是 MySQL 提供的工具、脚本语言（如 Perl）、Web应用开发语言（如 ASP、ColdFusion、JSP 和 PHP）、程序设计语言（如 C、C++、Java）等 服务器软件为 MySQL DBMS，你可以在本地安装的副本上运行， 也可以连接到运行在你具有访问权的远程服务器上的一个副本。 MySQL 是一个免费开源的关系型数据库管理系统（但也不意味着该数据库是完全免费的），适合中小型软件。 MySQL 是开放源代码的数据库。 MySQL 的跨平台性：不仅可以在 Windows 系列的操作系统上运行，还可以在 UNIX、Linux 和 Mac OS 等操作系统上运行。在这一方面，SQL Server 数据库虽然也是一款很优秀的商业数据库，但它只能在 Windows 系列的操作系统上运行。因此，MySQL 数据库的跨平台性是一个很大的优势。 MySQL 是一个真正的多用户、 多线程 SQL 数据库服务器。它能够快速、有效和安全的处理大量的数据。相对于 Oracle 等数据库来说，MySQL 的使用是非常简单的。MySQL 主要目标是快速、健壮和易用。 MySQL 与常用的主流数据库 Oracle、SQL Server 相比，主要特点就是免费，并且在任何平台上都能使用，占用的空间相对较小。但是，MySQL 也有一些不足，比如对于大型项目来说，MySQL 的容量和安全性就略逊于 Oracle 数据库。 MySQL 的适用场景： Web 网站系统： 因为 MySQL 数据库的安装配置都非常简单，使用过程中的维护也不像很多大型商业数据库管理系统那么复杂，而且性能出色。还有一个非常重要的原因就是 MySQL 是开放源代码的，完全可以免费使用。 Web 网站开发者也是 MySQL 最大的客户群。 日志记录系统： MySQL 数据库的插入和查询性能都非常的高效，如果设计的好，在使用 MyISAM 存储引擎的时候，两者可以做到互不锁定，达到很高的并发性能。所以，对需要大量的插入和查询日志记录的系统来说，MySQL 是非常不错的选择，比如处理用户的登录日志，操作日志等。 数据仓库系统： 通过 MySQL 的简单复制功能，可以很好的将数据从一台主机复制到另外一台 ，不仅仅在局域网内可以复制，在广域网同样可以。 嵌入式系统： MySQL 在资源的使用方面的伸缩性非常大，可以在资源非常充裕的环境下运行，也可以在资源非常少的环境下正常运行。它对于嵌入式环境来说，是一种非常合适的数据库系统，而且 MySQL 有专门针对于嵌入式环境的版本。 学习 MySQL 必须掌握的知识点如下，也是我准备学习的知识： MySQL 的下载安装。熟悉 MySQL 的配置文件，目录结构。 MySQL 服务器的启动，登录与退出。 MySQL 常用命令及语法规范。 MySQL 常用命令及语法规范。 MySQL 数据类型与数据表的操作。例如，数据表的增删改查、单表查询、多表查询等。 MySQL 运算符和函数，例如，日期函数，时间函数，信息函数，聚合函数，加密函数，自定义函数等。 MySQL 存储过程，存储过程的调用。 MySQL 各个存储引擎的特点，如何选择合适的存储引擎等。 MySQL 事务的概念和使用等。 MySQL 权限管理和用户管理等。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"系统学习计算机网络（五）：TCP详解","slug":"系统学习计算机网络（五）：TCP详解","date":"2021-03-20T01:46:50.000Z","updated":"2021-03-20T01:48:00.744Z","comments":true,"path":"94895040cb03/","link":"","permalink":"https://ozzienicholas.gitee.io/94895040cb03/","excerpt":"","text":"传输控制协议 TCP 概述TCP 最主要的特点 TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。 TCP 是面向连接的运输层协议。 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。 TCP 是面向字节流的：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。 TCP 的连接 TCP 把连接作为最基本的抽象。 每一条 TCP 连接有两个端点。 TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。 端口号拼接到 IP 地址即构成了套接字。 套接字： TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。 同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。 Socket 有多种不同的意思： 应用编程接口 API 称为 socket API, 简称为 socket。 socket API 中使用的一个函数名也叫作 socket。 调用 socket 函数的端点称为 socket。 调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。 在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。 可靠传输的工作原理停止等待协议 IP 网络所提供的是不可靠的传输： “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 全双工通信的双方既是发送方也是接收方。 无差错情况： 出现差错： 在接收方 B 会出现两种情况： B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。 M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。 在这两种情况下，B 都不会发送任何信息。 但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。 出现差错的解决办法： A如何知道 B 是否正确收到了 M1 呢？ 解决方法：超时重传 A 为每一个已发送的分组都设置了一个超时计时器。 A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。 若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组 若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？ 解决方法：编号 A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。 B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。 确认丢失和确认迟到： 确认丢失： 若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。 假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动： 第一，丢弃这个重复的分组 M1，不向上层交付。 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。 确认迟到： 传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。 A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。 B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。 注意： 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。 分组和确认分组都必须进行编号。 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 自动重传请求 ARQ：通常 A 最终总是可以收到对所有发出的分组的确认。 如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。 停止等待协议的优点是简单，缺点是信道利用率太低： 可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。 流水线传输：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 停止等待协议要点： 停止等待：发送方每次只发送一个分组，在收到确认后再发送下一个分组。 编号：对发送的每个分组和确认都进行编号。 自动重传请求：发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。 简单：但信道利用率太低。 连续 ARQ 协议 基本思想： 发送方一次可以发出多个分组。 使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。 滑动窗口协议比较复杂，是 TCP 协议的精髓所在。 每收到一个确认，发送方就把发送窗口向前滑动。 位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 接收方一般采用累积确认的方式。 采用回退N（Go-Back-N）方法进行重传。 回退N：表示需要再退回来重传已发送过的 N 个分组。例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 累积确认： 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 优缺点： 优点：容易实现，即使确认丢失也不必重传。 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 TCP 可靠通信的具体实现： TCP 连接的每一端都必须设有两个窗口： 一个发送窗口。 一个接收窗口。 TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。 TCP 两端的四个窗口经常处于动态变化之中。 TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。 连续 ARQ 协议与停止等待协议： TCP 报文段的首部格式 TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。 一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。 TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。 TCP 可靠传输的实现以字节为单位的滑动窗口 TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。 TCP 的滑动窗口是以字节为单位的。 发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。 发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。 接收窗口表示：只允许接收落入窗口内的数据。 发送缓存： 接收缓存： 发送缓存与接收缓存的作用： 发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据； TCP 已发送出但尚未收到确认的数据。 接收缓存用来暂时存放： 按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。 接收方发送确认：接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。 注意： A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。 TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。 TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 超时重传时间的选择 重传机制是 TCP 中最重要和最复杂的问题之一。 TCP 每发送一个报文段，就对这个报文段设置一次计时器。 只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。 重传时间的选择是 TCP 最复杂的问题之一。 TCP 超时重传时间设置： 如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。 但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。 TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。 选择确认 SACK 若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？ 答案是可以的。选择确认 SACK (Selective ACK) 就是一种可行的处理方法。 接收到的字节流序号不连续： TCP 的流量控制利用滑动窗口实现流量控制 流量控制：就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 可能发生死锁： B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。 但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。 如果没有其他措施，这种互相等待的死锁局面将一直延续下去。为了解决这个问题，TCP 为每一个连接设有一个持续计时器。 持续计时器： 只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。 若窗口不是零，则死锁的僵局就可以打破了。 TCP 的传输效率 可以用不同的机制来控制 TCP 报文段的发送时机： 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。 发送方糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。 发送方 TCP 每次接收到一字节的数据后就发送。这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。 解决方法：使用 Nagle 算法。 Nagle算法原理： 接收方糊涂窗口综合症： 当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。 若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。 解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。 TCP 的拥塞控制拥塞控制的一般原理 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞。 最坏结果：系统崩溃。 拥塞产生的原因：网络拥塞往往是由许多因素引起的，例如： 点缓存的容量太小； 链路的容量不足； 处理机处理的速率太慢； 拥塞本身会进一步加剧拥塞。 增加资源能解决拥塞吗？ 不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。 网络拥塞往往是由许多因素引起的。例如： 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞； 提高处理机处理的速率会会将瓶颈转移到其他地方； 拥塞控制与流量控制的区别： 拥塞控制所起的作用： 拥塞控制的一般原理： 拥塞控制的前提：网络能够承受现有的网络负荷。 实践证明，拥塞控制是很难设计的，因为它是一个动态问题。 分组的丢失是网络发生拥塞的征兆而不是原因。 在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。 开环控制和闭环控制： 属于闭环控制的有以下几种措施： 监测网络系统，以便检测到拥塞在何时、何处发生。 将拥塞发生的信息传送到可采取行动的地方。 调整网络系统的运行以解决出现的问题。 监测网络的拥塞的主要指标：（下面这些指标的上升都标志着拥塞的增长） 由于缺少缓存空间而被丢弃的分组的百分数； 平均队列长度； 超时重传的分组数； 平均分组时延； 分组时延的标准差，等等。 传递拥塞通知： 发送通知拥塞发生的分组； 在分组中保留表示拥塞状态的字段； 周期性地发出探测分组等。 采取行动的时机： 过于频繁，会使系统产生不稳定的振荡； 过于迟缓地采取行动又不具有任何实用价值。 解决拥塞的两条思路： 增加网络可用资源； 减少用户对资源的需求。 TCP 的拥塞控制方法 TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。 TCP发送方维持一个拥塞窗口 cwnd。 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为： 真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值) 控制拥塞窗口的原则： 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。 拥塞的判断： 四种拥塞控制算法： 慢开始 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 流程： 设置慢开始门限状态变量 ssthresh，慢开始门限 ssthresh 的用法如下： 当 cwnd &lt; ssthresh 时，使用慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” 的特点。 “拥塞避免” 并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。 “拥塞避免” 是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 快重传 发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。 使用快重传可以使整个网络的吞吐量提高约20%。 不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。 快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。 例如： 快恢复 当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法： 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ； 新拥塞窗口 cwnd = 慢开始门限 ssthresh ； 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 主动队列管理 AQM TCP 拥塞控制和网络层采取的策略有密切联系。 若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。 重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。 先进先出(FIFO) 处理规则 与 尾部丢弃策略： 路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。 当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。 路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。 TCP 的运输连接管理TCP 的连接建立 TCP 是面向连接的协议。 TCP 连接有三个阶段： 连接建立 数据传送 连接释放 TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。 TCP 连接建立过程中要解决的三个问题： 要使每一方能够确知对方的存在。 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。 客户—服务器方式： TCP 连接的建立采用客户服务器方式。 主动发起连接建立的应用进程叫做客户 (client)。 被动等待连接建立的应用进程叫做服务器 (server)。 TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手，采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。 TCP 的连接释放 TCP 连接释放过程比较复杂。 数据传输结束后，通信的双方都可释放连接。 TCP 连接释放过程是四报文握手： TCP 的有限状态机","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（四）：运输层概述与UDP详解","slug":"系统学习计算机网络（四）：运输层概述与UDP详解","date":"2021-03-20T01:46:05.000Z","updated":"2021-03-20T01:47:56.645Z","comments":true,"path":"a2ed71807ea0/","link":"","permalink":"https://ozzienicholas.gitee.io/a2ed71807ea0/","excerpt":"","text":"运输层协议概述进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 只有位于网络边缘部分的主机的协议栈才有运输层： 主机 A 与 主机 B 之间的通信的两层含义： 严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。 网络层和运输层有明显的区别： 网络层是为主机之间提供逻辑通信； 运输层为应用进程之间提供端到端的逻辑通信。 基于端口的复用和分用功能： 逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别： 当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。 当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 可靠信道与不可靠信道： 运输层的两个主要协议 TCP/IP 的运输层有两个主要协议： 用户数据报协议 UDP (User Datagram Protocol) 传输控制协议 TCP (Transmission Control Protocol) 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU： TCP 传送的数据单位协议是 TCP 报文段 UDP 传送的数据单位协议是 UDP 报文或用户数据报 使用 UDP 和 TCP 的典型应用和应用层协议： 主机上可能有多个进程同时技能型通信，进程是动态创建和撤销的： 运输层的 UDP 用户数据报与网际层的IP数据报有很大区别： IP 数据报要经过互连网中许多路由器的存储转发 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的 TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 运输层的端口 运行在计算机中的进程是用进程标识符来标志的，但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 需要解决的问题： 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。 有时我们会改换接收报文的进程，但并不需要通知所有发送方。 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。 解决这个问题的方法就是在运输层使用协议端口号，或通常简称为端口。 TCP/IP 运输层端口： 端口用一个 16 位端口号进行标志，允许有65535个不同的端口号。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。 由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机） 两大类端口： 服务器端使用的端口号： 熟知端口，数值一般为 0 ~ 1023。 登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端使用的端口号： 又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 常用的熟知端口： 用户数据报协议 UDPUDP 概述 UDP 只在 IP 的数据报服务之上增加了很少一点的功能： 复用和分用的功能 差错检测的功能 UDP 的主要特点： UDP 是无连接的 UDP 使用尽最大努力交付 UDP 是面向报文的 UDP 没有拥塞控制 UDP 支持一对一、一对多、多对一和多对多的交互通信 UDP 的首部开销小 UDP 是面向报文的： UDP 的首部格式 用户数据报 UDP 有两个字段：数据字段和首部字段，首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。 UDP 用户数据报格式： UDP 基于端口的分用：当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（三）：数据链路层","slug":"系统学习计算机网络（三）：数据链路层","date":"2021-03-20T01:45:19.000Z","updated":"2021-03-20T01:47:48.037Z","comments":true,"path":"310577faf33f/","link":"","permalink":"https://ozzienicholas.gitee.io/310577faf33f/","excerpt":"","text":"前序 计算机网络体系结构： 数据链路层是实现设备之间通信的非常重要的一层： 使用点对点信道的数据链路层数据链路和帧 链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 数据链路层传送的是帧： 三个基本问题 封装成帧：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。 透明传输：如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。 差错检测：在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在数据后面添加上的冗余码称为帧检验序列 FCS。 循环冗余检验 CRC 和帧检验序列 FCS 并不等同： CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 点对点协议 PPPPPP 协议的特点 **对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 **PPP 用户到 ISP 的链路使用 PPP 协议： PPP 协议的帧格式PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。 PPP 协议的工作状态 使用广播信道的数据链路层局域网的数据链路层 局域网最主要的特点是： 网络为一个单位所拥有 地理范围和站点数目均有限 局域网拓扑结构： 局域网对 LLC 子层是透明的： 适配器的作用：网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或 “网卡”，重要功能如下： 进行串行/并行转换。 对数据进行缓存。 在计算机的操作系统安装设备驱动程序。 实现以太网协议。 计算机通过适配器和局域网进行通信： CSMA/CD 协议 使用集线器的星形拓扑 使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD 协议，并共享逻辑上的总线。 集线器很像一个多接口的转发器，工作在物理层。 以太网的 MAC 层 在局域网中，硬件地址又称为物理地址，或 MAC 地址。 最常用的 MAC 帧是以太网 V2 的格式： 扩展的以太网在物理层扩展以太网 使用光纤扩展：主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。 使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网。 在数据链路层扩展以太网 扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。 交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。 以太网交换机的特点： 以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。 以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。 相互通信的主机都是独占传输媒体，无碰撞地传输数据（以太网交换机的每个接口是一个碰撞域）： 交换机使用了生成树协议：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 虚拟局域网 利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。 每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 划分虚拟局域网的方法： 基于交换机端口： 最简单、也是最常用的方法。 属于在第一层划分虚拟局域网的方法。 基于计算机网卡的MAC地址： 根据用户计算机的MAC地址划分虚拟局域网。 属于在第二层划分虚拟局域网的方法。 基于协议类型： 根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网。 属于在第二层划分虚拟局域网的方法。 基于IP子网地址： 根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。 属于在第三层划分虚拟局域网的方法。 基于高层应用或服务： 根据高层应用或服务、或者它们的组合划分虚拟局域网。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（二）：物理层","slug":"系统学习计算机网络（二）：物理层","date":"2021-03-20T01:44:39.000Z","updated":"2021-03-20T01:47:52.518Z","comments":true,"path":"f567b7b406b2/","link":"","permalink":"https://ozzienicholas.gitee.io/f567b7b406b2/","excerpt":"","text":"物理层的基本概念物理层的主要任务描述为确定与传输媒体的接口的一些特性： 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 数据通信的基础知识数据通信系统的模型 有关信道的几个基本概念 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。 基带（baseband）信号：即基本频带信号，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制。 带通（bandpass）信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 几种最基本的调制方法：（最基本的二元制调制方法有以下几种） 调幅(AM)：载波的振幅随基带数字信号而变化 调频(FM)：载波的频率随基带数字信号而变化 调相(PM) ：载波的初始相位随基带数字信号而变化 信道的极限容量与极限信息传输速率 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 有失真，但可识别： 失真大，无法识别： 奈氏准则：给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率，信道的极限信息传输速率 C 可表达为：$$C = W \\times \\log_2^{1+S/N} (b/s)$$ W 为信道的带宽（以 Hz 为单位） S 为信道内所传信号的平均功率 N 为信道内部的高斯噪声功率 香农公式表明： 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 物理层下面的传输媒体电信领域使用的电磁波的频谱 导引型传输媒体 双绞线 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆 50 Ω 同轴电缆 75 Ω 同轴电缆 光缆 光线在光纤中的折射 光纤的工作原理 多模光纤与单模光纤： 光纤优点： 通信容量非常大。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。 非导引型传输媒体 将自由空间称为“非导引型传输媒体” 传统微波通信有两种方式： 地面微波接力通信 卫星通信 信道复用技术 复用 (multiplexing) 是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。 复用的示意图： 频分、时分、统计时分复用 频分复用 FDM ： 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用 TDM： 时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM：STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。 波分复用 WDM 波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。 码分复用 CDM 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。 每个站被指派一个唯一的 m bit 码片序列。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011： 发送比特 1 时，就发送序列 00011011 发送比特 0 时，就发送序列 11100100 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 码片序列实现了扩频： 假定S站要发送信息的数据率为 b bit/s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。 这种通信方式是扩频(spread spectrum)通信中的一种。 扩频通信通常有两大类： 一种是直接序列扩频DSSS (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。 另一种是跳频扩频FHSS (Frequency Hopping Spread Spectrum)。 CDMA 的重要特点： 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。 码片序列的正交关系： 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积等于 0：$$S \\times T \\equiv \\frac{1}{m} \\sum_{i=1}^{m}S_iT_i = 0$$ 在实用的系统中是使用伪随机码序列。 CDMA 的工作原理： 宽带接入技术 用户要连接到互联网，必须先连接到某个ISP。 从宽带接入的媒体来看，可以将宽带接入技术划分为两大类： 有线宽带接入 无线宽带接入 ADSL技术 ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 DSL 就是数字用户线 (Digital Subscriber Line) 的缩写。 ADSL 的传输距离： ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。 ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。 ADSL 的特点： 上行和下行带宽做成不对称的：上行指从用户到 ISP，而下行指从 ISP 到用户。 ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。 光纤同轴混合网（HFC 网） HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。 HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。 现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。 HFC 网对 CATV 网进行了改造：HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 HFC 网采用结点体系结构： FTTx 技术 FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。 FTTx 表示 Fiber To The…（光纤到…），例如： 光纤到户(FTTH，Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。 光纤到大楼(FTTB，Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。 光纤到路边(FTTC，Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。 无源光网络 PON (Passive Optical Network) 的组成：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（一）：概述","slug":"系统学习计算机网络（一）：概述","date":"2021-03-20T01:43:57.000Z","updated":"2021-03-20T01:48:04.835Z","comments":true,"path":"36379c8f0263/","link":"","permalink":"https://ozzienicholas.gitee.io/36379c8f0263/","excerpt":"","text":"互联网概述 计算机网络是由若干个结点以及连接这些结点的链路组成。 网络把计算机连接在一起，而互联网则通过路由器把网络连接在一起，与网络相连的计算机常称为主机。 互联网的组成 虽然互联网的拓扑结构很复杂，但从工作方式上看，可以大致分为： 边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。 互联网的边缘部分： 连接在互联网上的这些主机，又被称为端系统。 注意，这里的端系统并不只是指的电脑，当然也可以是一个很小的网络摄像头等其他具有上网功能的设备。 “主机A 和 主机B 进行通信”，实际上指的是：“主机A 的某个进程和主机B 上的另一个进程进行通信”，这种阐述也被简称为 “计算机之间通信” 在网络边缘的端系统之间的通信方式可以分为两类：C/S方式 和 P2P方式。 C/S 方式（客户—服务器方式）： 这是最常用的方式，比如发送邮件。 “客户” 和 “服务器” 都是指通信中所涉及的两个应用进程，C/S 方式描述的是进程之间，客户是服务请求方，服务器是服务提供方，当然，服务请求方和服务提供方都要使用网络核心部分所提供的服务。 客户程序的主要特点： 被用户调用后，在通信时主动向远地服务器发起通信（请求服务），因此，客户程序必须知道服务器程序的地址。 客户程序是不需要特殊的硬件和很复杂的操作系统的。 服务器程序： 是一种专门用来提供某种服务的程序，可以同时处理多个远地和本地客户的请求。 系统启动之后，即会自动调用并且一直不停地运行，被动地等待并接受来自各地的客户的通信请求，因此，服务器程序不需要知道客户程序的地址。 与客户程序不同的是，服务器程序一般需要有强大的硬件和高级的操作系统支持。 客户和服务器的通信关系建立之后，通信可以是双向的，客户和服务器本来都指的是计算机进程（软件）。 顺带一提，使用计算机的人是计算机的 “用户” 而非 “客户”。 P2P 方式（对等连接方式）： 指两台主机在通信时，并不区分哪台是服务请求方与服务提供方。只要两台主机都运行了对等的连接软件（P2P 软件），它们就可以进行平等的、对等的连接通信，这时，双方都可以下载对方存储在硬盘中的共享文档。这时，双方都可以下载对方已经存储在硬盘中的共享文档，因此这几台主机也可以进行对等通信，从本质上，对等连接方式仍然使用的是客户—服务器方式，只是，对等连接中的每一台主机既是客户同时又是服务器。如下图： 互联网的核心部分： 网络核心部分是互联网中最复杂的部分。 路由器：在网络核心部分起着特殊的作用，它是一种专用的计算机（但不叫主机），它是实现分组交换的关键构件，其任务是转发收到的分组。 若要弄清楚什么是分组交换，建议先理解一下电路交换的基本概念，此处不做解释。 计算机网络的类别 按照网络的作用范围进行分类： 广域网（WAN，Wide Area Network）：也称 “远程网”，是互联网的核心部分，其任务是长距离运送主机发送的数据。 城域网（MAN，Metropolitan Area Network）：作用范围一般是一个城市，用来将多个局域网进行互连，目前很多城域网采用的是以太网技术，因此也常并入局域网的范围来讨论。 局域网（LAN，Local Area Network）：常见的局域网如校园网或企业网。 个人局域网（PAN，Personal Area Network）：也通常称为 “无线个人局域网（WPAN，Wireless PAN）”。 顺便指出，如果中央处理机之间的距离非常近（如距离仅1米），那么一般就称之为多处理机系统，而不是计算机网络。 按照网络的使用者进行分类： 公用网（Public Network）：通常是电信公司（国有或私有）出资建造的大型网络，所有人按规定缴费就可以使用的网络，因此公用网也可以成为 “公众网”。 专用网（Private Network）：一般是为了本单位的特殊业务工作而建造的。 计算机网络的性能 计算机网络的性能一般指它的几个重要的性能指标，但除了这些重要的性能指标，还有一些非性能特征也对网络的性能有很大的影响。 计算机网络的性能指标： 速率： 这是最重要的性能指标，指的是数据的传送速率，也称为 “数据率” 或 “比特率”。 速率的单位是 bit/s（或 b/s，有时也写为 bps），当速率较高时，常常在 bit/s 的前面加上一个字母，例如：k（kilo）= 10^3 = 千，M（Mega）= 10^6 = 兆，以此类推，还有 G（Giga，吉）、T（Tera，太）、P（Peta，拍）、E（Exa，艾）、Z（Zetta，泽）、Y（Yotta，尧），例如 4*10^10 bit/s 的数据率就记为 40Gbit/s。 需要注意，提到网络的速率时，往往指的是稳定速率或标称速率，而非网络实际上运行的速率。 带宽： 带宽本来是指某个信号具有的 “频带宽度”，信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫（或千赫、兆赫、吉赫）。在过去很长一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号），因此，表示某信道允许通过的信号频带范围就称为该信道的带宽（或通频带）。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的 “最高数据率”，这种意义的带宽的单位就是数据率的单位，即 bit/s。 在上述两种表述中，前者是 “频域” 称谓，后者是 “时域” 称谓，其本质是相同的，也就是说，一条通信链路的 “带宽” 越宽，其所能传输的 “最高数据率” 也越高。 吞吐量： 吞吐量表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。 吞吐量长用于对实际网络的测量，以便知道实际上到底有多少个数据量能够通过网络。吞吐量收到网络的带宽或网络的额定速率的限制，例如，对于一个 1 Gbit/s 的以太网，其额定速率是 1 Gbit/s，这个数值也是该以太网的吞吐量的绝对上限值，其实际的吞吐量可能也只有 100 Mbit/s 甚至更低。 有时吞吐量还可用每秒传送的字节数或帧数来表示。 时延： 时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，有时也称为 “延迟” 或 “迟延”。时延是无法立即准确计算的，大多数时候是根据以前的已发生的时延经历而推测下一次的时延。 网络的时延是由以下几个不同的部分组成： 发送时延：发送时延是主机或路由器发送数据帧所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，因此发送时延也叫做 “传输时延”，发送时延的计算公式是：发送时延 = 数据帧长度(bit) / 发送速率(bit/s)。 传播时延：传播时延是电子波在信道中传播需要一定的距离需要花费的时间。传播时延的计算公式是：传播时延 = 信道长度(n) / 电子波在信道上的传播速率(m/s)。 以上两种时延有本质上的不同：发送时延是发生在机器内部的发送器中，与传输信道的长度无关；传播时延是发生在及其外部的传输信道媒体上，信号传送的距离越远，传播时延就越大，这与信号的发送速率无关。 处理时延：主机或路由器在收到分组时要花费一定的时间进行处理。 排队时延：分组在经过网络传输时，要经过许多路由器，但分组在进入路由器后要先在输入队列中排队等待处理。 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积：时延带宽积等于传播时延和带宽相乘。 往返时间 RPT 利用率 计算机网络的非性能特征： 费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护 TCP/IP 体系结构 TCP/IP 的体系结构比较简单，它只有四层。下图给出了用这种四层协议表示方法的例子。请注意，图中的路由器在转发分组时最高只用到网络层而没有使用运输层和应用层： 我们分层次画出具体的协议来表示TCP/IP协议族（如图）： 它的特点是：上下两头大而中间小 — 应用层和网络接口层都有多种协议，而中间的IP 层很小，上层的各种协议都向下汇聚到-一个IP 协议中。 概念回顾 计算机网络（可简称为网络）把许多计算机连接在一起，而互连网则把许多网络连接在一起，互联网是网络的网络。 以小写字母 i 开始的 internet（互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。以大写字母 I 开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP 协议族作为通信规则。 互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程之间的通信。计算机网络采用的通信方式是客户—服务器方式和对等连接方式（P2P方式）。 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。 按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延(发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道（或网络）利用率。 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机操作系统（八）：页面置换算法","slug":"计算机操作系统（八）：页面置换算法","date":"2021-03-20T01:41:24.000Z","updated":"2021-03-20T01:42:37.868Z","comments":true,"path":"61c42f2ee851/","link":"","permalink":"https://ozzienicholas.gitee.io/61c42f2ee851/","excerpt":"","text":"虚拟内存虚拟内存的基本思想：每个程序都有自己的地址空间，这个空间被分割成多个块，每一个块被称作一页或页面。每一页有连续的地址范围。 这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。 当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。 Linux 进程内存布局 进程内存空间通过分段存储来管理 内核空间（kernel space）(1G)：内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。 用户空间（3G）： 环境变量（environment variables） 命令行参数（command-line arguments） 栈（stack）：栈又称堆栈，由编译器自动分配释放，用来存储临时数据和栈帧。 内存映射段（memory mapping segment）：将硬盘文件的内容直接映射到内存，内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。 堆（heap）：堆用于存放进程运行时动态分配的内存段。 BSS段（bss segment）：静态内存分配，保存未初始化的全局及静态变量（皆为0），可读可写。 数据段（data segment）：静态内存分配，保存已初始化的全局及静态变量，可读可写。 代码段（text segment）：保存可执行机器码和常量，可读不可写可执行。 保留区（reserved）(32位cpu下占128M)：位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。 它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。 在32位X86架构的Linux系统中，用户进程可执行程序一般从虚拟地址空间0x08048000开始加载。该加载地址由ELF文件头决定 交换分区：在物理内存满时， 如果还需要内存资源，内核则把物理内存中非活动的页面放到交换分区中。 分页大部分虚拟内存系统中都使用一种称为分页的技术。 由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟内存的计算机上，系统直接把虚拟地址送到内存总线上，读写操作使用具有相同地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。 虚拟地址空间按照固定大小划分成被称为页面（page）的若干单元。在物理内存中对应的单元称为页框。页面和页框的大小通常是一样的。实际系统中的页面大小从512字节到1GB。 栗子：一页4KB，64KB的虚拟地址空间和32KB的物理内存可得到16个虚拟页面和8个页框。从虚拟地址到物理地址的流程： 在上图中，虚拟地址8196（二进制是0010 0000 0000 0100），输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移量可以为一页内的全部4096个字节编址。 可用页号作为页表的索引，以得出对应于该虚拟页面的页框号。如果“在/不在”位是0，则引起缺页中断。如果该位是1，则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。 此处讨论缺页中断（或称为缺页错误）发生的事：假如操作系统访问虚拟页面B产生缺页中断，决定放弃页框1（对应虚拟页面A），那么它将把产生缺页中断所对应的虚拟页面（页面B）装入页框1的起始物理地址，并对MMU映射做两处修改：首先，它要将原来页框1所对应的虚拟页面（页面A）的表项设为未映射，使以后任何对原来虚拟页面（页面A）的访问都导致陷阱。随后，把引起缺页中断（页面B）的的表项设为映射，因此在引起陷阱的指令重新启动时，它将虚拟页面B映射为物理地址页框1中的某个地址。 页表虚拟地址被分成虚拟页号（高地址）和偏移量（低地址）两部分。不同的划分对应了不同的页面大小。 虚拟页号可作为页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到对应的页框。然后把页框号拼接到偏移量的高位端，以替换调虚拟页号，形成送往内存的物理地址。 页表的目的是把虚拟页面映射为页框，把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址（本篇博客讨论的情况均不涉及虚拟机，每个虚拟机都需要有自己的虚拟内存，因此页表组织变得很复杂，包括影子页表和嵌套页表）。 页表项的结构： 页框号：最重要的就是页框号，页映射的目的就是找到这个值 “在/不在”位：是1时表示该表项是有效的，可以使用；是0时则表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个缺页中断。 保护位：指出一个页允许什么样的方式访问，最简单的形式是只有一位，0表示读/写，1表示只读；更先进的方式是使用三位，各位分别表示是否启用读、写、执行该页面。 修改位：记录页面的使用情况，在写入一个页时自动设置修改位。如果一个页面已经被修改过（即它是“脏”的），则必须把它写会磁盘。如果没有被修改过（即它是“干净”的），可以直接被丢弃，因为它在磁盘上的副本仍然是有效的。脏位，反映看该页面的状态。 访问位：不论是读还是写，系统都会在该页面被访问时设置访问位。用于页面置换算法中。 禁止该页面被高速缓存：对于映射到设备寄存器而不是常规内存的页面很重要。具有独立的I/O空间而不使用内存映射I/O的机器不需要这一位。 加速分页过程每次访问内存都需要进行虚拟地址到物理地址的映射，每条指令进行一两次或更多页表访问是必要的。如果执行一条指令需要1ns，页表查询必须在0.2ns之内完成，以避免映射成为一个主要瓶颈。 现代计算机使用至少32位的虚拟地址。假设页面大小为4KB，32位的地址空间将有100万页，那么页表必然有100万条表项，而且每个进程都需要自己的页表。64位地址空间简直多到超乎你的想象。 转换检测缓冲区： 大多数程序总是对少量的页面进行多次的访问，只有很少的页表项会被反复读取，而其他大的页表项很少被访问。利用这种特性有一种解决方案：为计算机设计一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区（Translation Lookaside Buffers，TLB），有时又称为相联存储器或快表。它通常在MMU中，包含少量的表项，在实际中很少会超过256个。每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、保护码和该页锁对应的物理页框，还有另外一位用来记录这个表项是否有效（即是否在使用）。 TLB的工作过程：将一个虚拟地址放入MMU中进行转换时，硬件首先通过将该虚拟页号与TLB中所有表项同时（并行）进行匹配，判断虚拟页面是否在其中。如果发现在，并且不违反保护码，则将页框号直接从TLB中取出而不必再访问页表。如果违反了保护码，则会产生一个保护错误，就像对页表进行非法操作一样。如果虚拟页号不在TLB中，此时就会去进行正常的页表查询。接着从TLB中淘汰掉一个表项，然后用找到的页表项代替它。当一个表项被清除除TLB时，将修改位复制到内存中的页表项，而除了访问位，其他的值不变。当页表项中从页表中装入TLB中时，所有的值都来自内存。 软件TLB管理： 现代许多的机器，几乎所有的页面管理都在软件中实现。TLB被操作系统显示地加载，当发生TLB访问失效时，生成一个TLB失效并将问题交给操作系统解决。系统找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。TLB失效比缺页中断更加频繁。 如果TLB大到（如64个表项）可以减少失效率时，TLB的软件管理就会变得足够有效。 在减少TLB失效的同时，又要在发生TLB失效时减少处理开销。有时候操作系统能用“直觉”指出哪些页面下一步可能会被用到并预先为它们在TLB中装载表项。 （软件、硬件）处理TLB失效常用的办法都是找到页表并执行索引操作以定位将要访问的页面。软件做这样的搜索时，通过在内存中的固定位置维护一个大的（如4KB）TLB表项的软件高速缓存（该高速缓存的页面一直保存在TLB中）来减少TLB失效。 两种不同的TLB失效： 软失效：一个页面访问在内存中而不在TLB中，此时要做的是更新TLB，不需要产生磁盘I/O。（10~20个机器指令，几纳秒） 硬失效：页面本身不在内存中（当然也不TLB中），此时需要一次磁盘存取以装入该页面。（几毫秒，硬失效的处理时间往往是软失效的百万倍）：在也表中查找相应的映射被称为页表遍历，假设页表遍历没有在进程的页表汇总找到需要的页，从而产生了一个缺页错误，此时有三种可能： 所需要的页面就在内存中，但未记录在该进程的页表里。比如该页面可能已由其他其他进程从硬盘中调入内存，这种情况只需要把所需要的页面正确映射到页表中，而不是从磁盘调入。这是一种软失效，称为次要缺页错误。 需要从硬盘重新调入页面，这就是严重缺页错误。 程序访问了一个非法地址，根本不需要向TLB中新增映射。此时，操作系统一般会通过报告段错误来终止该程序。只有第三种缺页属于程序错误，其他缺页情况都会被硬件或操作系统以降低性能为代价而自动修复。 针对大内存的页表两种办解决巨大的虚拟地址空间？ 多级页表：32位的虚拟地址被划分为10位的PT1域，10位的PT2域和12位的Offset(偏移量)域。因为偏移量是12位，所以页面大小是4KB，共有220个页面。假设每个进程都占用了4G的线性地址空间，页表共含1M个表项，每个表项占4个字节，那么每个进程的页表要占据4M的内存空间。为了节省页表占用的空间，我们使用两级页表。每个进程都会被分配一个页目录，但是只有被实际使用页表才会被分配到内存里面。一级页表需要一次分配所有页表空间，两级页表则可以在需要的时候再分配页表空间。 引入多级页表的原因是避免把全部页表一直保存在内存中（特别是一些从不需要的页表）： 在左边的是顶级页表（页目录表），它有1024个表项，对应于10位的PT1域。当一个虚拟地址被送到MMU时，MMU首先提取PT1域并把该值作为访问顶级页表的索引。因为整个4GB（即32位）虚拟地址空间已经按4KB大小分块，所以顶级页表中这1024个表项的每一个都表示4M的块地址范围。二级页表的每一项都表示4KB的地址范围。Offset对4096个地址进行编址。 由索引顶级页表得到的表项中含有二级页表的地址或页框号。顶级页表的表项0指向程序正文的页表，表项1指向数据的页表，表项1023指向堆栈的页表，其他的表项未用，现在把PT2域作为访问选定的二级页表的索引，以便找到该虚拟页面的对应页框号。 虽然虚拟地址空间超过100万个页面，实际上只需要4个页表：顶级页表，0-4M（正文段），4M-8M（数据段）和顶端4M（堆栈段）的二级页表。顶级页表中1021个表项的“在/不在”都设成0，当访问他们时强制产生一个缺页中断。 二级页表可扩充为三级、四级或更多级。级数越多，灵活性就越大。 页目录指针表。每一级的页表项由32位扩展到了64位，这样处理器就能寻址到4GB以外的地址空间。 最优页面置换算法 当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，来为即将调入的页面腾出空间。 此算法不可能实现。在发生缺页中断的时候，在内存中的页面有的很快就会被访问，而有的页面可能要到10、100、1000条指令后才会被访问。此时要置换最迟被访问的页面，把因调用被替换的页面而引起的中断推迟到将来，越久越好。当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问，因此这个算法是无法被实现的。 这个算法可以用来对其他可实现算法的性能进行比较。 最近未使用页面置换算法（NRU，Not Recently Used） 当页面被访问（读或写）时设置R位，页面被写入（修改）时设置M位。 当启动一个进程时，它的所有页面的两个位都由操作系统设为0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。 当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类： 第0类：没有被访问，没有被修改。 第1类：没有被访问，已被修改（M）。 第2类：已被访问，没有被修改（R）。 第3类：已被访问，已被修改（RM）。 NRU 算法随机地从类编号最小的非空类中挑选一个页面淘汰。在一个时间滴答中（大约20ms）淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好。NRU算法的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。 算法思路：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。 所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#define MAX 100int judge(int a[],int n,int x) &#123; //判断数组中是否已有x，若有返回其下标值，没有则返回-1 int i; for(i=0; i&lt;n; i++) if(x==a[i]) return i; return -1;&#125;void init(int a[],int n) &#123; //初始化数组为-1 int i; for(i=0; i&lt;n; i++) a[i]=-1;&#125;void insert(int a[],int n,int x) &#123; //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) int i; for(i=0; i&lt;n-1; i++) a[i]=a[i+1]; a[n-1]=x;&#125;void move(int a[],int n,int i) &#123; //移动下标为i的元素到尾部 int j; int m=a[i]; for(j=i; j&lt;n-1; j++) a[j]=a[j+1]; a[n-1]=m;&#125;void print(int a[],int n) &#123; //输出当前数组元素 int i; for(i=0; i&lt;n; i++) if(a[i]!=-1) printf(&quot; %d&quot;,a[i]); printf(&quot;\\n&quot;);&#125;int main() &#123; int stack[MAX]; int top=-1; //模仿栈的定义 int n,x; printf(&quot;请输入物理块数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); init(stack,n); //初始化数组 printf(&quot;请输入内存访问序列：\\n&quot;); while(~scanf(&quot;%d&quot;,&amp;x)) &#123; //自动读数 printf(&quot;访问页面%d:\\n&quot;,x); top++; //读数后top自动+1 if(top==0) //若数组无元素 stack[top]=x; //插入一个元素 else if(top&lt;n) &#123; //若在物理块范围内 if(judge(stack,n,x)==-1) //若数组中不存在待插入元素 stack[top]=x; ree//新元素从尾部插入 else &#123; //若数组中存在待插入元素 move(stack,top,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; else &#123; //超过物理块数的元素 if(judge(stack,n,x)==-1) &#123; //若数组中不存在待插入元素 insert(stack,n,x); //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) top--; //因为没有插入新元素，回滚top值 &#125; else &#123; //若数组中存在待插入元素 move(stack,n,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; print(stack,n); //读一个序列号，输出当前数组元素 &#125; return 0;&#125; 先进先出页面置换算法（FIFO）开销同样较小的FIFO算法，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。这种算法的缺点是可能会把有用的页面淘汰掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define totalCmdNum 320 // 指令总数#define BlockNum 4 // 内存块总数// 内存块结构体typedef struct &#123; int id; // 物理地址 int page; // 页号(默认为-1) int keepTime; // 在内存中驻留的时间&#125; Block;int cmdNum = 0; // 指令执行次数int curCmd; // 当前正在执行的指令int isExecute[totalCmdNum]; // 判断每条指令是否执行的标志数组double lostPage = 0; // 缺页次数Block *blocks[BlockNum]; // 内存块指针数组// 初始化void init() &#123; // 初始化标志数组 for (int i = 0; i &lt; totalCmdNum; i++) &#123; // 0代表未执行 isExecute[i] = 0; &#125; // 设置随机数种子 srand(time(NULL)); // 初始化内存块数组 for (int i = 0; i &lt; BlockNum; i++) &#123; // 分配空间 blocks[i] = (Block *)malloc(sizeof(Block)); blocks[i]-&gt;id = i + 1; // 物理地址 blocks[i]-&gt;page = -1; // -1 代表此页还未分配 blocks[i]-&gt;keepTime = 0; // 内存驻留时间 &#125;&#125;// 产生指令int genCmd() &#123; cmdNum++; // 累计指令条数 if (cmdNum == 1) &#123; curCmd = rand() % totalCmdNum; &#125; if (cmdNum == 2) &#123; curCmd++; // 顺序执行下一条指令 &#125; if (cmdNum &gt;= 3) &#123; switch ((cmdNum - 2) % 4) &#123; case 1: // 前地址部分 curCmd = rand() % (curCmd - 2); break; case 2: case 0: curCmd++; // 顺序执行下一条指令 break; case 3: // 后地址部分 curCmd = curCmd + 1 + rand() % (totalCmdNum - curCmd); break; &#125; &#125; isExecute[curCmd] = 1; // 1代表该指令已被执行(可以重复执行) return curCmd;&#125;// 判断所有指令是否全部执行了一遍int isFinish() &#123; int flag = 1; // 遍历所有指令执行情况 for (int i = 0; i &lt; totalCmdNum; i++) &#123; if (isExecute[i] == 0) &#123; flag = 0; break; &#125; &#125; return flag;&#125;// 作业调度void dispatchJob() &#123; int page = genCmd() / 10; // 根据指令号计算页号 int i = 0; for (; i &lt; BlockNum; i++) &#123; // 如果访问的指令在内存中，则显示其物理地址 if (blocks[i]-&gt;page == page) &#123; printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[i]-&gt;id); break; &#125; &#125; // 如果访问的指令不在内存中 if (i &gt;= BlockNum) &#123; i = 0; for (; i &lt; BlockNum; i++) &#123; // 寻找未分配的内存块 if (blocks[i]-&gt;page == -1) &#123; blocks[i]-&gt;page = page; //printf(&quot;内存块未分配\\n&quot;); printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[i]-&gt;id); break; &#125; &#125; &#125; // 如果所有内存块都已被分配 if (i &gt;= BlockNum) &#123; int oldestBlock = 0; // 最先被分配的内存块 int maxKeepTime = blocks[0]-&gt;keepTime; // 最长内存驻留时间 i = 1; for (; i &lt; BlockNum; i++) &#123; if (blocks[i]-&gt;keepTime &gt; maxKeepTime) &#123; oldestBlock = blocks[i]-&gt;id; maxKeepTime = blocks[i]-&gt;keepTime; &#125; &#125; blocks[oldestBlock]-&gt;page = page; blocks[oldestBlock]-&gt;keepTime = 0; lostPage++; // 累计缺页次数 //printf(&quot;缺页了\\n&quot;); printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[oldestBlock]-&gt;id); &#125; i = 0; for (; i &lt; BlockNum; i++) &#123; if (blocks[i]-&gt;page != -1) &#123; blocks[i]-&gt;keepTime++; // 累计驻留时间 &#125; &#125;&#125;int main() &#123; init(); // 初始化 while (1) &#123; dispatchJob(); // 作业调度 if (isFinish()) &#123; // 判断作业是否运行完成 break; &#125; &#125; printf(&quot;\\n共执行指令%d条\\n&quot;, cmdNum); printf(&quot;缺页率约为:%.1lf%%\\n&quot;, (lostPage / cmdNum)*100); return 0;&#125; 第二次机会页面置换算法（SC，Second Chance） 对FIFO算法的改进，对FIFO算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位置0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入时间使它就像刚装入的一样，然后继续搜索。 第二次机会（second chance）算法是寻找一个在最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。假设所有页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。最后又会回到原来的表头页面，此时它的R位已经被清除了，因此这个页面会被淘汰，所以这个算法总是可以结束的。 假设在时间20发生了一次缺页中断，这时最老的页面是A，它是在时刻0到达的。如果A的R位是0，则将它淘汰出内存，或者把它写回磁盘（如果它已被修改过），或者只是简单地放弃（如果它是“干净”的）；另一方面，如果其R位已经设置了，则将A放到链表的尾部并且重新设置“装入时间”为当前时刻（20），然后清除R位。然后从B页面开始继续搜索合适的页面。 第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。特别地，想象一下，假设图3-15a中所有的页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。算法又将回到页面A，此时它的R位已经被清除了，因此A页面将被淘汰，所以这个算法总是可以结束的。 时钟页面置换算法（CLOCK） 对第二次机会算法的改进，第二次机会算法经常要在链表中移动页面，既降低了效率又不是很必要。 一个更好的做法就是把所有的页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面。当发生缺页中断时，首先检查表指针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表指针前移一个位置。如果R位是1就清除R位并把表指针前移一个位置；重复这个过程一直到找到一个R位为0的页面为止。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * clock_pro.c * * Created on: 2019年12月6日 * Author: zyli */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define Maxblocks 3int blocks[Maxblocks] = &#123;&#125;;int access[Maxblocks] = &#123;&#125;;int modify[Maxblocks] = &#123;&#125;;int pages_in_blocks = 0;int is_modified = 0;int aimed_i=-1;bool is_aimed(int pn) &#123; aimed_i=-1; for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(blocks[i]==pn) &#123; aimed_i=i; return true; &#125; &#125; return false;&#125;void loop() &#123; int taotaip=0; for(int j=0; j&lt;2; j++) &#123; for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!access[i]&amp;&amp;!modify[i]) &#123; taotaip=blocks[i]; for(; i&lt;pages_in_blocks; i++) &#123; blocks[i]=blocks[i+1]; access[i]=access[i+1]; modify[i]=modify[i+1]; &#125; if(!j) printf(&quot;第一圈有（0，0）的，是页面 %d，淘汰！把新页面放入队尾\\n&quot;,taotaip); else printf(&quot;第三圈有（0，0）的，是页面 %d，淘汰！把新页面放入队尾\\n&quot;,taotaip); return; &#125; &#125; if(!j) printf(&quot;第一圈没有（0，0）的，接着找（0，1）的\\n&quot;); else printf(&quot;第三圈没有（0，0）的，即上一圈（第二圈）全为（0，1）\\n&quot;); for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!(!access[i]&amp;&amp;modify[i])) &#123; access[i]=0; &#125; else &#123; taotaip=blocks[i]; for(; i&lt;pages_in_blocks; i++) &#123; blocks[i]=blocks[i+1]; access[i]=access[i+1]; modify[i]=modify[i+1]; &#125; if(!j) printf(&quot;第二圈有（0，1）的，是页面 %d，淘汰！第一个（0，1）之前的页面访问位全部置为0，并把新页面放入队尾\\n&quot;,taotaip); else printf(&quot;第四圈必有（0，1）的，将第一个（0，1）的，即页面%d淘汰！把新页面放入队尾\\n&quot;,taotaip); return; &#125; &#125; printf(&quot;第二圈没有（0，1）的，但把所有访问位置为0了，接着第三圈找（0，0）的\\n&quot;); &#125;&#125;void clock_pro(int pn) &#123; if(pages_in_blocks&lt;Maxblocks) &#123; if(is_aimed(pn)) &#123; access[aimed_i]=1; printf(&quot;输入页面是否被修改%d (0/1)\\n&quot;,pn); scanf(&quot;%d&quot;,&amp;is_modified); if(is_modified) modify[aimed_i]=1; &#125; else &#123; blocks[pages_in_blocks]=pn; access[pages_in_blocks]=1; modify[pages_in_blocks]=0; pages_in_blocks++; &#125; &#125; else &#123; if(is_aimed(pn)) &#123; access[aimed_i]=1; printf(&quot;输入页面是否被修改%d (0/1)\\n&quot;,pn); scanf(&quot;%d&quot;,&amp;is_modified); if(is_modified) modify[aimed_i]=1; &#125; else &#123; loop(); blocks[Maxblocks-1]=pn; access[Maxblocks-1]=1; modify[Maxblocks-1]=0; &#125; &#125;&#125;void print_blocks() &#123; int cato=0; printf(&quot;此时内存块里状态为：\\n&quot;); for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!access[i] &amp;&amp; !modify[i]) cato=1; if(!access[i] &amp;&amp; modify[i]) cato=2; if( access[i] &amp;&amp; !modify[i]) cato=3; if( access[i] &amp;&amp; modify[i]) cato=4; printf(&quot;%d %d %d ,对应第%d类型页面\\n&quot;,blocks[i],access[i],modify[i],cato); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; for(int i=0; i&lt;Maxblocks; i++) &#123; blocks[i]=-1; access[i]=0; modify[i]=0; &#125; int n=0; while(n&gt;=0) &#123; is_modified=0; printf(&quot;输入此时进程对哪个页面访问,输入-1结束程序\\n&quot;); scanf(&quot;%d&quot;,&amp;n); if(n&gt;=0) &#123; clock_pro(n); print_blocks(); &#125; &#125; system(&quot;pause&quot;); return 0; return 0;&#125; 最近最少使用页面置换算法（LRU，Least Recently Used） 在缺页中断发生时，置换未使用时间最长的页面。 LRU理论上是可以实现的，但是代价很高。维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。 假设用硬件实现：硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问完内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面，但是只有非常少的计算机拥有这样的硬件。 算法过程：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰，所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#define MAX 100int judge(int a[],int n,int x) &#123; //判断数组中是否已有x，若有返回其下标值，没有则返回-1 int i; for(i=0; i&lt;n; i++) if(x==a[i]) return i; return -1;&#125;void init(int a[],int n) &#123; //初始化数组为-1 int i; for(i=0; i&lt;n; i++) a[i]=-1;&#125;void insert(int a[],int n,int x) &#123; //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) int i; for(i=0; i&lt;n-1; i++) a[i]=a[i+1]; a[n-1]=x;&#125;void move(int a[],int n,int i) &#123; //移动下标为i的元素到尾部 int j; int m=a[i]; for(j=i; j&lt;n-1; j++) a[j]=a[j+1]; a[n-1]=m;&#125;void print(int a[],int n) &#123; //输出当前数组元素 int i; for(i=0; i&lt;n; i++) if(a[i]!=-1) printf(&quot; %d&quot;,a[i]); printf(&quot;\\n&quot;);&#125;int main() &#123; int stack[MAX]; int top=-1; //模仿栈的定义 int n,x; printf(&quot;请输入物理块数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); init(stack,n); //初始化数组 printf(&quot;请输入内存访问序列：\\n&quot;); while(~scanf(&quot;%d&quot;,&amp;x)) &#123; //自动读数 printf(&quot;访问页面%d:\\n&quot;,x); top++; //读数后top自动+1 if(top==0) //若数组无元素 stack[top]=x; //插入一个元素 else if(top&lt;n) &#123; //若在物理块范围内 if(judge(stack,n,x)==-1) //若数组中不存在待插入元素 stack[top]=x; //新元素从尾部插入 else &#123; //若数组中存在待插入元素 move(stack,top,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; else &#123; //超过物理块数的元素 if(judge(stack,n,x)==-1) &#123; //若数组中不存在待插入元素 insert(stack,n,x); //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) top--; //因为没有插入新元素，回滚top值 &#125; else &#123; //若数组中存在待插入元素 move(stack,n,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; print(stack,n); //读一个序列号，输出当前数组元素 &#125; return 0;&#125; 最不常用页面置换算法（NFU）（Not Frequently Used） 用一个软件模拟LRU，该算法将每个页面与一个软件计数器相关联。计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。 NFU的缺点是它不从不忘记任何事，比如一个页面之前频繁被访问，导致这个它的计数器很大，但是后来它不被访问了，而它的计数器的值还是很大，所以它一直不会被置换出去。 老化算法 老化算法是对NFU算法的修改，其修改包括两个部分，首先，在R位被加进之前将计数器右移一位，其次，将R位加到计数器最左端的位而不是最右端的位。 老化算法中的计数器只有有限位数，如果时钟滴答是20ms，8位一般是够用的。假如一个页面160ms没有被访问过，那么它很可能并不重要。 工作集页面置换算法 一个进程当前正在使用的页面的集合称为它的工作集。 若每执行几条指令就产生一次缺页中断，那么就称这个程序发生了颠簸。 在单纯的分页系统中，刚启动进程时，在内存中并没有页面。在CPU试图读取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面，其他由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略被称为请求调页。 有不少分页系统会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已经在内存中了。该方法称为工作集模型，大大减少缺页中断率。在进程前装入其工作集页面也称为预先调页。工作集是随时间变化的。 事实上大多数程序会任意访问一小部分页面，工作集随时间缓慢变化。当程序重新开始时，就有可能根据它上次结束时的工作集对要用到的页面做一个合理的推测，预先调页就是在程序IXUS运行之前预先装入推测的工作集的页面。 按照以前的方法，定义工作集为前1000万次内存访问锁使用过的页面的集合，那么现在就可以这样定义：工作集即是过去10ms中的内存访问所用到的页面的集合。这样的模型很合适而且更容易实现。要注意到，每个进程只计算它自己的执行时间。因此，如果一个进程在T时刻开始，在(T+100ms)的时刻使用了40msCPU时间，对工作集而言，它的时间就是40ms。一个程序从它开始执行到当前所实际使用的CPU时间总数通常称作当前实际运行时间。通过这个近似的方法，进程的工作集可以被称为在过去的τ秒实际运行时间中它所访问过的页面的集合。 基于工作集的页面置换算法就是找出一个不在工作集中的页面并淘汰它。每个表项至少包含两条信息：上次使用该页面的近似时间和R（访问位）。 过程： 扫描所有的页面检查R位 若（R == 1）：设置上次使用时间为当前实际时间，以表示缺页中断时该页面正在被使用 若（R == 0 且生存时间&gt;τ）：移出这个页面，该页面在当前时钟滴答中未被访问，不在工作集中，用新的页面置换它。扫描会继续进行以更新剩余的表项。 若（R == 0 且生存时间≤τ）：记住最小时间。如果该页面R==0且生存时间小于或等于τ，则页面仍在工作集中。把页面临时保存下来，但是要记住生存时间最长（“上次使用时间”的最小值）。如果扫描完整个页表却没有找到合适的淘汰的页面，如果找到了一个或多个R == 0的页面，就淘汰生存时间最长的页面。 在最坏的情况下，在当前时钟滴答中，所有的页面都被访问过了，也就是所有的R都为1，因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。 工作集时钟页面置换算法 在工作集页面置换算法中中，当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。 基于时钟算法，并且使用了工作集信息，被称为WSClock（工作集时钟）算法。由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。 与时钟算法一样，所需的数据结构是一个以页框为元素的循环表。最初，该表示空的，当装入第一个页面后，把它加到该表中。随着更多的页面加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位和M位。 与时钟算法一样，每次缺页中断时，首先检查指针指向的页面。如果R位是1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。 如果R位是0，查看生存时间，如果生存时间大于τ并且该页面是干净的，它就不在工作集中，而且在磁盘上它有一个有效的副本。申请此页框，并把新页面放在其中。如果该页面已经被修改过，就不立即申请此页框，为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作，有可能存在一个旧的而且干净的页面可以立即使用。 原则上，所有的页面都有可能因为磁盘I/O在某个时钟周期被调度，为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回n个页面。一旦达到该限制，就不允许调度新的写操作。 指针经过一圈返回它的起点，有两种情况： 至少调用了一次写操作 执行了写操作的页面已经是干净的了，置换遇到的第一个干净页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能已经把写操作重排序了。 没有调用过写操作 所有的页面都在工作集中，否则将至少执行了一个写操作。由于缺乏额外的信息，一个简单的方法就是随便置换一个干净的页面来使用，扫描中需要记录干净页面的位置。如果不存在干净页面，就选定当前页面并把它协会磁盘。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（七）：虚拟存储器","slug":"计算机操作系统（七）：虚拟存储器","date":"2021-03-20T01:40:02.000Z","updated":"2021-03-20T01:40:19.155Z","comments":true,"path":"b56da1eb9025/","link":"","permalink":"https://ozzienicholas.gitee.io/b56da1eb9025/","excerpt":"","text":"虚拟存储器概述交换技术与覆盖技术 是在多道环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到的矛盾。 交换技术被广泛用于小型分时系统中，交换技术的发展导致了虚存技术的出现；覆盖技术主要用在早期的操作系统中。 交换技术与覆盖技术异同点： 共同点：进程的程序和数据主要放在外存，当前需要执行的部分放在内存，内外存之间进行信息交换。 不同点：如何控制交换。 覆盖技术： 把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域。 程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）。 覆盖：一个作业的若干程序段，或几个作业的某些部分共享某一个存储空间 一般要求作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖 覆盖技术的缺点： 对用户不透明，增加了用户负担 目前这一技术用于小型系统中的系统程序的内存管理上 MS-DOS的启动过程中，多次使用覆盖技术；启动之后，用户程序区TPA的高端部分与COMMAND.COM暂驻模块也是一种覆盖结构 交换技术： 当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是进程在内存与外存之间的动态调度。 这种技术多用于分时系统中。 交换技术实现中的几个问题： 选择原则：将哪个进程换出内存？ 例如：分时系统中，时间片轮转法或基于优先数的调度算法，在选择换出进程时，要确定换出的进程是要长时间等待的。 需要特殊考虑的是：任何等待I/O进程中存在的问题。 解决：从来不换出处于等待I/O状态的进程。 有些I/O进程因DMA（直接存储器访问）而不能换出内存或换出前需要操作系统的特殊帮助。 如何确定交换时机？ 只要不用或者很少再用就换出。 只在内存空间不够或有不够的危险时换出。 交换时需要做哪些工作？ 盘交换区：足够大，存放所有用户程序的所有内存映像的拷贝。 直接存取：必须能够对这些用户程序的内存映像进行存取操作。 如何确定换入内存时位置？（换出后再换入的内存位置一定要在换出前的原来位置上吗？） 受地址“绑定”技术的影响，即绝对地址产生时机的限制 覆盖与交换的比较： 与覆盖技术相比，交换技术不要求用户给出程序段之间的逻辑覆盖结构；而且，交换发生在进程或作业之间。 而覆盖发生在同一进程或作业内。 覆盖只能覆盖那些与覆盖段无关的程序段。 虚拟存储器的引入 程序装入内存时可能会出现如下问题： 程序太大，要求的空间超出了内存总容量 有大量作业要求运行，但内存不能容下所有作业 常规存储器管理方式的特征 一次性：要求作业全部装入内存才能运行。 驻留性：程序装入内存后便一直驻留内存，直至运行结束。 虚拟存储器的基本思想是：程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。 虚拟存储器支持多道程序设计技术。 虚拟存储器定义：是指具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而其成本却又接近于外存。 注意：一个虚拟存储器的最大容量是由计算机的地址结构确定的。如：若CPU的有效地址长度为32位，则程序可以寻址范围是0～(2^32)-1 ，即虚存容量为 4GB。 虚拟存储器的容量与主存的实际大小没有直接的关系，而是由主存与辅存的容量之和所确定。 虚拟存储器的实现方法 虚拟存储器的实现都是建立在离散分配的存储管理方式基础上的。 主要有： 请求分页系统 请求分段系统 请求分页系统： 在分页系统的基础上增加了请求调页功能和页面置换功能 硬件支持： 请求分页的页表机制，它是在纯分页的页表机制上增加若干项而形成的，作为请求分页的数据结构； 缺页中断机构，即每当用户程序要访问的页面尚未调入内存时 便产生一缺页中断，以请求OS将所缺的页调入内存； 地址变换机构， 它同样是在纯分页地址变换机构的基础上发展形成的 实现请求分页的软件：用于实现请求调页的软件和实现页面置换的软件 请求分段系统：为了实现请求分段，系统同样需要必要的硬件支持： 请求分段的段表机制。这是在纯分段的段表机制基础上，增加若干项而形成的； 缺段中断机构。每当用户程序所要访问的段尚未调入内存时，产生一缺段中断，请求OS将所缺的段调入内存； 地址变换机构。与请求调页类似，实现请求调段和置换功能也需要得到OS的支持。 虚拟存储器的特征 虚拟存储器的特征有： 离散性（最基本的特征） 多次性：一个作业被分成多次调入内存运行。 对换性：允许在作业的运行过程中进行换进、换出。 虚拟性（最重要的特征）：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术。 请求分页存储管理方式请求分页中的硬件支持 系统需要解决的问题： 系统如何获知进程当前所需页面不在主存 当发现缺页时，如何把所缺页面调入主存 当主存中没有空闲的页框时，为了要接受一个新页，需要把老的一页淘汰出去，根据什么策略选择欲淘汰的页面 页描述子的扩充（页表机制）： 状态位P（中断位）指示该页是在内存还是在外存 访问位 A 用于记录本页在一段时间内被访问的次数或记录本页在最近多长时间未被访问 修改位 M 表示该页在内存中是否被修改过 外存地址该页在外存上的地址，通常是物理块号 缺页中断机构 在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断。相应的中断处理程序把控制转向缺页中断子程序，执行此子程序，即把所缺页面装入主存，然后处理机重新执行缺页时打断的指令。这时，就将顺利形成物理地址。 缺页中断与一般中断的区别： 在指令执行期间产生和处理中断信号 一条指令在执行期间可能产生多次缺页中断 涉及6次缺页中断的指令 ： 如果在快表中未找到该页的页表项，则应再到内存中去查找页表，再从找到的页表项中的状态位P，该页是否调入内存。其结果可能是： 该页已经调入内存，这是应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项，然后再写入该页的页表项。 该页尚未调入内存，这时便应产生缺页中断，请求OS从外存中把该页调入内存。 请求分页中的地址变换过程： 内存分配策略和分配算法 最小物理块数的确定： 指保证进程正常运行所需的最小物理块数。当系统分配的物理块数少于此值时，进程将无法运行。 进程应获得的最小物理块数与计算机的硬件结构有关，取决于指令的格式、 功能和寻址方式。 对于单地址指令且采用直接寻址方式的机器，则所需最少2个物理块。其中，一块存放指令页面，另一块则存放数据页面。 不同的作业要求不同。例如，允许间接寻址的机器，至少要求有3个物理块；而直接寻址方式所需的最少物理块数为2： 对于长度是两个或多于两个字节指令的机器，其指令本身可能跨两个页面，且源和目标地址所涉及的区域也可能跨两个页面，至少需要6个物理块。 物理块的分配策略：在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。于是可组合出以下三种适用的策略： 固定分配局部置换(Fixed Allocation, Local Replacement) 问题：分配块数难确定，太少，缺页频繁，吞吐量降低；太多，内存驻留进程数减少，CPU或其它资源可能空闲。 可变分配全局置换(Variable Allocation, Global Replacement) 先分配给各进程一定数的物理块，系统有一空闲物理块队列，缺页时从空闲队列取，若空闲队列空时，在选页调出。 可变分配局部置换(Variable Allocation, Local Replacemen) 先分配给各进程一定数的物理块，缺页时从该进程在内存的页选一换出，若其频繁缺页，系统再分配若干附加物理块。 物理块分配算法： 平均分配算法： 这是将系统中所有可供分配的物理块，平均分配给各个进程。 例如，当系统中有100个物理块，有5个进程在运行时，每个进程可分得20个物理块。这种方式貌似公平，但实际上是不公平的，因为它未考虑到各进程本身的大小。如有一个进程其大小为200页，只分配给它20个块，这样，它必然会有很高的缺页率；而另一个进程只有10页，却有10个物理块闲置未用。 按比例分配算法： 这是根据进程的大小按比例分配物理块的算法。如果系统中共有n个进程，每个进程的页面数为Si，则系统中各进程页面数的总和为： 又假定系统中可用的物理块总数为m，则每个进程所能分到的物理块数为bi，将有： b应该取整，它必须大于最小物理块数。 考虑优先权的分配算法： 在实际应用中，为了照顾到重要的、紧迫的用户程序能尽快地完成， 应为它分配较多的内存空间 通常采取的方法是把内存中可供分配的所有物理块分成两部分：一部分按比例地分配给各进程；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程 在重要的系统，如实时控制系统，则可能是完全按优先权为各进程分配其物理块的 调页策略 何时调入页面： 预调页策略：采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存，成功率50%。 请求调页策略： 当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便提出请求，由OS将其所需页面调入内存。 目前的虚拟存储中大多采用此种策略。 从何处调入页面 在请求分页系统中的外存分为两部分： 用于存放文件的文件区 用于存放对换页面的对换区 通常，由于对换区是采用连续分配方式，而文件区是采用离散分配方式，故对换区的磁盘I/O速度比文件区的高。这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下三种情况： 系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前， 便须将与该进程有关的文件，从文件区拷贝到对换区。 系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。 由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。 页面调入过程 每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。该程序通过查找页表，得到该页在外存的物理块地址。 若此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表 若内存已满，则须先按照某种置换算法从内存中选出一页准备换出： 页未被修改过，可不必将该页写回磁盘 页已被修改过， 则必须将它写回磁盘，然后再把所缺的页调入内存， 并修改页表中的相应表项，置其状态位为“1”，并将此页表项写入快表中。 在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据 页面置换算法 这里简略介绍主要的几个页面置换算法，算法详解请看：页面置换算法 最佳置换算法 采用最佳置换算法可保证获得最低的缺页率。 但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法也是无法实现的，但是可利用该算法去评价其它算法。 例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串：7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1进程运行时， 先将7，0，1三个页面装入内存。 以后，当进程要访问页面2时将会产生缺页中断。此时OS根据最佳置换算法，将淘汰页面7： 先进先出置换算法（FIFO） 该算法总是淘汰最先进入内存的页面，即选择在内存中的驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老页面。 但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，含有全局变量、常用函数、例程等的页面，FIFO置换算法并不能保证这些页面不被淘汰： 最近最久未使用置换算法（LRU） FIFO置换算法之所以性能较差，是因为它所依据的条件是各个页面调入内存的时间，而页面调入的先后并不能反映页面的使用情况。而最近最久未使用（LRU）的页面置换算法，则是根据页面调入内存后的使用情况。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似。因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。 算法描述：选择最后一次访问时间距离当前时间最长的一页并淘汰之。即淘汰没有使用的时间最长的页。实现代价很高（时间戳或硬件方法） 把LRU算法作为页面置换算法是比较好的，它对于各种类型的程序都能适用，但实现起来有相当大的难度，因为它要求系统具有较多的支持硬件。所要解决的问题有： 一个进程在内存中的各个页面各有多久时间未被进程访问； 如何快速地知道哪一页最近最久未使用的页面。 为此，须利用以下两类支持硬件： 移位寄存器：定时右移 栈：当进程访问某页时，将其移出压入“栈顶”，“栈底”换出。 影响缺页次数的因素： 分配给进程的物理页面数 页面本身的大小 程序的编制方法 页面淘汰算法 请求分段存储管理方式请求分段中的硬件支持 段表机制： 存取方式：用于标识本分段存取属性是只执行、只读还是允许读/写 存在位P：用于指示该段是否已调入内存 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页在最近多长时间未被访问。 修改位M：表示该段在调入内存后是否被修改过 外存地址：本段在外存上的地址，盘块块号 增补位：本段在运行过程中是否做过动态增长 请求分段系统中的中断处理过程： 从中可以看出，对缺段中断的处理要比对缺页中断的处理复杂，因为段是不定长的。 地址变换机构：请求分段系统中的地址变换机构，是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，因而在地址变换时，若发现所要访问的段不在内存时，必须先将所缺的段调入内存，并修改了段表之后，才能再利用段表进行地址变换。为此，在地址变换机制中又增加了某些功能，如缺段中断的请求及其处理等。 下图表示出了请求分段系统的地址变换过程：（段号为S，段内地址为W） 分段的共享与保护 共享段表 为了实现分段共享，可在系统中配置一张共享段表所有各共享段都在共享段表中占有一表项。 共享进程计数count 记录有多少个进程需要共享该分段 存取控制字段 对于一个共享段，应给不同的进程以不同的权限 段号 对于一个共享段，不同的进程可以各用不同的段号去共享该段 共享段的分配 对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1； 当又有其它进程需要调用该共享段时，无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段 共享段的回收： 撤消在该进程段表中共享段所对应的表项 执行count∶=count-1操作 若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段； 否则(减1结果不为0)，则只是取消调用者进程在共享段表中的有关记录。 分段保护 越界检查 在段表寄存器中放有段表长度信息；同样，在段表中也为每个段设置有段长字段。 在进行存储访问时，首先，将逻辑地址空间的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断信号； 其次，还要检查段内地址是否等于或大于段长，若大于段长，将产生地址越界中断信号，从而保证了每个进程只能在自己的地址空间内运行。 存取控制检查：在段表的每个表项中，都设置了一个“存取控制”字段，用于规定对该段的访问方式。通常的访问方式有： 只读：只允许程序对该段中的程序或数据进行读访问； 只执行：只允许程序调用该段去执行，但不准读该段的内容，也不允许对该段执行写操作； 读/写：允许程序对该段进行读写访问。 环保护机构：它是一种功能较完善的保护机构。在该机制中规定：低编号的环具有高优先权，OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序，则被安排在外环上。 低编号的环具有高优先权，操作系统位于最核心环 内环可访问外环数据：一个程序可以访问驻留在相同环或较低特权环中的数据 外环可请求内环服务：一个程序可以调用驻留在相同环或较高特权环中的服务","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（六）：存储管理方式","slug":"计算机操作系统（六）：存储管理方式","date":"2021-03-20T01:38:35.000Z","updated":"2021-03-20T01:39:23.277Z","comments":true,"path":"8850f5f3d4be/","link":"","permalink":"https://ozzienicholas.gitee.io/8850f5f3d4be/","excerpt":"","text":"分页存储管理方式在分页存储管理的方式中，如果不具备页面对换功能，则称为基本的（纯）分页管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。 离散分配方式： 连续分配方式要求为一个进程分配连续的内存空间，会形成许多“碎片”，尽管采用“紧凑”技术可以解决这个问题，但要为移动大量信息花去不少的处理机时间，代价较高。 如果允许一个进程直接分散地装入到许多不相邻接的分区中，称为离散分配方式。 离散分配方式有分页存储管理方式和分段存储管理方式两种。 分页：把用户程序按逻辑页划分成大小相等的部分，称为页或虚页。从0开始编制页号，页内地址是相对于0编址。 页面与页表 页面和物理块： 页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并加以编号，从0开始编制页号，页内地址是相对于0编址。 物理块：内存按页的大小划分为大小相等的区域，称为物理块（物理页面，页框(frame)，帧），同样加以编号，如0＃块、1＃块等等 在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 页面大小：页面的大小应选择的适中，且页面大小应是2的幂，通常为512 B~8 KB 页面若太小：虽然可使内存碎片减小，从而减少了内存碎片的总空间， 有利于提高内存利用率，但也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存； 此外，还会降低页面换进换出的效率 页面若太大：虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。 例如：系统页面大小为1KB，逻辑地址为2170，求页号与页内偏移量 页号 P=INT[2170/1024]=2。 页内偏移量d=2170 mod 1024 =122 第0页 0~1023 第1页 1024~2047 第2页 2048~3071 综上所述，表示为(2,122) 主存分配：把用户程序的任一页分配到内存中的任一物理块，从而实现非连续的内存分配。 问题：如何管理、如何进行地址变换。 页表 分页系统中，将进程的每一页离散地存储在内存的任一物理块中，为每个进程建立一张页面映像表，简称页表。 作用：实现页号到物理块号的映射。 例如： 页表列出了用户程序的逻辑地址与其在主存中的物理地址间的对应关系。 一个页表中包含若干个表目，表目的自然序号对应于用户程序中的页号，表目中的块号是该页对应的物理块号。 页表的每一个表目除了包含指向页框的指针外，还包括一个存取控制字段，表目也称为页描述子。 例如： 地址变换机构 基本地址变换机构： 实现从逻辑地址到物理地址的转换，将逻辑地址中的页号转换为内存中的物理块号，通过页表来完成。 页表的实现 寄存器：变换速度快、成本高，适应小型系统。 页表驻留在内存：速度较低、成本低，适应大系统。 页表大多驻留在内存中，在系统中设置页表寄存器PTR(Page – Table Register)，在其中存放页表在内存中的始址和页表的长度。 进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，才将这两个数据装入页表寄存器。 地址结构：例如：32位地址，011为偏移量，1231为页号，最大可以有1M（2^20）页，每页4KB（2^12） 。 基本的地址变换机构： 每个进程对应一页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。 当进程要访问某个进程逻辑地址中的数据时，分为页号和页内地址两部分。 如果页号大于或等于页表长度，则表示本次所访问的地址已经超越进程的地址空间。 地址变换过程： 指令 LOAD 1,2500 的地址变换过程（块大小为1024B）。 地址变换过程： 把虚拟地址2500转换成页号P=2，位移量W=452； 如果页号2大于页表大小，则中断；否则继续； 页号2与页表起址1000运算（1000+2*20，设页描述子大小为20）得到页描述子地址为1040； 从页描述子中读取块号8； 根据页描述子的“存取控制”判断该指令是否被允许访问内存，如果不允许，则中断；否则继续； 块号8与位移量452运算（8*1024+452=9644，1024为页面大小）得到物理地址9644； 执行LOAD操作。 具有快表的地址变换机构： 由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。 第一次是访问内存中的页表，从中找到该页的物理块号，将此块号与页内偏移量W拼接以形成物理地址。 第二次访问内存时，才是从第一步所得地址中获得所需数据（或向此地址中写入数据），并将此页号与高速缓存中的所有页码进行比较。 在具有快表的地址变换机构中，为提高地址变换速度，在地址变换机构中增设一个具有并行查询能力的高速缓冲寄存器，又称为“联想寄存器”（Associative Memory）或“快表”，用以存放当前访问的那些页表项，快表通常可存放16-512个表项，如果设计得当，命中率可达90％以上。 两级和多级页表 现代的大多数计算机系统，都支持非常大的逻辑地址空间(232~264)。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。 例如，对于一个具有32位逻辑地址空间的分页系统，若规定页面大小为4 KB即212 B，则在每个进程页表中的页表项可达1M(220)个之多。若每个表项占用4个字节(32bit)， 故每个进程仅仅其页表就要占用4 MB的内存空间，而且还要求是连续的。 可以采用这样两个方法来解决这一问题： 采用离散分配方式来解决难以找到一块连续的大内存空间的问题 只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入 两级页表(Two-Level Page Table) ：可利用将页表分页，并离散地将各个页面分别存放在不同的物理块中，同样要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），每个页表项中记录了页表页面的物理块号： 两级页表结构： 每个物理块为4KB，恰好放一个1页页表（1024个项，每项4Byte），共需1024个这样的块。 具有两级页表的地址变换机构: 分段存储管理方式分段存储管理方式的引入 基本分段存储管理： 不便于信息共享、保护、动态增长和链接。 分页存储管理的主要目的是为了提高内存利用率，满足用户在编程和使用上的要求。 分段管理的主要目的： 方便编程：通常，一个作业是由若干个自然段组成。因而，用户希望能把自己的作业按照逻辑关系划分为若干个段；每个段都有自己的名字和长度；要访问的逻辑地址是由段名（段号）和段内偏移量决定；每个段都从0开始编址。这样，用户程序在执行中可用段名和段内地址进行访问。用户作业通常按逻辑关系分若干个段： LOAD 1, [A]|&lt;D&gt; STORE 1,[B]|&lt;C&gt; 信息共享：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的。为了实现的共享，也希望存储管理能与用户程序分段的组织方式相适应。 程序与数据的共享是以信息的逻辑单位为基础 信息保护：在多道程序环境下，为了防止其它程序对某种程序在内存中的数据有意无意的破坏，必须采用保护措施，对内存中信息的保护，同样是对信息的逻辑单位进行保护。因此，采用分段的组织和管理方式，对于实现保护功能，将是更有效和方便的。 动态增长：在实际使用中，往往有些段特别是数据段，会不断地增长，而事先又无法确切地知道数据段会增长到多大。这种动态增长的情况是其它几种存储管理方式都难于应付的；而分段存储管理方式却能较好地解决这一问题。 动态链接：通常，用户源程序经过编译所形成的若干个目标程序，还须再经过链接以形成可执行程序后，方能执行，进行的链接称为静态链接。动态链接是指在作业运行之前，并不把几个目标程序段链接起来。 分段系统的基本原理 分段存储管理方式中，作业的地址空间被分成若干个段(segment)，每个段定义了一组逻辑信息。 分段地址中的地址具有如下结构： 分段方式已得到许多编译程序的支持。 段表： 在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中的不同的分区中 系统为每个进程建立一张段映射表，简称为“段表” 每个段在段表中占一个表项，其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度 它记录了段号，段的首（地）址和长度之间的关系，每一个程序设置一个段表，放在内存,属于进程的现场信息。 利用段表实现地址映射： 分段系统的地址变换过程： 地址映射及存储保护机制： 分页和分段的主要区别： 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。 分段的目的是为了能更好地满足用户的需要。 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定， 决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址； 而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名， 又需给出段内地址。 整理如下： 信息共享 分段存储的一个优点是易于实现段的共享，即允许若干个进程共享一个或多个分段。 分页系统中虽然也能实现程序和数据的共享，但远不如分段系统方便。 可重入代码（Reentrant Code）又称为“纯代码”（Pure Code）是一种允许多个进程同时访问的代码。可重入代码是一种不允许任何进程对它进行修改的代码。 分页系统中共享editor的示意图： 分段管理的优缺点： 优点： 便于动态申请内存 管理和使用统一化 便于共享 便于动态链接 缺点：产生碎片，段还需要连续的存储空间。 段页式存储管理方式 基本原理 是分段和分页原理的结合 将用户程序分成若干个段，再把每一段分成若干个页，并为每一段赋予一个段名 段页式管理中，地址机构由段号、段内页号及页内地址三部分所组成 作业地址空间和地址结构： 在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需同时配置段表和页表。由于允许将一个段中的页进行离散分配，因而使段表的内容略有变化：它不在是段的内存始址和段长，而是页表始址和页表长度。 利用段表和页表实现地址映射： 在段页式系统中，需三次访问内存： 第一次访问，是访问内存中的段表。 第二次访问，是访问内存中的页表。 第三次访问，才是真正从第二次访问所得的地址中，取出指令或数据。 段页式系统中的地址变换过程：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（五）：存储器管理概述","slug":"计算机操作系统（五）：存储器管理概述","date":"2021-03-20T01:36:13.000Z","updated":"2021-03-20T01:37:41.145Z","comments":true,"path":"0f07f5c9c9f3/","link":"","permalink":"https://ozzienicholas.gitee.io/0f07f5c9c9f3/","excerpt":"","text":"存储器的层次结构 计算机的基本物理组成： 指令的执行过程： CPU与内存的关系： 传输数据流程简图： 存储器是计算机系统重要的组成部分，虽然存储器的容量不断扩大，但仍不能满足要求，因此存储器管理是操作系统的重要工作。 存储器包括内存（主存）和外存（磁盘） 存储器的功能是保存数据，存储器的发展方向是高速、大容量和小体积。 内存在访问速度方面的发展：DRAM、SDRAM、SRAM等； 硬盘技术在大容量方面的发展：接口标准、存储密度等。 主存储器管理技术分为两大类： 实存储器管理； 虚拟存储器管理。 存储器的物理组织、多级存储器： 存储组织是指在存储技术和CPU寻址技术许可的范围内组织合理的存储结构。其依据是访问速度匹配关系、容量要求和价格。主要有以下结构： “寄存器-内存-外存” 结构 “寄存器-缓存-内存-外存”结构； 微机中的存储层次组织： 访问速度越慢，容量越大，价格越便宜； 最佳状态应是各层次的存储器都处于均衡的繁忙状态（如：缓存命中率正好使主存读写保持繁忙）。 存储器的层次： 高速缓存（Cache）：CPU要读取一个数据时，首先从Cache(SRAM)中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就用相对慢的速度从内存中读取并送给CPU处理，同时把这个数据所在的数据块调入Cache中，可以使得以后对整块数据的读取都从Cache中进行，不必再调用内存。 程序的装入和链接 多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事就是分配内存。 源程序要运行通常经过编译（compile）-&gt; 链接(link) -&gt; 装入(load)等几个步骤： 程序的装入： 绝对装入方式 事先确定了程序将驻留在内存的什么位置，即在内存中的绝对地址。 装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。 绝对地址的产生： 程序员直接赋予。不仅要求程序员熟悉内存使用情况，而且一旦程序或数据被修改后，可能要改变程序中的所有地址。通常在程序中采用符号地址，在编译或汇编时，再将符号地址转换为绝对地址。 编译或汇编时产生 缺点：绝对装入方式只能将目标模块装入到内存中事先指定的位置。在多道程序环境下，不可能预知目标模块放在内存中的地址，因此绝对装入方式不适合在多道环境下使用。 可重定位装入方式 程序中目标模块的地址通常从0开始，其他地址都是相对于0计算——相对地址 把在装入时对目标程序中指令和数据的地址修改过程称为重定位，又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。 例如： 缺点： 不断的分配和回收，造成内存中小空闲块很多，总空闲空间量够，但分配不了。 理论上的解决办法：办法：紧凑（移动），但该装入方法不支持。 可重定位方式不允许程序运行时在内存中移动位置。 动态运行时装入方式 动态运行时的装入程序，是在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址 程序的链接： 静态链接方式 在程序运行前，先将各目标模块及所需的库函数链接成一个完整的装配模块，以后不再拆开 在将这几个目标模块装配成一个装入模块时，须解决以下两个问题 对相对地址进行修改 变换外部调用符号 例如： 装入时动态链接 将用户的源程序编译后所得的一组目标模块在装入内存时采用边装入边链接的方式 便于修改和更新 便于实现对目标模块的共享 例如： 缺点：应用程序在每次运行的模块可能不相同。 运行时动态链接 运行时动态链接方式将对某些模块的链接推迟到执行时才进行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。 凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。 例如： 连续分配存储管理方式单一连续分配 连续分配方式为一个用户程序分配一个连续的内存空间。 单一连续分配是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。 把内存分为 系统区：OS使用，通常放在内存低址部分 用户区：用户可使用的全部内存空间 存储器保护机构不健全，易造成系统破坏。 优缺点： 优点：易于管理 缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存 例如： 固定分区分配 最简单的可运行多道程序的存储管理方式。 内存用户空间划分为若干个固定大小的区域，每个分区中只装入一道作业。 划分分区的方法 分区大小相等：即使所有的内存分区大小相等 太大：浪费 太小：不够用 分区大小不等：根据程序大小决定所使用的分区，划分为多个大、中、小搭配的分区 大班在大教室、小班在小教室 内存分配 ：分区的信息根据分区使用表管理 问题：并发进程数受分区个数的制约！ 出现：有内存却不能运行程序或大进程无法运行！ 动态分区分配 根据进程的实际需要，动态地为之分配内存空间。 分配中数据结构 空闲分区表 记录每个空闲分区的情况 空闲分区链 实现对空闲分区的分配和链接 例如： 基于顺序搜索的动态分区分配算法 分配算法主要有：首次适应算法FF、循环首次适应算法、最佳适应算法、最坏适应算法 首次适应被认为最好、最快。其次是循环，最佳最差（每次分配后剩下小碎片，难再分，不得不经常压缩内存，反而浪费CPU） 首次适应算法FF： 空闲分区链以地址递增顺序链接 分配时从链首开始查找，找到一个大小可满足的空闲分区，划出一块给请求者 优点：简单；优先利用低地址空闲区，保留高地址大空闲区 缺点：会造成在低地址部分很多难以利用的小空闲分区，查找效率低 循环首次适应算法： 每次分配时从上一次找到空闲分区的下一个空闲区开始查找 优点：减少查找空闲分区开销，空闲分区分布更均匀 缺点：缺乏大的空闲区 最佳适应算法： 空闲区按容量由小到大排序 每次分配时，把能满足要求、又是最小的分区分配给作业 优点：不缺乏大的空闲区 缺点：会在存储器中留直许多难以利用的小分区——“零头（或碎片）”；查找效率低 最坏适应算法： 空闲区按容量由大到小排序 每次分配时，把能满足要求、又是最大的分区分配给作业 优点：剩余的空间最大化，不出现太小的“零头” 缺点：缺乏大的空闲区 分区分配操作 回收内存 进程运行结束释放内存时，系统根据回收区的首地址，把它插入到空闲链表中。根据回收区的位置，有四种情况需处理： 情况1：回收区与插入点的前一个空闲分区相邻接 情况2：回收区与插入点的后一个空闲分区相邻接 情况3：回收区同时与插入点的前、后两个分区相邻接 情况4：回收区不与任何空闲区邻接 以上4种情况分别对应如下： 分区式存储管理的优缺点： 优点： 便于动态申请内存 便于共享内存 便于动态链接 缺点：碎片问题(外碎片)，要求连续的内存空间，内存利用率不高，受实际内存容量限制。 碎片问题：经过一段时间的分配回收后，内存中存在很多很小的空闲块。它们每一个都很小，不足以满足分配要求；但其总和满足分配要求，这些空闲块被称为碎片。 问题解决： 紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域。缺点是开销大，而且移动时机不好把握。 基于索引搜索的动态分区分配算法动态可重定位分区分配 动态重定位的引入： 连续分配存在的问题：必须有足够大的连续空间才能分配。可以用“拼接”或“紧凑”方法来解决： 动态重定位的实现 作业装入内存后的所有地址仍是相对地址，将相对地址转换成物理地址的工作在指令执行时进行 需要有硬件地址变换机构的支持 例如： 动态重定位分区分配算法： 与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了“紧凑”功能，通常是在找不到足够大的空闲分区来满足用户需求时，进行紧凑。 在一个分区释放后立即移动。 当请求得不到满足时再移动。 例如： 可重定位分区的优缺点 优点：决了可变分区分配所引入的“外零头”问题。消除内存碎片，提高内存利用率。 缺点：提高硬件成本，紧凑时花费CPU时间。 对换（Swapping） 对换的引入： 对换（也称交换）技术，最早用在单用户系统，在内存中仅驻留一道用户作业。 所有其它作业都驻留在外存的后备队列上，只调入一个作业进入内存运行；此作业的时间片用完时，该作业调至外存，再将后备队列上的另一个作业调入内存；也让它运行一个时间片的时间，然后又将它调出，再调下一个作业进入内存。 因为其效率太低，其CPU大约有一半的时间，都处于空闲状态。 所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存。对换是提高内存利用率的有效措施。 如果对换是以整个进程为单位，称为“整体对换”或“进程对换”。 如果对换是以“页”或“段”为单位进行的，则称为“页面对换”或“分段对换”，又统称为“部分对换”。 为了实现进程对换，系统必须能实现以下三方面的功能： （1）对换空间的管理； （2）进程的换出； （3）进程的换入。 对换空间的管理 外存中对换区主要存放从内存中换出的进程，对换空间管理的主要目标是提高进程换入和换出的速度。 对换区中空闲盘块的管理：在系统中配置相应的数据结构，记录外存的使用情况。形式与内存在动态分区分配方式中所用数据结构相似，即用空闲分区表或空闲分区链。在空闲分区表中的每个表目中应包含两项， 即对换区的首址及其大小，它们的单位是盘块号和盘块数。 对换区的分配采用连续分配方式，分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法。 进程的换出与换入 进程的换出：系统先选择处于“阻塞”状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上。若传送未出现错误，便回收其所占用的内存空间，并对该进程的进程控制块做相应的修改 进程的换入：系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（四）：死锁","slug":"计算机操作系统（四）：死锁","date":"2021-03-20T01:35:15.000Z","updated":"2021-03-20T01:35:46.105Z","comments":true,"path":"35479f43ab63/","link":"","permalink":"https://ozzienicholas.gitee.io/35479f43ab63/","excerpt":"","text":"死锁概述 死锁概念：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃。 死锁的定义：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。 关于死锁的一些结论： 参与死锁的进程最少是两个； 参与死锁的进程至少有两个已经占有资源； 参与死锁的所有进程都在等待资源； 参与死锁的进程是当前系统中所有进程的子集。 资源问题：在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印机、数据文件、队列、信号量等。 可重用性资源和消耗性资源： 可重用性资源：可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质： 每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。 进程在使用可重用性资源时，须按照这样的顺序： 请求资源。如果请求资源失败，请求进程将会被阻塞或循环等待； 使用资源。进程对资源进行操作，如用打印机进行打印； 释放资源。当进程使用完后自己释放资源。 系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。 可消耗性资源：可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的，它具有如下性质： 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0； 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0； 进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。 可抢占性资源和不可抢占性资源： 可抢占性资源：指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占。 不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。 计算机系统中的死锁： 竞争不可抢占性资源引起死锁：通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。如下表示共享文件时的死锁情况 ： 竞争可消耗资源引起死锁：如下表示在三个进程之间，在利用消息通信机制进行通信时所形成的死锁情况： 进程推进顺序不当引起死锁： 若并发进程 P1 和 P2 按曲线④所示的顺序推进，它们将进入不安全区D内。此时P1保持了资源R1, P2保持了资源R2，系统处于不安全状态。因为这时两进程再向前推进，便可能发生死锁。例如，当 P1 运行到 P1:Request(R2) 时，将因 R2 已被 P2 占用而阻塞；当 P2 运行到 P2: Request(R1) 时，也将因 R1 已被 P1 占用而阻塞，于是发生了进程死锁。 产生死锁的必要条件： 互斥条件：进程对所分配到的资源进行排它性的使用。 请求和保持条件：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有。 不剥夺条件：进程已获得的资源在未使用完之前不能被剥夺。 环路等待条件：在发生死锁时，必然存在一个 “进程—资源” 循环等待的环形链。 处理死锁的基本方法： 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止发生死锁。 避免死锁：不须采用各种限制措施去破坏产生死锁的必要条件，防止系统进入不安全状态，从而避免发生死锁，只需在事先加以较弱的限制条件。 检测死锁：不须检查系统是否已进入不安全区，允许系统在运行过程中发生死锁。 解除死锁：常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。 预防死锁 破坏 “请求和保持” 条件：所有进程在开始运行之前必须一次性的申请整个运行过程所需的全部资源。 优点：简单、易于实现、安全。 缺点：资源浪费严重、进程延迟运行。 破坏 “不可抢占” 条件：进程逐个地申请所需资源，当一个已经保持了某些资源的进程申请新资源而不能得到满足时，必须放弃所有已保持的资源。 缺点：实现复杂、代价高昂；延长了进程的周转时间，还增加了系统开销，降低了系统的吞吐量。 破坏 “循环等待” 条件：系统将所有资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序。 优点：资源利用率系统吞吐量较高。 缺点：在资源管理和资源申请方面仍有问题 例如： 存在问题：资源的需求顺序不等于序号，仍存在资源浪费。 其资源利用率和系统吞吐量，都有较明显的改善，但也存在下述严重问题： 资源所分配的序号，必须相对稳定，这就限制了新设备类型的增加。 进程使用各资源的顺序，与系统规定的顺序不同，造成对资源的浪费。 按规定次序申请资源的方法，必然会限制了用户简单、自主地编程。 避免死锁 系统安全状态： 在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。 所谓安全状态，是指系统能按某种进程顺序（P1, P2, …，Pn，称&lt;P1, P2, …, Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 安全状态举例： 假定系统中有三个进程 P1、 P2 和 P3，共有12台磁带机。 进程 P1 总共要求 10 台磁带机，P2 和 P3 分别要求 4 台和 9 台。 假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示： 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如，在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。 利用银行家算法避免死锁： 银行家算法中的数据结构： 可利用资源向量Available。这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j] = K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，表示进程i当前已分得Rj类资源的数目为K。 需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个，方能完成其任务。 即： 银行家算法步骤：设Requesti是进程Pi的请求向量，如果Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： （1）如果Requesti[j] ≤ Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 （2）如果Requesti[j] ≤ Available[j]，便转向步骤(3)；否则， 表示尚无足够资源，Pi须等待。 （3）系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值： Available[j] := Available[j] - Requesti[j]; Allocation[i,j] := Allocation[i,j] + Requesti[j]; Need[i,j] := Need[i,j] - Requesti[j]; （4）系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性算法： （1）设置两个向量： 工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work := Available; Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i] := false; 当有足够资源分配给进程时， 再令Finish[i] := true。 （2）从进程集合中找到一个能满足下述条件的进程； Finish[i] = false; Need[i,j] ≤ Work[j]; 若找到， 执行步骤(3)， 否则，执行步骤(4)。 （3）当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j] := Work[i] + Allocation[i,j]; Finish[i] := true; 执行步骤（2） （4）如果所有进程的Finish[i] = true都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。 死锁的检测 资源分配图：系统死锁可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个对偶G =（N，E），具有下述形成的定义和限制： N被分为两个互斥的子集，一组进程结点P=（p1，p2，…，pn），一组资源结点R={r1，r2，…，rn}，N=P∪R。如下图： 资源分配图表示法： 资源类：用方框表示（资源的不同类型） 资源实例：用方框中的圆点表示（存在于每个资源中） 进程：用圆圈中加进程名表示 分配边：资源实例进程的一条有向边 申请边：进程资源类的一条有向边 死锁定理：如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。 有环有死锁： 有环无死锁： 死锁定理——资源分配图化简： 找出一个既不阻塞又非独立的进程结点pi，在顺利的情况下pi可获得资源而继续运行，再释放所有资源。消去pi所有的请求边和分配边，将其变为孤立结点。 再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边。 在进行一系列化简后若能消去图中所有的边，使所有进程结点成为孤立结点，则称该图是可完全简化的；否则是不可完全简化的。 已经证明：所有的化简顺序都得到相同的不可简化图。同样可以证明，S为死锁的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件称为死锁定理。 死锁的解除 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。 常用的方法： 抢占资源：从其他进程剥夺足够的资源给死锁进程，以解除死锁状态。 终止进程： 撤消所有死锁进程。 按照某种顺序逐个地撤消代价最小的进程，直至有足够的资源可用，使死锁状态消除；所谓代价是指优先级、运行代价、进程的重要性和价值等。 终止进程的方法： 终止所有死锁进程： 这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了。 但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终止真可谓“功亏一篑”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一列举。 逐个终止进程： 稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态解脱出来为止。 但该方法所付出的代价也可能很大。因为每终止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止另一个进程。另外，在采取逐个终止进程策略时，还涉及到应采用什么策略选择一个要终止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是“代价最小”，很难有一个精确的度量。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（三）：处理机调度","slug":"计算机操作系统（三）：处理机调度","date":"2021-03-20T01:31:22.000Z","updated":"2021-03-20T01:31:50.948Z","comments":true,"path":"29326ada3e53/","link":"","permalink":"https://ozzienicholas.gitee.io/29326ada3e53/","excerpt":"","text":"处理机调度的层次和调度算法的目标处理机调度的层次 高级调度： 作业调度或长程调度，也称为接纳调度。 主要任务是按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入/输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利。 高级调度的时间尺度通常是分钟、小时或天。 在每次作业调度时，须决定： 接纳多少个作业：取决于多道程序度，即允许多少个作业同时在内存中运行。 要进行适当地折中，作业太多会使服务质量下降，作业太少会使资源利用率低。 接纳哪些作业：取决于作业调度算法，常用的作业调度算法包括先来先服务、短作业优先、作业优先权调度、响应比调度算法 低级调度： 进程调度或短程调度。 主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它。 常见的低级调度有非抢占式和抢占式两种。 低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效。 中级调度： 引入目的是为了提高内存利用率和系统吞吐量，使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。 主要任务是按照给定的原则和策略，将处于外存对换区中的重又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。 概念解释： 多道程序度：即允许多少个作业同时在内存中运行。 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。 吞吐量：是指在单位时间内系统所完成的作业数。 处理机调度算法的目标 处理机调度算法的共同目标： 资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算： 公平性。公平性是指应使诸进程都获得合理的CPU 时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。 平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。 策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。 批处理系统的目标： 平均周转时间短。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为： 为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间的具体分配状况，往往使用带权周转时间，即作业的周转时间T与系统为它提供服务的时间Ts之比，即W = T/Ts。而平均带权周转时间则可表示为： 系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。 处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由上所述可以看出，这些要求之间是存在着一定矛盾的。 实时系统的目标： 截止时间的保证。 可预测性。 分时系统的目标： 响应时间快。 均衡性。 作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。 操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。 作业和作业步作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。 作业控制块为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业运行时间)、资源需求(预计运行时间、要求内存大小等)、资源使用情况等。 作业运行的三个阶段和三种状态作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。即： 作业阶段 作业状态 收容阶段 后备状态 运行阶段 运行状态 完成阶段 完成状态 作业调度的主要任务 作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度在每次执行作业调度时，都需做出以下两个决定。 接纳多少个作业 接纳哪些作业 先来先服务 (first-come first-served，FCFS) 调度算法： FCFS 是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。 当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。 在采用FCFS算法时，人—机无法实现交互。 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。 短作业优先 (short job first，SJF) 的调度算法： 由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。 SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。 SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。 SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点： 必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。 对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。 优先级调度算法 (priority-scheduling algorithm，PSA) 和 高响应比优先调度算法 (Highest Response Ratio Next，HRRN) ： 我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。 高响应比优先算法是如何实现的呢? 如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为： 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比RP。据此，优先又可表示为： 进程调度进程调度的任务、机制和方式 进程调度的任务主要有： 保存处理机的现场信息。 按某种算法选取进程。 把处理器分配给进程。 为了实现进程调度，在进程调度机制中，应具有排队器、分派器、上下文切换器三个基本部分，如图： 进程调度方式： 非抢占方式：当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才把处理机分配给更为重要或紧迫的进程。 优点：算法简单，系统开销小；缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束。 引起进程调度的因素： 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行； 执行中的进程因提出I/O请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语。 抢占方式：当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。 优点：适于时间要求严格的实时系统；缺点：调度算法复杂，系统开销大。 主要有以下原则： 优先权原则：允许高优先权的新到进程抢占当前进程的处理机。 短作业（进程）优先原则：允许执行时间短的新到进程抢占当前进程的处理机。 时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统。 轮转调度算法 轮转法的基本原理：在轮转(RR)法中，系统将所有的就绪进程按 FCFS 策略排成一个就绪队列。系统可设置每隔一定时间（如30 ms）便产生一次中断，去激活进程调度程序进行调度，把 CPU 分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。 进程切换时机：在 RR 调度算法中，应在何时进行进程的切换，可分为两种情况： 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。 时间片大小的确定：在轮转算法中，时间片的大小对系统性能有很大的影响。下图给出了时间片大小对响应时间的影响，其中图(a)是时间片略大于典型交互的时间，而图(b)是时间片小于典型交互的时间： 下图给出了时间片分别为q = 1和q = 4时对平均周转时间的影响： 优先级调度算法 优先级调度算法的类型：优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种： 非抢占式优先级调度算法。 抢占式优先级调度算法。 优先级的类型： 静态优先级：静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个： 进程类型。 进程对资源的需求。 用户要求。 动态优先级：动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。 多队列调度算法如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多级队列调度算法能够在一定程度上弥补这一缺点。 多队列反馈调度算法 调度机制： 设置多个就绪队列。如图： 每个队列都采用FCFS算法。 当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。 当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，依此类推。 当进程最后被降到第n队列后，在第n队列中便采取按PR方式运行。 按队列优先级调度。 调度程序首先调度最高优先级队列中的诸进程运行。 仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1～(i-1)所有队列均空时，才会调度第i队列中的进程运行。 如果处理机正在第 i 队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。 调度算法的性能：在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。 用户类型可分为： 终端型用户。 短批处理作业用户。 长批处理作业用户。 基于公平原则的调度算法 在实施公平调度算法时系统中必须具有这样一些功能： 跟踪计算每个进程自创建以来已经执行的处理时间。 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。 保证调度算法： 保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。 一种比较容易实现的性能保证是处理机分配的公平性。 如果在系统中有 n 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 1/n。 公平分享调度算法： 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 实时调度在实时系统中，可能存在着两类不同性质的实时任务，即 HRT 任务和 SRT 任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。 实现实时调度的基本条件： 提供必要的信息。为了实现实时调度，系统应向调度程序提供有关任务的信息： 就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。 开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间，或者完成截止时间。 处理时间，一个任务从开始执行，直至完成时所需的时间。 资源要求，任务执行时所需的一组资源。 优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对”优先级，供调度程序参考。 系统处理能力强。在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。 假定系统中有 m 个周期性的硬实时任务 HRT，它们的处理时间可表示为 Ci，周期时间表示为 Pi，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的： 提高系统处理能力的途径有： 采用单处理机系统。但须增强其处理能力，以显著地减少对每一个任务的处理时间； 采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为： 采用抢占式调度机制。在含有 HRT 任务的实时系统中，广泛采用抢占机制。这样便可满足 HRT 任务对截止时间的要求，但这种调度机制比较复杂。 具有快速切换机制。为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力： 对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。 快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。 实时调度算法的分类（可以按不同方式对实时调度算法加以分类）： 根据实时任务性质，可将实时调度的算法分为： 硬实时调度算法 软实时调度算法 按调度方式，则可分为： 非抢占调度算法。又可分为： 非抢占式轮转调度算法 非抢占式优先调度算法 抢占调度算法。可根据抢占发生时间的不同而进一步分成： 基于时钟中断的抢占式优先级调度算法。 立即抢占的优先级调度算法。 优先级倒置： 优先级倒置的形成：当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。例如： P3最先执行，在执行了 P(mutex) 操作后，进入到临界区 CS-3。在时刻a，P2就绪，因为它比 P3 的优先级高，P2 抢占了 P3 的处理机而运行。 优先级倒置的解决方法： 一种简单的解决方法 —— 动态优先级继承，规定：假如进程 P3 在进入临界区后，P3 所占用的处理机就不允许被抢占。 例如：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（二）：进程的初步认识","slug":"计算机操作系统（二）：进程的初步认识","date":"2021-03-19T17:04:05.000Z","updated":"2021-03-20T01:03:05.086Z","comments":true,"path":"279bab449d3d/","link":"","permalink":"https://ozzienicholas.gitee.io/279bab449d3d/","excerpt":"","text":"进程与线程的知识体系图 在之后的文章中会陆续讲到，这里我们只说线程的知识 前言操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的CPU只有一一个，它们也支持（伪） 并发操作。它们会将一 一个单独的CPU抽象为多个虚拟机的CPU。可以说，没有进程的抽象，现代操作系统将不复存在。 在许多多道程序系统中， CPU会在进程间快速切换，使每个程说序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能运行多个进程。这样就会让我们产生并行的错觉。有时候人们说的伪并行（pseudoparallelism)其实就是这种情况，以此来区分多处理器系统（该系统由两个或多个CPU来共享同一个物理内存） 再解释一下伪并行：伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快。通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。 缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。 因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。下面我们就来探讨一下进程模型 进程模型在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程，简称为进程（process) 。 一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟CPU，但是实际情况是CPU会在各个进程之间进行来回切换。 如上图所示，这是一个具有4个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化： 在上图中，这4道程序被抽象为4个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。 从下图我们可以看到，在观察足够长的一 一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行： 因此，当我们说一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU)，每一个核也只能一次运行一个线程。 由于CPU会在各个进程之间来回快速切换，所以每个进程在CPU中的运行时间是无法确定的。并且当同一个进程再次在CPU中运行时，其在CPU内部的运行时间往往也是不固定的。这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行 了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？ 进程的创建操作系统需要一些方式来创建进程。下面是一 些创建进程的方式 系统初始化（init) 正在运行的程序执行了创建进程的系统调用（比如fork) 用户请求创建一个新进程 初始化一个批处理工作 系统初始化启动操作系统时，通常会创建若干个进程。 其中有些是前台进程（numerous processes) ，也就是同用户进行交互并替他们完成工作的进程。 一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。 还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。 进程运行在后台用来处理一些活动像是 e-mail, web网页，新闻，打印等等被称为守护进（daemons)。大型系统会有很多守护进程。在UNIX中，ps 程序可以列出正在运行的进程，在Windows中，可以使用任务管理器。 系统调用创建除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出系统调用用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的CPU上也可以使工作做的更快。 用户请求创建在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的UNIX系统中运行X,新进程将接管启动它的窗口。在Windows中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。 批处理创建最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。 当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。 从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。 该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。 该系统调用告诉操作系统创建一个新进程， 并直接或间接指示在其中运行哪个程序。 在UNIX中，仅有一个系统调用来创建一个新的进程，这个系统调用就是fork 。这个调用会创建一个与调用进程相关的副本。在fork后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在shell中输出sort命令时，shell 会fork 一个子进程然后子进程去执行sort命令。这两步过程的原因是允许子进程在fork之后但在execve之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。 而在Windows中，情况正相反，一个简单的Win32功能调用CreateProcess ，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有10个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了CreateProcess Win 32中大概有100个其他的函数用于处理进程的管理，同步以及相关的事务。 下面是UNIX操作系统和Windows操作系统系统调用的对比： 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。 在UNIX中，子进程的地址空间是父进程的一个拷贝，但是确是两个不同的地址空间；不可写的内存区域是共享的。某些UNIX实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过写时复制（copy- on- write)共享， 这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。 再次强调，可写的内存是不能被共享的。 但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。 进程的终止进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，但是通常是由于以下情况触发： 正常退出（自愿的） 错误退出（自愿的） 严重错误（非自愿的） 被其他进程杀死（非自愿的） 正常退出多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。 这个调用在UNIX中是exit，在Windows中是ExitProcess 。 面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。 错误退出进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令 1CC foo.c 为了能够编译foo.c但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。 严重错误进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是0等。 在有些系统比如UNIX中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。 被其他进程杀死第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。 在UNIX中，这个系统调用是kill。在Win32中对应的函数是TerminateProcess（注意不是系统调用）。 进程的层次结构在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。 UNIX进程体系在UNIX中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。 每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号kill 掉。 另一个例子，可以用来说明层次的作用：考虑UNIX 在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中。当init进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。 这些进程等待用户登录。如果登录成功，该登录进程就执行一个shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以init为根的进程树： 12345678910111213init─┬─NetworkManager（5427) ├─NetworkManagerD（5441) ├─acpid（5210) ├─apache2（6966)─┬─apache2（2890) │ ├─apache2（2893) │ ├─apache2（7163) │ ├─apache2（7165) │ ├─apache2（7166) │ ├─apache2（7167) │ └─apache2（7168) ├─atd（6369) ├─avahi-daemon（5658)───avahi-daemon（5659) ├─bonobo-activati（7816)───&#123;bonobo-activati&#125;（7817) Windows进程体系相反，Windows中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该询柄可以用来控制子进程。 然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在UNIX中，进程不能剥夺其子进程的进程权。（这样看来， 还是Windows比较渣）。 进程状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在shell命令中 1cat chapter1 chapter2 chapter3 | grep tree 第一个进程是cat ，将三个文件级联并输出。 第二个进程是grep ，它从输入中选择具有包含关键字tree的内容。 根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况：grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。当一个进程开始运行时，它可能会经历下面这几种状态（下图为进程状态切换图）： 图中会涉及三种状态： 运行态，运行态指的就是进程实际占用CPU时间片运行时 就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态 阻塞态，除非某种外部事件发生，否则进程不能运行 逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获得CPU时间分片。 第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。 三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些系统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX，当进程从管道或特殊文件（例如终端） 中读取没有可用的输入时，该进程会被自动终止。 转换2和转换3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。 转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。 程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。 当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4。如果此时没有其他进程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再轮到它运行。 从上面的观点引入了下面的模型： 基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。 操作系统最底层的就是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。 事实上，调度程序只是一段非常小的程序。 进程的实现操作系统为了执行进程间的切换，会维护着一张表格，这张表就是进程表（process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 下面展示了一个典型系统中的关键字段 典型的进程表表项中的一些字段 第一列内容与进程管理有关，第二列内容与存储管理 有关，第三列内容与文件管理有关。 存储管理的text segment、data segment、stack segment更多了解见下面这篇文章： 程序员需要了解的硬核知识之汇编语言（全） 现在我们应该对进程表有个大致的了解了，就可以在对单个CPU.上如何运行多个顺序进程的错觉做更多的解释。 与每一/0类相关联的是一个称作中断向量（interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。 假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。 然后软件就随即接管一切剩余的工作。 当中断结束后，操作系统会调用一个C程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。 然后将控制权转移给一 一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程： 硬件压入堆栈程序计数器等 硬件从中断向量装 入新的程序计数器 汇编语言过程保存寄存器的值 汇编语言过程设置新的堆栈 C中断服务器运行（典型的读和缓存写入） 调度器决定下面哪个程序先运行 C过程返回至汇编代码 汇编语言过程开始运行新的当前进程 一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（一）：认识操作系统","slug":"计算机操作系统（一）：认识操作系统","date":"2021-03-19T17:01:56.000Z","updated":"2021-03-20T01:02:30.237Z","comments":true,"path":"bfb7f7b98435/","link":"","permalink":"https://ozzienicholas.gitee.io/bfb7f7b98435/","excerpt":"","text":"操作系统简介 现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。 在硬件的基础上，计算机安装了一层软件，这些软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户的需求，这种软件被称之为 “操作系统”， 我们一般常见的操作系统主要有：Windows、Linux、FreeBSD 或 OS X，这种带有图形界面的操作系统，被统称为 “图形用户界面（GUI）”，而基于文本、命令行通常被统称为 “Shell”，如下是我们所探讨的操作系统的部件（这是一个操作系统的简化图）： 最下面是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，硬件之上是软件。 大部分计算机有两种运行模式：“内核态” 和 “用户态”，软件中最基础的部分是操作系统，它运行在内核态中，内核态也被称为 “管态” 和 “核心态”，它们都是操作系统的运行状态，只是叫法不同而已。操作系统具有硬件的访问权，可以在执行机器能够运行的任何指令。软件的其余部分运行在用户态下。 “用户接口程序（Shell 或者 GUI）”处于用户态中，并且它们处在用户态的最底层，允许用户运行其他的程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等等，而且，越靠近用户态的应用程序越容易编写。假如你不喜欢某个电子邮件阅读器，你可以随意换一个软件，但你不能自行写一个操作系统或者是中断处理程序，这个程序是由硬件保护的，防止外部对其进行修改。 计算机硬件简介操作系统与硬件 操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源，因此，操作系统必须足够了解硬件的运行，所以这里要先介绍现代计算机中的硬件。 从概念上来看，一个简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O设备都和总线串联起来并通过总线与其他设备进行通信。 简单个人计算机的组件： CPU CPU是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个CPU的执行周期是从内存中提取第一条指令、 解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。 每个 CPU 都有一组可以执行的特定指令集。因此，X86 的 CPU 不能执行 ARM 的程序并且ARM 的 CPU 也不能执行 X86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。 除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。 其中之一就是程序计数器(program counter) ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。另一个寄存器是堆栈指针(stack pointer) ，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。 还有一个寄存器是PSW(Program Status Word)程序状态字寄存器，这个寄存器是由操作系统维护的 8 个字节（64位） long类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW。用户程序通常可以读取整个PSW,但通常只能写入其某些字段。PSW在系统调用和 1/ 0 中起着重要作用。 操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时， 操作系统会保存所有寄存器的值，以便于后续重新运行该程序。为了提升性能，CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。 许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个CPU可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对N+ 1条指令解码，还可以读取N + 2条指令。像这样的组织形式被称为流水线(pipeline) 。 比流水线更先进的设计是超标量(superscalar) CPU，该设计如下： 在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、 解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。 这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。 除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。 当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下， 剩下的一部分运行在用户态下。 注意，设置 PSW 模式的二进制位为内核态也是禁止的。 用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 l/O 和内存保护的所有指令是禁止执行的。 为了获取操作系统的服务，用户程序必须使用系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。 需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。 多线程和多核芯片 多线程或超线程的特性起初是奔腾处理器（Intel Pentinum 4）引入的。 多线程允许 CPU 保持两个不同的线程状态并且在纳秒级(nanosecond)的时间完成切换，近似地说，线程是一种轻量级的进程。 例如，如果一个进程想要从内存中读取指令（这通常会经历几个时钟周期），多线程CPU则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。 对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的CPU。比如一个有两个CPU的操作系统，并且每个CPU运行两个线程，那么这对于操作系统来说就可能是4个CPU。 除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。 如图是带有共享 L2 缓存的 4 核芯片： 而带有分离 L2缓存的 4 核芯片则如下： 而说到线代的 GPU，则是指有成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算。 内存计算机的第二个主要的组件就是内存，目前采用了不同的处理方式，存储系统采用一种分层次的结构： 顶层的存储器访问效率最高，但是容量最小，成本也最高，以此类推。 高速缓存 位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行（cache lines） 为64字节，内存地址的 0 一 63 对应高速缓存行0，地址 64- 127 对应高速缓存行的1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。 高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。 随机存储器（RAM） ：内存中最重要的一 种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。 大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权， 缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 /home/ ast/projects/minix3/src/kernel/clock.c，这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个Web页面(URL)的地址转换为网络地址（P地址）后，这个转换结果也可以缓存起来供将来使用。 在任何缓存系统中，都会有下面这几个噬需解决的问题： 何时把新的内容放进缓存 把新的内容应该放在缓存的哪一行 在需要空闲空间时，应该把哪块内容从缓存中移除 应该把移除的内容放在某个较大存储器的何处 并不是每个问题都与每种缓存情况有关。对于CPU缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。 缓存是解决问题的一种好的方式，所以现代CPU设计了两种缓存。第一级缓存或者说是 L1 cache，总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个L1 cache。典型的L1 cache的大小为16 KB。另外，往往还设有二级缓存，也就是L2 cache，用来存放最近使用过的关键字，一 一般是兆字节为单位。L1 cache和L2 cache最大的不同在于是否存在延迟。访问L1 cache没有任何的延迟，然而访问L2 cache会有1 — 2个时钟周期的延后。 什么是时钟周期？计算机处理器或CPU的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz） 或千兆赫（GHz）。例如， 一个4 GHz处理器每秒执行4,000,000,000个时钟周期。 计算机处理器可以在每个时钟周期执行一条或多 条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的CPU在每个时钟周期只能执行一条指令， 而现代处理器在每个时钟周期可以执行多条指令。 主存 在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做RAM（Random AccessMenmory）。 除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。 ROM（Read Only Memory）中的内容一 旦存储后就不会再被修改。它非常快而且便宜。（如果有 人问你，有没有什么又快又便宜的内存设备，那就是ROM了）在计算机中，用于启动计算机的引导加载模块（也就是bootstrap ）就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。 EEPROM（Electrically Erasable PROM） 和闪存（flash menory）也是非易失性的，但是与ROM相反，它们可以擦除和重写。不过重写它们需要比写入RAM更多的时间，所以它们的使用方式与ROM相同，但是与ROM不同的是他们可以通过重写字段来纠正程序中出现的错误。 闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。 还有一类是CMOS，它是易失性的。许多计算机都会使用CMOS存储器保持当前时间和日期。 磁盘 磁盘（也就是硬盘），同RAM相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了 三个数量级。磁盘访问慢的原因是磁盘的构造不同。 磁盘驱动器的构造： 每个磁道划分若干扇区（如图），扇区的值是512字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要1ms。而随机移到一个柱面的典型时间为5ms至10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s ，而高速磁盘的速率是160MB/s 。需要注意，固态硬盘(Solid State Disk, SSD) 不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中， 与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。 许多计算机支持一种著名的虚拟内存机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit, MMU) 的部件来完成。 缓存和MMU的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为上下文切换（ context switch) ，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。 I/O 设备 I/O设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。 I/O设备另一部分是设备本身，设备本身有一一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。 每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为设备驱动程序(device driver) 。每个控制器厂 家都应该针对不同的操作系统提供不同的设备驱动程序。 为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径： 第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是UNIX 系统采用的工作方式 第二个途径是在一个操作系统文件中设置一个入口， 通知该文件需要一个设备驱动程序， 然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是Windows 采用的工作方式 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如USB和IEE 1394都需要动态可装载的设备驱动程序。 每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了I/O 端口空间。 在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下： 启动设备并发出中断的过程： 如上图所示，这是一个三步的I/O过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。 然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤2中使用某些总线向中断控制器发送信号。 如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在CPU的一个引脚上面声明，这就是步骤3。 在第4步中，中断控制器把该设备的编号放在总线上，这样CPU可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。 一旦CPU决定去实施中断后，程序计数器和PSW就会被压入到当前堆栈中并且CPU会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作中断向量(interrupt vector) 。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和PSW寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令， 这个过程如下： 总线 随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括IBM PC总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理1/O设备以及CPU到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现： 上图中的 x86 系统包含很多总线，高速缓存、内存、PCle、 PCI、 USB、SATA 和DMI,每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是PCIe(Peri pheral Component Interconnect Express)总线。 计算机启动过程 在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一 般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。 在母板上有一个称为基本输入输出系统(Basic Input Output System， BIOS) 的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、磁盘I/O以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS中发现错误时，可以由操作系统进行更新。 在计算机启动(booted) 时，BIOS 开启，它会首先检查所安装的RAM的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描PCle和PCI总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一 一次启动时的设备不同，则新的设备将被重新配置。 然后，BIOS通过尝试存储在CMOS 存储器中的设备清单 尝试启动设备 CMOS是Complementary Metal 0xide Sem iconductor （互补金属氧化物半导体）的缩写 。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的RAM 芯片。 因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。 而对BIOS中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入BIOS设置程序，方便地对系统进行设置。因此BIOS设置有时也被叫做CMOS设置。 用户可以在系统启动后进入一个BIOS配置程序，对设备清单进行修改。然后，判断是否能够从外部CD-ROM和USB驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。 然后操作系统会询问BIOS获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入CD- ROM驱动（由设备制造商提供）或者从Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/categories/Python/"},{"name":"Accumulation_Of_Reading","slug":"Accumulation-Of-Reading","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/"},{"name":"New_York_Times","slug":"Accumulation-Of-Reading/New-York-Times","permalink":"https://ozzienicholas.gitee.io/categories/Accumulation-Of-Reading/New-York-Times/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ozzienicholas.gitee.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"前端","slug":"前端","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"react","slug":"前端/react","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/react/"},{"name":"vue","slug":"前端/vue","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/vue/"},{"name":"JavaScript","slug":"前端/JavaScript","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/JavaScript/"},{"name":"node","slug":"前端/node","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/node/"},{"name":"css","slug":"前端/css","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/css/"},{"name":"开发","slug":"前端/开发","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91/"},{"name":"webpack","slug":"前端/webpack","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/webpack/"},{"name":"ACM","slug":"ACM","permalink":"https://ozzienicholas.gitee.io/categories/ACM/"},{"name":"随笔漫谈","slug":"前端/随笔漫谈","permalink":"https://ozzienicholas.gitee.io/categories/%E5%89%8D%E7%AB%AF/%E9%9A%8F%E7%AC%94%E6%BC%AB%E8%B0%88/"},{"name":"学校课程","slug":"学校课程","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"https://ozzienicholas.gitee.io/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ozzienicholas.gitee.io/tags/Python/"},{"name":"New_York_Times","slug":"New-York-Times","permalink":"https://ozzienicholas.gitee.io/tags/New-York-Times/"},{"name":"数据结构基础","slug":"数据结构基础","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"},{"name":"next.js","slug":"next-js","permalink":"https://ozzienicholas.gitee.io/tags/next-js/"},{"name":"redux","slug":"redux","permalink":"https://ozzienicholas.gitee.io/tags/redux/"},{"name":"react基础","slug":"react基础","permalink":"https://ozzienicholas.gitee.io/tags/react%E5%9F%BA%E7%A1%80/"},{"name":"vue-cli","slug":"vue-cli","permalink":"https://ozzienicholas.gitee.io/tags/vue-cli/"},{"name":"vue-router","slug":"vue-router","permalink":"https://ozzienicholas.gitee.io/tags/vue-router/"},{"name":"vuex","slug":"vuex","permalink":"https://ozzienicholas.gitee.io/tags/vuex/"},{"name":"vue基础","slug":"vue基础","permalink":"https://ozzienicholas.gitee.io/tags/vue%E5%9F%BA%E7%A1%80/"},{"name":"ES6","slug":"ES6","permalink":"https://ozzienicholas.gitee.io/tags/ES6/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://ozzienicholas.gitee.io/tags/JavaScript/"},{"name":"koa","slug":"koa","permalink":"https://ozzienicholas.gitee.io/tags/koa/"},{"name":"expres","slug":"expres","permalink":"https://ozzienicholas.gitee.io/tags/expres/"},{"name":"node","slug":"node","permalink":"https://ozzienicholas.gitee.io/tags/node/"},{"name":"css","slug":"css","permalink":"https://ozzienicholas.gitee.io/tags/css/"},{"name":"开发工具","slug":"开发工具","permalink":"https://ozzienicholas.gitee.io/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Git","slug":"Git","permalink":"https://ozzienicholas.gitee.io/tags/Git/"},{"name":"踩坑","slug":"踩坑","permalink":"https://ozzienicholas.gitee.io/tags/%E8%B8%A9%E5%9D%91/"},{"name":"webpack","slug":"webpack","permalink":"https://ozzienicholas.gitee.io/tags/webpack/"},{"name":"水题","slug":"水题","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B0%B4%E9%A2%98/"},{"name":"浏览器","slug":"浏览器","permalink":"https://ozzienicholas.gitee.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"},{"name":"数据库","slug":"数据库","permalink":"https://ozzienicholas.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"https://ozzienicholas.gitee.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}