{"meta":{"title":"Ozzie | Nicholas","subtitle":"","description":"OzzieNicholas的个人博客","author":"OzzieNicholas","url":"http://ozziely.com","root":"/"},"pages":[{"title":"","date":"2021-03-18T17:49:11.377Z","updated":"2021-03-18T17:49:11.377Z","comments":true,"path":"404.html","permalink":"http://ozziely.com/404","excerpt":"","text":"请留言告诉我您要访问哪个页面找不到了"},{"title":"","date":"2021-03-18T17:45:28.174Z","updated":"2021-03-18T13:58:09.160Z","comments":true,"path":"mylist/index.html","permalink":"http://ozziely.com/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-18T17:45:28.193Z","updated":"2021-03-18T13:57:51.312Z","comments":true,"path":"tags/index.html","permalink":"http://ozziely.com/tags/","excerpt":"","text":""},{"title":"所有分类","date":"2021-03-18T17:45:28.258Z","updated":"2021-03-18T13:57:28.462Z","comments":true,"path":"categories/index.html","permalink":"http://ozziely.com/categories/","excerpt":"","text":""},{"title":"","date":"2021-03-19T01:41:44.865Z","updated":"2021-03-19T01:41:44.865Z","comments":true,"path":"about/index.html","permalink":"http://ozziely.com/about/","excerpt":"","text":"终吾一生，愿念与征途，无非追求 “心之所向” 四字而已。 逝者如斯夫，虽若白驹之过隙，然何叹光阴之须臾？ 对酒当歌，人生几何！惟诗与远方，足矣！"},{"title":"我的朋友们","date":"2021-03-19T15:00:47.639Z","updated":"2021-03-19T15:00:47.639Z","comments":true,"path":"friends/index.html","permalink":"http://ozziely.com/friends/","excerpt":"","text":"","author":"Ozzie"}],"posts":[{"title":"数据库（二）：数据库的设计与操作","slug":"数据库（二）：数据库的设计与操作","date":"2021-03-20T01:54:41.000Z","updated":"2021-03-20T01:54:58.483Z","comments":true,"path":"7635befe4d5a/","link":"","permalink":"http://ozziely.com/7635befe4d5a/","excerpt":"","text":"数据库设计概述 在实际项目开发中，如果系统的数据存储量较大，设计的表较多，表与表之间的关系比较复杂，就必须先规范的设计数据库，然后再创建数据库、表等工作。 糟糕的数据库设计表现在以下几个方面： 访问数据效率低下 存在大量的数据冗余，浪费存储空间 更新和检索数据时会出现许多问题 良好的数据库设计表现在以下几方面： 访问效率高 减少数据冗余，节省存储空间，便于进一步扩展 可以使应用程序的开发变得更容易 数据库设计的基本步骤在了解数据库设计步骤之前，我们先来了解一下软件项目的开发周期，如下： 需求分析： 需求分析是数据库设计的第一步，是最困难、最耗费时间的一步，也是整个设计过程的基础。 本阶段的主要任务是对现实世界中要处理的对象（公司、部门及企业，也可以理解成客户）进行详细调查，然后通过分析，逐步明确客户/用户对系统的需求，包括数据需求和业务处理需求。 需求分析是否做的充分和准确，直接决定了在其上构建数据库大厦的速度与质量。需求分析做的不好，会导致整个数据库设计返工重做。 概要设计： 概要设计是数据库设计的关键，通过综合、归纳与抽象用户需求，形成一个具体 DBMS 的概念模型，也就是绘制数据库的 E-R 图。 E-R 图主要用于在项目团队内部，设计人员和客户之间进行沟通，确认需求信息的正确性和完整性。 逻辑设计/详细设计： 将 E-R 图转换为多张表，进行逻辑设计，确认各表的主外键，并应用数据库设计的三大范式进行审核，对其优化。 在这阶段，E-R 图非常重要。所以要学会根据各个实体定义的属性来画出总体的 E-R 图。 确定 E-R 图后，根据项目的技术实现，团队开发能力及项目的成本预算，选择具体的数据库（如 MySQL 或 Oracle 等）进行物理实现。 数据库实施：运用 DBMS 提供的数据语言（例如 SQL）、工具及宿主语言（例如 Java），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。 数据库运行和维护阶段：数据库应用系统经过试运行后即可投入正式运行。在运行过程中必须不断地对其进行评价、调整与修改。 SQL 语句的基本书写规则 SQL 语句要以分号 ; 结尾 在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。 大小写问题：（不区分大小写的意思是，全部大写或者全部小写或者大小写混合都是一样的） SQL 不区分关键字的大小写（例如，SELECT 等价于 select 等价于 SeLecT）； SQL 不区分表名和列名的大小写； SQL 区分插入到表中的数据的大小写。 常数的书写方式是固定的：（在 SQL 语句中直接书写的字符串、日期或者数字等称为常数） SQL 语句中含有字符串的时候，需要像 ‘abc’ 这样，使用英文单引号&#39;将字符串括起来，用来标识这是一个字符串。 SQL 语句中含有日期的时候，同样需要使用英文单引号将其括起来。日期的格式有很多种（’26 Jan 2010’ 或者’10/01/26’ 等）。 在 SQL 语句中书写数字的时候，不需要使用任何符号标识，直接写成 1000 这样的数字即可。 列名不是字符串，不能使用单引号，在 MySQL 中可以用倒引号`把表名和列名括起来。 MySql 的注释单行注释 方式一：# 1# 这是单行注释内容 方式二：-- 1-- 这是单行注释内容 多行注释唯一方式：/**/ 1234&#x2F;* 第一行注释内容 第二行注释内容*&#x2F; 数据库的操作查看数据库（show database …）语法： 1show databases [like &#39;数据库名&#39;]; 案例： 查看全部的数据库： 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 可以发现，在上面的列表中有 6 个数据库，它们都是安装 MySQL 时系统自动创建的，其各自功能如下： information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。 mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。 performance_schema：主要用于收集数据库服务器性能参数。 sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。 使用 like 从句： 1234567891011121314151617181920212223242526272829303132333435363738# 创建 test_db、db_test、db_test_db 三个数据库mysql&gt; create database test_db; mysql&gt; create database db_test; mysql&gt; create database db_test_db; # 使用 like 从句，查看与 test_db 完全匹配的数据库mysql&gt; show databases like &#39;test_db&#39;;+--------------------+ | Database (test_db) | +--------------------+ | test_db | +--------------------+ # 用 like 从句，查看名字中包含 test 的数据库mysql&gt; show databases like &#39;%test%&#39;; +-------------------+ | Database (%test%) | +-------------------+ | db_test | | db_test_db | | test_db | +-------------------+ # 用 like 从句，查看名字以 test 开头的数据库mysql&gt; show databases like &#39;test%&#39;; +------------------+ | Database (test%) | +------------------+ | test_db | +------------------+ # 用 like 从句，查看名字以 test 结尾的数据库mysql&gt; show databases like &#39;%test&#39;; +------------------+ | Database (%test) | +------------------+ | db_test | +------------------+ 创建数据库（create database …）语法： 123create database [if not exists] &lt;数据库名&gt;[[default] character set &lt;字符集名&gt;][[default] collate &lt;校对规则名&gt;]; [if not exists]：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。 [default] character set：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。 [default] collate：指定字符集的默认校对规则。 案例： 使用 if not exists： 123456789mysql&gt; create database test;Query OK, 1 row affected (0.20 sec)# 直接创建会报错mysql&gt; create database test;ERROR 1007 (HY000): Can&#39;t create database &#39;test&#39;; database existsmysql&gt; create database if not exists test;Query OK, 1 row affected, 1 warning (0.11 sec) 指定字符集： 123mysql&gt; create database test_db -&gt; default character set utf8;Query OK, 1 row affected, 1 warning (0.13 sec) 用 show create database &#39;数据库名&#39; 来查看该数据库的定义声明 1234567# 查看该数据库的定义声明mysql&gt; show create database test_db; +----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+------------------------------------------------------------------+ 注意： MySQL 的字符集（character）和校对规则（collate）是两个不同的概念。字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。 MySQL 不允许在同一系统下创建两个相同名称的数据库。 修改数据库（alter database …）语法： 123alter database [数据库名] &#123;[default] character set &lt;字符集名&gt; |[default] collate &lt;校对规则名&gt;&#125; alter database 用于更改数据库的全局特性。 使用 alter database 需要获得数据库 alter 权限。 数据库名称可以忽略，此时语句对应于默认数据库。 character set 子句用于更改默认的数据库字符集。 案例： 查看 test_db 的定义声明： 123456mysql&gt; show create database test_db;+----------+------------------------------------------------------------------+| Database | Create Database |+----------+------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+------------------------------------------------------------------+ 将数据库 test_db 的指定字符集修改为 gb2312： 123456789mysql&gt; alter database test_db -&gt; default character set gb2312;Query OK, 1 row affected (0.23 sec)mysql&gt; show create database test_db;+----------+--------------------------------------------------------------------+| Database | Create Database |+----------+--------------------------------------------------------------------+| test_db | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gb2312 *&#x2F; | 删除数据库（drop database ….）语法： 1drop database [if exists] &lt;数据库名&gt;; &lt;数据库名&gt;：指定要删除的数据库名。 if exists：用于防止当数据库不存在时发生错误。 drop database：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 drop database，需要获得数据库 drop 权限。 案例： 删除数据库 test： 12mysql&gt; drop database test;Query OK, 0 rows affected (0.06 sec) 再次删除时，会报错，之后使用 if exists 从句，可以防止系统报此类错误： 12345mysql&gt; drop database test;ERROR 1008 (HY000): Can&#39;t drop database &#39;test&#39;; database doesn&#39;t existmysql&gt; drop database if exists test;Query OK, 0 rows affected, 1 warning (0.02 sec) 注意： MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。 使用 drop database 命令时要非常谨慎，在执行该命令后，MySQL 不会给出任何提示确认信息。drop database 删除数据库后，数据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。因此最好在删除数据库之前先将数据库进行备份 选择数据库（ues database …）语法： 1use &lt;数据库名&gt;; 注意： 在操作数据库之前就必须要确定是哪一个数据库。 在 MySQL 中，USE 语句用来完成一个数据库到另一个数据库的跳转。 当用 create database 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。 该语句可以通知 MySQL 把&lt;数据库名&gt;所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。 只有使用 USE 语句来指定某个数据库作为当前数据库之后，才能对该数据库及其存储的数据对象执行操作。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://ozziely.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库（三）：mysql命令行基本操作","slug":"数据库（三）：MySQL 命令行基本操作","date":"2021-03-20T01:50:59.000Z","updated":"2021-03-20T01:53:28.166Z","comments":true,"path":"6ec4d66625a2/","link":"","permalink":"http://ozziely.com/6ec4d66625a2/","excerpt":"","text":"前序窗口启动 mysql 服务1net start mysql 登录1mysql -u root -p 导出数据库1mysqldump -u 用户名 -p –default-character-set&#x3D;latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1) 导出一个表1mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 例如： 1mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql 导入数据库 常用 source 命令： 123mysql -u root -pmysql&gt;use 数据库mysql&gt;source x.sql # 后面参数为脚本文件(如这里用到的.sql) 使用 mysqldump 命令： 1mysqldump -u 用户名 -p 密码 &lt; x.sql 使用 mysql 命令： 1mysql -u 用户名 -p -D 密码 &lt; x.sql 建议使用 Navicat 工具操作 mysql SQL 语句的分类 数据定义语言（DDL）：create、drop、alter 数据操作语言（DML）：insert、delete、update、truncate 数据查询语言（DQL）：select、show 数据控制语言：grant、revoke 操作数据库查看所有数据库：1SHOW DATABASES; 123456789mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 创建活跃连接：1SHOW PROCESSLIST; 123456789mysql&gt; show processlist;+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+| 4 | event_scheduler | localhost | NULL | Daemon | 25324 | Waiting on empty queue | NULL || 14 | root | localhost:52760 | NULL | Query | 0 | starting | show processlist |+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+ 创建数据库：1CREATE DATABASE &lt;数据库名&gt;; 123456789101112131415# 创建一个名为 ozzie 的数据库mysql&gt; create database ozzie;Query OK, 1 row affected (0.44 sec)# 查看所有的数据库（此时应该多出了 ozzie）mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || ozzie || performance_schema || sys |+--------------------+ 查看数据库的默认字符集：1SHOW CREATE DATABASE &lt;数据库名&gt;; 123456mysql&gt; show create database ozzie;+----------+----------------------------------------------------------------+| Database | Create Database |+----------+----------------------------------------------------------------+| ozzie | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |+----------+----------------------------------------------------------------+ 选择数据库：1USE 数据库名; 12mysql&gt; use ozzie;Database changed 查看当前使用的数据库：1SELECT DATABASES(); 123456mysql&gt; select database();+------------+| database() |+------------+| ozzie |+------------+ 修改数据库：1ALTER DATABASE &lt;数据库名&gt; DEFAULT CHARACTER SET GBK; 12345678910mysql&gt; alter database ozzie default character set gbk; Query OK, 1 row affected (0.47 sec) # 此时字符集由 utf8 变成了 gbkmysql&gt; show create database ozzie; +----------+---------------------------------------------------------------+| Database | Create Database |+----------+---------------------------------------------------------------+| ozzie | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gbk *&#x2F; |+----------+---------------------------------------------------------------+ 删除数据库：1DROP DATABASE 数据库名; 123456789101112mysql&gt; drop database ozzie;Query OK, 0 rows affected (0.19 sec)mysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || sys |+--------------------+ 操作表创建表1CREATE TABLE 数据表名(&lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]); 12345678910111213141516171819202122232425262728293031323334353637383940# 查看所有数据库mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql || performance_schema | | sys | +--------------------+ # 创建一个名为 ozzie 的数据库mysql&gt; CREATE DATABASE ozzie;Query OK, 1 row affected (0.23 sec) # 查看数据库（此时会多出一个 ozzie）mysql&gt; SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | ozzie | | performance_schema | | sys | +--------------------+ # 使用 ozziemysql&gt; USE ozzie;Database changed# 创建一个名为 student 的表mysql&gt; CREATE TABLE student -&gt; ( -&gt; id int(4) not null primary key auto_increment, -&gt; name char(20) not null, -&gt; sex char(4) not null default &#39;男&#39;, -&gt; degree double(16, 2) -&gt; );Query OK, 0 rows affected (1.77 sec) 查看表结构 方式一： 1DESC &lt;表名&gt;; 123456789mysql&gt; DESC student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+ 方式二： 1SHOW COLUMNS from &lt;表名&gt;; 123456789mysql&gt; SHOW COLUMNS FROM student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+ 查看所有表：1SHOW TABLES; 123456mysql&gt; SHOW TABLES;+-----------------+| Tables_in_ozzie |+-----------------+| student |+-----------------+ 插入数据：1INSERT INTO &lt;表名&gt; [(&lt;字段名&gt;[,..&lt;字段名n&gt;])] values (值)[,(值n)] 现在向表中插入两条记录，这两条记录分别表示： id 为 1，name 为 ‘Tom’，sex 为 ‘男’，degree 为 99.45 id 为 2，name 为 ‘Alice’，sex 为 ‘女’，degree 为 82.64 12345mysql&gt; insert into student values &gt; (1, &#39;Tom&#39;, &#39;男&#39;, 99.45), &gt; (2, &#39;Alice&#39;, &#39;女&#39;, 82.64);Query OK, 2 rows affected (0.91 sec)Records: 2 Duplicates: 0 Warnings: 0 查询数据：1SELECT &lt;字段, 字段, ...&gt; FROM &lt;表名&gt; WHERE &lt;表达式&gt;; 查看前两行的所有数据： 1234567mysql&gt; select * from student order by id limit 0,2;+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 1 | Tom | 男 | 99.45 || 2 | Alice | 女 | 82.64 |+----+-------+-----+--------+ 查看所有的 name： 1234567mysql&gt; select name from student;+-------+| name |+-------+| Tom || Alice |+-------+ 查看前两行的 degree： 1234567mysql&gt; select degree from student order by id limit 0,2;+--------+ | degree | +--------+ | 99.45 | | 82.64 | +--------+ 查看 id 为 1 的 sex： 123456mysql&gt; select sex from student where id&#x3D;1;+-----+| sex |+-----+| 男 |+-----+ 删除数据：1DELETE &lt;字段, 字段, ...&gt; FROM &lt;表达式&gt;; 删除 id 为 1 的记录： 12345678910111213141516171819202122232425262728# 先查看所有数据mysql&gt; select * from student+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 1 | Tom | 男 | 99.45 || 2 | Alice] | 女 | 82.64 |+----+-------+-----+--------+# 删除 id 为 1 的记录mysql&gt; delete from student where id&#x3D;1;Query OK, 1 row affected (0.79 sec)# 再次查看所有数据（此时应该只剩下 id&#x3D;2 的记录）mysql&gt; select * from student;+----+-------+-----+--------+| id | name | sex | degree |+----+-------+-----+--------+| 2 | Alice | 女 | 82.64 |+----+-------+-----+--------+# 删除 name 为 Alice 的记录mysql&gt; delete from student where name&#x3D;&#39;Alice&#39;;Query OK, 1 row affected (0.47 sec)# 再次查看所有数据（此时应该没有记录）mysql&gt; select * from student;Empty set (0.00 sec) 在表中增加字段：1ALTER TABLE &lt;表名&gt; add &lt;字段&gt; &lt;类型&gt; &lt;其他&gt;; 123456789101112131415161718192021222324252627# 查看表中原先字段mysql&gt; desc student; +--------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+--------+--------------+------+-----+---------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | | | degree | double(16,2) | YES | | NULL | |+--------+--------------+------+-----+---------+----------------+# 增加一条叫做 birthday 的字段，类型为 date，默认值为 &#39;2000-01-01&#39;mysql&gt; alter table student add birthday date default &#39;2000-01-01&#39;;Query OK, 0 rows affected (1.20 sec)Records: 0 Duplicates: 0 Warnings: 0# 现在多了一条 dirthday 字段mysql&gt; desc student;+----------+--------------+------+-----+------------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+------------+----------------+| id | int(4) | NO | PRI | NULL | auto_increment || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | || degree | double(16,2) | YES | | NULL | || birthday | date | YES | | 2000-01-01 | |+----------+--------------+------+-----+------------+----------------+ 删除表：1DROP TABLE &lt;表名&gt;; 12345mysql&gt; drop table student;Query OK, 0 rows affected (1.15 sec)mysql&gt; show tables;Empty set (0.00 sec) 更改表名：1RENAME TABLE &lt;原表名&gt; to &lt;新表名&gt;； 12345678910mysql&gt; rename table student to new_student;Query OK, 0 rows affected (0.70 sec)# 由 student 变为了 new_studentmysql&gt; show tables;+-----------------+| Tables_in_ozzie |+-----------------+| new_student |+-----------------+ 更改字段名字：1ALTER TABLE &lt;表名&gt; CHANGE &lt;字段名&gt; &lt;字段新名&gt; &lt;字段类型&gt;; 12345678910111213141516# 把名为 id 的字段改名称为 studentIdmysql&gt; alter table new_student change id studentId int(4);Query OK, 0 rows affected (0.79 sec)Records: 0 Duplicates: 0 Warnings: 0# 此时 id 应改为了 studentIdmysql&gt; desc new_student;+-----------+--------------+------+-----+------------+-------+| Field | Type | Null | Key | Default | Extra |+-----------+--------------+------+-----+------------+-------+| studentId | int(4) | NO | PRI | NULL | || name | char(20) | NO | | NULL | || sex | char(4) | NO | | 男 | || degree | double(16,2) | YES | | NULL | || birthday | date | YES | | 2000-01-01 | |+-----------+--------------+------+-----+------------+-------+","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://ozziely.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数据库（一）：数据库入门了解","slug":"数据库（一）：数据库入门了解","date":"2021-03-20T01:48:42.000Z","updated":"2021-03-20T01:50:09.505Z","comments":true,"path":"0c221b96c236/","link":"","permalink":"http://ozziely.com/0c221b96c236/","excerpt":"","text":"了解数据库： 数据库（DataBase）：数据库是一个以某种有组织的方式存储的数据集合，并不能用数据库来代表数据库软件，数据库软件应称为 DBMS（数据库管理系统），数据库 是通过DBMS创建和操纵的容器，简单来说，你使用的是DBMS，它替你访问数据库。 表（Table）：某种特定类型数据的结构化清单。每个表的名字（表名）在同一数据库中是唯一的，但在不同的数据库中可以使用相同的表名。 模式（Schema）：关于数据库和表的布局及特性的信息。有时，模式用作数据库的同义词，但模式的含义通常在上下文中并不是很清晰。 列（Column）：表由列组成，一列就是表中的一个字段。数据库中的每个列都有相应的数据类型，列可以存储的数据种类是有规定的。 行（Row）：表中的数据是按行存储的，一行就是表中的一个记录。所保存的每个记录存储在自己的行内。 如果将表想象为网格，网格中垂直的列为表列，水平行为表行。 可以将 “行” 称为 数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，“行” 才是正确的术语。 主键（Primary Key）：一列（或一组列），其值能够唯一区分表中每个行，唯一标识表中每行的这个列（或这组列）称为主键。例如用每个人的身份证号来标识每个人。 表中的任何列都可以作为主键，只要它满足以下条件： 任意两行都不具有相同的主键值； 每个行都必须具有一个主键值（主键列不允许 NULL 值）。 主键通常定义在表的一列上，但也可以使用多个列（组列）作为主键。 一些关于主键的约定： 不更新主键列中的值； 不重用主键列的值； 不在主键列中使用可能会更改的值（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键）。 DBMS（Data Base Management System，数据库管理系统）：是位于用户与操作系统之间的一层数据管理软件，是数据库系统的核心。数据的所有存储、检索、管理和处理实际上都是由数据库软件 —— DBMS 完成的。 DBMS 可分为两类： 基于共享文件系统的DBMS：例如 Microsoft Access 和 FileMaker，用于桌面用途，通常不用于高端或更关键的应用。 基于客户机—服务器的DBMS：例如 MySQL、Oracle 以及 Microsoft SQL Server 等数据库。客户机—服务器 应用分为两个不同的部分： 客户机是与用户打交道的软件，客户机软件通过网络把用户的请求提交给服务器软件。 服务器部分是负责所有数据访问和处理的一个软件，这个软件运行在 “数据库服务器” 上面，与数据文件打交道的只有服务器软件，关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。 客户机和服务器软件可能安装在两台计算 机或一台计算机上。不管它们在不在相同的计算机上，为进行 所有数据库交互，客户机软件都要与服务器软件进行通信。 DBA（Data Base Administrator，数据库用户）：是从事管理和维护数据库管理系统的相关工作人员。 DBS（Data Base System，数据库系统）：采用了数据库技术的计算机系统。 数据库的大致分类 数据库有两种类型，分别是关系型数据库和非关系型数据库。 关系型数据库：关系型数据库是建立在关系模型基础上的数据库，是由多张能互相连接的表组成的数据库。 优点： 都使用表结构，格式一致，易于维护。 使用通用的 SQL 语言操作，使用方便，可用于复杂查询。 数据存储在磁盘中，比较安全。 缺点： 读写性能比较差，不能满足海量数据的高效率读写。 不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。 固定的表结构，灵活度较低。 常见的关系型数据库：Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL。 非关系型数据库：非关系型数据库又被称为 NoSQL（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。 优点： 缺点： 常见的非关系型数据库：Neo4j、MongoDB、Redis、Memcached、MemcacheDB 和 HBase 等。 了解 SQL SQL（Structured Query Language）：是结构化查询语言，是一种专门用来与数据库通信的语言，用于存取数据以及查询、更新和管理关系数据库系统。 SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS（数据管理系统）都支持 SQL，所以，学习此语言使你几乎能与所有数据库打交道。 SQL不是一种专利语言，而且存在一个标准委员会，但是，任意两个 DBMS 实现的 SQL 都不完全相同，也就是，不同的 DBMS 对应的 SQL 语法不是完全可移植的。 与其他程序设计语言（如 C语言、Java 等）不同的是，SQL 由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。 SQL 的优点： 一体化：SQL 集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。 使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。 非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”，存储路径的选择和操作的执行由数据库管理系统自动完成。 语言简洁、语法简单：该语言的语句都是由描述性很强的英语单词组成，而且这些单词的数目不多。 SQL 包含以下 4 部分： 数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令： DROP：删除数据库和表等对象 CREATE：创建数据库和表等对象 ALTER：修改数据库和表等对象的结构 数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令： SELECT：查询表中的数据 INSERT：向表中插入新数据 UPDATE：更新表中的数据 DELETE：删除表中的数据 数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。 数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令： GRANT：赋予用户操作权限 REVOKE：取消用户的操作权限 COMMIT：确认对数据库中的数据进行的变更 ROLLBACK：取消对数据库中的数据进行的变更 实例如下： 上述实例的吓你详细过程如下： 下面的 SQL 语句声明创建一个名叫 students 的表： 1234567CREATE TABLE students ( student_id INT UNSIGNED, name VARCHAR(30), sex CHAR(1), birth DATE, PRIMARY KEY(student_id)); 该表包含 4 个字段，分别为 student_id、name、sex、birth，其中 student_id 定义为表的主键。 现在只是定义了一张表格，但并没有任何数据，接下来这条 SQL 声明语句，将在 students 表中插入一条数据记录： 12INSERT INTO students (student_id, name, sex, birth)VALUES (201803666, &#39;洛伊&#39;, &#39;1&#39;, &#39;2018-09-03&#39;) 上述 SQL 语句执行之后，students 表中就会增加一行新记录，在该记录中： student_id 字段的值为：201803666 name 字段的值为：”洛伊” sex 字段的值为：”1” birth 字段值为：”2018-09-03” 再使用 SELECT 查询语句获取刚才插入的数据，如下： 1234567SELECT name FROM students WHERE student_id&#x3D;201803666;+------+| name |+------+| 洛伊 |+------+1 row in set (0.00 sec) 标准 SQL 是指符合国际标准的 SQL，而非某个数据库厂商的 SQL 语法（如：Microsoft SQL Server 的 T-SQL，Oracle 的 PL/SQL，MySQL）。标准 SQL 可以在任何数据库中使用，而数据库厂商的 SQL 只适合它们对应的数据库，如 T-SQL 只适合 Microsoft SQL Server。 了解 MySQL MySQL 是一种 DBMS，它是一种数据库软件。 对于 MySQL： 客户机可以是 MySQL 提供的工具、脚本语言（如 Perl）、Web应用开发语言（如 ASP、ColdFusion、JSP 和 PHP）、程序设计语言（如 C、C++、Java）等 服务器软件为 MySQL DBMS，你可以在本地安装的副本上运行， 也可以连接到运行在你具有访问权的远程服务器上的一个副本。 MySQL 是一个免费开源的关系型数据库管理系统（但也不意味着该数据库是完全免费的），适合中小型软件。 MySQL 是开放源代码的数据库。 MySQL 的跨平台性：不仅可以在 Windows 系列的操作系统上运行，还可以在 UNIX、Linux 和 Mac OS 等操作系统上运行。在这一方面，SQL Server 数据库虽然也是一款很优秀的商业数据库，但它只能在 Windows 系列的操作系统上运行。因此，MySQL 数据库的跨平台性是一个很大的优势。 MySQL 是一个真正的多用户、 多线程 SQL 数据库服务器。它能够快速、有效和安全的处理大量的数据。相对于 Oracle 等数据库来说，MySQL 的使用是非常简单的。MySQL 主要目标是快速、健壮和易用。 MySQL 与常用的主流数据库 Oracle、SQL Server 相比，主要特点就是免费，并且在任何平台上都能使用，占用的空间相对较小。但是，MySQL 也有一些不足，比如对于大型项目来说，MySQL 的容量和安全性就略逊于 Oracle 数据库。 MySQL 的适用场景： Web 网站系统： 因为 MySQL 数据库的安装配置都非常简单，使用过程中的维护也不像很多大型商业数据库管理系统那么复杂，而且性能出色。还有一个非常重要的原因就是 MySQL 是开放源代码的，完全可以免费使用。 Web 网站开发者也是 MySQL 最大的客户群。 日志记录系统： MySQL 数据库的插入和查询性能都非常的高效，如果设计的好，在使用 MyISAM 存储引擎的时候，两者可以做到互不锁定，达到很高的并发性能。所以，对需要大量的插入和查询日志记录的系统来说，MySQL 是非常不错的选择，比如处理用户的登录日志，操作日志等。 数据仓库系统： 通过 MySQL 的简单复制功能，可以很好的将数据从一台主机复制到另外一台 ，不仅仅在局域网内可以复制，在广域网同样可以。 嵌入式系统： MySQL 在资源的使用方面的伸缩性非常大，可以在资源非常充裕的环境下运行，也可以在资源非常少的环境下正常运行。它对于嵌入式环境来说，是一种非常合适的数据库系统，而且 MySQL 有专门针对于嵌入式环境的版本。 学习 MySQL 必须掌握的知识点如下，也是我准备学习的知识： MySQL 的下载安装。熟悉 MySQL 的配置文件，目录结构。 MySQL 服务器的启动，登录与退出。 MySQL 常用命令及语法规范。 MySQL 常用命令及语法规范。 MySQL 数据类型与数据表的操作。例如，数据表的增删改查、单表查询、多表查询等。 MySQL 运算符和函数，例如，日期函数，时间函数，信息函数，聚合函数，加密函数，自定义函数等。 MySQL 存储过程，存储过程的调用。 MySQL 各个存储引擎的特点，如何选择合适的存储引擎等。 MySQL 事务的概念和使用等。 MySQL 权限管理和用户管理等。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://ozziely.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"系统学习计算机网络（五）：TCP详解","slug":"系统学习计算机网络（五）：TCP详解","date":"2021-03-20T01:46:50.000Z","updated":"2021-03-20T01:48:00.744Z","comments":true,"path":"94895040cb03/","link":"","permalink":"http://ozziely.com/94895040cb03/","excerpt":"","text":"传输控制协议 TCP 概述TCP 最主要的特点 TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。 TCP 是面向连接的运输层协议。 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 TCP 提供可靠交付的服务。 TCP 提供全双工通信。 TCP 是面向字节流的：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。 TCP 的连接 TCP 把连接作为最基本的抽象。 每一条 TCP 连接有两个端点。 TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。 端口号拼接到 IP 地址即构成了套接字。 套接字： TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。 同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。 Socket 有多种不同的意思： 应用编程接口 API 称为 socket API, 简称为 socket。 socket API 中使用的一个函数名也叫作 socket。 调用 socket 函数的端点称为 socket。 调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。 在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。 可靠传输的工作原理停止等待协议 IP 网络所提供的是不可靠的传输： “停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。 全双工通信的双方既是发送方也是接收方。 无差错情况： 出现差错： 在接收方 B 会出现两种情况： B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。 M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。 在这两种情况下，B 都不会发送任何信息。 但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。 出现差错的解决办法： A如何知道 B 是否正确收到了 M1 呢？ 解决方法：超时重传 A 为每一个已发送的分组都设置了一个超时计时器。 A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。 若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组 若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？ 解决方法：编号 A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。 B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。 确认丢失和确认迟到： 确认丢失： 若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。 假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动： 第一，丢弃这个重复的分组 M1，不向上层交付。 第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。 确认迟到： 传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。 A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。 B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。 注意： 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。 分组和确认分组都必须进行编号。 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 自动重传请求 ARQ：通常 A 最终总是可以收到对所有发出的分组的确认。 如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。 使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。 停止等待协议的优点是简单，缺点是信道利用率太低： 可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。 流水线传输：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 停止等待协议要点： 停止等待：发送方每次只发送一个分组，在收到确认后再发送下一个分组。 编号：对发送的每个分组和确认都进行编号。 自动重传请求：发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。 简单：但信道利用率太低。 连续 ARQ 协议 基本思想： 发送方一次可以发出多个分组。 使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。 滑动窗口协议比较复杂，是 TCP 协议的精髓所在。 每收到一个确认，发送方就把发送窗口向前滑动。 位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。 接收方一般采用累积确认的方式。 采用回退N（Go-Back-N）方法进行重传。 回退N：表示需要再退回来重传已发送过的 N 个分组。例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 累积确认： 接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。 优缺点： 优点：容易实现，即使确认丢失也不必重传。 缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。 当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 TCP 可靠通信的具体实现： TCP 连接的每一端都必须设有两个窗口： 一个发送窗口。 一个接收窗口。 TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。 TCP 两端的四个窗口经常处于动态变化之中。 TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。 连续 ARQ 协议与停止等待协议： TCP 报文段的首部格式 TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。 一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。 TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。 TCP 可靠传输的实现以字节为单位的滑动窗口 TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。 TCP 的滑动窗口是以字节为单位的。 发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。 发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。 接收窗口表示：只允许接收落入窗口内的数据。 发送缓存： 接收缓存： 发送缓存与接收缓存的作用： 发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据； TCP 已发送出但尚未收到确认的数据。 接收缓存用来暂时存放： 按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。 接收方发送确认：接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。 注意： A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。 TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。 TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 超时重传时间的选择 重传机制是 TCP 中最重要和最复杂的问题之一。 TCP 每发送一个报文段，就对这个报文段设置一次计时器。 只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。 重传时间的选择是 TCP 最复杂的问题之一。 TCP 超时重传时间设置： 如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。 但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。 TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。 选择确认 SACK 若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？ 答案是可以的。选择确认 SACK (Selective ACK) 就是一种可行的处理方法。 接收到的字节流序号不连续： TCP 的流量控制利用滑动窗口实现流量控制 流量控制：就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 可能发生死锁： B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。 但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。 如果没有其他措施，这种互相等待的死锁局面将一直延续下去。为了解决这个问题，TCP 为每一个连接设有一个持续计时器。 持续计时器： 只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。 若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。 若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。 若窗口不是零，则死锁的僵局就可以打破了。 TCP 的传输效率 可以用不同的机制来控制 TCP 报文段的发送时机： 第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。 第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。 第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。 发送方糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。 发送方 TCP 每次接收到一字节的数据后就发送。这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。 解决方法：使用 Nagle 算法。 Nagle算法原理： 接收方糊涂窗口综合症： 当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。 若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。 解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。 TCP 的拥塞控制拥塞控制的一般原理 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞。 最坏结果：系统崩溃。 拥塞产生的原因：网络拥塞往往是由许多因素引起的，例如： 点缓存的容量太小； 链路的容量不足； 处理机处理的速率太慢； 拥塞本身会进一步加剧拥塞。 增加资源能解决拥塞吗？ 不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。 网络拥塞往往是由许多因素引起的。例如： 增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞； 提高处理机处理的速率会会将瓶颈转移到其他地方； 拥塞控制与流量控制的区别： 拥塞控制所起的作用： 拥塞控制的一般原理： 拥塞控制的前提：网络能够承受现有的网络负荷。 实践证明，拥塞控制是很难设计的，因为它是一个动态问题。 分组的丢失是网络发生拥塞的征兆而不是原因。 在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。 开环控制和闭环控制： 属于闭环控制的有以下几种措施： 监测网络系统，以便检测到拥塞在何时、何处发生。 将拥塞发生的信息传送到可采取行动的地方。 调整网络系统的运行以解决出现的问题。 监测网络的拥塞的主要指标：（下面这些指标的上升都标志着拥塞的增长） 由于缺少缓存空间而被丢弃的分组的百分数； 平均队列长度； 超时重传的分组数； 平均分组时延； 分组时延的标准差，等等。 传递拥塞通知： 发送通知拥塞发生的分组； 在分组中保留表示拥塞状态的字段； 周期性地发出探测分组等。 采取行动的时机： 过于频繁，会使系统产生不稳定的振荡； 过于迟缓地采取行动又不具有任何实用价值。 解决拥塞的两条思路： 增加网络可用资源； 减少用户对资源的需求。 TCP 的拥塞控制方法 TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。 TCP发送方维持一个拥塞窗口 cwnd。 发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。 发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为： 真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值) 控制拥塞窗口的原则： 只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。 但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。 拥塞的判断： 四种拥塞控制算法： 慢开始 目的：用来确定网络的负载能力或拥塞程度。 算法的思路：由小到大逐渐增大拥塞窗口数值。 两个变量： 流程： 设置慢开始门限状态变量 ssthresh，慢开始门限 ssthresh 的用法如下： 当 cwnd &lt; ssthresh 时，使用慢开始算法。 当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。 拥塞避免 思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。 每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。 使拥塞窗口 cwnd 按线性规律缓慢增长。 在拥塞避免阶段，具有 “加法增大” 的特点。 “拥塞避免” 并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。 “拥塞避免” 是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 快重传 发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。 使用快重传可以使整个网络的吞吐量提高约20%。 不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。 快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。 例如： 快恢复 当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法： 慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ； 新拥塞窗口 cwnd = 慢开始门限 ssthresh ； 开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 主动队列管理 AQM TCP 拥塞控制和网络层采取的策略有密切联系。 若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。 重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。 先进先出(FIFO) 处理规则 与 尾部丢弃策略： 路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。 当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。 路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。 TCP 的运输连接管理TCP 的连接建立 TCP 是面向连接的协议。 TCP 连接有三个阶段： 连接建立 数据传送 连接释放 TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。 TCP 连接建立过程中要解决的三个问题： 要使每一方能够确知对方的存在。 要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。 能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。 客户—服务器方式： TCP 连接的建立采用客户服务器方式。 主动发起连接建立的应用进程叫做客户 (client)。 被动等待连接建立的应用进程叫做服务器 (server)。 TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手，采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。 TCP 的连接释放 TCP 连接释放过程比较复杂。 数据传输结束后，通信的双方都可释放连接。 TCP 连接释放过程是四报文握手： TCP 的有限状态机","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（四）：运输层概述与UDP详解","slug":"系统学习计算机网络（四）：运输层概述与UDP详解","date":"2021-03-20T01:46:05.000Z","updated":"2021-03-20T01:47:56.645Z","comments":true,"path":"a2ed71807ea0/","link":"","permalink":"http://ozziely.com/a2ed71807ea0/","excerpt":"","text":"运输层协议概述进程之间的通信 从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。 当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 只有位于网络边缘部分的主机的协议栈才有运输层： 主机 A 与 主机 B 之间的通信的两层含义： 严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。 从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。 网络层和运输层有明显的区别： 网络层是为主机之间提供逻辑通信； 运输层为应用进程之间提供端到端的逻辑通信。 基于端口的复用和分用功能： 逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别： 当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。 当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。 可靠信道与不可靠信道： 运输层的两个主要协议 TCP/IP 的运输层有两个主要协议： 用户数据报协议 UDP (User Datagram Protocol) 传输控制协议 TCP (Transmission Control Protocol) 两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU： TCP 传送的数据单位协议是 TCP 报文段 UDP 传送的数据单位协议是 UDP 报文或用户数据报 使用 UDP 和 TCP 的典型应用和应用层协议： 主机上可能有多个进程同时技能型通信，进程是动态创建和撤销的： 运输层的 UDP 用户数据报与网际层的IP数据报有很大区别： IP 数据报要经过互连网中许多路由器的存储转发 UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的 TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。 运输层的端口 运行在计算机中的进程是用进程标识符来标志的，但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。 需要解决的问题： 由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。 有时我们会改换接收报文的进程，但并不需要通知所有发送方。 我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。 解决这个问题的方法就是在运输层使用协议端口号，或通常简称为端口。 TCP/IP 运输层端口： 端口用一个 16 位端口号进行标志，允许有65535个不同的端口号。 端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。 由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机） 两大类端口： 服务器端使用的端口号： 熟知端口，数值一般为 0 ~ 1023。 登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。 客户端使用的端口号： 又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。 当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。 常用的熟知端口： 用户数据报协议 UDPUDP 概述 UDP 只在 IP 的数据报服务之上增加了很少一点的功能： 复用和分用的功能 差错检测的功能 UDP 的主要特点： UDP 是无连接的 UDP 使用尽最大努力交付 UDP 是面向报文的 UDP 没有拥塞控制 UDP 支持一对一、一对多、多对一和多对多的交互通信 UDP 的首部开销小 UDP 是面向报文的： UDP 的首部格式 用户数据报 UDP 有两个字段：数据字段和首部字段，首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。 UDP 用户数据报格式： UDP 基于端口的分用：当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（三）：数据链路层","slug":"系统学习计算机网络（三）：数据链路层","date":"2021-03-20T01:45:19.000Z","updated":"2021-03-20T01:47:48.037Z","comments":true,"path":"310577faf33f/","link":"","permalink":"http://ozziely.com/310577faf33f/","excerpt":"","text":"前序 计算机网络体系结构： 数据链路层是实现设备之间通信的非常重要的一层： 使用点对点信道的数据链路层数据链路和帧 链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 数据链路层传送的是帧： 三个基本问题 封装成帧：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。 透明传输：如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。 差错检测：在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。 在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。 在数据后面添加上的冗余码称为帧检验序列 FCS。 循环冗余检验 CRC 和帧检验序列 FCS 并不等同： CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 点对点协议 PPPPPP 协议的特点 **对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 **PPP 用户到 ISP 的链路使用 PPP 协议： PPP 协议的帧格式PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。 PPP 协议的工作状态 使用广播信道的数据链路层局域网的数据链路层 局域网最主要的特点是： 网络为一个单位所拥有 地理范围和站点数目均有限 局域网拓扑结构： 局域网对 LLC 子层是透明的： 适配器的作用：网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或 “网卡”，重要功能如下： 进行串行/并行转换。 对数据进行缓存。 在计算机的操作系统安装设备驱动程序。 实现以太网协议。 计算机通过适配器和局域网进行通信： CSMA/CD 协议 使用集线器的星形拓扑 使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD 协议，并共享逻辑上的总线。 集线器很像一个多接口的转发器，工作在物理层。 以太网的 MAC 层 在局域网中，硬件地址又称为物理地址，或 MAC 地址。 最常用的 MAC 帧是以太网 V2 的格式： 扩展的以太网在物理层扩展以太网 使用光纤扩展：主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。 使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网。 在数据链路层扩展以太网 扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。 交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。 以太网交换机的特点： 以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。 以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。 相互通信的主机都是独占传输媒体，无碰撞地传输数据（以太网交换机的每个接口是一个碰撞域）： 交换机使用了生成树协议：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 虚拟局域网 利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。 每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。 划分虚拟局域网的方法： 基于交换机端口： 最简单、也是最常用的方法。 属于在第一层划分虚拟局域网的方法。 基于计算机网卡的MAC地址： 根据用户计算机的MAC地址划分虚拟局域网。 属于在第二层划分虚拟局域网的方法。 基于协议类型： 根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网。 属于在第二层划分虚拟局域网的方法。 基于IP子网地址： 根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。 属于在第三层划分虚拟局域网的方法。 基于高层应用或服务： 根据高层应用或服务、或者它们的组合划分虚拟局域网。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（二）：物理层","slug":"系统学习计算机网络（二）：物理层","date":"2021-03-20T01:44:39.000Z","updated":"2021-03-20T01:47:52.518Z","comments":true,"path":"f567b7b406b2/","link":"","permalink":"http://ozziely.com/f567b7b406b2/","excerpt":"","text":"物理层的基本概念物理层的主要任务描述为确定与传输媒体的接口的一些特性： 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 数据通信的基础知识数据通信系统的模型 有关信道的几个基本概念 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。 基带（baseband）信号：即基本频带信号，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制。 带通（bandpass）信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 几种最基本的调制方法：（最基本的二元制调制方法有以下几种） 调幅(AM)：载波的振幅随基带数字信号而变化 调频(FM)：载波的频率随基带数字信号而变化 调相(PM) ：载波的初始相位随基带数字信号而变化 信道的极限容量与极限信息传输速率 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。 有失真，但可识别： 失真大，无法识别： 奈氏准则：给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率，信道的极限信息传输速率 C 可表达为：$$C = W \\times \\log_2^{1+S/N} (b/s)$$ W 为信道的带宽（以 Hz 为单位） S 为信道内所传信号的平均功率 N 为信道内部的高斯噪声功率 香农公式表明： 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 物理层下面的传输媒体电信领域使用的电磁波的频谱 导引型传输媒体 双绞线 屏蔽双绞线 STP (Shielded Twisted Pair) 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 同轴电缆 50 Ω 同轴电缆 75 Ω 同轴电缆 光缆 光线在光纤中的折射 光纤的工作原理 多模光纤与单模光纤： 光纤优点： 通信容量非常大。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。 非导引型传输媒体 将自由空间称为“非导引型传输媒体” 传统微波通信有两种方式： 地面微波接力通信 卫星通信 信道复用技术 复用 (multiplexing) 是通信技术中的基本概念。它允许用户使用一个共享信道进行通信，降低成本，提高利用率。 复用的示意图： 频分、时分、统计时分复用 频分复用 FDM ： 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。 时分复用 TDM： 时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。 TDM 信号也称为等时 (isochronous) 信号。 时分复用的所有用户在不同的时间占用同样的频带宽度。 时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。 统计时分复用 STDM：STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。 波分复用 WDM 波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。 码分复用 CDM 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。 每个站被指派一个唯一的 m bit 码片序列。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码。 例如，S 站的 8 bit 码片序列是 00011011： 发送比特 1 时，就发送序列 00011011 发送比特 0 时，就发送序列 11100100 S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) 码片序列实现了扩频： 假定S站要发送信息的数据率为 b bit/s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。 这种通信方式是扩频(spread spectrum)通信中的一种。 扩频通信通常有两大类： 一种是直接序列扩频DSSS (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。 另一种是跳频扩频FHSS (Frequency Hopping Spread Spectrum)。 CDMA 的重要特点： 每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。 码片序列的正交关系： 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量 两个不同站的码片序列正交，就是向量 S 和T 的规格化内积等于 0：$$S \\times T \\equiv \\frac{1}{m} \\sum_{i=1}^{m}S_iT_i = 0$$ 在实用的系统中是使用伪随机码序列。 CDMA 的工作原理： 宽带接入技术 用户要连接到互联网，必须先连接到某个ISP。 从宽带接入的媒体来看，可以将宽带接入技术划分为两大类： 有线宽带接入 无线宽带接入 ADSL技术 ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。 DSL 就是数字用户线 (Digital Subscriber Line) 的缩写。 ADSL 的传输距离： ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。 ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。 ADSL 的特点： 上行和下行带宽做成不对称的：上行指从用户到 ISP，而下行指从 ISP 到用户。 ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。 光纤同轴混合网（HFC 网） HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。 HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。 现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。 HFC 网对 CATV 网进行了改造：HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。 HFC 网采用结点体系结构： FTTx 技术 FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。 FTTx 表示 Fiber To The…（光纤到…），例如： 光纤到户(FTTH，Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。 光纤到大楼(FTTB，Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。 光纤到路边(FTTC，Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。 无源光网络 PON (Passive Optical Network) 的组成：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"系统学习计算机网络（一）：概述","slug":"系统学习计算机网络（一）：概述","date":"2021-03-20T01:43:57.000Z","updated":"2021-03-20T01:48:04.835Z","comments":true,"path":"36379c8f0263/","link":"","permalink":"http://ozziely.com/36379c8f0263/","excerpt":"","text":"互联网概述 计算机网络是由若干个结点以及连接这些结点的链路组成。 网络把计算机连接在一起，而互联网则通过路由器把网络连接在一起，与网络相连的计算机常称为主机。 互联网的组成 虽然互联网的拓扑结构很复杂，但从工作方式上看，可以大致分为： 边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。 互联网的边缘部分： 连接在互联网上的这些主机，又被称为端系统。 注意，这里的端系统并不只是指的电脑，当然也可以是一个很小的网络摄像头等其他具有上网功能的设备。 “主机A 和 主机B 进行通信”，实际上指的是：“主机A 的某个进程和主机B 上的另一个进程进行通信”，这种阐述也被简称为 “计算机之间通信” 在网络边缘的端系统之间的通信方式可以分为两类：C/S方式 和 P2P方式。 C/S 方式（客户—服务器方式）： 这是最常用的方式，比如发送邮件。 “客户” 和 “服务器” 都是指通信中所涉及的两个应用进程，C/S 方式描述的是进程之间，客户是服务请求方，服务器是服务提供方，当然，服务请求方和服务提供方都要使用网络核心部分所提供的服务。 客户程序的主要特点： 被用户调用后，在通信时主动向远地服务器发起通信（请求服务），因此，客户程序必须知道服务器程序的地址。 客户程序是不需要特殊的硬件和很复杂的操作系统的。 服务器程序： 是一种专门用来提供某种服务的程序，可以同时处理多个远地和本地客户的请求。 系统启动之后，即会自动调用并且一直不停地运行，被动地等待并接受来自各地的客户的通信请求，因此，服务器程序不需要知道客户程序的地址。 与客户程序不同的是，服务器程序一般需要有强大的硬件和高级的操作系统支持。 客户和服务器的通信关系建立之后，通信可以是双向的，客户和服务器本来都指的是计算机进程（软件）。 顺带一提，使用计算机的人是计算机的 “用户” 而非 “客户”。 P2P 方式（对等连接方式）： 指两台主机在通信时，并不区分哪台是服务请求方与服务提供方。只要两台主机都运行了对等的连接软件（P2P 软件），它们就可以进行平等的、对等的连接通信，这时，双方都可以下载对方存储在硬盘中的共享文档。这时，双方都可以下载对方已经存储在硬盘中的共享文档，因此这几台主机也可以进行对等通信，从本质上，对等连接方式仍然使用的是客户—服务器方式，只是，对等连接中的每一台主机既是客户同时又是服务器。如下图： 互联网的核心部分： 网络核心部分是互联网中最复杂的部分。 路由器：在网络核心部分起着特殊的作用，它是一种专用的计算机（但不叫主机），它是实现分组交换的关键构件，其任务是转发收到的分组。 若要弄清楚什么是分组交换，建议先理解一下电路交换的基本概念，此处不做解释。 计算机网络的类别 按照网络的作用范围进行分类： 广域网（WAN，Wide Area Network）：也称 “远程网”，是互联网的核心部分，其任务是长距离运送主机发送的数据。 城域网（MAN，Metropolitan Area Network）：作用范围一般是一个城市，用来将多个局域网进行互连，目前很多城域网采用的是以太网技术，因此也常并入局域网的范围来讨论。 局域网（LAN，Local Area Network）：常见的局域网如校园网或企业网。 个人局域网（PAN，Personal Area Network）：也通常称为 “无线个人局域网（WPAN，Wireless PAN）”。 顺便指出，如果中央处理机之间的距离非常近（如距离仅1米），那么一般就称之为多处理机系统，而不是计算机网络。 按照网络的使用者进行分类： 公用网（Public Network）：通常是电信公司（国有或私有）出资建造的大型网络，所有人按规定缴费就可以使用的网络，因此公用网也可以成为 “公众网”。 专用网（Private Network）：一般是为了本单位的特殊业务工作而建造的。 计算机网络的性能 计算机网络的性能一般指它的几个重要的性能指标，但除了这些重要的性能指标，还有一些非性能特征也对网络的性能有很大的影响。 计算机网络的性能指标： 速率： 这是最重要的性能指标，指的是数据的传送速率，也称为 “数据率” 或 “比特率”。 速率的单位是 bit/s（或 b/s，有时也写为 bps），当速率较高时，常常在 bit/s 的前面加上一个字母，例如：k（kilo）= 10^3 = 千，M（Mega）= 10^6 = 兆，以此类推，还有 G（Giga，吉）、T（Tera，太）、P（Peta，拍）、E（Exa，艾）、Z（Zetta，泽）、Y（Yotta，尧），例如 4*10^10 bit/s 的数据率就记为 40Gbit/s。 需要注意，提到网络的速率时，往往指的是稳定速率或标称速率，而非网络实际上运行的速率。 带宽： 带宽本来是指某个信号具有的 “频带宽度”，信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫（或千赫、兆赫、吉赫）。在过去很长一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号），因此，表示某信道允许通过的信号频带范围就称为该信道的带宽（或通频带）。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的 “最高数据率”，这种意义的带宽的单位就是数据率的单位，即 bit/s。 在上述两种表述中，前者是 “频域” 称谓，后者是 “时域” 称谓，其本质是相同的，也就是说，一条通信链路的 “带宽” 越宽，其所能传输的 “最高数据率” 也越高。 吞吐量： 吞吐量表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。 吞吐量长用于对实际网络的测量，以便知道实际上到底有多少个数据量能够通过网络。吞吐量收到网络的带宽或网络的额定速率的限制，例如，对于一个 1 Gbit/s 的以太网，其额定速率是 1 Gbit/s，这个数值也是该以太网的吞吐量的绝对上限值，其实际的吞吐量可能也只有 100 Mbit/s 甚至更低。 有时吞吐量还可用每秒传送的字节数或帧数来表示。 时延： 时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，有时也称为 “延迟” 或 “迟延”。时延是无法立即准确计算的，大多数时候是根据以前的已发生的时延经历而推测下一次的时延。 网络的时延是由以下几个不同的部分组成： 发送时延：发送时延是主机或路由器发送数据帧所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，因此发送时延也叫做 “传输时延”，发送时延的计算公式是：发送时延 = 数据帧长度(bit) / 发送速率(bit/s)。 传播时延：传播时延是电子波在信道中传播需要一定的距离需要花费的时间。传播时延的计算公式是：传播时延 = 信道长度(n) / 电子波在信道上的传播速率(m/s)。 以上两种时延有本质上的不同：发送时延是发生在机器内部的发送器中，与传输信道的长度无关；传播时延是发生在及其外部的传输信道媒体上，信号传送的距离越远，传播时延就越大，这与信号的发送速率无关。 处理时延：主机或路由器在收到分组时要花费一定的时间进行处理。 排队时延：分组在经过网络传输时，要经过许多路由器，但分组在进入路由器后要先在输入队列中排队等待处理。 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 时延带宽积：时延带宽积等于传播时延和带宽相乘。 往返时间 RPT 利用率 计算机网络的非性能特征： 费用 质量 标准化 可靠性 可扩展性和可升级性 易于管理和维护 TCP/IP 体系结构 TCP/IP 的体系结构比较简单，它只有四层。下图给出了用这种四层协议表示方法的例子。请注意，图中的路由器在转发分组时最高只用到网络层而没有使用运输层和应用层： 我们分层次画出具体的协议来表示TCP/IP协议族（如图）： 它的特点是：上下两头大而中间小 — 应用层和网络接口层都有多种协议，而中间的IP 层很小，上层的各种协议都向下汇聚到-一个IP 协议中。 概念回顾 计算机网络（可简称为网络）把许多计算机连接在一起，而互连网则把许多网络连接在一起，互联网是网络的网络。 以小写字母 i 开始的 internet（互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。以大写字母 I 开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP 协议族作为通信规则。 互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。 计算机通信是计算机中的进程之间的通信。计算机网络采用的通信方式是客户—服务器方式和对等连接方式（P2P方式）。 客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。 按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。 计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延(发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道（或网络）利用率。 网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。 五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机操作系统（八）：页面置换算法","slug":"计算机操作系统（八）：页面置换算法","date":"2021-03-20T01:41:24.000Z","updated":"2021-03-20T01:42:37.868Z","comments":true,"path":"61c42f2ee851/","link":"","permalink":"http://ozziely.com/61c42f2ee851/","excerpt":"","text":"虚拟内存虚拟内存的基本思想：每个程序都有自己的地址空间，这个空间被分割成多个块，每一个块被称作一页或页面。每一页有连续的地址范围。 这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。 当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。 当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。 Linux 进程内存布局 进程内存空间通过分段存储来管理 内核空间（kernel space）(1G)：内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。 用户空间（3G）： 环境变量（environment variables） 命令行参数（command-line arguments） 栈（stack）：栈又称堆栈，由编译器自动分配释放，用来存储临时数据和栈帧。 内存映射段（memory mapping segment）：将硬盘文件的内容直接映射到内存，内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。 堆（heap）：堆用于存放进程运行时动态分配的内存段。 BSS段（bss segment）：静态内存分配，保存未初始化的全局及静态变量（皆为0），可读可写。 数据段（data segment）：静态内存分配，保存已初始化的全局及静态变量，可读可写。 代码段（text segment）：保存可执行机器码和常量，可读不可写可执行。 保留区（reserved）(32位cpu下占128M)：位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。 它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。 在32位X86架构的Linux系统中，用户进程可执行程序一般从虚拟地址空间0x08048000开始加载。该加载地址由ELF文件头决定 交换分区：在物理内存满时， 如果还需要内存资源，内核则把物理内存中非活动的页面放到交换分区中。 分页大部分虚拟内存系统中都使用一种称为分页的技术。 由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟内存的计算机上，系统直接把虚拟地址送到内存总线上，读写操作使用具有相同地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到内存管理单元（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。 虚拟地址空间按照固定大小划分成被称为页面（page）的若干单元。在物理内存中对应的单元称为页框。页面和页框的大小通常是一样的。实际系统中的页面大小从512字节到1GB。 栗子：一页4KB，64KB的虚拟地址空间和32KB的物理内存可得到16个虚拟页面和8个页框。从虚拟地址到物理地址的流程： 在上图中，虚拟地址8196（二进制是0010 0000 0000 0100），输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移量可以为一页内的全部4096个字节编址。 可用页号作为页表的索引，以得出对应于该虚拟页面的页框号。如果“在/不在”位是0，则引起缺页中断。如果该位是1，则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。 此处讨论缺页中断（或称为缺页错误）发生的事：假如操作系统访问虚拟页面B产生缺页中断，决定放弃页框1（对应虚拟页面A），那么它将把产生缺页中断所对应的虚拟页面（页面B）装入页框1的起始物理地址，并对MMU映射做两处修改：首先，它要将原来页框1所对应的虚拟页面（页面A）的表项设为未映射，使以后任何对原来虚拟页面（页面A）的访问都导致陷阱。随后，把引起缺页中断（页面B）的的表项设为映射，因此在引起陷阱的指令重新启动时，它将虚拟页面B映射为物理地址页框1中的某个地址。 页表虚拟地址被分成虚拟页号（高地址）和偏移量（低地址）两部分。不同的划分对应了不同的页面大小。 虚拟页号可作为页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到对应的页框。然后把页框号拼接到偏移量的高位端，以替换调虚拟页号，形成送往内存的物理地址。 页表的目的是把虚拟页面映射为页框，把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址（本篇博客讨论的情况均不涉及虚拟机，每个虚拟机都需要有自己的虚拟内存，因此页表组织变得很复杂，包括影子页表和嵌套页表）。 页表项的结构： 页框号：最重要的就是页框号，页映射的目的就是找到这个值 “在/不在”位：是1时表示该表项是有效的，可以使用；是0时则表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个缺页中断。 保护位：指出一个页允许什么样的方式访问，最简单的形式是只有一位，0表示读/写，1表示只读；更先进的方式是使用三位，各位分别表示是否启用读、写、执行该页面。 修改位：记录页面的使用情况，在写入一个页时自动设置修改位。如果一个页面已经被修改过（即它是“脏”的），则必须把它写会磁盘。如果没有被修改过（即它是“干净”的），可以直接被丢弃，因为它在磁盘上的副本仍然是有效的。脏位，反映看该页面的状态。 访问位：不论是读还是写，系统都会在该页面被访问时设置访问位。用于页面置换算法中。 禁止该页面被高速缓存：对于映射到设备寄存器而不是常规内存的页面很重要。具有独立的I/O空间而不使用内存映射I/O的机器不需要这一位。 加速分页过程每次访问内存都需要进行虚拟地址到物理地址的映射，每条指令进行一两次或更多页表访问是必要的。如果执行一条指令需要1ns，页表查询必须在0.2ns之内完成，以避免映射成为一个主要瓶颈。 现代计算机使用至少32位的虚拟地址。假设页面大小为4KB，32位的地址空间将有100万页，那么页表必然有100万条表项，而且每个进程都需要自己的页表。64位地址空间简直多到超乎你的想象。 转换检测缓冲区： 大多数程序总是对少量的页面进行多次的访问，只有很少的页表项会被反复读取，而其他大的页表项很少被访问。利用这种特性有一种解决方案：为计算机设计一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区（Translation Lookaside Buffers，TLB），有时又称为相联存储器或快表。它通常在MMU中，包含少量的表项，在实际中很少会超过256个。每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、保护码和该页锁对应的物理页框，还有另外一位用来记录这个表项是否有效（即是否在使用）。 TLB的工作过程：将一个虚拟地址放入MMU中进行转换时，硬件首先通过将该虚拟页号与TLB中所有表项同时（并行）进行匹配，判断虚拟页面是否在其中。如果发现在，并且不违反保护码，则将页框号直接从TLB中取出而不必再访问页表。如果违反了保护码，则会产生一个保护错误，就像对页表进行非法操作一样。如果虚拟页号不在TLB中，此时就会去进行正常的页表查询。接着从TLB中淘汰掉一个表项，然后用找到的页表项代替它。当一个表项被清除除TLB时，将修改位复制到内存中的页表项，而除了访问位，其他的值不变。当页表项中从页表中装入TLB中时，所有的值都来自内存。 软件TLB管理： 现代许多的机器，几乎所有的页面管理都在软件中实现。TLB被操作系统显示地加载，当发生TLB访问失效时，生成一个TLB失效并将问题交给操作系统解决。系统找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。TLB失效比缺页中断更加频繁。 如果TLB大到（如64个表项）可以减少失效率时，TLB的软件管理就会变得足够有效。 在减少TLB失效的同时，又要在发生TLB失效时减少处理开销。有时候操作系统能用“直觉”指出哪些页面下一步可能会被用到并预先为它们在TLB中装载表项。 （软件、硬件）处理TLB失效常用的办法都是找到页表并执行索引操作以定位将要访问的页面。软件做这样的搜索时，通过在内存中的固定位置维护一个大的（如4KB）TLB表项的软件高速缓存（该高速缓存的页面一直保存在TLB中）来减少TLB失效。 两种不同的TLB失效： 软失效：一个页面访问在内存中而不在TLB中，此时要做的是更新TLB，不需要产生磁盘I/O。（10~20个机器指令，几纳秒） 硬失效：页面本身不在内存中（当然也不TLB中），此时需要一次磁盘存取以装入该页面。（几毫秒，硬失效的处理时间往往是软失效的百万倍）：在也表中查找相应的映射被称为页表遍历，假设页表遍历没有在进程的页表汇总找到需要的页，从而产生了一个缺页错误，此时有三种可能： 所需要的页面就在内存中，但未记录在该进程的页表里。比如该页面可能已由其他其他进程从硬盘中调入内存，这种情况只需要把所需要的页面正确映射到页表中，而不是从磁盘调入。这是一种软失效，称为次要缺页错误。 需要从硬盘重新调入页面，这就是严重缺页错误。 程序访问了一个非法地址，根本不需要向TLB中新增映射。此时，操作系统一般会通过报告段错误来终止该程序。只有第三种缺页属于程序错误，其他缺页情况都会被硬件或操作系统以降低性能为代价而自动修复。 针对大内存的页表两种办解决巨大的虚拟地址空间？ 多级页表：32位的虚拟地址被划分为10位的PT1域，10位的PT2域和12位的Offset(偏移量)域。因为偏移量是12位，所以页面大小是4KB，共有220个页面。假设每个进程都占用了4G的线性地址空间，页表共含1M个表项，每个表项占4个字节，那么每个进程的页表要占据4M的内存空间。为了节省页表占用的空间，我们使用两级页表。每个进程都会被分配一个页目录，但是只有被实际使用页表才会被分配到内存里面。一级页表需要一次分配所有页表空间，两级页表则可以在需要的时候再分配页表空间。 引入多级页表的原因是避免把全部页表一直保存在内存中（特别是一些从不需要的页表）： 在左边的是顶级页表（页目录表），它有1024个表项，对应于10位的PT1域。当一个虚拟地址被送到MMU时，MMU首先提取PT1域并把该值作为访问顶级页表的索引。因为整个4GB（即32位）虚拟地址空间已经按4KB大小分块，所以顶级页表中这1024个表项的每一个都表示4M的块地址范围。二级页表的每一项都表示4KB的地址范围。Offset对4096个地址进行编址。 由索引顶级页表得到的表项中含有二级页表的地址或页框号。顶级页表的表项0指向程序正文的页表，表项1指向数据的页表，表项1023指向堆栈的页表，其他的表项未用，现在把PT2域作为访问选定的二级页表的索引，以便找到该虚拟页面的对应页框号。 虽然虚拟地址空间超过100万个页面，实际上只需要4个页表：顶级页表，0-4M（正文段），4M-8M（数据段）和顶端4M（堆栈段）的二级页表。顶级页表中1021个表项的“在/不在”都设成0，当访问他们时强制产生一个缺页中断。 二级页表可扩充为三级、四级或更多级。级数越多，灵活性就越大。 页目录指针表。每一级的页表项由32位扩展到了64位，这样处理器就能寻址到4GB以外的地址空间。 最优页面置换算法 当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，来为即将调入的页面腾出空间。 此算法不可能实现。在发生缺页中断的时候，在内存中的页面有的很快就会被访问，而有的页面可能要到10、100、1000条指令后才会被访问。此时要置换最迟被访问的页面，把因调用被替换的页面而引起的中断推迟到将来，越久越好。当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问，因此这个算法是无法被实现的。 这个算法可以用来对其他可实现算法的性能进行比较。 最近未使用页面置换算法（NRU，Not Recently Used） 当页面被访问（读或写）时设置R位，页面被写入（修改）时设置M位。 当启动一个进程时，它的所有页面的两个位都由操作系统设为0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。 当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类： 第0类：没有被访问，没有被修改。 第1类：没有被访问，已被修改（M）。 第2类：已被访问，没有被修改（R）。 第3类：已被访问，已被修改（RM）。 NRU 算法随机地从类编号最小的非空类中挑选一个页面淘汰。在一个时间滴答中（大约20ms）淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好。NRU算法的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。 算法思路：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。 所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;stdio.h&gt;#define MAX 100int judge(int a[],int n,int x) &#123; //判断数组中是否已有x，若有返回其下标值，没有则返回-1 int i; for(i=0; i&lt;n; i++) if(x==a[i]) return i; return -1;&#125;void init(int a[],int n) &#123; //初始化数组为-1 int i; for(i=0; i&lt;n; i++) a[i]=-1;&#125;void insert(int a[],int n,int x) &#123; //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) int i; for(i=0; i&lt;n-1; i++) a[i]=a[i+1]; a[n-1]=x;&#125;void move(int a[],int n,int i) &#123; //移动下标为i的元素到尾部 int j; int m=a[i]; for(j=i; j&lt;n-1; j++) a[j]=a[j+1]; a[n-1]=m;&#125;void print(int a[],int n) &#123; //输出当前数组元素 int i; for(i=0; i&lt;n; i++) if(a[i]!=-1) printf(&quot; %d&quot;,a[i]); printf(&quot;\\n&quot;);&#125;int main() &#123; int stack[MAX]; int top=-1; //模仿栈的定义 int n,x; printf(&quot;请输入物理块数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); init(stack,n); //初始化数组 printf(&quot;请输入内存访问序列：\\n&quot;); while(~scanf(&quot;%d&quot;,&amp;x)) &#123; //自动读数 printf(&quot;访问页面%d:\\n&quot;,x); top++; //读数后top自动+1 if(top==0) //若数组无元素 stack[top]=x; //插入一个元素 else if(top&lt;n) &#123; //若在物理块范围内 if(judge(stack,n,x)==-1) //若数组中不存在待插入元素 stack[top]=x; ree//新元素从尾部插入 else &#123; //若数组中存在待插入元素 move(stack,top,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; else &#123; //超过物理块数的元素 if(judge(stack,n,x)==-1) &#123; //若数组中不存在待插入元素 insert(stack,n,x); //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) top--; //因为没有插入新元素，回滚top值 &#125; else &#123; //若数组中存在待插入元素 move(stack,n,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; print(stack,n); //读一个序列号，输出当前数组元素 &#125; return 0;&#125; 先进先出页面置换算法（FIFO）开销同样较小的FIFO算法，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。这种算法的缺点是可能会把有用的页面淘汰掉。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#define totalCmdNum 320 // 指令总数#define BlockNum 4 // 内存块总数// 内存块结构体typedef struct &#123; int id; // 物理地址 int page; // 页号(默认为-1) int keepTime; // 在内存中驻留的时间&#125; Block;int cmdNum = 0; // 指令执行次数int curCmd; // 当前正在执行的指令int isExecute[totalCmdNum]; // 判断每条指令是否执行的标志数组double lostPage = 0; // 缺页次数Block *blocks[BlockNum]; // 内存块指针数组// 初始化void init() &#123; // 初始化标志数组 for (int i = 0; i &lt; totalCmdNum; i++) &#123; // 0代表未执行 isExecute[i] = 0; &#125; // 设置随机数种子 srand(time(NULL)); // 初始化内存块数组 for (int i = 0; i &lt; BlockNum; i++) &#123; // 分配空间 blocks[i] = (Block *)malloc(sizeof(Block)); blocks[i]-&gt;id = i + 1; // 物理地址 blocks[i]-&gt;page = -1; // -1 代表此页还未分配 blocks[i]-&gt;keepTime = 0; // 内存驻留时间 &#125;&#125;// 产生指令int genCmd() &#123; cmdNum++; // 累计指令条数 if (cmdNum == 1) &#123; curCmd = rand() % totalCmdNum; &#125; if (cmdNum == 2) &#123; curCmd++; // 顺序执行下一条指令 &#125; if (cmdNum &gt;= 3) &#123; switch ((cmdNum - 2) % 4) &#123; case 1: // 前地址部分 curCmd = rand() % (curCmd - 2); break; case 2: case 0: curCmd++; // 顺序执行下一条指令 break; case 3: // 后地址部分 curCmd = curCmd + 1 + rand() % (totalCmdNum - curCmd); break; &#125; &#125; isExecute[curCmd] = 1; // 1代表该指令已被执行(可以重复执行) return curCmd;&#125;// 判断所有指令是否全部执行了一遍int isFinish() &#123; int flag = 1; // 遍历所有指令执行情况 for (int i = 0; i &lt; totalCmdNum; i++) &#123; if (isExecute[i] == 0) &#123; flag = 0; break; &#125; &#125; return flag;&#125;// 作业调度void dispatchJob() &#123; int page = genCmd() / 10; // 根据指令号计算页号 int i = 0; for (; i &lt; BlockNum; i++) &#123; // 如果访问的指令在内存中，则显示其物理地址 if (blocks[i]-&gt;page == page) &#123; printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[i]-&gt;id); break; &#125; &#125; // 如果访问的指令不在内存中 if (i &gt;= BlockNum) &#123; i = 0; for (; i &lt; BlockNum; i++) &#123; // 寻找未分配的内存块 if (blocks[i]-&gt;page == -1) &#123; blocks[i]-&gt;page = page; //printf(&quot;内存块未分配\\n&quot;); printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[i]-&gt;id); break; &#125; &#125; &#125; // 如果所有内存块都已被分配 if (i &gt;= BlockNum) &#123; int oldestBlock = 0; // 最先被分配的内存块 int maxKeepTime = blocks[0]-&gt;keepTime; // 最长内存驻留时间 i = 1; for (; i &lt; BlockNum; i++) &#123; if (blocks[i]-&gt;keepTime &gt; maxKeepTime) &#123; oldestBlock = blocks[i]-&gt;id; maxKeepTime = blocks[i]-&gt;keepTime; &#125; &#125; blocks[oldestBlock]-&gt;page = page; blocks[oldestBlock]-&gt;keepTime = 0; lostPage++; // 累计缺页次数 //printf(&quot;缺页了\\n&quot;); printf(&quot;指令%3d在内存块%d中\\n&quot;, curCmd, blocks[oldestBlock]-&gt;id); &#125; i = 0; for (; i &lt; BlockNum; i++) &#123; if (blocks[i]-&gt;page != -1) &#123; blocks[i]-&gt;keepTime++; // 累计驻留时间 &#125; &#125;&#125;int main() &#123; init(); // 初始化 while (1) &#123; dispatchJob(); // 作业调度 if (isFinish()) &#123; // 判断作业是否运行完成 break; &#125; &#125; printf(&quot;\\n共执行指令%d条\\n&quot;, cmdNum); printf(&quot;缺页率约为:%.1lf%%\\n&quot;, (lostPage / cmdNum)*100); return 0;&#125; 第二次机会页面置换算法（SC，Second Chance） 对FIFO算法的改进，对FIFO算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位置0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入时间使它就像刚装入的一样，然后继续搜索。 第二次机会（second chance）算法是寻找一个在最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。假设所有页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。最后又会回到原来的表头页面，此时它的R位已经被清除了，因此这个页面会被淘汰，所以这个算法总是可以结束的。 假设在时间20发生了一次缺页中断，这时最老的页面是A，它是在时刻0到达的。如果A的R位是0，则将它淘汰出内存，或者把它写回磁盘（如果它已被修改过），或者只是简单地放弃（如果它是“干净”的）；另一方面，如果其R位已经设置了，则将A放到链表的尾部并且重新设置“装入时间”为当前时刻（20），然后清除R位。然后从B页面开始继续搜索合适的页面。 第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。特别地，想象一下，假设图3-15a中所有的页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。算法又将回到页面A，此时它的R位已经被清除了，因此A页面将被淘汰，所以这个算法总是可以结束的。 时钟页面置换算法（CLOCK） 对第二次机会算法的改进，第二次机会算法经常要在链表中移动页面，既降低了效率又不是很必要。 一个更好的做法就是把所有的页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面。当发生缺页中断时，首先检查表指针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表指针前移一个位置。如果R位是1就清除R位并把表指针前移一个位置；重复这个过程一直到找到一个R位为0的页面为止。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * clock_pro.c * * Created on: 2019年12月6日 * Author: zyli */#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdbool.h&gt;#define Maxblocks 3int blocks[Maxblocks] = &#123;&#125;;int access[Maxblocks] = &#123;&#125;;int modify[Maxblocks] = &#123;&#125;;int pages_in_blocks = 0;int is_modified = 0;int aimed_i=-1;bool is_aimed(int pn) &#123; aimed_i=-1; for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(blocks[i]==pn) &#123; aimed_i=i; return true; &#125; &#125; return false;&#125;void loop() &#123; int taotaip=0; for(int j=0; j&lt;2; j++) &#123; for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!access[i]&amp;&amp;!modify[i]) &#123; taotaip=blocks[i]; for(; i&lt;pages_in_blocks; i++) &#123; blocks[i]=blocks[i+1]; access[i]=access[i+1]; modify[i]=modify[i+1]; &#125; if(!j) printf(&quot;第一圈有（0，0）的，是页面 %d，淘汰！把新页面放入队尾\\n&quot;,taotaip); else printf(&quot;第三圈有（0，0）的，是页面 %d，淘汰！把新页面放入队尾\\n&quot;,taotaip); return; &#125; &#125; if(!j) printf(&quot;第一圈没有（0，0）的，接着找（0，1）的\\n&quot;); else printf(&quot;第三圈没有（0，0）的，即上一圈（第二圈）全为（0，1）\\n&quot;); for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!(!access[i]&amp;&amp;modify[i])) &#123; access[i]=0; &#125; else &#123; taotaip=blocks[i]; for(; i&lt;pages_in_blocks; i++) &#123; blocks[i]=blocks[i+1]; access[i]=access[i+1]; modify[i]=modify[i+1]; &#125; if(!j) printf(&quot;第二圈有（0，1）的，是页面 %d，淘汰！第一个（0，1）之前的页面访问位全部置为0，并把新页面放入队尾\\n&quot;,taotaip); else printf(&quot;第四圈必有（0，1）的，将第一个（0，1）的，即页面%d淘汰！把新页面放入队尾\\n&quot;,taotaip); return; &#125; &#125; printf(&quot;第二圈没有（0，1）的，但把所有访问位置为0了，接着第三圈找（0，0）的\\n&quot;); &#125;&#125;void clock_pro(int pn) &#123; if(pages_in_blocks&lt;Maxblocks) &#123; if(is_aimed(pn)) &#123; access[aimed_i]=1; printf(&quot;输入页面是否被修改%d (0/1)\\n&quot;,pn); scanf(&quot;%d&quot;,&amp;is_modified); if(is_modified) modify[aimed_i]=1; &#125; else &#123; blocks[pages_in_blocks]=pn; access[pages_in_blocks]=1; modify[pages_in_blocks]=0; pages_in_blocks++; &#125; &#125; else &#123; if(is_aimed(pn)) &#123; access[aimed_i]=1; printf(&quot;输入页面是否被修改%d (0/1)\\n&quot;,pn); scanf(&quot;%d&quot;,&amp;is_modified); if(is_modified) modify[aimed_i]=1; &#125; else &#123; loop(); blocks[Maxblocks-1]=pn; access[Maxblocks-1]=1; modify[Maxblocks-1]=0; &#125; &#125;&#125;void print_blocks() &#123; int cato=0; printf(&quot;此时内存块里状态为：\\n&quot;); for(int i=0; i&lt;pages_in_blocks; i++) &#123; if(!access[i] &amp;&amp; !modify[i]) cato=1; if(!access[i] &amp;&amp; modify[i]) cato=2; if( access[i] &amp;&amp; !modify[i]) cato=3; if( access[i] &amp;&amp; modify[i]) cato=4; printf(&quot;%d %d %d ,对应第%d类型页面\\n&quot;,blocks[i],access[i],modify[i],cato); &#125; printf(&quot;\\n&quot;);&#125;int main() &#123; for(int i=0; i&lt;Maxblocks; i++) &#123; blocks[i]=-1; access[i]=0; modify[i]=0; &#125; int n=0; while(n&gt;=0) &#123; is_modified=0; printf(&quot;输入此时进程对哪个页面访问,输入-1结束程序\\n&quot;); scanf(&quot;%d&quot;,&amp;n); if(n&gt;=0) &#123; clock_pro(n); print_blocks(); &#125; &#125; system(&quot;pause&quot;); return 0; return 0;&#125; 最近最少使用页面置换算法（LRU，Least Recently Used） 在缺页中断发生时，置换未使用时间最长的页面。 LRU理论上是可以实现的，但是代价很高。维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。 假设用硬件实现：硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问完内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面，但是只有非常少的计算机拥有这样的硬件。 算法过程：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰，所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;stdio.h&gt;#define MAX 100int judge(int a[],int n,int x) &#123; //判断数组中是否已有x，若有返回其下标值，没有则返回-1 int i; for(i=0; i&lt;n; i++) if(x==a[i]) return i; return -1;&#125;void init(int a[],int n) &#123; //初始化数组为-1 int i; for(i=0; i&lt;n; i++) a[i]=-1;&#125;void insert(int a[],int n,int x) &#123; //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) int i; for(i=0; i&lt;n-1; i++) a[i]=a[i+1]; a[n-1]=x;&#125;void move(int a[],int n,int i) &#123; //移动下标为i的元素到尾部 int j; int m=a[i]; for(j=i; j&lt;n-1; j++) a[j]=a[j+1]; a[n-1]=m;&#125;void print(int a[],int n) &#123; //输出当前数组元素 int i; for(i=0; i&lt;n; i++) if(a[i]!=-1) printf(&quot; %d&quot;,a[i]); printf(&quot;\\n&quot;);&#125;int main() &#123; int stack[MAX]; int top=-1; //模仿栈的定义 int n,x; printf(&quot;请输入物理块数：\\n&quot;); scanf(&quot;%d&quot;,&amp;n); init(stack,n); //初始化数组 printf(&quot;请输入内存访问序列：\\n&quot;); while(~scanf(&quot;%d&quot;,&amp;x)) &#123; //自动读数 printf(&quot;访问页面%d:\\n&quot;,x); top++; //读数后top自动+1 if(top==0) //若数组无元素 stack[top]=x; //插入一个元素 else if(top&lt;n) &#123; //若在物理块范围内 if(judge(stack,n,x)==-1) //若数组中不存在待插入元素 stack[top]=x; //新元素从尾部插入 else &#123; //若数组中存在待插入元素 move(stack,top,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; else &#123; //超过物理块数的元素 if(judge(stack,n,x)==-1) &#123; //若数组中不存在待插入元素 insert(stack,n,x); //栈法插入(第一个元素出，后面元素前移，新元素从尾部入) top--; //因为没有插入新元素，回滚top值 &#125; else &#123; //若数组中存在待插入元素 move(stack,n,judge(stack,n,x)); //移动下标为i的元素到尾部 top--; //因为没有插入新元素，回滚top值 &#125; &#125; print(stack,n); //读一个序列号，输出当前数组元素 &#125; return 0;&#125; 最不常用页面置换算法（NFU）（Not Frequently Used） 用一个软件模拟LRU，该算法将每个页面与一个软件计数器相关联。计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。 NFU的缺点是它不从不忘记任何事，比如一个页面之前频繁被访问，导致这个它的计数器很大，但是后来它不被访问了，而它的计数器的值还是很大，所以它一直不会被置换出去。 老化算法 老化算法是对NFU算法的修改，其修改包括两个部分，首先，在R位被加进之前将计数器右移一位，其次，将R位加到计数器最左端的位而不是最右端的位。 老化算法中的计数器只有有限位数，如果时钟滴答是20ms，8位一般是够用的。假如一个页面160ms没有被访问过，那么它很可能并不重要。 工作集页面置换算法 一个进程当前正在使用的页面的集合称为它的工作集。 若每执行几条指令就产生一次缺页中断，那么就称这个程序发生了颠簸。 在单纯的分页系统中，刚启动进程时，在内存中并没有页面。在CPU试图读取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面，其他由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略被称为请求调页。 有不少分页系统会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已经在内存中了。该方法称为工作集模型，大大减少缺页中断率。在进程前装入其工作集页面也称为预先调页。工作集是随时间变化的。 事实上大多数程序会任意访问一小部分页面，工作集随时间缓慢变化。当程序重新开始时，就有可能根据它上次结束时的工作集对要用到的页面做一个合理的推测，预先调页就是在程序IXUS运行之前预先装入推测的工作集的页面。 按照以前的方法，定义工作集为前1000万次内存访问锁使用过的页面的集合，那么现在就可以这样定义：工作集即是过去10ms中的内存访问所用到的页面的集合。这样的模型很合适而且更容易实现。要注意到，每个进程只计算它自己的执行时间。因此，如果一个进程在T时刻开始，在(T+100ms)的时刻使用了40msCPU时间，对工作集而言，它的时间就是40ms。一个程序从它开始执行到当前所实际使用的CPU时间总数通常称作当前实际运行时间。通过这个近似的方法，进程的工作集可以被称为在过去的τ秒实际运行时间中它所访问过的页面的集合。 基于工作集的页面置换算法就是找出一个不在工作集中的页面并淘汰它。每个表项至少包含两条信息：上次使用该页面的近似时间和R（访问位）。 过程： 扫描所有的页面检查R位 若（R == 1）：设置上次使用时间为当前实际时间，以表示缺页中断时该页面正在被使用 若（R == 0 且生存时间&gt;τ）：移出这个页面，该页面在当前时钟滴答中未被访问，不在工作集中，用新的页面置换它。扫描会继续进行以更新剩余的表项。 若（R == 0 且生存时间≤τ）：记住最小时间。如果该页面R==0且生存时间小于或等于τ，则页面仍在工作集中。把页面临时保存下来，但是要记住生存时间最长（“上次使用时间”的最小值）。如果扫描完整个页表却没有找到合适的淘汰的页面，如果找到了一个或多个R == 0的页面，就淘汰生存时间最长的页面。 在最坏的情况下，在当前时钟滴答中，所有的页面都被访问过了，也就是所有的R都为1，因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。 工作集时钟页面置换算法 在工作集页面置换算法中中，当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。 基于时钟算法，并且使用了工作集信息，被称为WSClock（工作集时钟）算法。由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。 与时钟算法一样，所需的数据结构是一个以页框为元素的循环表。最初，该表示空的，当装入第一个页面后，把它加到该表中。随着更多的页面加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位和M位。 与时钟算法一样，每次缺页中断时，首先检查指针指向的页面。如果R位是1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。 如果R位是0，查看生存时间，如果生存时间大于τ并且该页面是干净的，它就不在工作集中，而且在磁盘上它有一个有效的副本。申请此页框，并把新页面放在其中。如果该页面已经被修改过，就不立即申请此页框，为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作，有可能存在一个旧的而且干净的页面可以立即使用。 原则上，所有的页面都有可能因为磁盘I/O在某个时钟周期被调度，为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回n个页面。一旦达到该限制，就不允许调度新的写操作。 指针经过一圈返回它的起点，有两种情况： 至少调用了一次写操作 执行了写操作的页面已经是干净的了，置换遇到的第一个干净页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能已经把写操作重排序了。 没有调用过写操作 所有的页面都在工作集中，否则将至少执行了一个写操作。由于缺乏额外的信息，一个简单的方法就是随便置换一个干净的页面来使用，扫描中需要记录干净页面的位置。如果不存在干净页面，就选定当前页面并把它协会磁盘。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（七）：虚拟存储器","slug":"计算机操作系统（七）：虚拟存储器","date":"2021-03-20T01:40:02.000Z","updated":"2021-03-20T01:40:19.155Z","comments":true,"path":"b56da1eb9025/","link":"","permalink":"http://ozziely.com/b56da1eb9025/","excerpt":"","text":"虚拟存储器概述交换技术与覆盖技术 是在多道环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到的矛盾。 交换技术被广泛用于小型分时系统中，交换技术的发展导致了虚存技术的出现；覆盖技术主要用在早期的操作系统中。 交换技术与覆盖技术异同点： 共同点：进程的程序和数据主要放在外存，当前需要执行的部分放在内存，内外存之间进行信息交换。 不同点：如何控制交换。 覆盖技术： 把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域。 程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）。 覆盖：一个作业的若干程序段，或几个作业的某些部分共享某一个存储空间 一般要求作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖 覆盖技术的缺点： 对用户不透明，增加了用户负担 目前这一技术用于小型系统中的系统程序的内存管理上 MS-DOS的启动过程中，多次使用覆盖技术；启动之后，用户程序区TPA的高端部分与COMMAND.COM暂驻模块也是一种覆盖结构 交换技术： 当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是进程在内存与外存之间的动态调度。 这种技术多用于分时系统中。 交换技术实现中的几个问题： 选择原则：将哪个进程换出内存？ 例如：分时系统中，时间片轮转法或基于优先数的调度算法，在选择换出进程时，要确定换出的进程是要长时间等待的。 需要特殊考虑的是：任何等待I/O进程中存在的问题。 解决：从来不换出处于等待I/O状态的进程。 有些I/O进程因DMA（直接存储器访问）而不能换出内存或换出前需要操作系统的特殊帮助。 如何确定交换时机？ 只要不用或者很少再用就换出。 只在内存空间不够或有不够的危险时换出。 交换时需要做哪些工作？ 盘交换区：足够大，存放所有用户程序的所有内存映像的拷贝。 直接存取：必须能够对这些用户程序的内存映像进行存取操作。 如何确定换入内存时位置？（换出后再换入的内存位置一定要在换出前的原来位置上吗？） 受地址“绑定”技术的影响，即绝对地址产生时机的限制 覆盖与交换的比较： 与覆盖技术相比，交换技术不要求用户给出程序段之间的逻辑覆盖结构；而且，交换发生在进程或作业之间。 而覆盖发生在同一进程或作业内。 覆盖只能覆盖那些与覆盖段无关的程序段。 虚拟存储器的引入 程序装入内存时可能会出现如下问题： 程序太大，要求的空间超出了内存总容量 有大量作业要求运行，但内存不能容下所有作业 常规存储器管理方式的特征 一次性：要求作业全部装入内存才能运行。 驻留性：程序装入内存后便一直驻留内存，直至运行结束。 虚拟存储器的基本思想是：程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。 虚拟存储器支持多道程序设计技术。 虚拟存储器定义：是指具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而其成本却又接近于外存。 注意：一个虚拟存储器的最大容量是由计算机的地址结构确定的。如：若CPU的有效地址长度为32位，则程序可以寻址范围是0～(2^32)-1 ，即虚存容量为 4GB。 虚拟存储器的容量与主存的实际大小没有直接的关系，而是由主存与辅存的容量之和所确定。 虚拟存储器的实现方法 虚拟存储器的实现都是建立在离散分配的存储管理方式基础上的。 主要有： 请求分页系统 请求分段系统 请求分页系统： 在分页系统的基础上增加了请求调页功能和页面置换功能 硬件支持： 请求分页的页表机制，它是在纯分页的页表机制上增加若干项而形成的，作为请求分页的数据结构； 缺页中断机构，即每当用户程序要访问的页面尚未调入内存时 便产生一缺页中断，以请求OS将所缺的页调入内存； 地址变换机构， 它同样是在纯分页地址变换机构的基础上发展形成的 实现请求分页的软件：用于实现请求调页的软件和实现页面置换的软件 请求分段系统：为了实现请求分段，系统同样需要必要的硬件支持： 请求分段的段表机制。这是在纯分段的段表机制基础上，增加若干项而形成的； 缺段中断机构。每当用户程序所要访问的段尚未调入内存时，产生一缺段中断，请求OS将所缺的段调入内存； 地址变换机构。与请求调页类似，实现请求调段和置换功能也需要得到OS的支持。 虚拟存储器的特征 虚拟存储器的特征有： 离散性（最基本的特征） 多次性：一个作业被分成多次调入内存运行。 对换性：允许在作业的运行过程中进行换进、换出。 虚拟性（最重要的特征）：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术。 请求分页存储管理方式请求分页中的硬件支持 系统需要解决的问题： 系统如何获知进程当前所需页面不在主存 当发现缺页时，如何把所缺页面调入主存 当主存中没有空闲的页框时，为了要接受一个新页，需要把老的一页淘汰出去，根据什么策略选择欲淘汰的页面 页描述子的扩充（页表机制）： 状态位P（中断位）指示该页是在内存还是在外存 访问位 A 用于记录本页在一段时间内被访问的次数或记录本页在最近多长时间未被访问 修改位 M 表示该页在内存中是否被修改过 外存地址该页在外存上的地址，通常是物理块号 缺页中断机构 在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断。相应的中断处理程序把控制转向缺页中断子程序，执行此子程序，即把所缺页面装入主存，然后处理机重新执行缺页时打断的指令。这时，就将顺利形成物理地址。 缺页中断与一般中断的区别： 在指令执行期间产生和处理中断信号 一条指令在执行期间可能产生多次缺页中断 涉及6次缺页中断的指令 ： 如果在快表中未找到该页的页表项，则应再到内存中去查找页表，再从找到的页表项中的状态位P，该页是否调入内存。其结果可能是： 该页已经调入内存，这是应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项，然后再写入该页的页表项。 该页尚未调入内存，这时便应产生缺页中断，请求OS从外存中把该页调入内存。 请求分页中的地址变换过程： 内存分配策略和分配算法 最小物理块数的确定： 指保证进程正常运行所需的最小物理块数。当系统分配的物理块数少于此值时，进程将无法运行。 进程应获得的最小物理块数与计算机的硬件结构有关，取决于指令的格式、 功能和寻址方式。 对于单地址指令且采用直接寻址方式的机器，则所需最少2个物理块。其中，一块存放指令页面，另一块则存放数据页面。 不同的作业要求不同。例如，允许间接寻址的机器，至少要求有3个物理块；而直接寻址方式所需的最少物理块数为2： 对于长度是两个或多于两个字节指令的机器，其指令本身可能跨两个页面，且源和目标地址所涉及的区域也可能跨两个页面，至少需要6个物理块。 物理块的分配策略：在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。于是可组合出以下三种适用的策略： 固定分配局部置换(Fixed Allocation, Local Replacement) 问题：分配块数难确定，太少，缺页频繁，吞吐量降低；太多，内存驻留进程数减少，CPU或其它资源可能空闲。 可变分配全局置换(Variable Allocation, Global Replacement) 先分配给各进程一定数的物理块，系统有一空闲物理块队列，缺页时从空闲队列取，若空闲队列空时，在选页调出。 可变分配局部置换(Variable Allocation, Local Replacemen) 先分配给各进程一定数的物理块，缺页时从该进程在内存的页选一换出，若其频繁缺页，系统再分配若干附加物理块。 物理块分配算法： 平均分配算法： 这是将系统中所有可供分配的物理块，平均分配给各个进程。 例如，当系统中有100个物理块，有5个进程在运行时，每个进程可分得20个物理块。这种方式貌似公平，但实际上是不公平的，因为它未考虑到各进程本身的大小。如有一个进程其大小为200页，只分配给它20个块，这样，它必然会有很高的缺页率；而另一个进程只有10页，却有10个物理块闲置未用。 按比例分配算法： 这是根据进程的大小按比例分配物理块的算法。如果系统中共有n个进程，每个进程的页面数为Si，则系统中各进程页面数的总和为： 又假定系统中可用的物理块总数为m，则每个进程所能分到的物理块数为bi，将有： b应该取整，它必须大于最小物理块数。 考虑优先权的分配算法： 在实际应用中，为了照顾到重要的、紧迫的用户程序能尽快地完成， 应为它分配较多的内存空间 通常采取的方法是把内存中可供分配的所有物理块分成两部分：一部分按比例地分配给各进程；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程 在重要的系统，如实时控制系统，则可能是完全按优先权为各进程分配其物理块的 调页策略 何时调入页面： 预调页策略：采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存，成功率50%。 请求调页策略： 当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便提出请求，由OS将其所需页面调入内存。 目前的虚拟存储中大多采用此种策略。 从何处调入页面 在请求分页系统中的外存分为两部分： 用于存放文件的文件区 用于存放对换页面的对换区 通常，由于对换区是采用连续分配方式，而文件区是采用离散分配方式，故对换区的磁盘I/O速度比文件区的高。这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下三种情况： 系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前， 便须将与该进程有关的文件，从文件区拷贝到对换区。 系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。 由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。 页面调入过程 每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。该程序通过查找页表，得到该页在外存的物理块地址。 若此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表 若内存已满，则须先按照某种置换算法从内存中选出一页准备换出： 页未被修改过，可不必将该页写回磁盘 页已被修改过， 则必须将它写回磁盘，然后再把所缺的页调入内存， 并修改页表中的相应表项，置其状态位为“1”，并将此页表项写入快表中。 在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据 页面置换算法 这里简略介绍主要的几个页面置换算法，算法详解请看：页面置换算法 最佳置换算法 采用最佳置换算法可保证获得最低的缺页率。 但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法也是无法实现的，但是可利用该算法去评价其它算法。 例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串：7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1进程运行时， 先将7，0，1三个页面装入内存。 以后，当进程要访问页面2时将会产生缺页中断。此时OS根据最佳置换算法，将淘汰页面7： 先进先出置换算法（FIFO） 该算法总是淘汰最先进入内存的页面，即选择在内存中的驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老页面。 但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，含有全局变量、常用函数、例程等的页面，FIFO置换算法并不能保证这些页面不被淘汰： 最近最久未使用置换算法（LRU） FIFO置换算法之所以性能较差，是因为它所依据的条件是各个页面调入内存的时间，而页面调入的先后并不能反映页面的使用情况。而最近最久未使用（LRU）的页面置换算法，则是根据页面调入内存后的使用情况。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似。因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。 算法描述：选择最后一次访问时间距离当前时间最长的一页并淘汰之。即淘汰没有使用的时间最长的页。实现代价很高（时间戳或硬件方法） 把LRU算法作为页面置换算法是比较好的，它对于各种类型的程序都能适用，但实现起来有相当大的难度，因为它要求系统具有较多的支持硬件。所要解决的问题有： 一个进程在内存中的各个页面各有多久时间未被进程访问； 如何快速地知道哪一页最近最久未使用的页面。 为此，须利用以下两类支持硬件： 移位寄存器：定时右移 栈：当进程访问某页时，将其移出压入“栈顶”，“栈底”换出。 影响缺页次数的因素： 分配给进程的物理页面数 页面本身的大小 程序的编制方法 页面淘汰算法 请求分段存储管理方式请求分段中的硬件支持 段表机制： 存取方式：用于标识本分段存取属性是只执行、只读还是允许读/写 存在位P：用于指示该段是否已调入内存 访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页在最近多长时间未被访问。 修改位M：表示该段在调入内存后是否被修改过 外存地址：本段在外存上的地址，盘块块号 增补位：本段在运行过程中是否做过动态增长 请求分段系统中的中断处理过程： 从中可以看出，对缺段中断的处理要比对缺页中断的处理复杂，因为段是不定长的。 地址变换机构：请求分段系统中的地址变换机构，是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，因而在地址变换时，若发现所要访问的段不在内存时，必须先将所缺的段调入内存，并修改了段表之后，才能再利用段表进行地址变换。为此，在地址变换机制中又增加了某些功能，如缺段中断的请求及其处理等。 下图表示出了请求分段系统的地址变换过程：（段号为S，段内地址为W） 分段的共享与保护 共享段表 为了实现分段共享，可在系统中配置一张共享段表所有各共享段都在共享段表中占有一表项。 共享进程计数count 记录有多少个进程需要共享该分段 存取控制字段 对于一个共享段，应给不同的进程以不同的权限 段号 对于一个共享段，不同的进程可以各用不同的段号去共享该段 共享段的分配 对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1； 当又有其它进程需要调用该共享段时，无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段 共享段的回收： 撤消在该进程段表中共享段所对应的表项 执行count∶=count-1操作 若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段； 否则(减1结果不为0)，则只是取消调用者进程在共享段表中的有关记录。 分段保护 越界检查 在段表寄存器中放有段表长度信息；同样，在段表中也为每个段设置有段长字段。 在进行存储访问时，首先，将逻辑地址空间的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断信号； 其次，还要检查段内地址是否等于或大于段长，若大于段长，将产生地址越界中断信号，从而保证了每个进程只能在自己的地址空间内运行。 存取控制检查：在段表的每个表项中，都设置了一个“存取控制”字段，用于规定对该段的访问方式。通常的访问方式有： 只读：只允许程序对该段中的程序或数据进行读访问； 只执行：只允许程序调用该段去执行，但不准读该段的内容，也不允许对该段执行写操作； 读/写：允许程序对该段进行读写访问。 环保护机构：它是一种功能较完善的保护机构。在该机制中规定：低编号的环具有高优先权，OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序，则被安排在外环上。 低编号的环具有高优先权，操作系统位于最核心环 内环可访问外环数据：一个程序可以访问驻留在相同环或较低特权环中的数据 外环可请求内环服务：一个程序可以调用驻留在相同环或较高特权环中的服务","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（六）：存储管理方式","slug":"计算机操作系统（六）：存储管理方式","date":"2021-03-20T01:38:35.000Z","updated":"2021-03-20T01:39:23.277Z","comments":true,"path":"8850f5f3d4be/","link":"","permalink":"http://ozziely.com/8850f5f3d4be/","excerpt":"","text":"分页存储管理方式在分页存储管理的方式中，如果不具备页面对换功能，则称为基本的（纯）分页管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。 离散分配方式： 连续分配方式要求为一个进程分配连续的内存空间，会形成许多“碎片”，尽管采用“紧凑”技术可以解决这个问题，但要为移动大量信息花去不少的处理机时间，代价较高。 如果允许一个进程直接分散地装入到许多不相邻接的分区中，称为离散分配方式。 离散分配方式有分页存储管理方式和分段存储管理方式两种。 分页：把用户程序按逻辑页划分成大小相等的部分，称为页或虚页。从0开始编制页号，页内地址是相对于0编址。 页面与页表 页面和物理块： 页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并加以编号，从0开始编制页号，页内地址是相对于0编址。 物理块：内存按页的大小划分为大小相等的区域，称为物理块（物理页面，页框(frame)，帧），同样加以编号，如0＃块、1＃块等等 在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 页面大小：页面的大小应选择的适中，且页面大小应是2的幂，通常为512 B~8 KB 页面若太小：虽然可使内存碎片减小，从而减少了内存碎片的总空间， 有利于提高内存利用率，但也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存； 此外，还会降低页面换进换出的效率 页面若太大：虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。 例如：系统页面大小为1KB，逻辑地址为2170，求页号与页内偏移量 页号 P=INT[2170/1024]=2。 页内偏移量d=2170 mod 1024 =122 第0页 0~1023 第1页 1024~2047 第2页 2048~3071 综上所述，表示为(2,122) 主存分配：把用户程序的任一页分配到内存中的任一物理块，从而实现非连续的内存分配。 问题：如何管理、如何进行地址变换。 页表 分页系统中，将进程的每一页离散地存储在内存的任一物理块中，为每个进程建立一张页面映像表，简称页表。 作用：实现页号到物理块号的映射。 例如： 页表列出了用户程序的逻辑地址与其在主存中的物理地址间的对应关系。 一个页表中包含若干个表目，表目的自然序号对应于用户程序中的页号，表目中的块号是该页对应的物理块号。 页表的每一个表目除了包含指向页框的指针外，还包括一个存取控制字段，表目也称为页描述子。 例如： 地址变换机构 基本地址变换机构： 实现从逻辑地址到物理地址的转换，将逻辑地址中的页号转换为内存中的物理块号，通过页表来完成。 页表的实现 寄存器：变换速度快、成本高，适应小型系统。 页表驻留在内存：速度较低、成本低，适应大系统。 页表大多驻留在内存中，在系统中设置页表寄存器PTR(Page – Table Register)，在其中存放页表在内存中的始址和页表的长度。 进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，才将这两个数据装入页表寄存器。 地址结构：例如：32位地址，011为偏移量，1231为页号，最大可以有1M（2^20）页，每页4KB（2^12） 。 基本的地址变换机构： 每个进程对应一页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。 当进程要访问某个进程逻辑地址中的数据时，分为页号和页内地址两部分。 如果页号大于或等于页表长度，则表示本次所访问的地址已经超越进程的地址空间。 地址变换过程： 指令 LOAD 1,2500 的地址变换过程（块大小为1024B）。 地址变换过程： 把虚拟地址2500转换成页号P=2，位移量W=452； 如果页号2大于页表大小，则中断；否则继续； 页号2与页表起址1000运算（1000+2*20，设页描述子大小为20）得到页描述子地址为1040； 从页描述子中读取块号8； 根据页描述子的“存取控制”判断该指令是否被允许访问内存，如果不允许，则中断；否则继续； 块号8与位移量452运算（8*1024+452=9644，1024为页面大小）得到物理地址9644； 执行LOAD操作。 具有快表的地址变换机构： 由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。 第一次是访问内存中的页表，从中找到该页的物理块号，将此块号与页内偏移量W拼接以形成物理地址。 第二次访问内存时，才是从第一步所得地址中获得所需数据（或向此地址中写入数据），并将此页号与高速缓存中的所有页码进行比较。 在具有快表的地址变换机构中，为提高地址变换速度，在地址变换机构中增设一个具有并行查询能力的高速缓冲寄存器，又称为“联想寄存器”（Associative Memory）或“快表”，用以存放当前访问的那些页表项，快表通常可存放16-512个表项，如果设计得当，命中率可达90％以上。 两级和多级页表 现代的大多数计算机系统，都支持非常大的逻辑地址空间(232~264)。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。 例如，对于一个具有32位逻辑地址空间的分页系统，若规定页面大小为4 KB即212 B，则在每个进程页表中的页表项可达1M(220)个之多。若每个表项占用4个字节(32bit)， 故每个进程仅仅其页表就要占用4 MB的内存空间，而且还要求是连续的。 可以采用这样两个方法来解决这一问题： 采用离散分配方式来解决难以找到一块连续的大内存空间的问题 只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入 两级页表(Two-Level Page Table) ：可利用将页表分页，并离散地将各个页面分别存放在不同的物理块中，同样要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），每个页表项中记录了页表页面的物理块号： 两级页表结构： 每个物理块为4KB，恰好放一个1页页表（1024个项，每项4Byte），共需1024个这样的块。 具有两级页表的地址变换机构: 分段存储管理方式分段存储管理方式的引入 基本分段存储管理： 不便于信息共享、保护、动态增长和链接。 分页存储管理的主要目的是为了提高内存利用率，满足用户在编程和使用上的要求。 分段管理的主要目的： 方便编程：通常，一个作业是由若干个自然段组成。因而，用户希望能把自己的作业按照逻辑关系划分为若干个段；每个段都有自己的名字和长度；要访问的逻辑地址是由段名（段号）和段内偏移量决定；每个段都从0开始编址。这样，用户程序在执行中可用段名和段内地址进行访问。用户作业通常按逻辑关系分若干个段： LOAD 1, [A]|&lt;D&gt; STORE 1,[B]|&lt;C&gt; 信息共享：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的。为了实现的共享，也希望存储管理能与用户程序分段的组织方式相适应。 程序与数据的共享是以信息的逻辑单位为基础 信息保护：在多道程序环境下，为了防止其它程序对某种程序在内存中的数据有意无意的破坏，必须采用保护措施，对内存中信息的保护，同样是对信息的逻辑单位进行保护。因此，采用分段的组织和管理方式，对于实现保护功能，将是更有效和方便的。 动态增长：在实际使用中，往往有些段特别是数据段，会不断地增长，而事先又无法确切地知道数据段会增长到多大。这种动态增长的情况是其它几种存储管理方式都难于应付的；而分段存储管理方式却能较好地解决这一问题。 动态链接：通常，用户源程序经过编译所形成的若干个目标程序，还须再经过链接以形成可执行程序后，方能执行，进行的链接称为静态链接。动态链接是指在作业运行之前，并不把几个目标程序段链接起来。 分段系统的基本原理 分段存储管理方式中，作业的地址空间被分成若干个段(segment)，每个段定义了一组逻辑信息。 分段地址中的地址具有如下结构： 分段方式已得到许多编译程序的支持。 段表： 在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中的不同的分区中 系统为每个进程建立一张段映射表，简称为“段表” 每个段在段表中占一个表项，其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度 它记录了段号，段的首（地）址和长度之间的关系，每一个程序设置一个段表，放在内存,属于进程的现场信息。 利用段表实现地址映射： 分段系统的地址变换过程： 地址映射及存储保护机制： 分页和分段的主要区别： 页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。 分段的目的是为了能更好地满足用户的需要。 页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定， 决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。 分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址； 而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名， 又需给出段内地址。 整理如下： 信息共享 分段存储的一个优点是易于实现段的共享，即允许若干个进程共享一个或多个分段。 分页系统中虽然也能实现程序和数据的共享，但远不如分段系统方便。 可重入代码（Reentrant Code）又称为“纯代码”（Pure Code）是一种允许多个进程同时访问的代码。可重入代码是一种不允许任何进程对它进行修改的代码。 分页系统中共享editor的示意图： 分段管理的优缺点： 优点： 便于动态申请内存 管理和使用统一化 便于共享 便于动态链接 缺点：产生碎片，段还需要连续的存储空间。 段页式存储管理方式 基本原理 是分段和分页原理的结合 将用户程序分成若干个段，再把每一段分成若干个页，并为每一段赋予一个段名 段页式管理中，地址机构由段号、段内页号及页内地址三部分所组成 作业地址空间和地址结构： 在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需同时配置段表和页表。由于允许将一个段中的页进行离散分配，因而使段表的内容略有变化：它不在是段的内存始址和段长，而是页表始址和页表长度。 利用段表和页表实现地址映射： 在段页式系统中，需三次访问内存： 第一次访问，是访问内存中的段表。 第二次访问，是访问内存中的页表。 第三次访问，才是真正从第二次访问所得的地址中，取出指令或数据。 段页式系统中的地址变换过程：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（五）：存储器管理概述","slug":"计算机操作系统（五）：存储器管理概述","date":"2021-03-20T01:36:13.000Z","updated":"2021-03-20T01:37:41.145Z","comments":true,"path":"0f07f5c9c9f3/","link":"","permalink":"http://ozziely.com/0f07f5c9c9f3/","excerpt":"","text":"存储器的层次结构 计算机的基本物理组成： 指令的执行过程： CPU与内存的关系： 传输数据流程简图： 存储器是计算机系统重要的组成部分，虽然存储器的容量不断扩大，但仍不能满足要求，因此存储器管理是操作系统的重要工作。 存储器包括内存（主存）和外存（磁盘） 存储器的功能是保存数据，存储器的发展方向是高速、大容量和小体积。 内存在访问速度方面的发展：DRAM、SDRAM、SRAM等； 硬盘技术在大容量方面的发展：接口标准、存储密度等。 主存储器管理技术分为两大类： 实存储器管理； 虚拟存储器管理。 存储器的物理组织、多级存储器： 存储组织是指在存储技术和CPU寻址技术许可的范围内组织合理的存储结构。其依据是访问速度匹配关系、容量要求和价格。主要有以下结构： “寄存器-内存-外存” 结构 “寄存器-缓存-内存-外存”结构； 微机中的存储层次组织： 访问速度越慢，容量越大，价格越便宜； 最佳状态应是各层次的存储器都处于均衡的繁忙状态（如：缓存命中率正好使主存读写保持繁忙）。 存储器的层次： 高速缓存（Cache）：CPU要读取一个数据时，首先从Cache(SRAM)中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就用相对慢的速度从内存中读取并送给CPU处理，同时把这个数据所在的数据块调入Cache中，可以使得以后对整块数据的读取都从Cache中进行，不必再调用内存。 程序的装入和链接 多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事就是分配内存。 源程序要运行通常经过编译（compile）-&gt; 链接(link) -&gt; 装入(load)等几个步骤： 程序的装入： 绝对装入方式 事先确定了程序将驻留在内存的什么位置，即在内存中的绝对地址。 装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。 绝对地址的产生： 程序员直接赋予。不仅要求程序员熟悉内存使用情况，而且一旦程序或数据被修改后，可能要改变程序中的所有地址。通常在程序中采用符号地址，在编译或汇编时，再将符号地址转换为绝对地址。 编译或汇编时产生 缺点：绝对装入方式只能将目标模块装入到内存中事先指定的位置。在多道程序环境下，不可能预知目标模块放在内存中的地址，因此绝对装入方式不适合在多道环境下使用。 可重定位装入方式 程序中目标模块的地址通常从0开始，其他地址都是相对于0计算——相对地址 把在装入时对目标程序中指令和数据的地址修改过程称为重定位，又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。 例如： 缺点： 不断的分配和回收，造成内存中小空闲块很多，总空闲空间量够，但分配不了。 理论上的解决办法：办法：紧凑（移动），但该装入方法不支持。 可重定位方式不允许程序运行时在内存中移动位置。 动态运行时装入方式 动态运行时的装入程序，是在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址 程序的链接： 静态链接方式 在程序运行前，先将各目标模块及所需的库函数链接成一个完整的装配模块，以后不再拆开 在将这几个目标模块装配成一个装入模块时，须解决以下两个问题 对相对地址进行修改 变换外部调用符号 例如： 装入时动态链接 将用户的源程序编译后所得的一组目标模块在装入内存时采用边装入边链接的方式 便于修改和更新 便于实现对目标模块的共享 例如： 缺点：应用程序在每次运行的模块可能不相同。 运行时动态链接 运行时动态链接方式将对某些模块的链接推迟到执行时才进行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。 凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。 例如： 连续分配存储管理方式单一连续分配 连续分配方式为一个用户程序分配一个连续的内存空间。 单一连续分配是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。 把内存分为 系统区：OS使用，通常放在内存低址部分 用户区：用户可使用的全部内存空间 存储器保护机构不健全，易造成系统破坏。 优缺点： 优点：易于管理 缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存 例如： 固定分区分配 最简单的可运行多道程序的存储管理方式。 内存用户空间划分为若干个固定大小的区域，每个分区中只装入一道作业。 划分分区的方法 分区大小相等：即使所有的内存分区大小相等 太大：浪费 太小：不够用 分区大小不等：根据程序大小决定所使用的分区，划分为多个大、中、小搭配的分区 大班在大教室、小班在小教室 内存分配 ：分区的信息根据分区使用表管理 问题：并发进程数受分区个数的制约！ 出现：有内存却不能运行程序或大进程无法运行！ 动态分区分配 根据进程的实际需要，动态地为之分配内存空间。 分配中数据结构 空闲分区表 记录每个空闲分区的情况 空闲分区链 实现对空闲分区的分配和链接 例如： 基于顺序搜索的动态分区分配算法 分配算法主要有：首次适应算法FF、循环首次适应算法、最佳适应算法、最坏适应算法 首次适应被认为最好、最快。其次是循环，最佳最差（每次分配后剩下小碎片，难再分，不得不经常压缩内存，反而浪费CPU） 首次适应算法FF： 空闲分区链以地址递增顺序链接 分配时从链首开始查找，找到一个大小可满足的空闲分区，划出一块给请求者 优点：简单；优先利用低地址空闲区，保留高地址大空闲区 缺点：会造成在低地址部分很多难以利用的小空闲分区，查找效率低 循环首次适应算法： 每次分配时从上一次找到空闲分区的下一个空闲区开始查找 优点：减少查找空闲分区开销，空闲分区分布更均匀 缺点：缺乏大的空闲区 最佳适应算法： 空闲区按容量由小到大排序 每次分配时，把能满足要求、又是最小的分区分配给作业 优点：不缺乏大的空闲区 缺点：会在存储器中留直许多难以利用的小分区——“零头（或碎片）”；查找效率低 最坏适应算法： 空闲区按容量由大到小排序 每次分配时，把能满足要求、又是最大的分区分配给作业 优点：剩余的空间最大化，不出现太小的“零头” 缺点：缺乏大的空闲区 分区分配操作 回收内存 进程运行结束释放内存时，系统根据回收区的首地址，把它插入到空闲链表中。根据回收区的位置，有四种情况需处理： 情况1：回收区与插入点的前一个空闲分区相邻接 情况2：回收区与插入点的后一个空闲分区相邻接 情况3：回收区同时与插入点的前、后两个分区相邻接 情况4：回收区不与任何空闲区邻接 以上4种情况分别对应如下： 分区式存储管理的优缺点： 优点： 便于动态申请内存 便于共享内存 便于动态链接 缺点：碎片问题(外碎片)，要求连续的内存空间，内存利用率不高，受实际内存容量限制。 碎片问题：经过一段时间的分配回收后，内存中存在很多很小的空闲块。它们每一个都很小，不足以满足分配要求；但其总和满足分配要求，这些空闲块被称为碎片。 问题解决： 紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域。缺点是开销大，而且移动时机不好把握。 基于索引搜索的动态分区分配算法动态可重定位分区分配 动态重定位的引入： 连续分配存在的问题：必须有足够大的连续空间才能分配。可以用“拼接”或“紧凑”方法来解决： 动态重定位的实现 作业装入内存后的所有地址仍是相对地址，将相对地址转换成物理地址的工作在指令执行时进行 需要有硬件地址变换机构的支持 例如： 动态重定位分区分配算法： 与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了“紧凑”功能，通常是在找不到足够大的空闲分区来满足用户需求时，进行紧凑。 在一个分区释放后立即移动。 当请求得不到满足时再移动。 例如： 可重定位分区的优缺点 优点：决了可变分区分配所引入的“外零头”问题。消除内存碎片，提高内存利用率。 缺点：提高硬件成本，紧凑时花费CPU时间。 对换（Swapping） 对换的引入： 对换（也称交换）技术，最早用在单用户系统，在内存中仅驻留一道用户作业。 所有其它作业都驻留在外存的后备队列上，只调入一个作业进入内存运行；此作业的时间片用完时，该作业调至外存，再将后备队列上的另一个作业调入内存；也让它运行一个时间片的时间，然后又将它调出，再调下一个作业进入内存。 因为其效率太低，其CPU大约有一半的时间，都处于空闲状态。 所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存。对换是提高内存利用率的有效措施。 如果对换是以整个进程为单位，称为“整体对换”或“进程对换”。 如果对换是以“页”或“段”为单位进行的，则称为“页面对换”或“分段对换”，又统称为“部分对换”。 为了实现进程对换，系统必须能实现以下三方面的功能： （1）对换空间的管理； （2）进程的换出； （3）进程的换入。 对换空间的管理 外存中对换区主要存放从内存中换出的进程，对换空间管理的主要目标是提高进程换入和换出的速度。 对换区中空闲盘块的管理：在系统中配置相应的数据结构，记录外存的使用情况。形式与内存在动态分区分配方式中所用数据结构相似，即用空闲分区表或空闲分区链。在空闲分区表中的每个表目中应包含两项， 即对换区的首址及其大小，它们的单位是盘块号和盘块数。 对换区的分配采用连续分配方式，分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法。 进程的换出与换入 进程的换出：系统先选择处于“阻塞”状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上。若传送未出现错误，便回收其所占用的内存空间，并对该进程的进程控制块做相应的修改 进程的换入：系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（四）：死锁","slug":"计算机操作系统（四）：死锁","date":"2021-03-20T01:35:15.000Z","updated":"2021-03-20T01:35:46.105Z","comments":true,"path":"35479f43ab63/","link":"","permalink":"http://ozziely.com/35479f43ab63/","excerpt":"","text":"死锁概述 死锁概念：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃。 死锁的定义：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。 关于死锁的一些结论： 参与死锁的进程最少是两个； 参与死锁的进程至少有两个已经占有资源； 参与死锁的所有进程都在等待资源； 参与死锁的进程是当前系统中所有进程的子集。 资源问题：在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印机、数据文件、队列、信号量等。 可重用性资源和消耗性资源： 可重用性资源：可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质： 每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。 进程在使用可重用性资源时，须按照这样的顺序： 请求资源。如果请求资源失败，请求进程将会被阻塞或循环等待； 使用资源。进程对资源进行操作，如用打印机进行打印； 释放资源。当进程使用完后自己释放资源。 系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。 可消耗性资源：可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的，它具有如下性质： 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0； 每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0； 进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。 可抢占性资源和不可抢占性资源： 可抢占性资源：指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占。 不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。 计算机系统中的死锁： 竞争不可抢占性资源引起死锁：通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。如下表示共享文件时的死锁情况 ： 竞争可消耗资源引起死锁：如下表示在三个进程之间，在利用消息通信机制进行通信时所形成的死锁情况： 进程推进顺序不当引起死锁： 若并发进程 P1 和 P2 按曲线④所示的顺序推进，它们将进入不安全区D内。此时P1保持了资源R1, P2保持了资源R2，系统处于不安全状态。因为这时两进程再向前推进，便可能发生死锁。例如，当 P1 运行到 P1:Request(R2) 时，将因 R2 已被 P2 占用而阻塞；当 P2 运行到 P2: Request(R1) 时，也将因 R1 已被 P1 占用而阻塞，于是发生了进程死锁。 产生死锁的必要条件： 互斥条件：进程对所分配到的资源进行排它性的使用。 请求和保持条件：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有。 不剥夺条件：进程已获得的资源在未使用完之前不能被剥夺。 环路等待条件：在发生死锁时，必然存在一个 “进程—资源” 循环等待的环形链。 处理死锁的基本方法： 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止发生死锁。 避免死锁：不须采用各种限制措施去破坏产生死锁的必要条件，防止系统进入不安全状态，从而避免发生死锁，只需在事先加以较弱的限制条件。 检测死锁：不须检查系统是否已进入不安全区，允许系统在运行过程中发生死锁。 解除死锁：常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。 预防死锁 破坏 “请求和保持” 条件：所有进程在开始运行之前必须一次性的申请整个运行过程所需的全部资源。 优点：简单、易于实现、安全。 缺点：资源浪费严重、进程延迟运行。 破坏 “不可抢占” 条件：进程逐个地申请所需资源，当一个已经保持了某些资源的进程申请新资源而不能得到满足时，必须放弃所有已保持的资源。 缺点：实现复杂、代价高昂；延长了进程的周转时间，还增加了系统开销，降低了系统的吞吐量。 破坏 “循环等待” 条件：系统将所有资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序。 优点：资源利用率系统吞吐量较高。 缺点：在资源管理和资源申请方面仍有问题 例如： 存在问题：资源的需求顺序不等于序号，仍存在资源浪费。 其资源利用率和系统吞吐量，都有较明显的改善，但也存在下述严重问题： 资源所分配的序号，必须相对稳定，这就限制了新设备类型的增加。 进程使用各资源的顺序，与系统规定的顺序不同，造成对资源的浪费。 按规定次序申请资源的方法，必然会限制了用户简单、自主地编程。 避免死锁 系统安全状态： 在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。 所谓安全状态，是指系统能按某种进程顺序（P1, P2, …，Pn，称&lt;P1, P2, …, Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。 安全状态举例： 假定系统中有三个进程 P1、 P2 和 P3，共有12台磁带机。 进程 P1 总共要求 10 台磁带机，P2 和 P3 分别要求 4 台和 9 台。 假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示： 如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如，在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。 利用银行家算法避免死锁： 银行家算法中的数据结构： 可利用资源向量Available。这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j] = K，则表示系统中现有Rj类资源K个。 最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj类资源的最大数目为K。 分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，表示进程i当前已分得Rj类资源的数目为K。 需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个，方能完成其任务。 即： 银行家算法步骤：设Requesti是进程Pi的请求向量，如果Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查： （1）如果Requesti[j] ≤ Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。 （2）如果Requesti[j] ≤ Available[j]，便转向步骤(3)；否则， 表示尚无足够资源，Pi须等待。 （3）系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值： Available[j] := Available[j] - Requesti[j]; Allocation[i,j] := Allocation[i,j] + Requesti[j]; Need[i,j] := Need[i,j] - Requesti[j]; （4）系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。 安全性算法： （1）设置两个向量： 工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work := Available; Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i] := false; 当有足够资源分配给进程时， 再令Finish[i] := true。 （2）从进程集合中找到一个能满足下述条件的进程； Finish[i] = false; Need[i,j] ≤ Work[j]; 若找到， 执行步骤(3)， 否则，执行步骤(4)。 （3）当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j] := Work[i] + Allocation[i,j]; Finish[i] := true; 执行步骤（2） （4）如果所有进程的Finish[i] = true都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。 死锁的检测 资源分配图：系统死锁可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个对偶G =（N，E），具有下述形成的定义和限制： N被分为两个互斥的子集，一组进程结点P=（p1，p2，…，pn），一组资源结点R={r1，r2，…，rn}，N=P∪R。如下图： 资源分配图表示法： 资源类：用方框表示（资源的不同类型） 资源实例：用方框中的圆点表示（存在于每个资源中） 进程：用圆圈中加进程名表示 分配边：资源实例进程的一条有向边 申请边：进程资源类的一条有向边 死锁定理：如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。 有环有死锁： 有环无死锁： 死锁定理——资源分配图化简： 找出一个既不阻塞又非独立的进程结点pi，在顺利的情况下pi可获得资源而继续运行，再释放所有资源。消去pi所有的请求边和分配边，将其变为孤立结点。 再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边。 在进行一系列化简后若能消去图中所有的边，使所有进程结点成为孤立结点，则称该图是可完全简化的；否则是不可完全简化的。 已经证明：所有的化简顺序都得到相同的不可简化图。同样可以证明，S为死锁的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件称为死锁定理。 死锁的解除 当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。 常用的方法： 抢占资源：从其他进程剥夺足够的资源给死锁进程，以解除死锁状态。 终止进程： 撤消所有死锁进程。 按照某种顺序逐个地撤消代价最小的进程，直至有足够的资源可用，使死锁状态消除；所谓代价是指优先级、运行代价、进程的重要性和价值等。 终止进程的方法： 终止所有死锁进程： 这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了。 但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终止真可谓“功亏一篑”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一列举。 逐个终止进程： 稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态解脱出来为止。 但该方法所付出的代价也可能很大。因为每终止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止另一个进程。另外，在采取逐个终止进程策略时，还涉及到应采用什么策略选择一个要终止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是“代价最小”，很难有一个精确的度量。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（三）：处理机调度","slug":"计算机操作系统（三）：处理机调度","date":"2021-03-20T01:31:22.000Z","updated":"2021-03-20T01:31:50.948Z","comments":true,"path":"29326ada3e53/","link":"","permalink":"http://ozziely.com/29326ada3e53/","excerpt":"","text":"处理机调度的层次和调度算法的目标处理机调度的层次 高级调度： 作业调度或长程调度，也称为接纳调度。 主要任务是按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入/输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利。 高级调度的时间尺度通常是分钟、小时或天。 在每次作业调度时，须决定： 接纳多少个作业：取决于多道程序度，即允许多少个作业同时在内存中运行。 要进行适当地折中，作业太多会使服务质量下降，作业太少会使资源利用率低。 接纳哪些作业：取决于作业调度算法，常用的作业调度算法包括先来先服务、短作业优先、作业优先权调度、响应比调度算法 低级调度： 进程调度或短程调度。 主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它。 常见的低级调度有非抢占式和抢占式两种。 低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效。 中级调度： 引入目的是为了提高内存利用率和系统吞吐量，使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。 主要任务是按照给定的原则和策略，将处于外存对换区中的重又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。 概念解释： 多道程序度：即允许多少个作业同时在内存中运行。 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。 吞吐量：是指在单位时间内系统所完成的作业数。 处理机调度算法的目标 处理机调度算法的共同目标： 资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算： 公平性。公平性是指应使诸进程都获得合理的CPU 时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。 平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。 策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。 批处理系统的目标： 平均周转时间短。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为： 为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间的具体分配状况，往往使用带权周转时间，即作业的周转时间T与系统为它提供服务的时间Ts之比，即W = T/Ts。而平均带权周转时间则可表示为： 系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。 处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由上所述可以看出，这些要求之间是存在着一定矛盾的。 实时系统的目标： 截止时间的保证。 可预测性。 分时系统的目标： 响应时间快。 均衡性。 作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。 操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。 作业和作业步作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。 作业控制块为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业运行时间)、资源需求(预计运行时间、要求内存大小等)、资源使用情况等。 作业运行的三个阶段和三种状态作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。即： 作业阶段 作业状态 收容阶段 后备状态 运行阶段 运行状态 完成阶段 完成状态 作业调度的主要任务 作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度在每次执行作业调度时，都需做出以下两个决定。 接纳多少个作业 接纳哪些作业 先来先服务 (first-come first-served，FCFS) 调度算法： FCFS 是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。 当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。 在采用FCFS算法时，人—机无法实现交互。 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。 短作业优先 (short job first，SJF) 的调度算法： 由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。 SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。 SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。 SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点： 必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。 对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。 优先级调度算法 (priority-scheduling algorithm，PSA) 和 高响应比优先调度算法 (Highest Response Ratio Next，HRRN) ： 我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。 高响应比优先算法是如何实现的呢? 如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为： 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比RP。据此，优先又可表示为： 进程调度进程调度的任务、机制和方式 进程调度的任务主要有： 保存处理机的现场信息。 按某种算法选取进程。 把处理器分配给进程。 为了实现进程调度，在进程调度机制中，应具有排队器、分派器、上下文切换器三个基本部分，如图： 进程调度方式： 非抢占方式：当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才把处理机分配给更为重要或紧迫的进程。 优点：算法简单，系统开销小；缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束。 引起进程调度的因素： 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行； 执行中的进程因提出I/O请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语。 抢占方式：当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。 优点：适于时间要求严格的实时系统；缺点：调度算法复杂，系统开销大。 主要有以下原则： 优先权原则：允许高优先权的新到进程抢占当前进程的处理机。 短作业（进程）优先原则：允许执行时间短的新到进程抢占当前进程的处理机。 时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统。 轮转调度算法 轮转法的基本原理：在轮转(RR)法中，系统将所有的就绪进程按 FCFS 策略排成一个就绪队列。系统可设置每隔一定时间（如30 ms）便产生一次中断，去激活进程调度程序进行调度，把 CPU 分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。 进程切换时机：在 RR 调度算法中，应在何时进行进程的切换，可分为两种情况： 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。 时间片大小的确定：在轮转算法中，时间片的大小对系统性能有很大的影响。下图给出了时间片大小对响应时间的影响，其中图(a)是时间片略大于典型交互的时间，而图(b)是时间片小于典型交互的时间： 下图给出了时间片分别为q = 1和q = 4时对平均周转时间的影响： 优先级调度算法 优先级调度算法的类型：优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种： 非抢占式优先级调度算法。 抢占式优先级调度算法。 优先级的类型： 静态优先级：静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个： 进程类型。 进程对资源的需求。 用户要求。 动态优先级：动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。 多队列调度算法如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多级队列调度算法能够在一定程度上弥补这一缺点。 多队列反馈调度算法 调度机制： 设置多个就绪队列。如图： 每个队列都采用FCFS算法。 当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。 当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，依此类推。 当进程最后被降到第n队列后，在第n队列中便采取按PR方式运行。 按队列优先级调度。 调度程序首先调度最高优先级队列中的诸进程运行。 仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1～(i-1)所有队列均空时，才会调度第i队列中的进程运行。 如果处理机正在第 i 队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。 调度算法的性能：在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。 用户类型可分为： 终端型用户。 短批处理作业用户。 长批处理作业用户。 基于公平原则的调度算法 在实施公平调度算法时系统中必须具有这样一些功能： 跟踪计算每个进程自创建以来已经执行的处理时间。 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。 保证调度算法： 保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。 一种比较容易实现的性能保证是处理机分配的公平性。 如果在系统中有 n 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 1/n。 公平分享调度算法： 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 实时调度在实时系统中，可能存在着两类不同性质的实时任务，即 HRT 任务和 SRT 任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。 实现实时调度的基本条件： 提供必要的信息。为了实现实时调度，系统应向调度程序提供有关任务的信息： 就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。 开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间，或者完成截止时间。 处理时间，一个任务从开始执行，直至完成时所需的时间。 资源要求，任务执行时所需的一组资源。 优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对”优先级，供调度程序参考。 系统处理能力强。在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。 假定系统中有 m 个周期性的硬实时任务 HRT，它们的处理时间可表示为 Ci，周期时间表示为 Pi，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的： 提高系统处理能力的途径有： 采用单处理机系统。但须增强其处理能力，以显著地减少对每一个任务的处理时间； 采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为： 采用抢占式调度机制。在含有 HRT 任务的实时系统中，广泛采用抢占机制。这样便可满足 HRT 任务对截止时间的要求，但这种调度机制比较复杂。 具有快速切换机制。为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力： 对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。 快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。 实时调度算法的分类（可以按不同方式对实时调度算法加以分类）： 根据实时任务性质，可将实时调度的算法分为： 硬实时调度算法 软实时调度算法 按调度方式，则可分为： 非抢占调度算法。又可分为： 非抢占式轮转调度算法 非抢占式优先调度算法 抢占调度算法。可根据抢占发生时间的不同而进一步分成： 基于时钟中断的抢占式优先级调度算法。 立即抢占的优先级调度算法。 优先级倒置： 优先级倒置的形成：当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。例如： P3最先执行，在执行了 P(mutex) 操作后，进入到临界区 CS-3。在时刻a，P2就绪，因为它比 P3 的优先级高，P2 抢占了 P3 的处理机而运行。 优先级倒置的解决方法： 一种简单的解决方法 —— 动态优先级继承，规定：假如进程 P3 在进入临界区后，P3 所占用的处理机就不允许被抢占。 例如：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（二）：进程的初步认识","slug":"计算机操作系统（二）：进程的初步认识","date":"2021-03-19T17:04:05.000Z","updated":"2021-03-20T01:03:05.086Z","comments":true,"path":"279bab449d3d/","link":"","permalink":"http://ozziely.com/279bab449d3d/","excerpt":"","text":"进程与线程的知识体系图 在之后的文章中会陆续讲到，这里我们只说线程的知识 前言操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的CPU只有一一个，它们也支持（伪） 并发操作。它们会将一 一个单独的CPU抽象为多个虚拟机的CPU。可以说，没有进程的抽象，现代操作系统将不复存在。 在许多多道程序系统中， CPU会在进程间快速切换，使每个程说序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能运行多个进程。这样就会让我们产生并行的错觉。有时候人们说的伪并行（pseudoparallelism)其实就是这种情况，以此来区分多处理器系统（该系统由两个或多个CPU来共享同一个物理内存） 再解释一下伪并行：伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快。通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。 缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。 因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。下面我们就来探讨一下进程模型 进程模型在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程，简称为进程（process) 。 一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟CPU，但是实际情况是CPU会在各个进程之间进行来回切换。 如上图所示，这是一个具有4个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化： 在上图中，这4道程序被抽象为4个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。 从下图我们可以看到，在观察足够长的一 一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行： 因此，当我们说一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU)，每一个核也只能一次运行一个线程。 由于CPU会在各个进程之间来回快速切换，所以每个进程在CPU中的运行时间是无法确定的。并且当同一个进程再次在CPU中运行时，其在CPU内部的运行时间往往也是不固定的。这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行 了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？ 进程的创建操作系统需要一些方式来创建进程。下面是一 些创建进程的方式 系统初始化（init) 正在运行的程序执行了创建进程的系统调用（比如fork) 用户请求创建一个新进程 初始化一个批处理工作 系统初始化启动操作系统时，通常会创建若干个进程。 其中有些是前台进程（numerous processes) ，也就是同用户进行交互并替他们完成工作的进程。 一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。 还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。 进程运行在后台用来处理一些活动像是 e-mail, web网页，新闻，打印等等被称为守护进（daemons)。大型系统会有很多守护进程。在UNIX中，ps 程序可以列出正在运行的进程，在Windows中，可以使用任务管理器。 系统调用创建除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出系统调用用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的CPU上也可以使工作做的更快。 用户请求创建在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的UNIX系统中运行X,新进程将接管启动它的窗口。在Windows中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。 批处理创建最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。 当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。 从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。 该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。 该系统调用告诉操作系统创建一个新进程， 并直接或间接指示在其中运行哪个程序。 在UNIX中，仅有一个系统调用来创建一个新的进程，这个系统调用就是fork 。这个调用会创建一个与调用进程相关的副本。在fork后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在shell中输出sort命令时，shell 会fork 一个子进程然后子进程去执行sort命令。这两步过程的原因是允许子进程在fork之后但在execve之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。 而在Windows中，情况正相反，一个简单的Win32功能调用CreateProcess ，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有10个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了CreateProcess Win 32中大概有100个其他的函数用于处理进程的管理，同步以及相关的事务。 下面是UNIX操作系统和Windows操作系统系统调用的对比： 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。 在UNIX中，子进程的地址空间是父进程的一个拷贝，但是确是两个不同的地址空间；不可写的内存区域是共享的。某些UNIX实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过写时复制（copy- on- write)共享， 这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。 再次强调，可写的内存是不能被共享的。 但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。 进程的终止进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，但是通常是由于以下情况触发： 正常退出（自愿的） 错误退出（自愿的） 严重错误（非自愿的） 被其他进程杀死（非自愿的） 正常退出多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。 这个调用在UNIX中是exit，在Windows中是ExitProcess 。 面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。 错误退出进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令 1CC foo.c 为了能够编译foo.c但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。 严重错误进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是0等。 在有些系统比如UNIX中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。 被其他进程杀死第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。 在UNIX中，这个系统调用是kill。在Win32中对应的函数是TerminateProcess（注意不是系统调用）。 进程的层次结构在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。 UNIX进程体系在UNIX中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。 每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号kill 掉。 另一个例子，可以用来说明层次的作用：考虑UNIX 在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中。当init进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。 这些进程等待用户登录。如果登录成功，该登录进程就执行一个shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以init为根的进程树： 12345678910111213init─┬─NetworkManager（5427) ├─NetworkManagerD（5441) ├─acpid（5210) ├─apache2（6966)─┬─apache2（2890) │ ├─apache2（2893) │ ├─apache2（7163) │ ├─apache2（7165) │ ├─apache2（7166) │ ├─apache2（7167) │ └─apache2（7168) ├─atd（6369) ├─avahi-daemon（5658)───avahi-daemon（5659) ├─bonobo-activati（7816)───&#123;bonobo-activati&#125;（7817) Windows进程体系相反，Windows中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该询柄可以用来控制子进程。 然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在UNIX中，进程不能剥夺其子进程的进程权。（这样看来， 还是Windows比较渣）。 进程状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在shell命令中 1cat chapter1 chapter2 chapter3 | grep tree 第一个进程是cat ，将三个文件级联并输出。 第二个进程是grep ，它从输入中选择具有包含关键字tree的内容。 根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况：grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。当一个进程开始运行时，它可能会经历下面这几种状态（下图为进程状态切换图）： 图中会涉及三种状态： 运行态，运行态指的就是进程实际占用CPU时间片运行时 就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态 阻塞态，除非某种外部事件发生，否则进程不能运行 逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获得CPU时间分片。 第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。 三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些系统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX，当进程从管道或特殊文件（例如终端） 中读取没有可用的输入时，该进程会被自动终止。 转换2和转换3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。 转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。 程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。 当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4。如果此时没有其他进程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再轮到它运行。 从上面的观点引入了下面的模型： 基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。 操作系统最底层的就是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。 事实上，调度程序只是一段非常小的程序。 进程的实现操作系统为了执行进程间的切换，会维护着一张表格，这张表就是进程表（process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 下面展示了一个典型系统中的关键字段 典型的进程表表项中的一些字段 第一列内容与进程管理有关，第二列内容与存储管理 有关，第三列内容与文件管理有关。 存储管理的text segment、data segment、stack segment更多了解见下面这篇文章： 程序员需要了解的硬核知识之汇编语言（全） 现在我们应该对进程表有个大致的了解了，就可以在对单个CPU.上如何运行多个顺序进程的错觉做更多的解释。 与每一/0类相关联的是一个称作中断向量（interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。 假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。 然后软件就随即接管一切剩余的工作。 当中断结束后，操作系统会调用一个C程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。 然后将控制权转移给一 一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程： 硬件压入堆栈程序计数器等 硬件从中断向量装 入新的程序计数器 汇编语言过程保存寄存器的值 汇编语言过程设置新的堆栈 C中断服务器运行（典型的读和缓存写入） 调度器决定下面哪个程序先运行 C过程返回至汇编代码 汇编语言过程开始运行新的当前进程 一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（一）：认识操作系统","slug":"计算机操作系统（一）：认识操作系统","date":"2021-03-19T17:01:56.000Z","updated":"2021-03-20T01:02:30.237Z","comments":true,"path":"bfb7f7b98435/","link":"","permalink":"http://ozziely.com/bfb7f7b98435/","excerpt":"","text":"操作系统简介 现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。 在硬件的基础上，计算机安装了一层软件，这些软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户的需求，这种软件被称之为 “操作系统”， 我们一般常见的操作系统主要有：Windows、Linux、FreeBSD 或 OS X，这种带有图形界面的操作系统，被统称为 “图形用户界面（GUI）”，而基于文本、命令行通常被统称为 “Shell”，如下是我们所探讨的操作系统的部件（这是一个操作系统的简化图）： 最下面是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，硬件之上是软件。 大部分计算机有两种运行模式：“内核态” 和 “用户态”，软件中最基础的部分是操作系统，它运行在内核态中，内核态也被称为 “管态” 和 “核心态”，它们都是操作系统的运行状态，只是叫法不同而已。操作系统具有硬件的访问权，可以在执行机器能够运行的任何指令。软件的其余部分运行在用户态下。 “用户接口程序（Shell 或者 GUI）”处于用户态中，并且它们处在用户态的最底层，允许用户运行其他的程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等等，而且，越靠近用户态的应用程序越容易编写。假如你不喜欢某个电子邮件阅读器，你可以随意换一个软件，但你不能自行写一个操作系统或者是中断处理程序，这个程序是由硬件保护的，防止外部对其进行修改。 计算机硬件简介操作系统与硬件 操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源，因此，操作系统必须足够了解硬件的运行，所以这里要先介绍现代计算机中的硬件。 从概念上来看，一个简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O设备都和总线串联起来并通过总线与其他设备进行通信。 简单个人计算机的组件： CPU CPU是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个CPU的执行周期是从内存中提取第一条指令、 解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。 每个 CPU 都有一组可以执行的特定指令集。因此，X86 的 CPU 不能执行 ARM 的程序并且ARM 的 CPU 也不能执行 X86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。 除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。 其中之一就是程序计数器(program counter) ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。另一个寄存器是堆栈指针(stack pointer) ，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。 还有一个寄存器是PSW(Program Status Word)程序状态字寄存器，这个寄存器是由操作系统维护的 8 个字节（64位） long类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW。用户程序通常可以读取整个PSW,但通常只能写入其某些字段。PSW在系统调用和 1/ 0 中起着重要作用。 操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时， 操作系统会保存所有寄存器的值，以便于后续重新运行该程序。为了提升性能，CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。 许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个CPU可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对N+ 1条指令解码，还可以读取N + 2条指令。像这样的组织形式被称为流水线(pipeline) 。 比流水线更先进的设计是超标量(superscalar) CPU，该设计如下： 在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、 解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。 这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。 除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。 当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下， 剩下的一部分运行在用户态下。 注意，设置 PSW 模式的二进制位为内核态也是禁止的。 用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 l/O 和内存保护的所有指令是禁止执行的。 为了获取操作系统的服务，用户程序必须使用系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。 需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。 多线程和多核芯片 多线程或超线程的特性起初是奔腾处理器（Intel Pentinum 4）引入的。 多线程允许 CPU 保持两个不同的线程状态并且在纳秒级(nanosecond)的时间完成切换，近似地说，线程是一种轻量级的进程。 例如，如果一个进程想要从内存中读取指令（这通常会经历几个时钟周期），多线程CPU则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。 对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的CPU。比如一个有两个CPU的操作系统，并且每个CPU运行两个线程，那么这对于操作系统来说就可能是4个CPU。 除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。 如图是带有共享 L2 缓存的 4 核芯片： 而带有分离 L2缓存的 4 核芯片则如下： 而说到线代的 GPU，则是指有成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算。 内存计算机的第二个主要的组件就是内存，目前采用了不同的处理方式，存储系统采用一种分层次的结构： 顶层的存储器访问效率最高，但是容量最小，成本也最高，以此类推。 高速缓存 位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行（cache lines） 为64字节，内存地址的 0 一 63 对应高速缓存行0，地址 64- 127 对应高速缓存行的1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。 高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。 随机存储器（RAM） ：内存中最重要的一 种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。 大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权， 缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 /home/ ast/projects/minix3/src/kernel/clock.c，这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个Web页面(URL)的地址转换为网络地址（P地址）后，这个转换结果也可以缓存起来供将来使用。 在任何缓存系统中，都会有下面这几个噬需解决的问题： 何时把新的内容放进缓存 把新的内容应该放在缓存的哪一行 在需要空闲空间时，应该把哪块内容从缓存中移除 应该把移除的内容放在某个较大存储器的何处 并不是每个问题都与每种缓存情况有关。对于CPU缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。 缓存是解决问题的一种好的方式，所以现代CPU设计了两种缓存。第一级缓存或者说是 L1 cache，总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个L1 cache。典型的L1 cache的大小为16 KB。另外，往往还设有二级缓存，也就是L2 cache，用来存放最近使用过的关键字，一 一般是兆字节为单位。L1 cache和L2 cache最大的不同在于是否存在延迟。访问L1 cache没有任何的延迟，然而访问L2 cache会有1 — 2个时钟周期的延后。 什么是时钟周期？计算机处理器或CPU的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz） 或千兆赫（GHz）。例如， 一个4 GHz处理器每秒执行4,000,000,000个时钟周期。 计算机处理器可以在每个时钟周期执行一条或多 条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的CPU在每个时钟周期只能执行一条指令， 而现代处理器在每个时钟周期可以执行多条指令。 主存 在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做RAM（Random AccessMenmory）。 除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。 ROM（Read Only Memory）中的内容一 旦存储后就不会再被修改。它非常快而且便宜。（如果有 人问你，有没有什么又快又便宜的内存设备，那就是ROM了）在计算机中，用于启动计算机的引导加载模块（也就是bootstrap ）就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。 EEPROM（Electrically Erasable PROM） 和闪存（flash menory）也是非易失性的，但是与ROM相反，它们可以擦除和重写。不过重写它们需要比写入RAM更多的时间，所以它们的使用方式与ROM相同，但是与ROM不同的是他们可以通过重写字段来纠正程序中出现的错误。 闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。 还有一类是CMOS，它是易失性的。许多计算机都会使用CMOS存储器保持当前时间和日期。 磁盘 磁盘（也就是硬盘），同RAM相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了 三个数量级。磁盘访问慢的原因是磁盘的构造不同。 磁盘驱动器的构造： 每个磁道划分若干扇区（如图），扇区的值是512字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要1ms。而随机移到一个柱面的典型时间为5ms至10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s ，而高速磁盘的速率是160MB/s 。需要注意，固态硬盘(Solid State Disk, SSD) 不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中， 与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。 许多计算机支持一种著名的虚拟内存机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit, MMU) 的部件来完成。 缓存和MMU的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为上下文切换（ context switch) ，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。 I/O 设备 I/O设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。 I/O设备另一部分是设备本身，设备本身有一一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。 每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为设备驱动程序(device driver) 。每个控制器厂 家都应该针对不同的操作系统提供不同的设备驱动程序。 为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径： 第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是UNIX 系统采用的工作方式 第二个途径是在一个操作系统文件中设置一个入口， 通知该文件需要一个设备驱动程序， 然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是Windows 采用的工作方式 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如USB和IEE 1394都需要动态可装载的设备驱动程序。 每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了I/O 端口空间。 在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下： 启动设备并发出中断的过程： 如上图所示，这是一个三步的I/O过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。 然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤2中使用某些总线向中断控制器发送信号。 如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在CPU的一个引脚上面声明，这就是步骤3。 在第4步中，中断控制器把该设备的编号放在总线上，这样CPU可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。 一旦CPU决定去实施中断后，程序计数器和PSW就会被压入到当前堆栈中并且CPU会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作中断向量(interrupt vector) 。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和PSW寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令， 这个过程如下： 总线 随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括IBM PC总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理1/O设备以及CPU到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现： 上图中的 x86 系统包含很多总线，高速缓存、内存、PCle、 PCI、 USB、SATA 和DMI,每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是PCIe(Peri pheral Component Interconnect Express)总线。 计算机启动过程 在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一 般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。 在母板上有一个称为基本输入输出系统(Basic Input Output System， BIOS) 的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、磁盘I/O以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS中发现错误时，可以由操作系统进行更新。 在计算机启动(booted) 时，BIOS 开启，它会首先检查所安装的RAM的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描PCle和PCI总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一 一次启动时的设备不同，则新的设备将被重新配置。 然后，BIOS通过尝试存储在CMOS 存储器中的设备清单 尝试启动设备 CMOS是Complementary Metal 0xide Sem iconductor （互补金属氧化物半导体）的缩写 。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的RAM 芯片。 因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。 而对BIOS中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入BIOS设置程序，方便地对系统进行设置。因此BIOS设置有时也被叫做CMOS设置。 用户可以在系统启动后进入一个BIOS配置程序，对设备清单进行修改。然后，判断是否能够从外部CD-ROM和USB驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。 然后操作系统会询问BIOS获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入CD- ROM驱动（由设备制造商提供）或者从Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"数据库","slug":"学校课程/数据库","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"学校课程/计算机网络","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://ozziely.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}