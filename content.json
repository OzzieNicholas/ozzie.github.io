{"meta":{"title":"Ozzie | Nicholas","subtitle":"","description":"OzzieNicholas的个人博客","author":"OzzieNicholas","url":"http://ozziely.com","root":"/"},"pages":[{"title":"","date":"2021-03-18T17:49:11.377Z","updated":"2021-03-18T17:49:11.377Z","comments":true,"path":"404.html","permalink":"http://ozziely.com/404","excerpt":"","text":"请留言告诉我您要访问哪个页面找不到了"},{"title":"","date":"2021-03-18T17:45:28.174Z","updated":"2021-03-18T13:58:09.160Z","comments":true,"path":"mylist/index.html","permalink":"http://ozziely.com/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-18T17:45:28.193Z","updated":"2021-03-18T13:57:51.312Z","comments":true,"path":"tags/index.html","permalink":"http://ozziely.com/tags/","excerpt":"","text":""},{"title":"所有分类","date":"2021-03-18T17:45:28.258Z","updated":"2021-03-18T13:57:28.462Z","comments":true,"path":"categories/index.html","permalink":"http://ozziely.com/categories/","excerpt":"","text":""},{"title":"","date":"2021-03-19T01:41:44.865Z","updated":"2021-03-19T01:41:44.865Z","comments":true,"path":"about/index.html","permalink":"http://ozziely.com/about/","excerpt":"","text":"终吾一生，愿念与征途，无非追求 “心之所向” 四字而已。 逝者如斯夫，虽若白驹之过隙，然何叹光阴之须臾？ 对酒当歌，人生几何！惟诗与远方，足矣！"},{"title":"我的朋友们","date":"2021-03-19T15:00:47.639Z","updated":"2021-03-19T15:00:47.639Z","comments":true,"path":"friends/index.html","permalink":"http://ozziely.com/friends/","excerpt":"","text":"","author":"Ozzie"}],"posts":[{"title":"计算机操作系统（三）：处理机调度","slug":"计算机操作系统（三）：处理机调度","date":"2021-03-20T01:31:22.000Z","updated":"2021-03-20T01:31:50.948Z","comments":true,"path":"29326ada3e53/","link":"","permalink":"http://ozziely.com/29326ada3e53/","excerpt":"","text":"处理机调度的层次和调度算法的目标处理机调度的层次 高级调度： 作业调度或长程调度，也称为接纳调度。 主要任务是按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入/输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利。 高级调度的时间尺度通常是分钟、小时或天。 在每次作业调度时，须决定： 接纳多少个作业：取决于多道程序度，即允许多少个作业同时在内存中运行。 要进行适当地折中，作业太多会使服务质量下降，作业太少会使资源利用率低。 接纳哪些作业：取决于作业调度算法，常用的作业调度算法包括先来先服务、短作业优先、作业优先权调度、响应比调度算法 低级调度： 进程调度或短程调度。 主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它。 常见的低级调度有非抢占式和抢占式两种。 低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效。 中级调度： 引入目的是为了提高内存利用率和系统吞吐量，使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。 主要任务是按照给定的原则和策略，将处于外存对换区中的重又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。 概念解释： 多道程序度：即允许多少个作业同时在内存中运行。 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。 吞吐量：是指在单位时间内系统所完成的作业数。 处理机调度算法的目标 处理机调度算法的共同目标： 资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算： 公平性。公平性是指应使诸进程都获得合理的CPU 时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。 平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。 策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。 批处理系统的目标： 平均周转时间短。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为： 为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间的具体分配状况，往往使用带权周转时间，即作业的周转时间T与系统为它提供服务的时间Ts之比，即W = T/Ts。而平均带权周转时间则可表示为： 系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。 处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由上所述可以看出，这些要求之间是存在着一定矛盾的。 实时系统的目标： 截止时间的保证。 可预测性。 分时系统的目标： 响应时间快。 均衡性。 作业与作业调度 在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。 操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。 作业和作业步作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。 作业控制块为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业运行时间)、资源需求(预计运行时间、要求内存大小等)、资源使用情况等。 作业运行的三个阶段和三种状态作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。即： 作业阶段 作业状态 收容阶段 后备状态 运行阶段 运行状态 完成阶段 完成状态 作业调度的主要任务 作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度在每次执行作业调度时，都需做出以下两个决定。 接纳多少个作业 接纳哪些作业 先来先服务 (first-come first-served，FCFS) 调度算法： FCFS 是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。 当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。 在采用FCFS算法时，人—机无法实现交互。 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。 短作业优先 (short job first，SJF) 的调度算法： 由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。 SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。 SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。 SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点： 必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。 对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。 优先级调度算法 (priority-scheduling algorithm，PSA) 和 高响应比优先调度算法 (Highest Response Ratio Next，HRRN) ： 我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。 在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。 高响应比优先算法是如何实现的呢? 如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为： 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比RP。据此，优先又可表示为： 进程调度进程调度的任务、机制和方式 进程调度的任务主要有： 保存处理机的现场信息。 按某种算法选取进程。 把处理器分配给进程。 为了实现进程调度，在进程调度机制中，应具有排队器、分派器、上下文切换器三个基本部分，如图： 进程调度方式： 非抢占方式：当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才把处理机分配给更为重要或紧迫的进程。 优点：算法简单，系统开销小；缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束。 引起进程调度的因素： 正在执行的进程执行完毕， 或因发生某事件而不能再继续执行； 执行中的进程因提出I/O请求而暂停执行； 在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语。 抢占方式：当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。 优点：适于时间要求严格的实时系统；缺点：调度算法复杂，系统开销大。 主要有以下原则： 优先权原则：允许高优先权的新到进程抢占当前进程的处理机。 短作业（进程）优先原则：允许执行时间短的新到进程抢占当前进程的处理机。 时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统。 轮转调度算法 轮转法的基本原理：在轮转(RR)法中，系统将所有的就绪进程按 FCFS 策略排成一个就绪队列。系统可设置每隔一定时间（如30 ms）便产生一次中断，去激活进程调度程序进行调度，把 CPU 分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。 进程切换时机：在 RR 调度算法中，应在何时进行进程的切换，可分为两种情况： 若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。 在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。 时间片大小的确定：在轮转算法中，时间片的大小对系统性能有很大的影响。下图给出了时间片大小对响应时间的影响，其中图(a)是时间片略大于典型交互的时间，而图(b)是时间片小于典型交互的时间： 下图给出了时间片分别为q = 1和q = 4时对平均周转时间的影响： 优先级调度算法 优先级调度算法的类型：优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种： 非抢占式优先级调度算法。 抢占式优先级调度算法。 优先级的类型： 静态优先级：静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个： 进程类型。 进程对资源的需求。 用户要求。 动态优先级：动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。 多队列调度算法如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多级队列调度算法能够在一定程度上弥补这一缺点。 多队列反馈调度算法 调度机制： 设置多个就绪队列。如图： 每个队列都采用FCFS算法。 当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。 当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，依此类推。 当进程最后被降到第n队列后，在第n队列中便采取按PR方式运行。 按队列优先级调度。 调度程序首先调度最高优先级队列中的诸进程运行。 仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1～(i-1)所有队列均空时，才会调度第i队列中的进程运行。 如果处理机正在第 i 队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。 调度算法的性能：在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。 用户类型可分为： 终端型用户。 短批处理作业用户。 长批处理作业用户。 基于公平原则的调度算法 在实施公平调度算法时系统中必须具有这样一些功能： 跟踪计算每个进程自创建以来已经执行的处理时间。 计算每个进程应获得的处理机时间，即自创建以来的时间除以n。 计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。 比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。 调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。 保证调度算法： 保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。 一种比较容易实现的性能保证是处理机分配的公平性。 如果在系统中有 n 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 1/n。 公平分享调度算法： 分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。 实时调度在实时系统中，可能存在着两类不同性质的实时任务，即 HRT 任务和 SRT 任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。 实现实时调度的基本条件： 提供必要的信息。为了实现实时调度，系统应向调度程序提供有关任务的信息： 就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。 开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间，或者完成截止时间。 处理时间，一个任务从开始执行，直至完成时所需的时间。 资源要求，任务执行时所需的一组资源。 优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对”优先级，供调度程序参考。 系统处理能力强。在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。 假定系统中有 m 个周期性的硬实时任务 HRT，它们的处理时间可表示为 Ci，周期时间表示为 Pi，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的： 提高系统处理能力的途径有： 采用单处理机系统。但须增强其处理能力，以显著地减少对每一个任务的处理时间； 采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为： 采用抢占式调度机制。在含有 HRT 任务的实时系统中，广泛采用抢占机制。这样便可满足 HRT 任务对截止时间的要求，但这种调度机制比较复杂。 具有快速切换机制。为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力： 对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。 快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。 实时调度算法的分类（可以按不同方式对实时调度算法加以分类）： 根据实时任务性质，可将实时调度的算法分为： 硬实时调度算法 软实时调度算法 按调度方式，则可分为： 非抢占调度算法。又可分为： 非抢占式轮转调度算法 非抢占式优先调度算法 抢占调度算法。可根据抢占发生时间的不同而进一步分成： 基于时钟中断的抢占式优先级调度算法。 立即抢占的优先级调度算法。 优先级倒置： 优先级倒置的形成：当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。例如： P3最先执行，在执行了 P(mutex) 操作后，进入到临界区 CS-3。在时刻a，P2就绪，因为它比 P3 的优先级高，P2 抢占了 P3 的处理机而运行。 优先级倒置的解决方法： 一种简单的解决方法 —— 动态优先级继承，规定：假如进程 P3 在进入临界区后，P3 所占用的处理机就不允许被抢占。 例如：","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（二）：进程的初步认识","slug":"计算机操作系统（二）：进程的初步认识","date":"2021-03-19T17:04:05.000Z","updated":"2021-03-20T01:03:05.086Z","comments":true,"path":"279bab449d3d/","link":"","permalink":"http://ozziely.com/279bab449d3d/","excerpt":"","text":"进程与线程的知识体系图 在之后的文章中会陆续讲到，这里我们只说线程的知识 前言操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的CPU只有一一个，它们也支持（伪） 并发操作。它们会将一 一个单独的CPU抽象为多个虚拟机的CPU。可以说，没有进程的抽象，现代操作系统将不复存在。 在许多多道程序系统中， CPU会在进程间快速切换，使每个程说序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能运行多个进程。这样就会让我们产生并行的错觉。有时候人们说的伪并行（pseudoparallelism)其实就是这种情况，以此来区分多处理器系统（该系统由两个或多个CPU来共享同一个物理内存） 再解释一下伪并行：伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快。通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。 缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。 因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。下面我们就来探讨一下进程模型 进程模型在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程，简称为进程（process) 。 一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟CPU，但是实际情况是CPU会在各个进程之间进行来回切换。 如上图所示，这是一个具有4个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化： 在上图中，这4道程序被抽象为4个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。 从下图我们可以看到，在观察足够长的一 一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行： 因此，当我们说一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU)，每一个核也只能一次运行一个线程。 由于CPU会在各个进程之间来回快速切换，所以每个进程在CPU中的运行时间是无法确定的。并且当同一个进程再次在CPU中运行时，其在CPU内部的运行时间往往也是不固定的。这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行 了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？ 进程的创建操作系统需要一些方式来创建进程。下面是一 些创建进程的方式 系统初始化（init) 正在运行的程序执行了创建进程的系统调用（比如fork) 用户请求创建一个新进程 初始化一个批处理工作 系统初始化启动操作系统时，通常会创建若干个进程。 其中有些是前台进程（numerous processes) ，也就是同用户进行交互并替他们完成工作的进程。 一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。 还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。 进程运行在后台用来处理一些活动像是 e-mail, web网页，新闻，打印等等被称为守护进（daemons)。大型系统会有很多守护进程。在UNIX中，ps 程序可以列出正在运行的进程，在Windows中，可以使用任务管理器。 系统调用创建除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出系统调用用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的CPU上也可以使工作做的更快。 用户请求创建在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的UNIX系统中运行X,新进程将接管启动它的窗口。在Windows中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。 批处理创建最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。 当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。 从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。 该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。 该系统调用告诉操作系统创建一个新进程， 并直接或间接指示在其中运行哪个程序。 在UNIX中，仅有一个系统调用来创建一个新的进程，这个系统调用就是fork 。这个调用会创建一个与调用进程相关的副本。在fork后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个新的程序。例如，当一个用户在shell中输出sort命令时，shell 会fork 一个子进程然后子进程去执行sort命令。这两步过程的原因是允许子进程在fork之后但在execve之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。 而在Windows中，情况正相反，一个简单的Win32功能调用CreateProcess ，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有10个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了CreateProcess Win 32中大概有100个其他的函数用于处理进程的管理，同步以及相关的事务。 下面是UNIX操作系统和Windows操作系统系统调用的对比： 在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。 在UNIX中，子进程的地址空间是父进程的一个拷贝，但是确是两个不同的地址空间；不可写的内存区域是共享的。某些UNIX实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过写时复制（copy- on- write)共享， 这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。 再次强调，可写的内存是不能被共享的。 但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。 进程的终止进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，但是通常是由于以下情况触发： 正常退出（自愿的） 错误退出（自愿的） 严重错误（非自愿的） 被其他进程杀死（非自愿的） 正常退出多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。 这个调用在UNIX中是exit，在Windows中是ExitProcess 。 面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。 错误退出进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令 1CC foo.c 为了能够编译foo.c但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。 严重错误进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是0等。 在有些系统比如UNIX中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。 被其他进程杀死第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。 在UNIX中，这个系统调用是kill。在Win32中对应的函数是TerminateProcess（注意不是系统调用）。 进程的层次结构在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。 UNIX进程体系在UNIX中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。 每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号kill 掉。 另一个例子，可以用来说明层次的作用：考虑UNIX 在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中。当init进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。 这些进程等待用户登录。如果登录成功，该登录进程就执行一个shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以init为根的进程树： 12345678910111213init─┬─NetworkManager（5427) ├─NetworkManagerD（5441) ├─acpid（5210) ├─apache2（6966)─┬─apache2（2890) │ ├─apache2（2893) │ ├─apache2（7163) │ ├─apache2（7165) │ ├─apache2（7166) │ ├─apache2（7167) │ └─apache2（7168) ├─atd（6369) ├─avahi-daemon（5658)───avahi-daemon（5659) ├─bonobo-activati（7816)───&#123;bonobo-activati&#125;（7817) Windows进程体系相反，Windows中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该询柄可以用来控制子进程。 然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在UNIX中，进程不能剥夺其子进程的进程权。（这样看来， 还是Windows比较渣）。 进程状态尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。例如，一个进程的结果可以作为另一个进程的输入，在shell命令中 1cat chapter1 chapter2 chapter3 | grep tree 第一个进程是cat ，将三个文件级联并输出。 第二个进程是grep ，它从输入中选择具有包含关键字tree的内容。 根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况：grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。当一个进程开始运行时，它可能会经历下面这几种状态（下图为进程状态切换图）： 图中会涉及三种状态： 运行态，运行态指的就是进程实际占用CPU时间片运行时 就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态 阻塞态，除非某种外部事件发生，否则进程不能运行 逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获得CPU时间分片。 第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。 三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些系统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX，当进程从管道或特殊文件（例如终端） 中读取没有可用的输入时，该进程会被自动终止。 转换2和转换3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。 转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。 程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算法来尝试平衡系统整体效率与各个流程之间的竞争需求。 当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4。如果此时没有其他进程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再轮到它运行。 从上面的观点引入了下面的模型： 基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。 操作系统最底层的就是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。 事实上，调度程序只是一段非常小的程序。 进程的实现操作系统为了执行进程间的切换，会维护着一张表格，这张表就是进程表（process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。 下面展示了一个典型系统中的关键字段 典型的进程表表项中的一些字段 第一列内容与进程管理有关，第二列内容与存储管理 有关，第三列内容与文件管理有关。 存储管理的text segment、data segment、stack segment更多了解见下面这篇文章： 程序员需要了解的硬核知识之汇编语言（全） 现在我们应该对进程表有个大致的了解了，就可以在对单个CPU.上如何运行多个顺序进程的错觉做更多的解释。 与每一/0类相关联的是一个称作中断向量（interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。 假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。 然后软件就随即接管一切剩余的工作。 当中断结束后，操作系统会调用一个C程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。 然后将控制权转移给一 一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程： 硬件压入堆栈程序计数器等 硬件从中断向量装 入新的程序计数器 汇编语言过程保存寄存器的值 汇编语言过程设置新的堆栈 C中断服务器运行（典型的读和缓存写入） 调度器决定下面哪个程序先运行 C过程返回至汇编代码 汇编语言过程开始运行新的当前进程 一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"计算机操作系统（一）：认识操作系统","slug":"计算机操作系统（一）：认识操作系统","date":"2021-03-19T17:01:56.000Z","updated":"2021-03-20T01:02:30.237Z","comments":true,"path":"bfb7f7b98435/","link":"","permalink":"http://ozziely.com/bfb7f7b98435/","excerpt":"","text":"操作系统简介 现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。 在硬件的基础上，计算机安装了一层软件，这些软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户的需求，这种软件被称之为 “操作系统”， 我们一般常见的操作系统主要有：Windows、Linux、FreeBSD 或 OS X，这种带有图形界面的操作系统，被统称为 “图形用户界面（GUI）”，而基于文本、命令行通常被统称为 “Shell”，如下是我们所探讨的操作系统的部件（这是一个操作系统的简化图）： 最下面是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，硬件之上是软件。 大部分计算机有两种运行模式：“内核态” 和 “用户态”，软件中最基础的部分是操作系统，它运行在内核态中，内核态也被称为 “管态” 和 “核心态”，它们都是操作系统的运行状态，只是叫法不同而已。操作系统具有硬件的访问权，可以在执行机器能够运行的任何指令。软件的其余部分运行在用户态下。 “用户接口程序（Shell 或者 GUI）”处于用户态中，并且它们处在用户态的最底层，允许用户运行其他的程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等等，而且，越靠近用户态的应用程序越容易编写。假如你不喜欢某个电子邮件阅读器，你可以随意换一个软件，但你不能自行写一个操作系统或者是中断处理程序，这个程序是由硬件保护的，防止外部对其进行修改。 计算机硬件简介操作系统与硬件 操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源，因此，操作系统必须足够了解硬件的运行，所以这里要先介绍现代计算机中的硬件。 从概念上来看，一个简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O设备都和总线串联起来并通过总线与其他设备进行通信。 简单个人计算机的组件： CPU CPU是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个CPU的执行周期是从内存中提取第一条指令、 解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。 每个 CPU 都有一组可以执行的特定指令集。因此，X86 的 CPU 不能执行 ARM 的程序并且ARM 的 CPU 也不能执行 X86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。 除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。 其中之一就是程序计数器(program counter) ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。另一个寄存器是堆栈指针(stack pointer) ，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。 还有一个寄存器是PSW(Program Status Word)程序状态字寄存器，这个寄存器是由操作系统维护的 8 个字节（64位） long类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW。用户程序通常可以读取整个PSW,但通常只能写入其某些字段。PSW在系统调用和 1/ 0 中起着重要作用。 操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时， 操作系统会保存所有寄存器的值，以便于后续重新运行该程序。为了提升性能，CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。 许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个CPU可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对N+ 1条指令解码，还可以读取N + 2条指令。像这样的组织形式被称为流水线(pipeline) 。 比流水线更先进的设计是超标量(superscalar) CPU，该设计如下： 在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、 解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。 这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。 除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。 当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下， 剩下的一部分运行在用户态下。 注意，设置 PSW 模式的二进制位为内核态也是禁止的。 用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 l/O 和内存保护的所有指令是禁止执行的。 为了获取操作系统的服务，用户程序必须使用系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。 需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。 多线程和多核芯片 多线程或超线程的特性起初是奔腾处理器（Intel Pentinum 4）引入的。 多线程允许 CPU 保持两个不同的线程状态并且在纳秒级(nanosecond)的时间完成切换，近似地说，线程是一种轻量级的进程。 例如，如果一个进程想要从内存中读取指令（这通常会经历几个时钟周期），多线程CPU则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。 对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的CPU。比如一个有两个CPU的操作系统，并且每个CPU运行两个线程，那么这对于操作系统来说就可能是4个CPU。 除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。 如图是带有共享 L2 缓存的 4 核芯片： 而带有分离 L2缓存的 4 核芯片则如下： 而说到线代的 GPU，则是指有成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算。 内存计算机的第二个主要的组件就是内存，目前采用了不同的处理方式，存储系统采用一种分层次的结构： 顶层的存储器访问效率最高，但是容量最小，成本也最高，以此类推。 高速缓存 位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行（cache lines） 为64字节，内存地址的 0 一 63 对应高速缓存行0，地址 64- 127 对应高速缓存行的1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。 高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。 随机存储器（RAM） ：内存中最重要的一 种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。 大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权， 缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 /home/ ast/projects/minix3/src/kernel/clock.c，这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个Web页面(URL)的地址转换为网络地址（P地址）后，这个转换结果也可以缓存起来供将来使用。 在任何缓存系统中，都会有下面这几个噬需解决的问题： 何时把新的内容放进缓存 把新的内容应该放在缓存的哪一行 在需要空闲空间时，应该把哪块内容从缓存中移除 应该把移除的内容放在某个较大存储器的何处 并不是每个问题都与每种缓存情况有关。对于CPU缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。 缓存是解决问题的一种好的方式，所以现代CPU设计了两种缓存。第一级缓存或者说是 L1 cache，总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个L1 cache。典型的L1 cache的大小为16 KB。另外，往往还设有二级缓存，也就是L2 cache，用来存放最近使用过的关键字，一 一般是兆字节为单位。L1 cache和L2 cache最大的不同在于是否存在延迟。访问L1 cache没有任何的延迟，然而访问L2 cache会有1 — 2个时钟周期的延后。 什么是时钟周期？计算机处理器或CPU的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz） 或千兆赫（GHz）。例如， 一个4 GHz处理器每秒执行4,000,000,000个时钟周期。 计算机处理器可以在每个时钟周期执行一条或多 条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的CPU在每个时钟周期只能执行一条指令， 而现代处理器在每个时钟周期可以执行多条指令。 主存 在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做RAM（Random AccessMenmory）。 除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。 ROM（Read Only Memory）中的内容一 旦存储后就不会再被修改。它非常快而且便宜。（如果有 人问你，有没有什么又快又便宜的内存设备，那就是ROM了）在计算机中，用于启动计算机的引导加载模块（也就是bootstrap ）就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。 EEPROM（Electrically Erasable PROM） 和闪存（flash menory）也是非易失性的，但是与ROM相反，它们可以擦除和重写。不过重写它们需要比写入RAM更多的时间，所以它们的使用方式与ROM相同，但是与ROM不同的是他们可以通过重写字段来纠正程序中出现的错误。 闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。 还有一类是CMOS，它是易失性的。许多计算机都会使用CMOS存储器保持当前时间和日期。 磁盘 磁盘（也就是硬盘），同RAM相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了 三个数量级。磁盘访问慢的原因是磁盘的构造不同。 磁盘驱动器的构造： 每个磁道划分若干扇区（如图），扇区的值是512字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要1ms。而随机移到一个柱面的典型时间为5ms至10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s ，而高速磁盘的速率是160MB/s 。需要注意，固态硬盘(Solid State Disk, SSD) 不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中， 与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。 许多计算机支持一种著名的虚拟内存机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit, MMU) 的部件来完成。 缓存和MMU的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为上下文切换（ context switch) ，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。 I/O 设备 I/O设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。 I/O设备另一部分是设备本身，设备本身有一一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。 每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为设备驱动程序(device driver) 。每个控制器厂 家都应该针对不同的操作系统提供不同的设备驱动程序。 为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径： 第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是UNIX 系统采用的工作方式 第二个途径是在一个操作系统文件中设置一个入口， 通知该文件需要一个设备驱动程序， 然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是Windows 采用的工作方式 第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如USB和IEE 1394都需要动态可装载的设备驱动程序。 每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了I/O 端口空间。 在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下： 启动设备并发出中断的过程： 如上图所示，这是一个三步的I/O过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。 然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤2中使用某些总线向中断控制器发送信号。 如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在CPU的一个引脚上面声明，这就是步骤3。 在第4步中，中断控制器把该设备的编号放在总线上，这样CPU可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。 一旦CPU决定去实施中断后，程序计数器和PSW就会被压入到当前堆栈中并且CPU会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作中断向量(interrupt vector) 。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和PSW寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令， 这个过程如下： 总线 随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括IBM PC总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理1/O设备以及CPU到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现： 上图中的 x86 系统包含很多总线，高速缓存、内存、PCle、 PCI、 USB、SATA 和DMI,每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是PCIe(Peri pheral Component Interconnect Express)总线。 计算机启动过程 在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一 般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。 在母板上有一个称为基本输入输出系统(Basic Input Output System， BIOS) 的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、磁盘I/O以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS中发现错误时，可以由操作系统进行更新。 在计算机启动(booted) 时，BIOS 开启，它会首先检查所安装的RAM的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描PCle和PCI总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一 一次启动时的设备不同，则新的设备将被重新配置。 然后，BIOS通过尝试存储在CMOS 存储器中的设备清单 尝试启动设备 CMOS是Complementary Metal 0xide Sem iconductor （互补金属氧化物半导体）的缩写 。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的RAM 芯片。 因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。 而对BIOS中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入BIOS设置程序，方便地对系统进行设置。因此BIOS设置有时也被叫做CMOS设置。 用户可以在系统启动后进入一个BIOS配置程序，对设备清单进行修改。然后，判断是否能够从外部CD-ROM和USB驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。 然后操作系统会询问BIOS获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入CD- ROM驱动（由设备制造商提供）或者从Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。","categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}],"categories":[{"name":"学校课程","slug":"学校课程","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/"},{"name":"计算机操作系统","slug":"学校课程/计算机操作系统","permalink":"http://ozziely.com/categories/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"计算机操作系统","slug":"计算机操作系统","permalink":"http://ozziely.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]}