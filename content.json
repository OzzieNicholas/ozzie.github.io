{"meta":{"title":"Ozzie | Nicholas","subtitle":"","description":"OzzieNicholas的个人博客","author":"OzzieNicholas","url":"http://ozziely.com","root":"/"},"pages":[{"title":"","date":"2021-03-18T17:49:11.377Z","updated":"2021-03-18T17:49:11.377Z","comments":true,"path":"404.html","permalink":"http://ozziely.com/404","excerpt":"","text":"请留言告诉我您要访问哪个页面找不到了"},{"title":"","date":"2021-03-18T17:45:28.174Z","updated":"2021-03-18T13:58:09.160Z","comments":true,"path":"mylist/index.html","permalink":"http://ozziely.com/mylist/","excerpt":"","text":""},{"title":"所有标签","date":"2021-03-18T17:45:28.193Z","updated":"2021-03-18T13:57:51.312Z","comments":true,"path":"tags/index.html","permalink":"http://ozziely.com/tags/","excerpt":"","text":""},{"title":"所有分类","date":"2021-03-18T17:45:28.258Z","updated":"2021-03-18T13:57:28.462Z","comments":true,"path":"categories/index.html","permalink":"http://ozziely.com/categories/","excerpt":"","text":""},{"title":"","date":"2021-03-19T01:41:44.865Z","updated":"2021-03-19T01:41:44.865Z","comments":true,"path":"about/index.html","permalink":"http://ozziely.com/about/","excerpt":"","text":"终吾一生，愿念与征途，无非追求 “心之所向” 四字而已。 逝者如斯夫，虽若白驹之过隙，然何叹光阴之须臾？ 对酒当歌，人生几何！惟诗与远方，足矣！"},{"title":"我的朋友们","date":"2021-03-19T15:00:47.639Z","updated":"2021-03-19T15:00:47.639Z","comments":true,"path":"friends/index.html","permalink":"http://ozziely.com/friends/","excerpt":"","text":"","author":"Ozzie"}],"posts":[{"title":"细解浏览器缓存","slug":"细解浏览器缓存","date":"2020-08-02T01:54:26.000Z","updated":"2021-03-19T01:58:01.806Z","comments":true,"path":"6bbe4ee13dda/","link":"","permalink":"http://ozziely.com/6bbe4ee13dda/","excerpt":"","text":"前言 在开发中，我们总会提到 “合理设置缓存”，缓存机制非常普遍，有客户端缓存、服务器缓存、代理服务器缓存等等，在 HTTP 中，具有缓存功能的是浏览器缓存。 HTTP 缓存是作为web 性能优化的重要手段。 HTML5 引入了应用程序缓存，在没有网络的情况下也能进行访问，同时，还引入了 storage 本地存储，这些都属于应用缓存，本文主要是和浏览器缓存相关的，也可以说是 HTTP 缓存。 什么是浏览器缓存？ MDN 的解释是： A browser cache holds all documents downloaded via HTTP by the user … without requiring an additional trip to the server. 意思就是，浏览器缓存保存着用户通过 HTTP 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求，简单说，就是在你访问过某网站之后，这个站点的文字、图片等所有资源都被下载到本地了，下次再党文该网站时，会判断是否满足缓存条件，如果满足，则不用再花时间去等待资源的获取了。 浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的所以在分析浏览器缓存机制之前，我们待会儿得先简单介绍一下 HTTP 报文。 HTTP 报文 HTTP 报文分两种： HTTP 请求（Resquest）报文，报文格式为：请求行 — HTTP 头（通用信息头、请求头、实体头）— 请求报文主体（只有 POST 才有报文主体），如图： HTTP 响应（Response）报文，报文格式为：状态行 — HTTP头（通用信息头、请求头、实体头）— 响应报文主体，如图： 注意： 通用信息头指的是请求和响应报文都支持的头域，分别为：Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via 实体头则是实体信息的实体头域，分别为：Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header 之前是为了方别理解，而将通用信息头、响应头/请求头、实体头都归为了 HTTP 头 缓存的优点 减少了冗余的数据传递，节省宽带流量 减少了服务器的负担，大大提高了网站性能 加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因 缓存过程分析 浏览器与服务器通信的方式是应答模式，即为：浏览器发起 HTTP 请求 — 服务器响应该请求，那么，浏览器第一次向服务器发起该请求后拿到结果，会根据响应报文中的 HTTP 头的缓存标识，决定是否缓存结果，若是，则将请求结果和缓存标识存入浏览器缓存中，如图： 由上图可知： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中 以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，下面开始理解浏览器缓存的使用规则 缓存的规则缓存的分类 一般来说，浏览器缓存可以分为： 强缓存 协商缓存（对比缓存） 浏览器在加载资源时，会先判断是否命中强缓存，再验证是否命中协商缓存 强缓存 浏览器在加载资源时，会先根据本地缓存资源的 header 中的信息判断是否命中强缓存，如果命中，则直接使用缓存中的资源，而不会再向服务器发送请求，如图： 从图中可以看出，强缓存的一般流程是： 查看 header 头中的 Expire 和 Cache-control 来判断是否满足规则 如果满足规则，就返回缓存的数据 如果不满足规则，就向服务器发送请求 服务器返回数据 将新数据存入缓存 接下来我们主要就关注 Expire 和 Cache-control 这两个字段 Expire： Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，当客户端的时间小于 Expires 的值时，直接使用缓存结果。 再看看 MDN 中如何解释这个字段： The Expires header contains the date/time after which the response is considered stale. 这个字段包含了一个时间，过了这个时间，响应将会失效。也就是说，Expire 这个字段表示缓存到期时间，我们来打开一个网站并查看 Response Header 看看这个字段： 1Expires:Fri, 27 Oct 2017 07:55:30 GMT 可能在你查看这的时候发现时间都已经是过去了 ~，GMT 表示的是格林威治时间，和北京时间相差8小时，上面的这个时间表示的是 2017年10月27日15:55:30。 通过设置 Expire 来设置缓存有一个缺点：这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。 Expires 是 HTTP/1.0的字段，但是现在浏览器默认使用的是 HTTP/1.1，那么在HTTP/1.1 中网页缓存还是否由 Expires 控制？ 到了 HTTP/1.1，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。接下来我们开始认识 Cache-Control。 Cache-Control： 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。 承接上面的例子，既然不能设置绝对时间，那就设置相对时间吧 在 HTTP/1.1 中，增加了一个字段 Cache-Control ，它包含一个 max-age 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间： 1Cache-Control:max-age&#x3D;600 这个表示的就是最大有效时间是 600s ，对的，它的单位是秒。 Cache-Control 除了 max-age 属性之外还有一些属性： no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。 no-store：禁止使用缓存，每一次都要重新请求数据。 public：默认设置。 private：不能被多用户共享。 接下来，我们直接看一个例子，如下： 由上面的例子我们可以知道： HTTP 响应报文中 Expires 的时间值，是一个绝对值 HTTP响应报文中 Cache-Control 为 max-age=600，是相对值 由于 Cache-Control 的优先级比 Expires，那么直接根据 Cache-Control 的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于Expires 是更好的选择，所以同时存在时，只有 Cache-Control生效。了解强制缓存的过程后，我们拓展性的思考一下：浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？ 我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size值则代表该缓存存放的位置，分别为 from memory cache 和 from disk cache： 那么 from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？ from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 memory –&gt; disk 对于上个结论，我们需要了解内存缓存（from memory cache）和硬盘缓存（from disk cache），如下: 内存缓存（from memory cache）：内存缓存具有两个特点，分别是快速读取和时效性。 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。 时效性：一旦该进程关闭，则该进程的内存则会清空。 硬盘缓存（from disk cache）：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。 在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache） 现在基本上都会同时设置 Expire 和 Cache-Control ，Cache-Control 的优先级别更高。 协商缓存 当强缓存没有命中的时，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 304 ，告诉浏览器资源未更新，可使用本地的缓存。 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304，如下： 协商缓存失效，返回200和请求结果结果，如下： 协商缓存整体流程图： 从图中可以看出，协商缓存一般是这样一个流程： 把资源标识，比如 If-Modify-Since 或 Etag 发送到服务器，确认资源是否更新 如果资源未更新，请求响应返回的http状态为 304 并且会显示一个 Not Modified 的字符串，告诉浏览器使用本地缓存 如果资源已经更新，返回新的数据 将新数据存入缓存 Last-Modified / If-Modified-Since： Last-Modified 是浏览器第一次请求资源的时候，服务器返回的 header 上会带有一个 Last-Modified 字段，服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下： 同样的，这是一个 GMT 的绝对时间。 If-Modified-Since 则是客户端再次发起该请求时，携带上次请求返回的 Last-Modified 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 If-Modified-Since 字段，则会根据 If-Modified-Since 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 If-Modified-Since 的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下： 当然，这个方法也是有缺点的： 最小单位是秒。也就是说如果我短时间内资源发生了改变，Last-Modified 并不会发生变化； 周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 Last-Modified 可不这样认为。 所以，后来又引入一个 Etag Etag： Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下： If-None-Matchc是客户端再次发起该请求时，携带上次请求返回的唯一标识 Etag 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 If-None-Match，则会根据 If-None-Match 的字段值与该资源在服务器的 Etag 值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下： 它一般是由文件内容 hash 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 Etag发生改变。 同样地，在浏览器第一次请求资源时，服务器会返回一个 Etag 标识。当再次请求该资源时， 会通过 If-no-match 字段将 Etag 发送回服务器，然后服务器进行比较，如果相等，则返回 304 表示未修改。 Last-Modified 和 Etag 是可以同时设置的，服务器会优先校验 Etag，如果 Etag 相等就会继续比对 Last-Modified，最后才会决定是否返回 304。 Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since，同时存在则只有 Etag / If-None-Match 生效。 总结 强制缓存优先于协商缓存进行，若强制缓存（Expires和Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match）， 协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存 总结的主要过程如下： 即，当浏览器再次访问一个已经访问过的资源时，它会这样做： 看看是否命中强缓存，如果命中，就直接使用缓存了； 如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存； 如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存； 否则，返回最新的资源。 用户对缓存的影响若是问到用户进行一些操作的时候，对缓存是有什么影响的，答案如下： 用户操作 Expires/Cache-Control Last-Modified/Etag 地址栏回车 √ √ 页面链接跳转 √ √ 新开窗口 √ √ 前进回退 √ √ F5 刷新 × √ Ctrl+F5 强制刷新 × × 不同刷新的请求执行过程 URL（最快）：浏览器地址栏中写入URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。 F5：告诉浏览器去服务器看看这个文件是否有过期了。于是浏览器就发送一个请求带上 If-Modify-since。 Ctrl+F5：让浏览器先把缓存中的文件删了，然后再去服务器请求个完整的资源文件下来，于是客户端就完成了强行更新的操作。","categories":[{"name":"探索笔记","slug":"探索笔记","permalink":"http://ozziely.com/categories/%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"探索笔记","slug":"探索笔记","permalink":"http://ozziely.com/tags/%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"}],"author":"Ozzie"},{"title":"Next.js入门笔记","slug":"Next.js入门笔记","date":"2020-07-09T14:32:06.000Z","updated":"2021-03-19T02:00:15.294Z","comments":true,"path":"13c3110fab14/","link":"","permalink":"http://ozziely.com/13c3110fab14/","excerpt":"","text":"前言 初识 Next.js，请查看它的官网介绍： Next.js 官网 Next.js 中文网 好吧，官网的话总是那么拗口，毫不避讳地说，我的能力还完全不能对某某框架指评，若对此感兴趣，请读者移步知乎：对 Next.js 的评价 另外附上两个你可能会用到的链接： Github 地址：Github - next.js 社区：Spectrum 初识Next.js安装 Next.js 支持 Windows、Mac 和 Linux系统，均可安装，但是前提是你已经安装了 Node.js 创建示例项目的过程如下： 12345mkdir hello-nextcd hello-nextnpm init -ynpm install --save react react-dom nextmkdir pages 使用 打开 hello-next/package.json，替换 scripts： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot;&#125; 启动 1npm run dev 在浏览器中打开 http://localhost:3000,你会看到页面显示 404 | This page could not be found. 创建你的第一个页面 创建 pages/index.js，并输入： 1234567const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/div&gt;);export default Index; 再次输入 npm run dev，就能看到效果了 上述案例中，我们在 pages/index.js 模块中默认（default）导出了一个简单的 React 组件 试错 尝试着错一次：将 pages/index.js 改为： 1234567const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js &lt;/div&gt;);export default Index; 重新启动，浏览器显示： 一般情况下，Next.js 将跟踪此类错误并在浏览器中显示，这便于我们快速发现错误，而你修改代码并保存后，页面将立即出现对应结果，而不会重新加载整个页面，这是通过 webpack 的 模块热替换 实现的，Next 默认支持这个功能 2020.3.30 页面间导航Introduction 我们的应用程序虽然很简单，只有一个页面，但是我们可以添加任意多个页面，例如： 创建 pages/about.js 来新建 “About” 页面 1234567const About = () =&gt; ( &lt;div&gt; &lt;p&gt;About Page&lt;/p&gt; &lt;/div&gt;);export default About; 修改 pages/index.js： 12345678const Index = () =&gt; ( &lt;div&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;a href=&quot;http://localhost:3000/about&quot;&gt;This is a link to About-Page&lt;/a&gt; &lt;/div&gt;);export default Index; 之后我们可以通过 http://localhost:3000/about 来访问该页面 之后，我们需要连接两个页面，首先想到的是可以用一个 HTML 的 &lt;a /&gt; 标签实现，但是结果就是：浏览器会向服务器请求下一页并刷新当前页面，也就是这样做并不会执行客户端导航 为了支持浏览器端导航，我们需要使用 Next.js 提供的 Link 组件，这个组件是通过 next/link 导出的，接下来我们将使用它 我们需要准备一个简单的 Next.js 应用课程，请在 hello-next 下输入： 1git clone https://github.com/zeit/next-learn-demo.git 现在我们进入 hello-next/next-learn-demo/1-navigate-between-pages 启动程序： 123cd next-learn-demo/1-navigate-between-pagesnpm installnpm run dev 打开 http://localhost:3000/ 访问该程序 使用Link组件 注意，接下来的操作均在 hello-next/next-learn-demo/1-navigate-between-pages 下完成的 在 pages/index.js 中添加： 123456789101112import Link from &#x27;next/link&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;p&gt;Hello next.js&lt;/p&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Page&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt; )&#125; 在这里，我们将 next/link 导入为 Link，并按照如下的方式使用： 123&lt;Link href=&quot;/about&quot;&gt; &lt;a&gt;About Page&lt;/a&gt;&lt;/Link&gt; 访问 3000 端口可查看结果 这次点击链接同样会导航到 “About” 页面，这是客户端导航，操作在浏览器中进行，而不向浏览器发送请求，你可以通过打开浏览器的 网络请求检查器（network request inspector） 来验证这一点 后退按钮： 当你点击链接，再点击后退时，依然会切换到历史记录的上一页，也就是 next/link 为你完成了所有 location.history 的操作 添加链接道具 或许你需要在连接中添加属性或道具，比如你需要向链接中添加 title 属性，我们可以这样添加它： 123&lt;Link href=&quot;/about&quot;&gt; &lt;a title=&quot;About-Pages&quot;&gt;About Page&lt;/a&gt;&lt;/Link&gt; 查看元素，可以看到结果如下： 切记不可添加到错误的地方去，若写成如下： 123&lt;Link href=&quot;/about&quot; title=&quot;About-Pages&quot;&gt; &lt;a&gt;About Page&lt;/a&gt;&lt;/Link&gt; 则会在控制台中报错： 实际上，Link 组件上的标题道具无效，是因为 Link 只是一个包装器组件，只接收 href 和一些类似的道具。如果需要向其添加道具，则需要将道具添加到其子项，这种情况下，Link 组件的子代是锚标记 使用共享组件Introduction 我们可以通过导出 React 组件并将该组件放在 pages 目录中来创建页面，每个页面的 URL 都是基于文件名的，由于导出的页面是 JavaScript 模块，因此我们也可以将其他 JavaScript 组件导入其中 我们将创建一个公共的 Header 组件并将其用于多个页面，最后我们将研究实现 Layout 组件，并了解它如何帮我们定义多个页面的外观 运行 我们之前已经安装过了 next-learn-demo，这里直接使用： 进入 hello-next/next-learn-demo/2-using-shared-components，之后我们的操作也会在此目录下 运行： 12npm installnpm run dev 创建标题组件 下面创建一个 Header 组件，创建 2-using-shared-components/components/Header.js： 123456789101112131415161718import Link from &#x27;next/link&#x27;;const linkStyle = &#123; marginRight: 15,&#125;;const Header = () =&gt; ( &lt;div&gt; &lt;Link href=&quot;/&quot;&gt; &lt;a style=&#123;marginRight&#125;&gt;Home&lt;/a&gt; &lt;/Link&gt; &lt;Link href=&quot;/about&quot;&gt; &lt;a style=&#123;marginRight&#125;&gt;About&lt;/a&gt; &lt;/Link&gt; &lt;/div&gt;);export default Header; 现在，导入 Header 组件并在页面中使用它： 将 index.js 修改为： 12345678910import Header from &#x27;../components/Header&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/div&gt; )&#125; 将 about.js 修改为： 12345678910import Header from &#x27;../components/Header&#x27;;export default function Index() &#123; return ( &lt;div&gt; &lt;Header /&gt; &lt;p&gt;This is the About Page&lt;/p&gt; &lt;/div&gt; )&#125; 启动之后可以查看结果 试错：现在将 components 目录改名为 comps，报错如下： 我们不需要将我们的组件放在一个特殊的目录里，也就是说，该组件目录名称可以取为任何，实际上，唯一特殊的目录是 /pages 和 /public，你甚至可以在 /pages 里面创建组件. 布局组件 本节依然是在 2-using-shared-components/ 下完成的 我们将创建 Layout 组件，以实现各页面上的通用样式，在 components/MyLayout.js 中输入： 12345678910111213141516import Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const Layout = props =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &#123;props.children&#125; &lt;/div&gt;);export default Layout; 完成操作后，我们可以在页面中使用以下布局： 在 pages/index.js 中输入： 123456789import Layout from &#x27;../components/MyLayout&#x27;;export default function Index() &#123; return ( &lt;Layout&gt; &lt;p&gt;Hello Next.js&lt;/p&gt; &lt;/Layout&gt; )&#125; 在 pages/about.js 中输入： 123456789import Layout from &#x27;../components/MyLayout&#x27;;export default function About() &#123; return ( &lt;Layout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/Layout&gt; )&#125; 启动，查看样式 试错：将 MyLayout.js 中的 &#123;props.children&#125; 删除，再启动，观察结果： 页面上只保留了 Header 的内容，其他的均消失了 渲染子组件 前一个试错中，我们删除了 &#123;props.children&#125;，则 Layout 无法呈现我们放入 Layout 元素内的内容，如下所示： 1234567export default function About() &#123; return ( &lt;Layout&gt; &lt;p&gt;This is the about page&lt;/p&gt; &lt;/Layout&gt; );&#125; 但这只是创建布局组件的一种方法，以下是其他方法。 方法一：布局为高阶组件 1234567891011121314151617181920// components/MyLayout.jsimport Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const withLayout = Page =&gt; &#123; return () =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &lt;Page /&gt; &lt;/div&gt; );&#125;;export default withLayout; 1234567// pages/index.jsimport withLayout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &lt;p&gt;Hello Next.js&lt;/p&gt;;export default withLayout(Page); 1234567// pages/about.jsimport withLayout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &lt;p&gt;This is the about page&lt;/p&gt;;export default withLayout(Page); 方法二：页面内容作为道具 123456789101112131415161718// components/MyLayout.jsimport Header from &#x27;./Header&#x27;;const layoutStyle = &#123; margin: 20, padding: 20, border: &#x27;1px solid #DDD&#x27;&#125;;const Layout = props =&gt; ( &lt;div style=&#123;layoutStyle&#125;&gt; &lt;Header /&gt; &#123;props.content&#125; &lt;/div&gt;);export default Layout; 123456789// pages/index.jsimport Layout from &#x27;../components/MyLayout.js&#x27;;const indexPageContent = &lt;p&gt;Hello Next.js&lt;/p&gt;;export default function Index() &#123; return &lt;Layout content=&#123;indexPageContent&#125; /&gt;;&#125; 123456789// pages/about.jsimport Layout from &#x27;../components/MyLayout.js&#x27;;const aboutPageContent = &lt;p&gt;This is the about page&lt;/p&gt;;export default function About() &#123; return &lt;Layout content=&#123;aboutPageContent&#125; /&gt;;&#125; 创建动态页面Introduction 之前通过使用组件，我们创建了包含了多个页面的小案例，之前为了创建一个页面，我们必须新建一个文件作为模块导出，但是在一个真正的应用程序中，我们还需动态地创建页面以显示动态内容，接下来我们会使用 查询字符串 来实现这一点 我们将创建一个简单的博客应用，它在主页上展示一个所有文章的列表，展示如下： 主页有文章列表 点击某标题的链接，会出现对应的文章 安装设置 我们仍然使用之前安装过的 next-learn-demo，进入 next-learn-demo/3-create-dynamic-pages，接下来的一切也将在这个目录下完成 运行 12npm installnpm run dev 添加文章列表 首先，我们在文章主页添加标题列表，如下： 1234567891011121314151617181920212223import Link from &#x27;next/link&#x27;;import Layout from &#x27;../components/MyLayout.js&#x27;;const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt; &lt;a&gt;&#123;props.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;);export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &lt;PostLink title=&quot;Hello Next.js&quot; /&gt; &lt;PostLink title=&quot;Learn Next.js is awesome&quot; /&gt; &lt;PostLink title=&quot;Deploy apps with Zeit&quot; /&gt; &lt;/ul&gt; &lt;/Layout&gt; )&#125; 通过查询字符串传递数据 我们将通过查询字符串作为参数（也称查询参数）并传递数据，如： 123456789// pages/index.jsconst PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&#123;`/post?title=$&#123;props.title&#125;`&#125;&gt; &lt;a&gt;&#123;props.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;); 此例中，查询参数是 title，我们使用 PostLink 来执行的操作 你也可以检查 Link 组件的 href 属性，以此类推，你可以使用查询字符串传递任何类型的数据 创建Post页面 现在我们需要创建 post 页面来显示博客文章，为此，我们需要从查询字符串中获得标题， 创建 pages/post.js 文件： 1234567891011121314import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../components/MyLayout&#x27;;const Page = () =&gt; &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/Layout&gt; );&#125;;export default Page; 启动项目，并点击三个标题链接 上面的运作过程如下： 首先从 next/router 导入并使用 useRouter 函数，该函数返回 Next.js 的是 router 对象 使用路由器（router）中的 query 对象，该对象保存了所有查询参数 然后，使用 router.query.title 获取标题 useRouter 函数的介绍： useRouter 允许你访问页面中的 router 对象，它是一个 React Hook，能与功能组件协同合工作 之前的示例中，useRouter 函数被放到预添加的页面组件中，而下面示例中，useRouter 函数在 Content 组件中，预添加的组件是 Page，但是功能不变 1234567891011121314151617181920import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../components/MyLayout&#x27;;const Content = () =&gt; &#123; const router = useRouter(); return ( &lt;&gt; &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/&gt; );&#125;;const Page = () =&gt; ( &lt;Layout&gt; &lt;Content /&gt; &lt;/Layout&gt;);export default Page; 使用动态路由清理URLIntroduction 请确保你正在使用是 Next.js 9 或更高版本接下来的操作都会在 next-learn-demo/4-clean-urls 中进行，请调至指定目录 我们已经知道了如何使用查询字符串创建动态页面，指向我们的某个博客文章的链接如： 1http：&#x2F;&#x2F; localhost：3000 &#x2F; post？title &#x3D; Hello％20Next.js 而此链接要表达的却是： 1http：&#x2F;&#x2F; localhost：3000 &#x2F; p &#x2F; hello-nextjs 动态路由 启动项目，在 4-clean-urls/ 下输入： 12npm installnpm run dev 我们将使用 Next.js 的 动态路由 功能，它允许你处理 /pages 动态路由 现在我们将创建新页面，并命名为 pages/p/[id].js，这也是我们创建的第一个动态路由，步骤如下： 首先，在 /pages 内添加文件夹 /p 然后，你需要在 /p 文件夹中创建 [id].js，并在这些 js 文件中添加如下内容： 123456789101112import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Layout from &#x27;../../components/MyLayout&#x27;;export default function Post() &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt; &lt;p&gt;This is the blog post content.&lt;/p&gt; &lt;/Layout&gt; );&#125;; 前一页是特殊的，它不会处理 /about 等静态路由，而是会处理 p/ 之后的路由，例如，此页面将处理 /p/hello-next.js，而 /p/post-1/another 页面名称中的带有方括号（[]）使其成为动态路由，你不能使页面名称的一部分成为动态名称，而只能使全名成为动态名称，例如，支持 /pages/p/[id].js，但不支持 /pages/p/post-[id].js 创建动态路线时，我们在方括号（[]）之间添加了 id，这是页面接受到查询参数的名称，因此对于 /p/hello-nextjs，该 query 对象将具有 &#123; id: &#39;hello-nextjs&#39; &#125;，我们可以使用 useRouter() 进行访问 现在，我们新的动态路由添加多个链接，修改 pages/index.js： 12345678910111213141516171819202122232425// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;props.id&#125;`&#125;&gt; &lt;a&gt;&#123;props.id&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;)export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &lt;PostLink id=&quot;Hello-Next.js&quot; /&gt; &lt;PostLink id=&quot;Learn-Next.js&quot; /&gt; &lt;PostLink id=&quot;Deploy-Next.js&quot; /&gt; &lt;/ul&gt; &lt;/Layout&gt; )&#125; 着重看看以下内容： 1234567const PostLink = props =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;props.id&#125;`&#125;&gt; &lt;a&gt;&#123;props.id&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;) 在 &lt;Link&gt; 元素中，href 代表的是该页面在 pages 文件夹中的路径，而 as 代表的是该页面在浏览器中的 URL 路径 现在，你可以重新启动项目，注意观察 URL 的变化！ 动态路由可以很好地和浏览器历史记录配合使用，而我们要做的就是将 as 添加到链接组件中 为页面获取数据Introduction 接下来的操作都会在 next-learn-demo/6-fetching-data 中进行，请调至指定目录 现在我们已经能创建一个相对完整的 Next.js 应用，但还没有解决的是：如何从远程数据源中获取数据？，Next.js 提供了一个标准 API 来获取页面所需的数据，即 getInitialProps 异步函数 getInitialProps 只能添加到页面导出的默认组件中，在其他组件中是不会起作用的，它可以从远程数据源为指定页面获取数据，并将这些数据通过 props 传递到我们的页面，它会同时在客户端和服务器上工作，因为它在两个环境中都会被调用 我们将利用 getInitialProps 构建一个应用程序来显示有关 Batman TV Shows 的信息，利用的是公开的 TVmaze API 在即将演示的示例中，我们的主页上有一个文章列表，现在我们来展示 Batman TV shows 的节目列表，我们将从远程服务器上获取这些节目列表，而不是硬编码 在这个示例中，我们使用的是 TVMaze API 来获取 TV shows 节目列表，这是一个搜索电视节目的 API 安装设置 进入 next-learn-demo/6-fetching-data，输入： 12npm installnpm run dev 在浏览器中打开 http://localhost:3000/ 查看项目 获取BatmanShows的数据 首先，我们需要安装 isomorphic-unfetch，这是我们用来获取数据的工具库，这是浏览器的 fetch API 的一个简单实现，但在客户端和服务器环境中都可以使用 1npm install --save isomorphic-unfetch 将 pages/index.js 替换为以下内容： 1234567891011121314151617181920212223242526272829303132333435// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;import fetch from &#x27;isomorphic-unfetch&#x27;;const Index = props =&gt; ( &lt;Layout&gt; &lt;h1&gt;Batman TV Shows&lt;/h1&gt; &lt;ul&gt; &#123; props.shows.map(show =&gt; ( &lt;li key=&#123;show.id&#125;&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;show.id&#125;`&#125;&gt; &lt;a&gt;&#123;show.name&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;/Layout&gt;);Index.getInitialProps = async function() &#123; const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;); const data = await res.json(); console.log(`Show data fetched. Count: $&#123;data.length&#125;`); return &#123; shows: data.map(entry =&gt; entry.show) &#125;;&#125;;export default Index; 我们着重分析下面这部分： 12345678910Index.getInitialProps = async function() &#123; const res = await fetch(&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;); const data = await res.json(); console.log(`Show data fetched. Count: $&#123;data.length&#125;`); return &#123; shows: data.map(entry =&gt; entry.show) &#125;;&#125;; 这是一个静态异步函数，可以添加到程序的任何页面中，使用此函数，我们就可以获取数据并作为 props 传递给我们的页面 以下便是我们的抓取结果，数据被抓取后，将会作为 props 的 ‘show’ 属性传递我们的页面中 注意，我们之前有一行用于打印信息的代码： 1console.log(`Show data fetched. Count: $&#123;data.length&#125;`); 那么到底是在服务器端输出呢，还是在浏览器端的控制台输出呢，现在刷新一下浏览器，会发现之后服务端的控制台显示 在这种情况下，消息只会在服务端输出，因为我们的页面是在服务端绘制的，所以，我们在服务端已经有了数据，没有必要在客户端再次获取这些数据 实现 Post 页面 现在让我们把 TV show 的详细信息添加到 post 中：将 pages/p/[id].js 替换为以下内容： 1234567891011121314151617181920212223// pages/p/[id].jsimport Layout from &#x27;../../components/MyLayout&#x27;;import fetch from &#x27;isomorphic-unfetch&#x27;;const Post = props =&gt; ( &lt;Layout&gt; &lt;h1&gt;&#123;props.show.name&#125;&lt;/h1&gt; &lt;p&gt;&#123; props.show.summary.replace(/&lt;[/]?[pb]&gt;/g), &#x27;&#x27; &#125;&lt;/p&gt; &lt;/Layout&gt;);Post.getInitialProps = async function(context) &#123; const &#123; id &#125; = context.query; const res = await fetch(`https://api.tvmaze.com/shows/$&#123;id&#125;`); const show = await res.json(); console.log(`Fetched show: $&#123;show.name&#125;`); return &#123; show &#125;;&#125;;export default Post; 注意该页的 getInitialProps： 123456789Post.getInitialProps = async function(context) &#123; const &#123; id &#125; = context.query; const res = await fetch(`https://api.tvmaze.com/shows/$&#123;id&#125;`); const show = await res.json(); console.log(`Fetched show: $&#123;show.name&#125;`); return &#123; show &#125;;&#125;; 该函数的第一个参数是 context 对象，此对象包含一个 query 对象，我们用 context.query 来获取信息，即 id 对象，并使其在 TVMaze API 中获取电视节目数据 在这个 getInitialProps 函数中，我们添加了一个 console.log 来打印节目的标题，现在我们看看它将打印到哪里 打开服务器和客户端的控制台，然后启动项目，访问 3000 端口 单击第一个 Batman show 的标题 结果是：会在客户端的控制台输出 与之前不同的是，我们这次只能在客户端看到消息，这是因为我们通过客户端导航到了 post 页面 当我们单击链接时，由于该链接是被 Next.js 的 &lt;Link&gt; 组件包装过的组件，所以页面转换将在浏览器中进行，而不会想服务器发起请求 但是，如果你直接访问的是 post 页面，而不是点击链接（例如，你直接访问 http://localhost:3000/p/975 ），消息会被打印在服务端，而不是客户端 为组件添加样式Introduction 接下来的操作都会在 next-learn-demo/7-styling-components 中进行，请调至指定目录 对于 React，我们可以使用许多不同的技术来设置样式，这些技术可以分为两大类： 传统的基于 CSS 文件的样式设计（包括 SASS、PostCSS 等） CSS in JS 传统的基于 CSS 文件的样式设计（尤其是 SSR）需要考虑一堆的实际问题，因此我们在为 Mext.js 设置样式时避免使用这种方法，相反，我们会在 JS 中使用 CSS，你可以使用它来设置某单个组件的样式，而不是导入 CSS 文件 为此，我们需要认识一个新的框架：styled-jsx，这是Next.js 预装了一个 CSS in JS 框架，它允许你为组件编写熟悉的 CSS 规则，这些 CSS 规则对组件以外的任何内容（当然也包括子组件）都没有影响，也就是说，你的 CSS 规则是有作用域的 安装设置 进入 next-learn-demo/7-styling-components 输入 12npm installnpm run dev 启动项目，访问应用 设置主页的样式 现在我们在主页中添加一些样式，进入 pages/index.js： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// pages/index.jsimport Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;function getPosts() &#123; return [ &#123; id: &#x27;hello-nextjs&#x27;, title: &#x27;Hello Next.js&#x27; &#125;, &#123; id: &#x27;learn-nextjs&#x27;, title: &#x27;Learn Next.js is awesome&#x27; &#125;, &#123; id: &#x27;deploy-nextjs&#x27;, title: &#x27;Deploy apps with ZEIT&#x27; &#125; ];&#125;export default function Blog() &#123; return ( &lt;Lauout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &#123; getPosts().map(post =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; &lt;style jsx&gt;&#123;` h1, a &#123; font-family: &#x27;Arial&#x27;; &#125; ul &#123; padding: 0 &#125; li &#123; list-style: none; margin: 5px, 0; &#125; a &#123; text-decoration: none; color: red; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/Lauout&gt; )&#125; 那个 &lt;style jsx&gt; 元素，就是我们编写 CSS 规则的地方 现在可以启动项目，查看结果 上面的代码中，我们没有直接在 &lt;style&gt; 标签内编写样式代码，而是写在模板字符串（&#123;``&#125;）里面的，Next.js 默认支持 babel 语法，而 styled-jsx 可以看做 babel 的一个插件，它将解析所有 CSS 并将其应用于构建工程 CSS样式和嵌套组件 现在我们将会对主页做一些更改，我们将会像这样隔离 Link 组件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import Layout from &#x27;../components/MyLayout&#x27;;import Link from &#x27;next/link&#x27;;function getPosts() &#123; return [ &#123; id: &#x27;hello-nextjs&#x27;, title: &#x27;Hello Next.js&#x27; &#125;, &#123; id: &#x27;learn-nextjs&#x27;, title: &#x27;Learn Next.js is awesome&#x27; &#125;, &#123; id: &#x27;deploy-nextjs&#x27;, title: &#x27;Deploy apps with ZEIT&#x27; &#125; ];&#125;const PostLink = (&#123; post &#125;) =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;/li&gt;);export default function Blog() &#123; return ( &lt;Layout&gt; &lt;h1&gt;My Blog&lt;/h1&gt; &lt;ul&gt; &#123;getPosts().map(post =&gt; ( &lt;PostLink key=&#123;post.id&#125; post=&#123;post&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;style jsx&gt;&#123;` h1, a &#123; font-family: &#x27;Arial&#x27;; &#125; ul &#123; padding: 0; &#125; li &#123; list-style: none; margin: 5px 0; &#125; a &#123; text-decoration: none; color: blue; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/Layout&gt; );&#125; 运行后发现：h1 的样式还在，但是链接已经失效了，如下： 上述结果显示：CSS 样式规则对子组件中的元素没有影响，styled-jsx 这个特性可以帮助你管理大型的应用程序的样式，在这种情况下，我们需要直接设置子组件的样式，在我们的示例中，我们需要对 Link 组件执行以下操作： 123456789101112131415161718192021const PostLink = (&#123; post &#125;) =&gt; ( &lt;li&gt; &lt;Link href=&quot;/p/[id]&quot; as=&#123;`/p/$&#123;post.id&#125;`&#125;&gt; &lt;a&gt;&#123;post.title&#125;&lt;/a&gt; &lt;/Link&gt; &lt;style jsx&gt;&#123;` li &#123; list-style: none; margin: 5px 0; &#125; a &#123; text-decoration: none; color: blue; font-family: &#x27;Arial&#x27;; &#125; a:hover &#123; opacity: 0.6; &#125; `&#125;&lt;/style&gt; &lt;/li&gt;); 拓展了解：全局选择器 全局样式 有时我们确实需要更改子组件内部的样式，尤其是在使用支持 React 的 markdown 时 我们需要安装 react-markdown 1npm install --save react-markdown 下面就是全局样式派上用场的地方，现在就来试试利用 styled-jsx 添加一些全局样式，打开 pages/p/[id].js： 123456789101112131415161718192021222324252627282930313233343536373839404142import &#123; useRouter &#125; from &#x27;next/router&#x27;;import Markdown from &#x27;react-markdown&#x27;;import Layout from &#x27;../../components/MyLayout&#x27;;export default () =&gt; &#123; const router = useRouter(); return ( &lt;Layout&gt; &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt; &lt;div className=&quot;markdown&quot;&gt; &lt;Markdown source=&#123;`This is our blog post.Yes. We can have a [link](/link).And we can have a title as well.### This is a titlr.And here&#x27;s the content. `&#125; /&gt; &lt;/div&gt; &lt;style jsx global&gt;&#123;` .markdown &#123; font-family: &#x27;Arial&#x27;; &#125; .markdown a &#123; text-decoration: none; color: red; &#125; .markdown a:hover &#123; opacity: 0.6; &#125; .markdown h3 &#123; margin: 0; padding: 0; text-transform: uppercase; &#125; `&#125;&lt;/style&gt; &lt;/Layout&gt; );&#125;; 注意，markdown 语法部分的缩进不可修改！！！ 我们定义的 style 作用于整个 &lt;div&gt; 标签部分，也就是作用于全局，虽然这样很方便，但是还是建议写带有作用域的样式 尽管如此，这依然是一个比普通样式标签更好的解决方案，使用 styled-jsx 时，所有必要的特定于浏览器厂商前缀和 CSS 校验都通过了一个 Babel 插件完成了，这并不会导致额外的开销 部署 Next.js 应用程序Introduction 接下来的操作都会在 next-learn-demo/8-deploying 中进行，请调至指定目录 ZEIT Now 是将应用程序部署到生产环境的最简单和可扩展的方法，但是，你可以部署 Next.js 应用程序，而且它相对来讲比较简单 现在我们将部署 Next.js 应用程序 进入 next-learn-demo/8-deploying，输入命令： 12npm installnpm run dev 部署到 ZEIT Now 我们来看一下 package.json 文件的 script 配置段： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start&quot; &#125;, 首先，我们需要为生产环境编译我们的 Next.js 应用程序，它将生成一组优化的用于生产环境的代码： 1npm run build 然后，你需要启动 Next.js 应用程序并监听某个端口，此服务器将执行服务器端渲染并返回静态页面（使用上述命令编译） 1npm run start 现在可以查看效果：http://localhost:3000 运行两个实例 现在我们将为我们的应用程序启动两个实例，通常这样是为了横向扩展我们的应用程序 首先，将 package.json 中的 script 配置端替换为以下的内容： 12345&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;next&quot;, &quot;build&quot;: &quot;next build&quot;, &quot;start&quot;: &quot;next start -p %PORT%&quot;&#125; 我们更改了 start 脚本，它卸载接受一个代表端口号的参数来启动应用程序 注意，%PORT% 是对于 Windows 来说的，Linux 对应的是 $PORT 现在构建我们的应用程序： 1npm run build 现在我们需要安装一个新的包，即：cross-env，我们在全局环境下安装： 1npm install cross-env -g 同时打开两个终端，分别在终端中输入： 12cross-env PORT=8000 npm startcross-env PORT=9000 npm start 在 Linux 上，则直接打开两个命令行终端，并分别在每个命令行终端上运行： 12PORT=8000 npm startPORT=9000 npm start 现在，在浏览器分别查看：http://localhost:8000 和 http://localhost:9000 可以得到的结果是，你只需要对应用程序构建一次。然后就可以在任意多个端口上启动它 结语 求进之路，持之谦卑","categories":[{"name":"React","slug":"React","permalink":"http://ozziely.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://ozziely.com/tags/React/"}]}],"categories":[{"name":"探索笔记","slug":"探索笔记","permalink":"http://ozziely.com/categories/%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","permalink":"http://ozziely.com/categories/React/"}],"tags":[{"name":"探索笔记","slug":"探索笔记","permalink":"http://ozziely.com/tags/%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0/"},{"name":"React","slug":"React","permalink":"http://ozziely.com/tags/React/"}]}