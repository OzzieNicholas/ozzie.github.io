<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机操作系统（二）：进程的初步认识</title>
      <link href="279bab449d3d/"/>
      <url>279bab449d3d/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程的知识体系图"><a href="#进程与线程的知识体系图" class="headerlink" title="进程与线程的知识体系图"></a>进程与线程的知识体系图</h2><p><img src="https://user-images.githubusercontent.com/49378661/98496888-9de1a800-227d-11eb-94a0-065bdaacb230.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98496888-9de1a800-227d-11eb-94a0-065bdaacb230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109084704273"></p><blockquote><p>在之后的文章中会陆续讲到，这里我们只说线程的知识</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内<br>容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的<br>CPU只有一一个，它们也支持（伪） 并发操作。它们会将一 一个单独的CPU抽象为多个虚拟机的CPU。<br>可以说，没有进程的抽象，现代操作系统将不复存在。</p><p><img src="https://user-images.githubusercontent.com/49378661/98496964-ccf81980-227d-11eb-88ef-edb7fa1385a1.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98496964-ccf81980-227d-11eb-88ef-edb7fa1385a1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109085235569"></p><p>在许多多道程序系统中， CPU会在进程间快速切换，使每个程说序运行几十或者几百毫秒。然而，严格<br>意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能<br>运行多个进程。这样就会让我们产生并行的错觉。有时候人们说的伪并行（pseudoparallelism)<br>其实就是这种情况，以此来区分多处理器系统（该系统由两个或多个CPU来共享同一个物理内存）</p><blockquote><p>再解释一下伪并行：伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快。<br>通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。</p><p>缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。</p></blockquote><p>因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所<br>以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得<br>并行更加容易理解和分析。下面我们就来探讨一下进程模型</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程，简称为进程（process) 。 一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟CPU，但是实际情况是CPU会在各个进程之间进行来回切换。<br><img src="https://user-images.githubusercontent.com/49378661/98497019-ef8a3280-227d-11eb-8db8-78c4fe056fd6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497019-ef8a3280-227d-11eb-8db8-78c4fe056fd6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109090338163"></p><p>如上图所示，这是一个具有4个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化：<br><img src="https://user-images.githubusercontent.com/49378661/98497035-f6b14080-227d-11eb-966e-974c70391734.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497035-f6b14080-227d-11eb-966e-974c70391734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109090459710"></p><p>在上图中，这4道程序被抽象为4个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一 一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行：<br><img src="https://user-images.githubusercontent.com/49378661/98497048-fca72180-227d-11eb-8bea-12df8a803c75.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497048-fca72180-227d-11eb-8bea-12df8a803c75.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109091326053"></p><p>因此，当我们说一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU)，每一个核<br>也只能一次运行一个线程。</p><p>由于CPU会在各个进程之间来回快速切换，所以每个进程在CPU中的运行时间是无法确定的。并且<br>当同一个进程再次在CPU中运行时，其在CPU内部的运行时间往往也是不固定的。这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行 了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>操作系统需要一些方式来创建进程。下面是一 些创建进程的方式</p><ul><li>系统初始化（init)</li><li>正在运行的程序执行了创建进程的系统调用（比如fork)</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ul><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>启动操作系统时，通常会创建若干个进程。</p><p>其中有些是前台进程（numerous processes) ，也就是同用户进行交互并替他们完成工作的进程。</p><p>一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。</p><p>还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。</p><p>进程运行在后台用来处理一些活动像是 e-mail, web网页，新闻，打印等等被称为守护进（daemons)。大型系统会有很多守护进程。在UNIX中，ps 程序可以列出正在运行的进程，在Windows中，可以使用任务管理器。</p><h3 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h3><p>除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出系统调用用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的CPU上也可以使工作做的更快。</p><h3 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h3><p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的UNIX系统中运行X,新进程将接管启动它的窗口。在Windows中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p><h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。</p><p>当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p><p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。</p><p>该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。</p><p>该系统调用告诉操作系统创建一个新进程， 并直接或间接指示在其中运行哪个程序。</p><p>在UNIX中，仅有一个系统调用来创建一个新的进程，这个系统调用就是fork 。这个调用会创建一<br>个与调用进程相关的副本。在fork后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和<br>相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个<br>新的程序。例如，当一个用户在shell中输出sort命令时，shell 会fork 一个子进程然后子进程去执行sort命令。这两步过程的原因是允许子进程在fork之后但在execve之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。</p><p>而在Windows中，情况正相反，一个简单的Win32功能调用CreateProcess ，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有10个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以<br>及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了CreateProcess Win 32中大概有100个其他的函数用于处理进程的管理，同步以及相关的事务。</p><p>下面是UNIX操作系统和Windows操作系统系统调用的对比：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497063-03359900-227e-11eb-891b-88667de5f354.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497063-03359900-227e-11eb-891b-88667de5f354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109093537417"></p><p>在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。</p><p>在UNIX中，子进程的地址空间是父进程的一个拷贝，但是确是两个不同的地址空间；不可写的内存区域是共享的。某些UNIX实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过写时复制（copy- on- write)共享， 这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。</p><p>再次强调，可写的内存是不能被共享的。 但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，但是通常是由于以下情况触发：</p><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>严重错误（非自愿的）</li><li>被其他进程杀死（非自愿的）</li></ul><h3 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h3><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。</p><p>这个调用在UNIX中是exit，在Windows中是ExitProcess 。</p><p>面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p><h3 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h3><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC foo.c</span><br></pre></td></tr></table></figure><p>为了能够编译foo.c但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向<br>屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><h3 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h3><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是0等。</p><p>在有些系统比如UNIX中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><h3 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h3><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。</p><p>在UNIX中，这个系统调用是kill。在Win32中对应的函数是TerminateProcess（注意不是系统调用）。</p><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h3 id="UNIX进程体系"><a href="#UNIX进程体系" class="headerlink" title="UNIX进程体系"></a>UNIX进程体系</h3><p>在UNIX中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一<br>个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有<br>活动进程）。</p><p>每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号kill 掉。</p><p>另一个例子，可以用来说明层次的作用：考虑UNIX 在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中。当init进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。 这些进程等待用户登录。如果登录成功，该登录进程就执行一个shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以init为根的进程树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init─┬─NetworkManager（5427)</span><br><span class="line">        ├─NetworkManagerD（5441)</span><br><span class="line">        ├─acpid（5210)</span><br><span class="line">        ├─apache2（6966)─┬─apache2（2890)</span><br><span class="line">        │               ├─apache2（2893)</span><br><span class="line">        │               ├─apache2（7163)</span><br><span class="line">        │               ├─apache2（7165)</span><br><span class="line">        │               ├─apache2（7166)</span><br><span class="line">        │               ├─apache2（7167)</span><br><span class="line">        │               └─apache2（7168)</span><br><span class="line">        ├─atd（6369)</span><br><span class="line">        ├─avahi-daemon（5658)───avahi-daemon（5659)</span><br><span class="line">        ├─bonobo-activati（7816)───&#123;bonobo-activati&#125;（7817)</span><br></pre></td></tr></table></figure><h3 id="Windows进程体系"><a href="#Windows进程体系" class="headerlink" title="Windows进程体系"></a>Windows进程体系</h3><p>相反，Windows中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是<br>在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该询柄可以用来控制子进程。</p><p>然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在UNIX中，进程不能剥夺其子进程的进程权。（这样看来， 还是Windows比较渣）。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮<br>助。例如，一个进程的结果可以作为另一个进程的输入，在shell命令中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程是cat ，将三个文件级联并输出。</p><p>第二个进程是grep ，它从输入中选择具有包含关键字tree的内容。</p><p>根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况：grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。<br>当一个进程开始运行时，它可能会经历下面这几种状态（下图为进程状态切换图）：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497118-22342b00-227e-11eb-9074-9c30e007c0b4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497118-22342b00-227e-11eb-9074-9c30e007c0b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109105506449"></p><p>图中会涉及三种状态：</p><ol><li>运行态，运行态指的就是进程实际占用CPU时间片运行时</li><li>就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li>阻塞态，除非某种外部事件发生，否则进程不能运行</li></ol><p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获<br>得CPU时间分片。</p><p>第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。</p><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些<br>系统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX，当进程从管道或特殊文件（例如终端） 中读取没有可用的输入时，该进程会被自动终止。</p><p>转换2和转换3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。</p><p>转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。</p><p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算<br>法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p><p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4。如果此时没有其他进<br>程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再<br>轮到它运行。</p><p>从上面的观点引入了下面的模型：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497133-2a8c6600-227e-11eb-9120-af97d8e2bc51.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497133-2a8c6600-227e-11eb-9120-af97d8e2bc51.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109110000239"></p><p>基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。</p><p>操作系统最底层的就是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。</p><p>事实上，调度程序只是一段非常小的程序。</p><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是进程表（process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状<br>况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><p>下面展示了一个典型系统中的关键字段</p><p><img src="https://user-images.githubusercontent.com/49378661/98497144-2fe9b080-227e-11eb-8b9a-2710bd808168.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497144-2fe9b080-227e-11eb-8b9a-2710bd808168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109110430257"></p><p>典型的进程表表项中的一些字段</p><p>第一列内容与进程管理有关，第二列内容与存储管理 有关，第三列内容与文件管理有关。</p><p>存储管理的text segment、data segment、stack segment更多了解见下面这篇文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484788&idx=1&sn=8a17224cabe09d3bd564dfdf22e2ff5d&chksm=fc45f887cb3271914f0e688a3cce4d7e3ce9077cdde199648e72aa92ad08fba2047b4483b7e8&token=504034995&lang=zh_CN%23rd">程序员需要了解的硬核知识之汇编语言（全）</a></p><p>现在我们应该对进程表有个大致的了解了，就可以在对单个CPU.上如何运行多个顺序进程的错觉做更<br>多的解释。</p><p>与每一/0类相关联的是一个称作中断向量（interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。</p><p>假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。</p><p>然后软件就随即接管一切剩余的工作。</p><p>当中断结束后，操作系统会调用一个C程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进<br>程就绪，接着调用调度程序，决定随后运行哪个进程。</p><p>然后将控制权转移给一 一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程：</p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装 入新的程序计数器</li><li>汇编语言过程保存寄存器的值</li><li>汇编语言过程设置新的堆栈</li><li>C中断服务器运行（典型的读和缓存写入）</li><li>调度器决定下面哪个程序先运行</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（一）：认识操作系统</title>
      <link href="bfb7f7b98435/"/>
      <url>bfb7f7b98435/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h2><ol><li>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。<br><img src="https://user-images.githubusercontent.com/49378661/97126827-e758d000-1772-11eb-98e6-e29dbc8ec6e3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126827-e758d000-1772-11eb-98e6-e29dbc8ec6e3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026083834317"></li><li>在硬件的基础上，计算机安装了一层软件，这些软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户的需求，这种软件被称之为 “操作系统”，</li><li>我们一般常见的操作系统主要有：Windows、Linux、FreeBSD 或 OS X，这种带有图形界面的操作系统，被统称为 “图形用户界面（GUI）”，而基于文本、命令行通常被统称为 “Shell”，如下是我们所探讨的操作系统的部件（这是一个操作系统的简化图）：<br><img src="https://user-images.githubusercontent.com/49378661/97126859-ffc8ea80-1772-11eb-9b7a-a87a8c9107fd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126859-ffc8ea80-1772-11eb-9b7a-a87a8c9107fd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026083935975"><ul><li>最下面是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，硬件之上是软件。</li><li>大部分计算机有两种运行模式：“内核态” 和 “用户态”，软件中最基础的部分是操作系统，它运行在内核态中，内核态也被称为 “管态” 和 “核心态”，它们都是操作系统的运行状态，只是叫法不同而已。操作系统具有硬件的访问权，可以在执行机器能够运行的任何指令。软件的其余部分运行在用户态下。</li><li>“用户接口程序（Shell 或者 GUI）”处于用户态中，并且它们处在用户态的最底层，允许用户运行其他的程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等等，而且，越靠近用户态的应用程序越容易编写。假如你不喜欢某个电子邮件阅读器，你可以随意换一个软件，但你不能自行写一个操作系统或者是中断处理程序，这个程序是由硬件保护的，防止外部对其进行修改。</li></ul></li></ol><h2 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h2><h3 id="操作系统与硬件"><a href="#操作系统与硬件" class="headerlink" title="操作系统与硬件"></a>操作系统与硬件</h3><ol><li>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源，因此，操作系统必须足够了解硬件的运行，所以这里要先介绍现代计算机中的硬件。</li><li>从概念上来看，一个简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O设备都和总线串联起来并通过总线与其他设备进行通信。<ul><li>简单个人计算机的组件：<br><img src="https://user-images.githubusercontent.com/49378661/97126920-26872100-1773-11eb-990e-28caadd150f8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126920-26872100-1773-11eb-990e-28caadd150f8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026084030631"></li></ul></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ol><li>CPU是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个CPU的执行周期是从内存中提取第一条指令、 解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</li><li>每个 CPU 都有一组可以执行的特定指令集。因此，X86 的 CPU 不能执行 ARM 的程序并且ARM 的 CPU 也不能执行 X86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</li><li>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。<ul><li>其中之一就是程序计数器(program counter) ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。另一个寄存器是堆栈指针(stack pointer) ，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</li><li>还有一个寄存器是PSW(Program Status Word)程序状态字寄存器，这个寄存器是由操作系统维护的 8 个字节（64位） long类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW。用户程序通常可以读取整个PSW,但通常只能写入其某些字段。PSW在系统调用和 1/ 0 中起着重要作用。</li></ul></li><li>操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时， 操作系统会保存所有寄存器的值，以便于后续重新运行该程序。为了提升性能，CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。 许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个CPU可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对N+ 1条指令解码，还可以读取N + 2条指令。像这样的组织形式被称为流水线(pipeline) 。<br><img src="https://user-images.githubusercontent.com/49378661/97126952-3d2d7800-1773-11eb-8eca-9fcb00d5f7c3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126952-3d2d7800-1773-11eb-8eca-9fcb00d5f7c3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092152254"><ul><li>比流水线更先进的设计是超标量(superscalar) CPU，该设计如下：<br><img src="https://user-images.githubusercontent.com/49378661/97126965-43bbef80-1773-11eb-853e-e6b72b54e0b0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126965-43bbef80-1773-11eb-853e-e6b72b54e0b0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092300000"><ul><li>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、 解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。</li><li>这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</li></ul></li></ul></li><li>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。<ul><li>当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下， 剩下的一部分运行在用户态下。<ul><li>注意，设置 PSW 模式的二进制位为内核态也是禁止的。</li></ul></li><li>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 l/O 和内存保护的所有指令是禁止执行的。</li><li>为了获取操作系统的服务，用户程序必须使用系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</li></ul></li><li>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</li></ol><h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><ol><li><p>多线程或超线程的特性起初是奔腾处理器（Intel Pentinum 4）引入的。</p></li><li><p>多线程允许 CPU 保持两个不同的线程状态并且在纳秒级(nanosecond)的时间完成切换，近似地说，线程是一种轻量级的进程。</p></li><li><p>例如，如果一个进程想要从内存中读取指令（这通常会经历几个时钟周期），多线程CPU则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。</p></li><li><p>对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的CPU。比如一个有两个CPU的操作系统，并且每个CPU运行两个线程，那么这对于操作系统来说就可能是4个CPU。</p></li><li><p>除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。</p></li><li><p>如图是带有共享 L2 缓存的 4 核芯片：<br><img src="https://user-images.githubusercontent.com/49378661/97126976-4b7b9400-1773-11eb-8496-6856adb9d712.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126976-4b7b9400-1773-11eb-8496-6856adb9d712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092304767"><br><img src="https://user-images.githubusercontent.com/49378661/97126989-50d8de80-1773-11eb-8c8b-4d0f1f492dec.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126989-50d8de80-1773-11eb-8c8b-4d0f1f492dec.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921093826668"></p><ul><li>而带有分离 L2缓存的 4 核芯片则如下：<br><img src="https://user-images.githubusercontent.com/49378661/97127060-8a114e80-1773-11eb-873a-607bb5415978.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127060-8a114e80-1773-11eb-873a-607bb5415978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921094004991"></li></ul></li><li><p>而说到线代的 GPU，则是指有成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算。</p></li></ol><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机的第二个主要的组件就是内存，目前采用了不同的处理方式，存储系统采用一种分层次的结构：<br><img src="https://user-images.githubusercontent.com/49378661/97127274-23d8fb80-1774-11eb-815b-f0db39a46cd4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127274-23d8fb80-1774-11eb-815b-f0db39a46cd4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921094359988"></p><p>顶层的存储器访问效率最高，但是容量最小，成本也最高，以此类推。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ol><li><p>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行（cache lines） 为64字节，内存地址的 0 一 63 对应高速缓存行0，地址 64- 127 对应高速缓存行的1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。</p></li><li><p>高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p></li><li><p>随机存储器（RAM） ：内存中最重要的一 种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p></li><li><p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权， 缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 <code>/home/ ast/projects/minix3/src/kernel/clock.c</code>，这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个Web页面(URL)的地址转换为网络地址（P地址）后，这个转换结果也可以缓存起来供将来使用。</p></li><li><p>在任何缓存系统中，都会有下面这几个噬需解决的问题：</p><ul><li>何时把新的内容放进缓存</li><li>把新的内容应该放在缓存的哪一行</li><li>在需要空闲空间时，应该把哪块内容从缓存中移除</li><li>应该把移除的内容放在某个较大存储器的何处</li><li>并不是每个问题都与每种缓存情况有关。对于CPU缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。</li></ul></li><li><p>缓存是解决问题的一种好的方式，所以现代CPU设计了两种缓存。第一级缓存或者说是 L1 cache，总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个L1 cache。典型的L1 cache的大小为16 KB。另外，往往还设有二级缓存，也就是L2 cache，用来存放最近使用过的关键字，一 一般是兆字节为单位。L1 cache和L2 cache最大的不同在于是否存在延迟。访问L1 cache没有任何的延迟，然而访问L2 cache会有1 — 2个时钟周期的延后。</p><blockquote><p>什么是时钟周期？<br>计算机处理器或CPU的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz） 或千兆赫（GHz）。例如， 一个4 GHz处理器每秒执行4,000,000,000个时钟周期。</p><p>计算机处理器可以在每个时钟周期执行一条或多 条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的CPU在每个时钟周期只能执行一条指令， 而现代处理器在每个时钟周期可以执行多条指令。</p></blockquote></li></ol><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><ol><li>在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做RAM（Random AccessMenmory）。</li><li>除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。</li><li>ROM（Read Only Memory）中的内容一 旦存储后就不会再被修改。它非常快而且便宜。（如果有 人问你，有没有什么又快又便宜的内存设备，那就是ROM了）在计算机中，用于启动计算机的引导加载模块（也就是bootstrap ）就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。</li><li>EEPROM（Electrically Erasable PROM） 和闪存（flash menory）也是非易失性的，但是与ROM相反，它们可以擦除和重写。不过重写它们需要比写入RAM更多的时间，所以它们的使用方式与ROM相同，但是与ROM不同的是他们可以通过重写字段来纠正程序中出现的错误。<ul><li>闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。</li><li>还有一类是CMOS，它是易失性的。许多计算机都会使用CMOS存储器保持当前时间和日期。</li></ul></li></ol><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ol><li><p>磁盘（也就是硬盘），同RAM相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了 三个数量级。磁盘访问慢的原因是磁盘的构造不同。</p><ul><li>磁盘驱动器的构造：<br><img src="https://user-images.githubusercontent.com/49378661/97127508-c2655c80-1774-11eb-8e81-5b802c30e80c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127508-c2655c80-1774-11eb-8e81-5b802c30e80c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026090018123"></li></ul></li><li><p>每个磁道划分若干扇区（如图），扇区的值是512字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要1ms。而随机移到一个柱面的典型时间为5ms至10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s ，而高速磁盘的速率是160MB/s 。需要注意，固态硬盘(Solid State Disk, SSD) 不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中， 与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。<br><img src="https://user-images.githubusercontent.com/49378661/97127140-ccd32680-1773-11eb-9561-e6924a995377.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127140-ccd32680-1773-11eb-9561-e6924a995377.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026090510293"></p></li><li><p>许多计算机支持一种著名的虚拟内存机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit, MMU) 的部件来完成。</p></li><li><p>缓存和MMU的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为上下文切换（ context switch) ，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p></li></ol><h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><ol><li><p>I/O设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。</p></li><li><p>I/O设备另一部分是设备本身，设备本身有一一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。</p></li><li><p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为设备驱动程序(device driver) 。每个控制器厂 家都应该针对不同的操作系统提供不同的设备驱动程序。</p></li><li><p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径：</p><ul><li>第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是UNIX 系统采用的工作方式</li><li>第二个途径是在一个操作系统文件中设置一个入口， 通知该文件需要一个设备驱动程序， 然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是Windows 采用的工作方式</li><li>第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如USB和IEE 1394都需要动态可装载的设备驱动程序。</li></ul></li><li><p>每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了I/O 端口空间。</p></li><li><p>在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下：</p><p>启动设备并发出中断的过程：<br><img src="https://user-images.githubusercontent.com/49378661/97127519-d315d280-1774-11eb-86b8-ece24306133b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127519-d315d280-1774-11eb-86b8-ece24306133b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026091609088"></p><ul><li>如上图所示，这是一个三步的I/O过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。</li><li>然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤2中使用某些总线向中断控制器发送信号。</li><li>如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在CPU的一个引脚上面声明，这就是步骤3。</li><li>在第4步中，中断控制器把该设备的编号放在总线上，这样CPU可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。</li><li>一旦CPU决定去实施中断后，程序计数器和PSW就会被压入到当前堆栈中并且CPU会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作中断向量(interrupt vector) 。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和PSW寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令， 这个过程如下：<br><img src="https://user-images.githubusercontent.com/49378661/97127175-dfe5f680-1773-11eb-96fd-40a6ba465d4a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127175-dfe5f680-1773-11eb-96fd-40a6ba465d4a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026091959369"></li></ul></li></ol><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ol><li><p>随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括IBM PC总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理1/O设备以及CPU到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现：<br><img src="https://user-images.githubusercontent.com/49378661/97127186-e3797d80-1773-11eb-8149-163c8b7ca64e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127186-e3797d80-1773-11eb-8149-163c8b7ca64e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026092111966"></p><ul><li>上图中的 x86 系统包含很多总线，高速缓存、内存、PCle、 PCI、 USB、SATA 和DMI,每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是PCIe(Peri pheral Component Interconnect Express)总线。</li></ul></li></ol><h3 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h3><ol><li><p>在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一 般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。</p></li><li><p>在母板上有一个称为基本输入输出系统(Basic Input Output System， BIOS) 的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、磁盘I/O以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS中发现错误时，可以由操作系统进行更新。</p></li><li><p>在计算机启动(booted) 时，BIOS 开启，它会首先检查所安装的RAM的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描PCle和PCI总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一 一次启动时的设备不同，则新的设备将被重新配置。</p></li><li><p>然后，BIOS通过尝试存储在CMOS 存储器中的设备清单 尝试启动设备</p><blockquote><p>CMOS是Complementary Metal 0xide Sem iconductor （互补金属氧化物半导体）的缩写 。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的RAM 芯片。 因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p><p>而对BIOS中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入BIOS设置程序，方便地对系统进行设置。因此BIOS设置有时也被叫做CMOS设置。</p></blockquote></li><li><p>用户可以在系统启动后进入一个BIOS配置程序，对设备清单进行修改。然后，判断是否能够从外部CD-ROM和USB驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。</p></li><li><p>然后操作系统会询问BIOS获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入CD- ROM驱动（由设备制造商提供）或者从Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
