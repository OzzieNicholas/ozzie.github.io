<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>How Snubs to Public Health Left Missouri Behind on Vaccine Equity</title>
      <link href="ebc3063d5984/"/>
      <url>ebc3063d5984/</url>
      
        <content type="html"><![CDATA[<h2 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h2><blockquote><p>The underfunding of public health and political backlash destabilized Missouri’s vaccine rollout, creating racial inequity and forcing some residents to drive hours to get shots.</p></blockquote><p>ST. LOUIS — Missourians have driven hours to find vaccines in rural counties — at least those with cars and the time. Tens of thousands of doses are waiting to be distributed,  slowly being rolled out in a federal long-term care program. Waitlists are hundreds of thousands of people long. Black residents are getting left behind.</p><p>Missouri’s rocky vaccine rollout places it among the bottom states nationwide, with 23.7% of the population vaccinated with at least one dose as of Thursday, compared with the <a href="https://covid.cdc.gov/covid-data-tracker/#vaccinations">national average of 26.3%</a>. If <a href="https://www.usnews.com/news/best-states/missouri">Missouri</a> were on par with the national rate, that would be roughly equivalent to more than 162,000 additional people vaccinated, or almost the entire population of the city of Springfield.</p><hr><p>Part of the problem, health experts said, is that the state bypassed its 115 local health departments in its initial vaccine rollout plans. Instead, state officials largely outsourced the work to hospitals, consultants and federal programs, reasoning hospitals and mass vaccination sites had the workforce and facilities to deliver high numbers of vaccines.</p><p>Meanwhile, local health departments and federally qualified health centers, which typically reach the most vulnerable populations not connected to traditional health systems, were each initially left to divvy up about 8% of the state’s vaccine supply. That allocation has since increased to 15%, but it hasn’t been enough to fill the remaining gaps.</p><p>“You get what we pay for,” said Spring Schmidt, former co-acting director of the St. Louis County health department, noting public health departments in the state have been underfunded for decades. “This is an infrastructure that is similar to governmental utilities or other services that our citizens expect to be provided for them and tend to only notice when they fall.”</p><hr><p>The local health departments knew what needed to be done. “We’ve drilled for this, we’ve got plans on shelves that are collecting dust for this,” Schmidt said.</p><p>But that’s the rub of long-standing health department underfunding: Even with all the plans honed in flu and H1N1 vaccination campaigns, health departments still would need the staff and facilities to pull off something of this scale, said Dr. <a href="https://www.ssmhealth.com/resources/about/leadership/senior-leadership/alexander-garza-md-chief-community-health-officer">Alex Garza</a>, head of the St. Louis Metropolitan Pandemic Task Force, a consortium of the area’s major hospital systems. And the state and county governments aren’t providing the necessary funding to do the job.</p><p>A <a href="https://khn.org/news/us-public-health-system-underfunded-under-threat-faces-more-cuts-amid-covid-pandemic/">2020 Kaiser Health News and AP investigation</a> found that Missouri public health staffing at the state level had fallen 8% from 2010 to 2019, a loss of 106 full-time employees. Public health spending per Missourian was $50 per year – one of the bottom 10 states in the nation.</p><p>When the pandemic struck, local health departments had only 408 employees trained to give vaccinations, according to a report released Friday by #HealthierMO, a group advocating for better public health in the state. That means if only those staffers had given vaccines, they would each need to vaccinate some 15,000 people – in many cases, administering two shots. In even the most efficient scenario, with each person taking five minutes to vaccinate, that would take more than seven months for just one shot per person.</p><p>At the same time, public health officials get blamed for enacting pandemic safety measures. State legislators are discussing limits to public health powers and local officials have withheld funding from their health departments, hindering their power to act in the crisis.</p><hr><p><strong>A Question of Equity</strong></p><p>Missouri public health officials said the outsourcing approach missed the mark on the mission of public health: getting the vaccine to those who need it the most.</p><p>Only <a href="https://covidvaccine.mo.gov/data/">9.9% of Black Missourians</a> are vaccinated, as opposed to 18.3% of white Missourians, according to available data. A <a href="https://covidvaccine.mo.gov/equity/">series of reports</a> produced by Deloitte, a major consulting firm advising the state on the rollout, showed a pattern of vaccine deserts in metro areas, where the state’s Black residents are concentrated.</p><p>Nationally, non-Hispanic Black Americans are 1.9 times more likely to die of covid than white Americans, according to a Centers for Disease Control and Prevention <a href="https://www.cdc.gov/coronavirus/2019-ncov/covid-data/investigations-discovery/hospitalization-death-by-race-ethnicity.html">analysis</a>. Black Missourians make up <a href="https://showmestrong.mo.gov/data/public-health/demographics/">13.1% of the state’s COVID-19 deaths</a>, higher than their <a href="https://www.census.gov/quickfacts/MO">11.8%</a> share of the population.</p><p>Some of the Deloitte reports in early March also found [nearly a third](<a href="https://covidvaccine.mo.gov/equity/pdf/State">https://covidvaccine.mo.gov/equity/pdf/State</a> of Missouri_HealthPrism_Vaccine Distribution Analysis_03082021_Final.pdf) of Missouri residents traveled outside their county to get vaccinated. Democratic state Sen. Jill Schupp and other critics have said the initial rollout data show it’s because the geographic allocation of vaccines did not match up with population sizes.</p><p>“If you are elderly and don’t do that kind of driving, if you’re low-income and don’t have that access to transportation, if you’re a working person who can’t take time off work to drive an hour and a half one way to get your vaccine – those people are left to fend for themselves,” Schupp said.</p><p>Decisions were made to prioritize vaccines based on population and risk factors, said state Health and Senior Services Director Dr. Randall Williams and Gov. Mike Parson’s deputy chief of staff, Robert Knodell. They say no single group would be happy with their allocation amid the limited initial vaccine supply.</p><hr><p>未完待续…（这篇新闻也太长了…）</p><blockquote><p>Note: This article is excerpted from The New York Times. The link to the original article is <a href="https://www.usnews.com/news/best-states/articles/2021-03-26/missouris-public-health-defunding-led-to-vaccine-chaos">https://www.usnews.com/news/best-states/articles/2021-03-26/missouris-public-health-defunding-led-to-vaccine-chaos</a></p></blockquote><hr><h2 id="Vocabulary"><a href="#Vocabulary" class="headerlink" title="Vocabulary"></a>Vocabulary</h2><table><thead><tr><th align="center">单词</th><th align="center">词义</th></tr></thead><tbody><tr><td align="center">snub</td><td align="center">n&amp;v. 冷落，斥责，抵制</td></tr><tr><td align="center">vaccine</td><td align="center">n. 疫苗；adj. 疫苗的</td></tr><tr><td align="center">equity</td><td align="center">n. 公平，公正</td></tr><tr><td align="center">equitable</td><td align="center">adj. 公平的，公正的</td></tr><tr><td align="center">inequity</td><td align="center">n. 不公平，不公正</td></tr><tr><td align="center">underfund</td><td align="center">v. 对…提供资金不足</td></tr><tr><td align="center">political</td><td align="center">adj. 政治的，党派的</td></tr><tr><td align="center">backlash</td><td align="center">n&amp;v. 反冲，强烈抵制</td></tr><tr><td align="center">destabilized</td><td align="center">adj. 不稳定的；v. 使失去平衡</td></tr><tr><td align="center">rollout</td><td align="center">n. 首次展示</td></tr><tr><td align="center">roll out</td><td align="center">铺开，滚出，推出，实行</td></tr><tr><td align="center">racial</td><td align="center">adj. 种族的，个人的</td></tr><tr><td align="center">force</td><td align="center">n. 力量，武力，军队；v. 促使，推动，强迫</td></tr><tr><td align="center">resident</td><td align="center">n. 居民，房客；adj. 居住的，常驻的</td></tr><tr><td align="center">rural</td><td align="center">adj. 农村的，乡下的，田园的</td></tr><tr><td align="center">rurality</td><td align="center">n. 田园风光</td></tr><tr><td align="center">dose</td><td align="center">n. 剂量，一剂；v. 服药</td></tr><tr><td align="center">distribute</td><td align="center">v. 分配，分开，把…分类</td></tr><tr><td align="center">federal</td><td align="center">adj. 联邦的，同盟的；adv. 联邦政府地</td></tr><tr><td align="center">term</td><td align="center">n. 术语，学期，期限；v. 把…叫做</td></tr><tr><td align="center">waitlist</td><td align="center">n. 等候者名单</td></tr><tr><td align="center">rocky</td><td align="center">adj. （多）岩石的，坚实的，摇晃的，头晕目眩的</td></tr><tr><td align="center">among</td><td align="center">prep. 在…中间，…之一</td></tr><tr><td align="center">nationwide</td><td align="center">adj. 全国性的，全国范围内的；adv. 在全国</td></tr><tr><td align="center">par</td><td align="center">n. 标准，票面价值，平均数量；adj. 标准的，票面的</td></tr><tr><td align="center">rough</td><td align="center">adj. 粗糙的，粗略的；v. 使粗糙，草拟</td></tr><tr><td align="center">additional</td><td align="center">adj. 附加的，额外的</td></tr><tr><td align="center">entire</td><td align="center">adj. 全部的，整个的，全体的</td></tr><tr><td align="center">almost</td><td align="center">adv. 几乎，差不多</td></tr><tr><td align="center">bypass</td><td align="center">n. 旁路，支路；v. 绕过，避开，忽视</td></tr><tr><td align="center">department</td><td align="center">n. 部，部门，系，科，局</td></tr><tr><td align="center">initial</td><td align="center">adj. 最初的，字首的</td></tr><tr><td align="center">outsource</td><td align="center">v. 把…外包</td></tr><tr><td align="center">hospital</td><td align="center">n. 医院</td></tr><tr><td align="center">consultant</td><td align="center">n. 顾问，咨询者，会诊医生</td></tr><tr><td align="center">mass</td><td align="center">n. 块，团，群众，大量；<br />adj. 群众的，大量的，集中的；<br />v. 使聚集，使集合</td></tr><tr><td align="center">workforce</td><td align="center">n. 劳动力，职工总数</td></tr><tr><td align="center">facility</td><td align="center">n. 设施，设备</td></tr><tr><td align="center">site</td><td align="center">n. 地点，位置，场所；v. 设置，为…选址</td></tr><tr><td align="center">qualify</td><td align="center">v. 限定，修饰，使具有资格，证明…合格</td></tr><tr><td align="center">typically</td><td align="center">adv. 代表性地，作为特色地</td></tr><tr><td align="center">vulnerable</td><td align="center">adj. 易受攻击的，易受伤害的</td></tr><tr><td align="center">traditional</td><td align="center">adj. 传统的，惯例的</td></tr><tr><td align="center">divvy</td><td align="center">n&amp;v. 分摊，分配</td></tr><tr><td align="center">allocation</td><td align="center">n. 分配</td></tr><tr><td align="center">since</td><td align="center">prep&amp;adv. 自…以后</td></tr><tr><td align="center">fill</td><td align="center">n&amp;v. 充满，满足</td></tr><tr><td align="center">remain</td><td align="center">n&amp;v. 保留，保持，剩余</td></tr><tr><td align="center">gap</td><td align="center">n. 间隙，缺口，差距，分歧；v. 裂开，分裂</td></tr><tr><td align="center">fall</td><td align="center">n&amp;v. 落下，跌倒，减少</td></tr><tr><td align="center">decade</td><td align="center">n. 十年</td></tr><tr><td align="center">infrastructure</td><td align="center">n. 基础设施，公共建设</td></tr><tr><td align="center">drill</td><td align="center">n. 训练，演习，钻孔机；v. 钻孔，训练</td></tr><tr><td align="center">shelve</td><td align="center">v. 搁置，将…放在一边</td></tr><tr><td align="center">dust</td><td align="center">n. 灰尘；v. 撒，拂去灰尘</td></tr><tr><td align="center">rub</td><td align="center">n&amp;v. 摩擦，惹怒</td></tr><tr><td align="center">hone</td><td align="center">v. （技艺）训练，使…锋利</td></tr><tr><td align="center">scale</td><td align="center">n. 规模，比例；v. 测量，攀登</td></tr><tr><td align="center">staff</td><td align="center">n. 职员，参谋；adj. 职员的；v. 给…配备人员</td></tr><tr><td align="center">pandemic</td><td align="center">adj. （疾病）在全国（全世界）流行的；<br />n. 流行病，瘟疫</td></tr><tr><td align="center">struck</td><td align="center">v. 罢工，打击，撞击；adj. 受罢工影响的</td></tr><tr><td align="center">advocate</td><td align="center">n. 拥护者，辩护者（律师）；v. 提倡，拥护，为…辩护</td></tr><tr><td align="center">efficient</td><td align="center">adj. 有效率的，生效的</td></tr><tr><td align="center">measures</td><td align="center">n. 措施；v. 测量</td></tr><tr><td align="center">consult</td><td align="center">v. 查阅，商量，向…请教</td></tr><tr><td align="center">priority</td><td align="center">n. 优先，优先权</td></tr><tr><td align="center">deputy</td><td align="center">n. 代理人，代表；adj. 副的，代理的</td></tr><tr><td align="center">chief</td><td align="center">n. 首领，酋长，主要部分；<br />adj. 首席的，主要的；<br />adv. 首要地，主要地</td></tr><tr><td align="center">amid</td><td align="center">prep. 在…过程中</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Accumulation_Of_Reading </category>
          
          <category> New_York_Times </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New_York_Times </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WHO：COVID19 Origin Report ‘Roughly Now Finalized’</title>
      <link href="ed985442a002/"/>
      <url>ed985442a002/</url>
      
        <content type="html"><![CDATA[<h2 id="WHO-COVID-19-Origin-Report-‘Roughly-Now-Finalized’"><a href="#WHO-COVID-19-Origin-Report-‘Roughly-Now-Finalized’" class="headerlink" title="WHO: COVID-19 Origin Report ‘Roughly Now Finalized’"></a>WHO: COVID-19 Origin Report ‘Roughly Now Finalized’</h2><blockquote><p>The head of the international team behind an investigation into the origin of the virus said the highly anticipated report should be made public in the next few days.</p></blockquote><p><img src="https://www.usnews.com/dims4/USNEWS/2ff394a/2147483647/thumbnail/640x420/quality/85/?url=http://media.beam.usnews.com/e8/30/dafe4e4f46f2823944d891950bdd/210326-editorial.jpg" class="lazyload" data-srcset="https://www.usnews.com/dims4/USNEWS/2ff394a/2147483647/thumbnail/640x420/quality/85/?url=http://media.beam.usnews.com/e8/30/dafe4e4f46f2823944d891950bdd/210326-editorial.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="WUHAN, Feb. 9, 2021 -- Peter Ben Embarek, a member of the WHO-China joint study team, answers questions at the WHO-China joint study press conference in Wuhan, central China&#39;s Hubei Province, Feb. 9, 2021. (Photo by Cheng Min/Xinhua via Getty) (Xinhua/Cheng Min via Getty Images) "></p><p>A WORLD HEALTH Organization official who is leading the international team behind an investigation into the origin of the coronavirus said Friday that the group’s full report will be issued in the coming days.</p><p>“You probably heard me say in the past that we were very close to finalizing the report, and I’m the first one to regret it’s not yet out,” WHO expert Peter Ben Embarek said during a press conference. “But it’s roughly now finalized.”</p><p>Team members discussed some of their findings in February – including that it is “extremely unlikely” that the coronavirus originated in a lab – but the details of the report are highly anticipated.</p><p>“The content is now complete, and, frankly speaking, I expect that in the next few days that whole process will be completed, and we’ll be able to release it publicly,” Embarek said.</p><p>“It’s a very slow and complicated process to get it there,” he added, noting work happening across several time zones and in both Chinese in English languages.</p><p>White House press secretary Jen Psaki said on Friday that the Biden administration will examine the data behind the report before determining how to proceed. A State Department spokesman said in February that the U.S. would welcome WHO’s findings in an official report but that it will use the U.S. intelligence community to “reach our own conclusions.”</p><p>Former Director of the Centers for Disease Control and Prevention Robert Redfield recently <a href="https://www.cnn.com/2021/03/26/health/covid-war-doctors-sanjay-gupta/index.html">told CNN</a> that he believes the virus originated in a Chinese lab.</p><p>Leading infectious disease expert Anthony Fauci on Friday said that Redfield’s comments were just his opinion, noting that “there are other alternatives, others that most people hold by.”</p><blockquote><p>Note: This article is excerpted from The New York Times. The link to the original article is <code>https://www.usnews.com/news/health-news/articles/2021-03-26/who-coronavirus-origin-report-roughly-now-finalized</code></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Accumulation_Of_Reading </category>
          
          <category> New_York_Times </category>
          
      </categories>
      
      
        <tags>
            
            <tag> New_York_Times </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（一）：绪论</title>
      <link href="60568f9b024a/"/>
      <url>60568f9b024a/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h2><h3 id="数据结构的定义"><a href="#数据结构的定义" class="headerlink" title="数据结构的定义"></a>数据结构的定义</h3><ol><li>寻求数学模型的实质是分析问题，从中提取操作的对象，并找出这些操作对象之间的关系，然后用数学语言加以描述。有些问题的数据模型可以用具体的数学方程等来表示，但是更多的实际问题是无法用数学方程来表示的，这就需要从数据入手来分析并得到解决问题的方法。</li><li>数据是描述客观事物的数和字符的集合。</li><li>数据元素：数据元素是数据的基本单位（例如，某个班的基本信息表中，一个学生就是一个数据元素）。<ul><li>有时，数据元素也称为元素、结点、顶点或者记录等。</li><li>一个数据元素也可以由若干个数据项组成。</li></ul></li><li>数据项：数据项是具有独立含义的数据最小单位，也成为字段或者域（例如，某个班的基本信息表中，每一个数据元素，即每一个学生记录，都由学号、姓名等数据项构成）。</li><li>数据对象：数据对象是指性质相同的数据元素的集合，它是数据的一个子集。<ul><li>在平时的交流中，所提及的数据通常是指数据对象。</li></ul></li><li>数据结构：数据结构是指所有数据元素以及数据元素之间的关系。<ul><li>可以看做是相互之间存在着某种特定关系的数据元素的集合。我们常把数据结构看做是带结构的数据元素的集合。</li><li>数据结构通常包括：<ul><li>数据的逻辑结构：这是由数据元素之间的逻辑关系构成。</li><li>数据的存储结构：这是数据元素及其关系在计算机存储器中的存储表示，也成为数据的物理结构。</li><li>数据的运算：即施加在该数据上的操作。</li></ul></li></ul></li></ol><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中得出的。</p><ol><li><p>逻辑结构的表示：逻辑结构有很多中表示方式，常见的有图表和二元组等。</p><ul><li><p>图像表示：采用表格或者图形直接描述数据的逻辑关系。</p><ul><li>每个结点对应着一个数据元素。</li><li>两结点之间带箭头的连线表示它们之间的相邻关系。</li></ul></li><li><p>二元组表示：二元组是一种通用的数据逻辑结构表示方式，一个二元组的表示例如：<code>B = (D, R)</code></p><ul><li><p><code>B = (D, R)</code> 中，D表示数据元素的集合，R 表示 D 上的二元关系的集合，即：–</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D &#x3D; &#123;d_i | 1≤i≤n,n≥0&#125;</span><br><span class="line"></span><br><span class="line"># d_i 表示 D 中第 i 个数据元素，n 为 D 中数据元素的个数。</span><br><span class="line"></span><br><span class="line"># 若 n&#x3D;0，则 D 是一个空集，表示 B 无结构或者认为具有任意结构</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">R &#x3D; &#123;r_j | 1≤j≤m,m≥0&#125;</span><br><span class="line"></span><br><span class="line"># r_j 表示 R 中第 j 个关系，m 为 R 中关系的个数。</span><br><span class="line"></span><br><span class="line"># 若 m&#x3D;0，则 R 是一个空集，表示 D 中的元素间不存在任何逻辑关系，等同于数学中的集合</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next.js入门详解教程</title>
      <link href="3e56fbdb64fa/"/>
      <url>3e56fbdb64fa/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>初识 Next.js，请查看它的官网介绍：<ul><li><a href="https://nextjs.org/">Next.js 官网</a></li><li><a href="https://www.nextjs.cn/">Next.js 中文网</a></li></ul></li><li>好吧，官网的话总是那么拗口，若对此感兴趣，请读者移步知乎：<a href="https://www.zhihu.com/search?type=content&q=nextjs">对 Next.js 的评价</a></li><li>另外附上两个你可能会用到的链接：<ul><li>Github 地址：<a href="https://github.com/zeit/next.js">Github - next.js</a></li><li>社区：<a href="https://spectrum.chat/next-js">Spectrum</a></li></ul></li></ol><hr><h2 id="初识Next-js"><a href="#初识Next-js" class="headerlink" title="初识Next.js"></a>初识Next.js</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>Next.js 支持 Windows、Mac 和 Linux系统，均可安装，但是前提是你已经安装了 Node.js</li><li>创建示例项目的过程如下： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> hello-next</span><br><span class="line"><span class="built_in">cd</span> hello-next</span><br><span class="line">npm init -y</span><br><span class="line">npm install --save react react-dom next</span><br><span class="line"><span class="built_in">mkdir</span> pages</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li>打开 <code>hello-next/package.json</code>，替换 <code>scripts</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;dev&quot;</span>: <span class="string">&quot;next&quot;</span>,</span><br><span class="line"><span class="string">&quot;build&quot;</span>: <span class="string">&quot;next build&quot;</span>,</span><br><span class="line"><span class="string">&quot;start&quot;</span>: <span class="string">&quot;next start&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>启动 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure> 在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000</a>,你会看到页面显示 <strong>404 | This page could not be found</strong>.</li><li>创建你的第一个页面<ul><li>创建 <code>pages/index.js</code>，并输入：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Index = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello Next.js&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure></li><li>再次输入 <code>npm run dev</code>，就能看到效果了</li><li>上述案例中，我们在 <code>pages/index.js</code> 模块中默认（default）导出了一个简单的 React 组件</li></ul></li><li>试错<ul><li>尝试着错一次：将 <code>pages/index.js</code> 改为：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Index = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello Next.js</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure></li><li>重新启动，浏览器显示：<br>  <img src="https://s2.ax1x.com/2020/02/14/1XeRmQ.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/14/1XeRmQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>一般情况下，Next.js 将跟踪此类错误并在浏览器中显示，这便于我们快速发现错误，而你修改代码并保存后，页面将立即出现对应结果，而不会重新加载整个页面，这是通过 webpack 的 <strong><a href="https://webpack.js.org/concepts/hot-module-replacement/">模块热替换</a></strong> 实现的，Next 默认支持这个功能</li></ul></li></ol><hr><p>2020.3.30</p><h2 id="页面间导航"><a href="#页面间导航" class="headerlink" title="页面间导航"></a>页面间导航</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol><li>我们的应用程序虽然很简单，只有一个页面，但是我们可以添加任意多个页面，例如：<ul><li>创建 <code>pages/about.js</code> 来新建 “About” 页面  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> About = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;About Page&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> About;</span><br></pre></td></tr></table></figure></li><li>修改 <code>pages/index.js</code>：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Index = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;Hello Next.js&lt;/p&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;http://localhost:3000/about&quot;</span>&gt;This is a link to About-Page&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure></li><li>之后我们可以通过 <a href="http://localhost:3000/about">http://localhost:3000/about</a> 来访问该页面</li><li>之后，我们需要连接两个页面，首先想到的是可以用一个 HTML 的 <code>&lt;a /&gt;</code> 标签实现，但是结果就是：浏览器会向服务器请求下一页并刷新当前页面，也就是这样做并不会执行客户端导航</li></ul></li><li>为了支持浏览器端导航，我们需要使用 Next.js 提供的 <code>Link</code> 组件，这个组件是通过 <code>next/link</code> 导出的，接下来我们将使用它</li><li>我们需要准备一个简单的 Next.js 应用课程，请在 <code>hello-next</code> 下输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zeit/next-learn-demo.git</span><br></pre></td></tr></table></figure></li><li>现在我们进入 <code>hello-next/next-learn-demo/1-navigate-between-pages</code> 启动程序： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> next-learn-demo/<span class="number">1</span>-navigate-between-pages</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure><ul><li>打开 <a href="http://localhost:3000/">http://localhost:3000/</a> 访问该程序</li></ul></li></ol><h3 id="使用Link组件"><a href="#使用Link组件" class="headerlink" title="使用Link组件"></a>使用Link组件</h3><blockquote><p>注意，接下来的操作均在 <code>hello-next/next-learn-demo/1-navigate-between-pages</code> 下完成的</p></blockquote><ol><li>在 <code>pages/index.js</code> 中添加： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Hello next.js&lt;/p&gt;</span><br><span class="line">      &lt;Link href=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">        &lt;a&gt;About Page&lt;/a&gt;</span><br><span class="line">      &lt;/Link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在这里，我们将 <code>next/link</code> 导入为 <code>Link</code>，并按照如下的方式使用：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">  &lt;a&gt;About Page&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure></li><li>访问 3000 端口可查看结果</li></ul></li><li>这次点击链接同样会导航到 “About” 页面，这是客户端导航，操作在浏览器中进行，而不向浏览器发送请求，你可以通过打开浏览器的 <strong>网络请求检查器（network request inspector）</strong> 来验证这一点</li><li>后退按钮：<br> 当你点击链接，再点击后退时，依然会切换到历史记录的上一页，也就是 <code>next/link</code> 为你完成了所有 <code>location.history</code> 的操作</li></ol><h3 id="添加链接道具"><a href="#添加链接道具" class="headerlink" title="添加链接道具"></a>添加链接道具</h3><ol><li>或许你需要在连接中添加属性或道具，比如你需要向链接中添加 <code>title</code> 属性，我们可以这样添加它： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">&lt;a title=<span class="string">&quot;About-Pages&quot;</span>&gt;About Page&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure> 查看元素，可以看到结果如下：<br> <img src="https://s2.ax1x.com/2020/02/14/1XGSVf.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/14/1XGSVf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>切记不可添加到错误的地方去，若写成如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link href=<span class="string">&quot;/about&quot;</span> title=<span class="string">&quot;About-Pages&quot;</span>&gt;</span><br><span class="line">&lt;a&gt;About Page&lt;/a&gt;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure> 则会在控制台中报错：<br> <img src="https://s2.ax1x.com/2020/02/14/1XJPw6.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/14/1XJPw6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>实际上，<code>Link</code> 组件上的标题道具无效，是因为 Link 只是一个包装器组件，只接收 <code>href</code> 和一些类似的道具。如果需要向其添加道具，则需要将道具添加到其子项，这种情况下，<code>Link</code> 组件的子代是锚标记</li></ol><hr><h2 id="使用共享组件"><a href="#使用共享组件" class="headerlink" title="使用共享组件"></a>使用共享组件</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><ol><li>我们可以通过导出 React 组件并将该组件放在 <code>pages</code> 目录中来创建页面，每个页面的 URL 都是基于文件名的，由于导出的页面是 JavaScript 模块，因此我们也可以将其他 JavaScript 组件导入其中</li><li>我们将创建一个公共的 Header 组件并将其用于多个页面，最后我们将研究实现 Layout 组件，并了解它如何帮我们定义多个页面的外观</li></ol><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><ol><li>我们之前已经安装过了 <code>next-learn-demo</code>，这里直接使用：<ul><li>进入 <code>hello-next/next-learn-demo/2-using-shared-components</code>，之后我们的操作也会在此目录下</li></ul></li><li>运行： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建标题组件"><a href="#创建标题组件" class="headerlink" title="创建标题组件"></a>创建标题组件</h3><ol><li>下面创建一个 Header 组件，创建 <code>2-using-shared-components/components/Header.js</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> linkStyle = &#123;</span><br><span class="line">  marginRight: <span class="number">15</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Header = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/&quot;</span>&gt;</span><br><span class="line">      &lt;a style=&#123;marginRight&#125;&gt;Home&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/about&quot;</span>&gt;</span><br><span class="line">      &lt;a style=&#123;marginRight&#125;&gt;About&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure></li><li>现在，导入 Header 组件并在页面中使用它：<ul><li>将 <code>index.js</code> 修改为：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;../components/Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;Header /&gt;</span><br><span class="line">  &lt;p&gt;Hello Next.js&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>将 <code>about.js</code> 修改为：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;../components/Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;p&gt;This is the About Page&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>启动之后可以查看结果</li></ul></li><li>试错：现在将 <code>components</code> 目录改名为 <code>comps</code>，报错如下：<br> <img src="https://s2.ax1x.com/2020/02/14/1jmeGq.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/14/1jmeGq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><ul><li>我们不需要将我们的组件放在一个特殊的目录里，也就是说，该组件目录名称可以取为任何，实际上，唯一特殊的目录是 <code>/pages</code> 和 <code>/public</code>，你甚至可以在 <code>/pages</code> 里面创建组件.</li></ul></li></ol><h3 id="布局组件"><a href="#布局组件" class="headerlink" title="布局组件"></a>布局组件</h3><blockquote><p>本节依然是在 <code>2-using-shared-components/</code> 下完成的</p></blockquote><ol><li>我们将创建 Layout 组件，以实现各页面上的通用样式，在 <code>components/MyLayout.js</code> 中输入： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layoutStyle = &#123;</span><br><span class="line">  margin: <span class="number">20</span>,</span><br><span class="line">  padding: <span class="number">20</span>,</span><br><span class="line">  border: <span class="string">&#x27;1px solid #DDD&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layout = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div style=&#123;layoutStyle&#125;&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &#123;props.children&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Layout;</span><br></pre></td></tr></table></figure></li><li>完成操作后，我们可以在页面中使用以下布局：<ul><li>在 <code>pages/index.js</code> 中输入：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;p&gt;Hello Next.js&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在 <code>pages/about.js</code> 中输入：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;p&gt;This is the about page&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>启动，查看样式</li></ul></li><li>试错：将 <code>MyLayout.js</code> 中的 <code>&#123;props.children&#125;</code> 删除，再启动，观察结果：<ul><li>页面上只保留了 <code>Header</code> 的内容，其他的均消失了</li></ul></li></ol><h3 id="渲染子组件"><a href="#渲染子组件" class="headerlink" title="渲染子组件"></a>渲染子组件</h3><ol><li>前一个试错中，我们删除了 <code>&#123;props.children&#125;</code>，则 <code>Layout</code> 无法呈现我们放入 <code>Layout</code> 元素内的内容，如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;p&gt;This is the about page&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 但这只是创建布局组件的一种方法，以下是其他方法。</li><li>方法一：布局为高阶组件 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/MyLayout.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layoutStyle = &#123;</span><br><span class="line">  margin: <span class="number">20</span>,</span><br><span class="line">  padding: <span class="number">20</span>,</span><br><span class="line">  border: <span class="string">&#x27;1px solid #DDD&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> withLayout = <span class="function"><span class="params">Page</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> (</span><br><span class="line">    &lt;div style=&#123;layoutStyle&#125;&gt;</span><br><span class="line">      &lt;Header /&gt;</span><br><span class="line">      &lt;Page /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLayout;</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> withLayout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello Next.js<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLayout(Page);</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/about.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> withLayout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function">() =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is the about page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withLayout(Page);</span><br></pre></td></tr></table></figure></li><li>方法二：页面内容作为道具 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// components/MyLayout.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">&#x27;./Header&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> layoutStyle = &#123;</span><br><span class="line">  margin: <span class="number">20</span>,</span><br><span class="line">  padding: <span class="number">20</span>,</span><br><span class="line">  border: <span class="string">&#x27;1px solid #DDD&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Layout = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div style=&#123;layoutStyle&#125;&gt;</span><br><span class="line">    &lt;Header /&gt;</span><br><span class="line">    &#123;props.content&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Layout;</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> indexPageContent = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello Next.js<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Index</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">content</span>=<span class="string">&#123;indexPageContent&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/about.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aboutPageContent = <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is the about page<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">About</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> <span class="attr">content</span>=<span class="string">&#123;aboutPageContent&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="创建动态页面"><a href="#创建动态页面" class="headerlink" title="创建动态页面"></a>创建动态页面</h2><h3 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h3><ol><li>之前通过使用组件，我们创建了包含了多个页面的小案例，之前为了创建一个页面，我们必须新建一个文件作为模块导出，但是在一个真正的应用程序中，我们还需动态地创建页面以显示动态内容，接下来我们会使用 <strong>查询字符串</strong> 来实现这一点</li><li>我们将创建一个简单的博客应用，它在主页上展示一个所有文章的列表，展示如下：<ul><li>主页有文章列表<br><img src="https://s2.ax1x.com/2020/02/16/3pmcK1.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/16/3pmcK1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>点击某标题的链接，会出现对应的文章<br><img src="https://s2.ax1x.com/2020/02/16/3pnPrq.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/16/3pnPrq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li></ol><h3 id="安装设置"><a href="#安装设置" class="headerlink" title="安装设置"></a>安装设置</h3><ol><li>我们仍然使用之前安装过的 <code>next-learn-demo</code>，进入 <code>next-learn-demo/3-create-dynamic-pages</code>，接下来的一切也将在这个目录下完成</li><li>运行 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li></ol><h3 id="添加文章列表"><a href="#添加文章列表" class="headerlink" title="添加文章列表"></a>添加文章列表</h3><ol><li>首先，我们在文章主页添加标题列表，如下： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PostLink = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=&#123;<span class="string">`/post?title=<span class="subst">$&#123;props.title&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;props.title&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;My Blog&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;PostLink title=<span class="string">&quot;Hello Next.js&quot;</span> /&gt;</span><br><span class="line">        &lt;PostLink title=<span class="string">&quot;Learn Next.js is awesome&quot;</span> /&gt;</span><br><span class="line">        &lt;PostLink title=<span class="string">&quot;Deploy apps with Zeit&quot;</span> /&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过查询字符串传递数据"><a href="#通过查询字符串传递数据" class="headerlink" title="通过查询字符串传递数据"></a>通过查询字符串传递数据</h3></li><li>我们将通过查询字符串作为参数（也称查询参数）并传递数据，如： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PostLink = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=&#123;<span class="string">`/post?title=<span class="subst">$&#123;props.title&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;props.title&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>此例中，查询参数是 <code>title</code>，我们使用 <code>PostLink</code> 来执行的操作</li><li>你也可以检查 <code>Link</code> 组件的 <code>href</code> 属性，以此类推，你可以使用查询字符串传递任何类型的数据</li></ul></li></ol><h3 id="创建Post页面"><a href="#创建Post页面" class="headerlink" title="创建Post页面"></a>创建<code>Post</code>页面</h3><ol><li>现在我们需要创建 post 页面来显示博客文章，为此，我们需要从查询字符串中获得标题，</li><li>创建 <code>pages/post.js</code> 文件： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This is the blog post content.&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page;</span><br></pre></td></tr></table></figure><ul><li>启动项目，并点击三个标题链接</li></ul></li><li>上面的运作过程如下：<ul><li>首先从 <code>next/router</code> 导入并使用 <code>useRouter</code> 函数，该函数返回 Next.js 的是 <code>router</code> 对象</li><li>使用路由器（router）中的 <code>query</code> 对象，该对象保存了所有查询参数</li><li>然后，使用 <code>router.query.title</code> 获取标题</li></ul></li><li>useRouter 函数的介绍：<ul><li><a href="https://www.nextjs.cn/docs/api-reference/next/router#userouter">useRouter</a> 允许你访问页面中的 router 对象，它是一个 <a href="https://reactjs.org/docs/hooks-intro.html">React Hook</a>，能与功能组件协同合工作</li><li>之前的示例中，useRouter 函数被放到预添加的页面组件中，而下面示例中，useRouter 函数在 <code>Content</code> 组件中，预添加的组件是 <code>Page</code>，但是功能不变  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Content = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;h1&gt;&#123;router.query.title&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This is the blog post content.&lt;/p&gt;</span><br><span class="line">    &lt;/&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Page = <span class="function">() =&gt;</span> (</span><br><span class="line">  &lt;Layout&gt;</span><br><span class="line">    &lt;Content /&gt;</span><br><span class="line">  &lt;/Layout&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Page;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="使用动态路由清理URL"><a href="#使用动态路由清理URL" class="headerlink" title="使用动态路由清理URL"></a>使用动态路由清理URL</h2><h3 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>请确保你正在使用是 Next.js 9 或更高版本<br>接下来的操作都会在 <code>next-learn-demo/4-clean-urls</code> 中进行，请调至指定目录</p></blockquote><ol><li>我们已经知道了如何使用查询字符串创建动态页面，指向我们的某个博客文章的链接如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http：&#x2F;&#x2F; localhost：3000 &#x2F; post？title &#x3D; Hello％20Next.js</span><br></pre></td></tr></table></figure> 而此链接要表达的却是： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http：&#x2F;&#x2F; localhost：3000 &#x2F; p &#x2F; hello-nextjs</span><br></pre></td></tr></table></figure></li></ol><h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><ol><li>启动项目，在 <code>4-clean-urls/</code> 下输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li><li>我们将使用 Next.js 的 <a href="https://nextjs.org/docs/routing/dynamic-routes">动态路由</a> 功能，它允许你处理 <code>/pages</code> 动态路由</li><li>现在我们将创建新页面，并命名为 <code>pages/p/[id].js</code>，这也是我们创建的第一个动态路由，步骤如下：<ul><li>首先，在 <code>/pages</code> 内添加文件夹 <code>/p</code></li><li>然后，你需要在 <code>/p</code> 文件夹中创建 <code>[id].js</code>，并在这些 js 文件中添加如下内容：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Post</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;p&gt;This is the blog post content.&lt;/p&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li>前一页是特殊的，它不会处理 <code>/about</code> 等静态路由，而是会处理 <code>p/</code> 之后的路由，例如，此页面将处理 <code>/p/hello-next.js</code>，而 <code>/p/post-1/another</code></li><li>页面名称中的带有方括号（<code>[]</code>）使其成为动态路由，你不能使页面名称的一部分成为动态名称，而只能使全名成为动态名称，例如，支持 <code>/pages/p/[id].js</code>，但不支持 <code>/pages/p/post-[id].js</code></li><li>创建动态路线时，我们在方括号（[]）之间添加了 id，这是页面接受到查询参数的名称，因此对于 <code>/p/hello-nextjs</code>，该 <code>query</code> 对象将具有 <code>&#123; id: &#39;hello-nextjs&#39; &#125;</code>，我们可以使用 <a href="https://nextjs.org/docs/api-reference/next/router#userouter">useRouter()</a> 进行访问</li><li>现在，我们新的动态路由添加多个链接，修改 <code>pages/index.js</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PostLink = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;props.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;props.id&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;My Blog&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &lt;PostLink id=<span class="string">&quot;Hello-Next.js&quot;</span> /&gt;</span><br><span class="line">        &lt;PostLink id=<span class="string">&quot;Learn-Next.js&quot;</span> /&gt;</span><br><span class="line">        &lt;PostLink id=<span class="string">&quot;Deploy-Next.js&quot;</span> /&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>着重看看以下内容：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PostLink = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;props.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;props.id&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>在 <code>&lt;Link&gt;</code> 元素中，<code>href</code> 代表的是该页面在 <code>pages</code> 文件夹中的路径，而 <code>as</code> 代表的是该页面在浏览器中的 URL 路径</li></ul></li><li>现在，你可以重新启动项目，注意观察 URL 的变化！<br>  <img src="https://s2.ax1x.com/2020/02/17/3CmhPU.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/17/3CmhPU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>动态路由可以很好地和浏览器历史记录配合使用，而我们要做的就是将 <code>as</code> 添加到链接组件中</li></ol><hr><h2 id="为页面获取数据"><a href="#为页面获取数据" class="headerlink" title="为页面获取数据"></a>为页面获取数据</h2><h3 id="Introduction-4"><a href="#Introduction-4" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>接下来的操作都会在 <code>next-learn-demo/6-fetching-data</code> 中进行，请调至指定目录</p></blockquote><ol><li>现在我们已经能创建一个相对完整的 Next.js 应用，但还没有解决的是：<strong>如何从远程数据源中获取数据？</strong>，Next.js 提供了一个标准 API 来获取页面所需的数据，即 <strong><code>getInitialProps 异步函数</code></strong></li><li><code>getInitialProps</code> 只能添加到页面导出的默认组件中，在其他组件中是不会起作用的，它可以从远程数据源为指定页面获取数据，并将这些数据通过 props 传递到我们的页面，它会同时在客户端和服务器上工作，因为它在两个环境中都会被调用</li><li>我们将利用 <code>getInitialProps</code> 构建一个应用程序来显示有关 Batman TV Shows 的信息，利用的是公开的 <a href="https://www.tvmaze.com/api">TVmaze API</a></li><li>在即将演示的示例中，我们的主页上有一个文章列表，现在我们来展示 <code>Batman TV shows</code> 的节目列表，我们将从远程服务器上获取这些节目列表，而不是硬编码<ul><li>在这个示例中，我们使用的是 <a href="https://www.tvmaze.com/api">TVMaze API</a> 来获取 TV shows 节目列表，这是一个搜索电视节目的 API</li></ul></li></ol><h3 id="安装设置-1"><a href="#安装设置-1" class="headerlink" title="安装设置"></a>安装设置</h3><ol><li>进入 <code>next-learn-demo/6-fetching-data</code>，输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li><li>在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000/</a> 查看项目</li></ol><h3 id="获取BatmanShows的数据"><a href="#获取BatmanShows的数据" class="headerlink" title="获取BatmanShows的数据"></a>获取BatmanShows的数据</h3><ol><li>首先，我们需要安装 <a href="https://github.com/developit/unfetch">isomorphic-unfetch</a>，这是我们用来获取数据的工具库，这是浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">fetch API</a> 的一个简单实现，但在客户端和服务器环境中都可以使用 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save isomorphic-unfetch</span><br></pre></td></tr></table></figure></li><li>将 <code>pages/index.js</code> 替换为以下内容： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;isomorphic-unfetch&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;Layout&gt;</span><br><span class="line">    &lt;h1&gt;Batman TV Shows&lt;/h1&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;</span><br><span class="line">        props.shows.map(<span class="function"><span class="params">show</span> =&gt;</span> (</span><br><span class="line">          &lt;li key=&#123;show.id&#125;&gt;</span><br><span class="line">            &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;show.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">              &lt;a&gt;&#123;show.name&#125;&lt;/a&gt;</span><br><span class="line">            &lt;/Link&gt;</span><br><span class="line">          &lt;/li&gt;</span><br><span class="line">        ))</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/Layout&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Index.getInitialProps = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Show data fetched. Count: <span class="subst">$&#123;data.length&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    shows: data.map(<span class="function"><span class="params">entry</span> =&gt;</span> entry.show)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Index;</span><br></pre></td></tr></table></figure></li><li>我们着重分析下面这部分： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Index.getInitialProps = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://api.tvmaze.com/search/shows?q=batman&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Show data fetched. Count: <span class="subst">$&#123;data.length&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    shows: data.map(<span class="function"><span class="params">entry</span> =&gt;</span> entry.show)</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>这是一个静态异步函数，可以添加到程序的任何页面中，使用此函数，我们就可以获取数据并作为 props 传递给我们的页面</li><li>以下便是我们的抓取结果，数据被抓取后，将会作为 props 的 ‘show’ 属性传递我们的页面中<br>  <img src="https://s2.ax1x.com/2020/02/17/3PEsaT.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/17/3PEsaT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>注意，我们之前有一行用于打印信息的代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Show data fetched. Count: <span class="subst">$&#123;data.length&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><ul><li>那么到底是在服务器端输出呢，还是在浏览器端的控制台输出呢，现在刷新一下浏览器，会发现之后服务端的控制台显示<br>  <img src="https://s2.ax1x.com/2020/02/17/3PeiKs.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/17/3PeiKs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>在这种情况下，消息只会在服务端输出，因为我们的页面是在服务端绘制的，所以，我们在服务端已经有了数据，没有必要在客户端再次获取这些数据</li></ul></li></ol><h3 id="实现-Post-页面"><a href="#实现-Post-页面" class="headerlink" title="实现 Post 页面"></a>实现 Post 页面</h3><ol><li>现在让我们把 TV show 的详细信息添加到 post 中：将 <code>pages/p/[id].js</code> 替换为以下内容： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/p/[id].js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../../components/MyLayout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fetch <span class="keyword">from</span> <span class="string">&#x27;isomorphic-unfetch&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Post = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;Layout&gt;</span><br><span class="line">    &lt;h1&gt;&#123;props.show.name&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;&#123; props.show.summary.replace(<span class="regexp">/&lt;[/]?[pb]&gt;/g</span>), <span class="string">&#x27;&#x27;</span> &#125;&lt;/p&gt;</span><br><span class="line">  &lt;/Layout&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">Post.getInitialProps = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = context.query;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`https://api.tvmaze.com/shows/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> show = <span class="keyword">await</span> res.json();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Fetched show: <span class="subst">$&#123;show.name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; show &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Post;</span><br></pre></td></tr></table></figure><ul><li>注意该页的 <code>getInitialProps</code>：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Post.getInitialProps = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; id &#125; = context.query;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">`https://api.tvmaze.com/shows/<span class="subst">$&#123;id&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> show = <span class="keyword">await</span> res.json();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Fetched show: <span class="subst">$&#123;show.name&#125;</span>`</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; show &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>该函数的第一个参数是 <strong>context 对象</strong>，此对象包含一个 <code>query</code> 对象，我们用 <code>context.query</code> 来获取信息，即 <code>id</code> 对象，并使其在 TVMaze API 中获取电视节目数据</li></ul></li><li>在这个 <code>getInitialProps</code> 函数中，我们添加了一个 <code>console.log</code> 来打印节目的标题，现在我们看看它将打印到哪里<ul><li>打开服务器和客户端的控制台，然后启动项目，访问 3000 端口</li><li>单击第一个 Batman show 的标题</li></ul></li><li>结果是：会在客户端的控制台输出<br> <img src="https://s2.ax1x.com/2020/02/17/3PM0ER.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/17/3PM0ER.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><ul><li>与之前不同的是，我们这次只能在客户端看到消息，这是因为我们通过客户端导航到了 post 页面</li><li>当我们单击链接时，由于该链接是被 Next.js 的 <code>&lt;Link&gt;</code> 组件包装过的组件，所以页面转换将在浏览器中进行，而不会想服务器发起请求</li><li>但是，如果你直接访问的是 post 页面，而不是点击链接（例如，你直接访问 <a href="http://localhost:3000/p/975">http://localhost:3000/p/975</a> ），消息会被打印在服务端，而不是客户端</li></ul></li></ol><hr><h2 id="为组件添加样式"><a href="#为组件添加样式" class="headerlink" title="为组件添加样式"></a>为组件添加样式</h2><h3 id="Introduction-5"><a href="#Introduction-5" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>接下来的操作都会在 <code>next-learn-demo/7-styling-components</code> 中进行，请调至指定目录</p></blockquote><ol><li>对于 React，我们可以使用许多不同的技术来设置样式，这些技术可以分为两大类：<ul><li>传统的基于 CSS 文件的样式设计（包括 SASS、PostCSS 等）</li><li><a href="https://github.com/MicheleBertoli/css-in-js">CSS in JS</a></li></ul></li><li>传统的基于 CSS 文件的样式设计（尤其是 SSR）需要考虑一堆的实际问题，因此我们在为 Mext.js 设置样式时避免使用这种方法，相反，我们会在 JS 中使用 CSS，你可以使用它来设置某单个组件的样式，而不是导入 CSS 文件</li><li>为此，我们需要认识一个新的框架：<a href="https://github.com/zeit/styled-jsx">styled-jsx</a>，这是Next.js 预装了一个 CSS in JS 框架，它允许你为组件编写熟悉的 CSS 规则，这些 CSS 规则对组件以外的任何内容（当然也包括子组件）都没有影响，也就是说，你的 CSS 规则是有作用域的</li></ol><h3 id="安装设置-2"><a href="#安装设置-2" class="headerlink" title="安装设置"></a>安装设置</h3><ol><li>进入 <code>next-learn-demo/7-styling-components</code></li><li>输入 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li><li>启动项目，访问应用</li></ol><h3 id="设置主页的样式"><a href="#设置主页的样式" class="headerlink" title="设置主页的样式"></a>设置主页的样式</h3><ol><li>现在我们在主页中添加一些样式，进入 <code>pages/index.js</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pages/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;hello-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Hello Next.js&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;learn-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Learn Next.js is awesome&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;deploy-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Deploy apps with ZEIT&#x27;</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Lauout&gt;</span><br><span class="line">      &lt;h1&gt;My Blog&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          getPosts().map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;post.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">                &lt;a&gt;&#123;post.title&#125;&lt;/a&gt;</span><br><span class="line">              &lt;/Link&gt;</span><br><span class="line">            &lt;/li&gt;</span><br><span class="line">          ))</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">        h1, a &#123;</span></span><br><span class="line"><span class="string">          font-family: &#x27;Arial&#x27;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        ul &#123;</span></span><br><span class="line"><span class="string">          padding: 0</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        li &#123;</span></span><br><span class="line"><span class="string">          list-style: none;</span></span><br><span class="line"><span class="string">          margin: 5px, 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        a &#123;</span></span><br><span class="line"><span class="string">          text-decoration: none;</span></span><br><span class="line"><span class="string">          color: red;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        a:hover &#123;</span></span><br><span class="line"><span class="string">          opacity: 0.6;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      `</span>&#125;&lt;/style&gt;</span><br><span class="line">    &lt;/Lauout&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>那个 <code>&lt;style jsx&gt;</code> 元素，就是我们编写 CSS 规则的地方</li><li>现在可以启动项目，查看结果<br>  <img src="https://s2.ax1x.com/2020/02/17/3ik94e.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/17/3ik94e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>上面的代码中，我们没有直接在 <code>&lt;style&gt;</code> 标签内编写样式代码，而是写在模板字符串（<code>&#123;``&#125;</code>）里面的，Next.js 默认支持 babel 语法，而 <code>styled-jsx</code> 可以看做 babel 的一个插件，它将解析所有 CSS 并将其应用于构建工程</li></ol><h3 id="CSS样式和嵌套组件"><a href="#CSS样式和嵌套组件" class="headerlink" title="CSS样式和嵌套组件"></a>CSS样式和嵌套组件</h3><ol><li>现在我们将会对主页做一些更改，我们将会像这样隔离 Link 组件： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../components/MyLayout&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Link <span class="keyword">from</span> <span class="string">&#x27;next/link&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosts</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;hello-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Hello Next.js&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;learn-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Learn Next.js is awesome&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">id</span>: <span class="string">&#x27;deploy-nextjs&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Deploy apps with ZEIT&#x27;</span> &#125;</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PostLink = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;post.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;post.title&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Blog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;My Blog&lt;/h1&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">        &#123;getPosts().map(<span class="function"><span class="params">post</span> =&gt;</span> (</span><br><span class="line">          &lt;PostLink key=&#123;post.id&#125; post=&#123;post&#125; /&gt;</span><br><span class="line">        ))&#125;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line">      &lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">        h1, a &#123;</span></span><br><span class="line"><span class="string">          font-family: &#x27;Arial&#x27;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        ul &#123;</span></span><br><span class="line"><span class="string">          padding: 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        li &#123;</span></span><br><span class="line"><span class="string">          list-style: none;</span></span><br><span class="line"><span class="string">          margin: 5px 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        a &#123;</span></span><br><span class="line"><span class="string">          text-decoration: none;</span></span><br><span class="line"><span class="string">          color: blue;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        a:hover &#123;</span></span><br><span class="line"><span class="string">          opacity: 0.6;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      `</span>&#125;&lt;/style&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行后发现：h1 的样式还在，但是链接已经失效了，如下：<br>  <img src="https://s2.ax1x.com/2020/02/18/3is3bd.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/02/18/3is3bd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>上述结果显示：CSS 样式规则对子组件中的元素没有影响，<code>styled-jsx</code> 这个特性可以帮助你管理大型的应用程序的样式，在这种情况下，我们需要直接设置子组件的样式，在我们的示例中，我们需要对 Link 组件执行以下操作： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PostLink = <span class="function">(<span class="params">&#123; post &#125;</span>) =&gt;</span> (</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;Link href=<span class="string">&quot;/p/[id]&quot;</span> <span class="keyword">as</span>=&#123;<span class="string">`/p/<span class="subst">$&#123;post.id&#125;</span>`</span>&#125;&gt;</span><br><span class="line">      &lt;a&gt;&#123;post.title&#125;&lt;/a&gt;</span><br><span class="line">    &lt;/Link&gt;</span><br><span class="line">    &lt;style jsx&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">      li &#123;</span></span><br><span class="line"><span class="string">        list-style: none;</span></span><br><span class="line"><span class="string">        margin: 5px 0;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      a &#123;</span></span><br><span class="line"><span class="string">        text-decoration: none;</span></span><br><span class="line"><span class="string">        color: blue;</span></span><br><span class="line"><span class="string">        font-family: &#x27;Arial&#x27;;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      a:hover &#123;</span></span><br><span class="line"><span class="string">        opacity: 0.6;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    `</span>&#125;&lt;/style&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>拓展了解：<a href="https://github.com/zeit/styled-jsx#one-off-global-selectors">全局选择器</a></li></ul></li></ol><h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><ol><li>有时我们确实需要更改子组件内部的样式，尤其是在使用支持 React 的 markdown 时<ul><li>我们需要安装 <code>react-markdown</code>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save react-markdown</span><br></pre></td></tr></table></figure></li></ul></li><li>下面就是全局样式派上用场的地方，现在就来试试利用 <code>styled-jsx</code> 添加一些全局样式，打开 <code>pages/p/[id].js</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;next/router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Markdown <span class="keyword">from</span> <span class="string">&#x27;react-markdown&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">&#x27;../../components/MyLayout&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> router = useRouter();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Layout&gt;</span><br><span class="line">      &lt;h1&gt;&#123;router.query.id&#125;&lt;/h1&gt;</span><br><span class="line">      &lt;div className=<span class="string">&quot;markdown&quot;</span>&gt;</span><br><span class="line">        &lt;Markdown</span><br><span class="line">          source=&#123;<span class="string">`</span></span><br><span class="line"><span class="string">This is our blog post.</span></span><br><span class="line"><span class="string">Yes. We can have a [link](/link).</span></span><br><span class="line"><span class="string">And we can have a title as well.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### This is a titlr.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">And here&#x27;s the content.</span></span><br><span class="line"><span class="string">          `</span>&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;style jsx <span class="built_in">global</span>&gt;&#123;<span class="string">`</span></span><br><span class="line"><span class="string">        .markdown &#123;</span></span><br><span class="line"><span class="string">          font-family: &#x27;Arial&#x27;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        .markdown a &#123;</span></span><br><span class="line"><span class="string">          text-decoration: none;</span></span><br><span class="line"><span class="string">          color: red;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        .markdown a:hover &#123;</span></span><br><span class="line"><span class="string">          opacity: 0.6;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        .markdown h3 &#123;</span></span><br><span class="line"><span class="string">          margin: 0;</span></span><br><span class="line"><span class="string">          padding: 0;</span></span><br><span class="line"><span class="string">          text-transform: uppercase;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      `</span>&#125;&lt;/style&gt;</span><br><span class="line">    &lt;/Layout&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意，<strong>markdown 语法部分的缩进不可修改！！！</strong></li><li>我们定义的 style 作用于整个 <code>&lt;div&gt;</code> 标签部分，也就是作用于全局，虽然这样很方便，但是还是建议写带有作用域的样式</li><li>尽管如此，这依然是一个比普通样式标签更好的解决方案，使用 styled-jsx 时，所有必要的特定于浏览器厂商前缀和 CSS 校验都通过了一个 Babel 插件完成了，这并不会导致额外的开销</li></ul></li></ol><hr><h2 id="部署-Next-js-应用程序"><a href="#部署-Next-js-应用程序" class="headerlink" title="部署 Next.js 应用程序"></a>部署 Next.js 应用程序</h2><h3 id="Introduction-6"><a href="#Introduction-6" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p>接下来的操作都会在 <code>next-learn-demo/8-deploying</code> 中进行，请调至指定目录</p></blockquote><ol><li><a href="https://zeit.co/home">ZEIT Now</a> 是将应用程序部署到生产环境的最简单和可扩展的方法，但是，你可以部署 Next.js 应用程序，而且它相对来讲比较简单</li><li>现在我们将部署 Next.js 应用程序</li><li>进入 <code>next-learn-demo/8-deploying</code>，输入命令： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li></ol><h3 id="部署到-ZEIT-Now"><a href="#部署到-ZEIT-Now" class="headerlink" title="部署到 ZEIT Now"></a>部署到 ZEIT Now</h3><ol><li>我们来看一下 <code>package.json</code> 文件的 <code>script</code> 配置段： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">   &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">   &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">   &quot;start&quot;: &quot;next start&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li><li>首先，我们需要为生产环境编译我们的 Next.js 应用程序，它将生成一组优化的用于生产环境的代码： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li>然后，你需要启动 Next.js 应用程序并监听某个端口，此服务器将执行服务器端渲染并返回静态页面（使用上述命令编译） <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run <span class="built_in">start</span></span><br></pre></td></tr></table></figure><ul><li>现在可以查看效果：<a href="http://localhost:3000/">http://localhost:3000</a></li></ul></li></ol><h3 id="运行两个实例"><a href="#运行两个实例" class="headerlink" title="运行两个实例"></a>运行两个实例</h3><ol><li>现在我们将为我们的应用程序启动两个实例，通常这样是为了横向扩展我们的应用程序</li><li>首先，将 <code>package.json</code> 中的 <code>script</code> 配置端替换为以下的内容： <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;dev&quot;: &quot;next&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;next build&quot;,</span><br><span class="line">  &quot;start&quot;: &quot;next start -p %PORT%&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们更改了 <code>start</code> 脚本，它卸载接受一个代表端口号的参数来启动应用程序</li><li>注意，<code>%PORT%</code> 是对于 Windows 来说的，Linux 对应的是 <code>$PORT</code></li></ul></li><li>现在构建我们的应用程序： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li>现在我们需要安装一个新的包，即：<code>cross-env</code>，我们在全局环境下安装： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cross-env -g</span><br></pre></td></tr></table></figure></li><li>同时打开两个终端，分别在终端中输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cross-env PORT=<span class="number">8000</span> npm <span class="built_in">start</span></span><br><span class="line">cross-env PORT=<span class="number">9000</span> npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure><ul><li>在 Linux 上，则直接打开两个命令行终端，并分别在每个命令行终端上运行：  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PORT=<span class="number">8000</span> npm <span class="built_in">start</span></span><br><span class="line">PORT=<span class="number">9000</span> npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li></ul></li><li>现在，在浏览器分别查看：<a href="http://localhost:8000/">http://localhost:8000</a> 和 <a href="http://localhost:9000/">http://localhost:9000</a></li><li>可以得到的结果是，你只需要对应用程序构建一次。然后就可以在任意多个端口上启动它</li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote><p>求进之路，持之谦卑</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux入门Demo：TodoList</title>
      <link href="54fba009696d/"/>
      <url>54fba009696d/</url>
      
        <content type="html"><![CDATA[<h2 id="Demo说明"><a href="#Demo说明" class="headerlink" title="Demo说明"></a>Demo说明</h2><ol><li>本次 Demo 使用了 antd 呈现样式，需要通过 <code>npm install antd --save</code> 安装该组件库</li><li>在使用 Redux 之前，需要安装 redux，可以用 <code>npm install redux --save</code> 安装</li></ol><hr><h2 id="代码以及说明"><a href="#代码以及说明" class="headerlink" title="代码以及说明"></a>代码以及说明</h2><h3 id="需熟记的图"><a href="#需熟记的图" class="headerlink" title="需熟记的图"></a>需熟记的图</h3><p><img src="https://s1.ax1x.com/2020/04/03/GUQpvT.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/04/03/GUQpvT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="结果样式"><a href="#结果样式" class="headerlink" title="结果样式"></a>结果样式</h3><p><img src="https://s1.ax1x.com/2020/04/03/GUuWse.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/04/03/GUuWse.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><ol><li>目录结构 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|-src</span><br><span class="line">  |-index.js</span><br><span class="line">  |-TodoList.js</span><br><span class="line">  |-store</span><br><span class="line">    |-index.js</span><br><span class="line">    |-reducer.js</span><br></pre></td></tr></table></figure></li><li><strong><code>/src/index.js</code></strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//渲染页面</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="comment">//引入TodoList组件</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">&#x27;./TodoList&#x27;</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;TodoList /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><strong><code>/src/TodoList.js</code></strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TodoList组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"><span class="comment">//引入antd样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span></span><br><span class="line"><span class="comment">//按需引入输入框、按钮、列表项样式</span></span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, List &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="comment">//通过store的getState方法获取公共数据</span></span><br><span class="line">    <span class="built_in">this</span>.state = store.getState();</span><br><span class="line">    <span class="built_in">this</span>.handleInputChange = <span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleStoreChange = <span class="built_in">this</span>.handleStoreChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleBtnClick = <span class="built_in">this</span>.handleBtnClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="comment">//只要store发生改变，就立即执行handleStoreChange这个方法</span></span><br><span class="line">    store.subscribe(<span class="built_in">this</span>.handleStoreChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;<span class="attr">marginLeft</span>:<span class="string">&#x27;30px&#x27;</span>, <span class="attr">marginTop</span>:<span class="string">&#x27;10px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Input placeholder=<span class="string">&#x27;TodoList&#x27;</span></span><br><span class="line">                 style=&#123;&#123;<span class="attr">width</span>:<span class="string">&#x27;300px&#x27;</span>, <span class="attr">marginRight</span>:<span class="string">&#x27;10px&#x27;</span>&#125;&#125;</span><br><span class="line">                 value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">                 onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Button type=<span class="string">&#x27;primary&#x27;</span></span><br><span class="line">                  onClick=&#123;<span class="built_in">this</span>.handleBtnClick&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            提交</span><br><span class="line">          &lt;/Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;List bordered</span><br><span class="line">              style=&#123;&#123;<span class="attr">marginTop</span>:<span class="string">&#x27;10px&#x27;</span>, <span class="attr">width</span>:<span class="string">&#x27;500px&#x27;</span>&#125;&#125;</span><br><span class="line">              dataSource=&#123;<span class="built_in">this</span>.state.list&#125;</span><br><span class="line">              renderItem=&#123;</span><br><span class="line">                (item, index) =&gt; (</span><br><span class="line">                  &lt;List.Item onClick=&#123;<span class="built_in">this</span>.handleItemDelete.bind(<span class="built_in">this</span>, index)&#125;&gt;</span><br><span class="line">                    &#123;item&#125;</span><br><span class="line">                  &lt;/List.Item&gt;</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;  <span class="comment">//触发功能：改变输入框值</span></span><br><span class="line">    <span class="keyword">const</span> action = &#123;  <span class="comment">//将此需求用action表达</span></span><br><span class="line">      type: <span class="string">&#x27;CHANGE_INPUT_VALUE&#x27;</span>,  <span class="comment">//type即需求的描述，</span></span><br><span class="line">      value: e.target.value  <span class="comment">//value是要传给sotre的值</span></span><br><span class="line">    &#125;;</span><br><span class="line">    store.dispatch(action);  <span class="comment">//将action传给store，store会自动将action对象的内容传给reducer</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">handleStoreChange</span>(<span class="params"></span>)</span> &#123;  <span class="comment">//得到新的state值</span></span><br><span class="line">    <span class="comment">//用getState方法得到最新的store数据，并通知setState更新</span></span><br><span class="line">    <span class="built_in">this</span>.setState(store.getState())</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">handleBtnClick</span>(<span class="params"></span>)</span> &#123;  <span class="comment">//触发功能：增加列表项</span></span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">&#x27;ADD_LIST&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    store.dispatch(action)  <span class="comment">//传给Store</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">handleItemDelete</span>(<span class="params">index</span>)</span> &#123;  <span class="comment">// 触发功能：删除列表项</span></span><br><span class="line">    <span class="keyword">const</span> action = &#123;</span><br><span class="line">      type: <span class="string">&#x27;DELETE_LIST&#x27;</span>,</span><br><span class="line">      value: index</span><br><span class="line">    &#125;</span><br><span class="line">    store.dispatch(action)  <span class="comment">//传给store</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList;</span><br></pre></td></tr></table></figure></li><li><strong><code>/src/store/index.js</code></strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Store部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从redux中引入createStore方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="comment">//引入Reducer</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;./reducer&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(  <span class="comment">//通过createStore()创建一个公共的数据存储仓</span></span><br><span class="line">  reducer,  <span class="comment">// 将reducer部分传递给store</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure></li><li><strong><code>/src/store/reducer.js</code></strong> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reducer部分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">  inputValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  list: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reducer负责管理整个store中的数据</span></span><br><span class="line"><span class="comment">//reducer里面必须返回一个函数，参数中的state就是整个store仓库里存储的数据</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt;  &#123;  <span class="comment">//state先定为defaultState</span></span><br><span class="line">  <span class="keyword">if</span>(action.type === <span class="string">&#x27;changeInputValue&#x27;</span>) &#123;  <span class="comment">//若需触发改变输入框值的功能</span></span><br><span class="line">    <span class="comment">//深拷贝state</span></span><br><span class="line">    <span class="keyword">const</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));</span><br><span class="line">    <span class="comment">//改变state的输入框值，即是改变渲染的输入框值</span></span><br><span class="line">    newState.inputValue = action.value;</span><br><span class="line">    <span class="comment">//由于reducer不能直接修改传递过来的state，所以通过newState返回修改的结果</span></span><br><span class="line">    <span class="comment">// store会根据newState替换原来的state值</span></span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === <span class="string">&#x27;addTodoItem&#x27;</span>) &#123;  <span class="comment">//若需触发增加列表项的功能</span></span><br><span class="line">    <span class="keyword">const</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));  <span class="comment">//深拷贝state</span></span><br><span class="line">    newState.list.push(newState.inputValue);  <span class="comment">//添加列表项</span></span><br><span class="line">    newState.inputValue = <span class="string">&#x27;&#x27;</span>;  <span class="comment">//清空输入栏</span></span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(action.type === <span class="string">&#x27;DELETE_LIST&#x27;</span>) &#123;  <span class="comment">//若需触发删除列表项的功能</span></span><br><span class="line">    <span class="keyword">const</span> newState = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(state));  <span class="comment">//深拷贝state</span></span><br><span class="line">    newState.list.splice(action.value, <span class="number">1</span>);  <span class="comment">//删除列表项</span></span><br><span class="line">    <span class="keyword">return</span> newState;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>之前写 action 的时候，我们会发现诸多不便，比如 <code>type</code> 很容易写错之类的，不如将 action 部分拆分出来，这会提高代码的质量，步骤如下：</li></ul><ol><li>新建文件：<ul><li><code>/src/store/actionTypes.js</code>：用来单独保存 action 的 <code>type</code></li><li><code>/src/store/actionCreators.js</code>：用来封装 action 的创建</li></ul></li><li>代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/src/store/actionTypes.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE = <span class="string">&#x27;change_input_value&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_LIST = <span class="string">&#x27;add_list&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DELETE_LIST = <span class="string">&#x27;delete_list&#x27;</span>;</span><br></pre></td></tr></table></figure> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/src/store/actionCreators.js</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE, ADD_LIST, DELETE_LIST &#125; <span class="keyword">from</span> <span class="string">&#x27;./actionTypes&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeInputValueAction = <span class="function">(<span class="params">value</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: CHANGE_INPUT_VALUE,</span><br><span class="line">  value</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> addListAction = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  type: ADD_LIST</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> deleteListAction = <span class="function">(<span class="params">index</span>) =&gt;</span> (&#123;</span><br><span class="line">  type: DELETE_LIST,</span><br><span class="line">  index</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>那么，<code>/src/TodoList.js</code> 可以改为： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;antd/dist/antd.css&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Input, Button, List &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="comment">//引入创建的 action</span></span><br><span class="line"><span class="keyword">import</span> &#123; changeInputValueAction, addListAction, deleteListAction &#125; <span class="keyword">from</span> <span class="string">&#x27;./store/actionCreators&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = store.getState();</span><br><span class="line">    <span class="built_in">this</span>.handleInputChange = <span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleBtnClick = <span class="built_in">this</span>.handleBtnClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleStoreChange = <span class="built_in">this</span>.handleStoreChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    store.subscribe(<span class="built_in">this</span>.handleStoreChange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123;<span class="attr">marginLeft</span>:<span class="string">&#x27;30px&#x27;</span>, <span class="attr">marginTop</span>:<span class="string">&#x27;20px&#x27;</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;Input placeholder=<span class="string">&#x27;TodoList&#x27;</span></span><br><span class="line">                 style=&#123;&#123;<span class="attr">width</span>:<span class="string">&#x27;300px&#x27;</span>, <span class="attr">marginRight</span>:<span class="string">&#x27;10px&#x27;</span>&#125;&#125;</span><br><span class="line">                 value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">                 onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">          &lt;Button type=<span class="string">&#x27;primary&#x27;</span></span><br><span class="line">                  onClick=&#123;<span class="built_in">this</span>.handleBtnClick&#125;</span><br><span class="line">          &gt;</span><br><span class="line">            提交</span><br><span class="line">          &lt;/Button&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">        &lt;List bordered</span><br><span class="line">              style=&#123;&#123;<span class="attr">marginTop</span>:<span class="string">&#x27;10px&#x27;</span>, <span class="attr">width</span>:<span class="string">&#x27;500px&#x27;</span>&#125;&#125;</span><br><span class="line">              dataSource=&#123;<span class="built_in">this</span>.state.list&#125;</span><br><span class="line">              renderItem=&#123;</span><br><span class="line">                (item, index) =&gt; (</span><br><span class="line">                  &lt;List.Item onClick=&#123;<span class="built_in">this</span>.handleItemDelete.bind(<span class="built_in">this</span>, index)&#125;&gt;</span><br><span class="line">                    &#123;item&#125;</span><br><span class="line">                  &lt;/List.Item&gt;</span><br><span class="line">                )</span><br><span class="line">              &#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//直接使用 changeInputValueAction，并传入参数 e.target.value</span></span><br><span class="line">    <span class="keyword">const</span> action = changeInputValueAction(e.target.value);</span><br><span class="line">    store.dispatch(action);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleBtnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//直接使用 addListAction 这个 action</span></span><br><span class="line">    <span class="keyword">const</span> action = addListAction();</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleStoreChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(store.getState())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleItemDelete</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//直接使用 deleteListAction 这个 action</span></span><br><span class="line">    <span class="keyword">const</span> action = deleteListAction(index);</span><br><span class="line">    store.dispatch(action)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>store</code> 必须是唯一的</li><li>只有 <code>store</code> 才能改变自己的内容（注意，<code>reducer</code> 是不能改变的）</li><li><code>Reducer</code> 必须是纯函数</li><li>目前，我们学到的 Redux 的核心 API 有：<ul><li><code>createStore()</code></li><li><code>store.dispatch()</code></li><li><code>store.getState()</code></li><li><code>store.subScribe()</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React教程（五）：TodoList案例</title>
      <link href="c470b271c23e/"/>
      <url>c470b271c23e/</url>
      
        <content type="html"><![CDATA[<h2 id="组件代码"><a href="#组件代码" class="headerlink" title="组件代码"></a>组件代码</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoList.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component, Fragment &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      list: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;input value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">               onChange=&#123;<span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleBtnClick.bind(<span class="built_in">this</span>)&#125;&gt;提交&lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;li</span><br><span class="line">                  key=&#123;index&#125;</span><br><span class="line">                  onClick=&#123;<span class="built_in">this</span>.handleItemDelete.bind(<span class="built_in">this</span>, index)&#125;</span><br><span class="line">                &gt;</span><br><span class="line">                  &#123;item&#125;</span><br><span class="line">                &lt;/li&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleBtnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: [...this.state.list, <span class="built_in">this</span>.state.inputValue],</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleItemDelete</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = [...this.state.list];</span><br><span class="line">    list.splice(index, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: list</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList;</span><br></pre></td></tr></table></figure><hr><h2 id="组件拆分重构"><a href="#组件拆分重构" class="headerlink" title="组件拆分重构"></a>组件拆分重构</h2><h3 id="父组件"><a href="#父组件" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoList.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component, Fragment&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">&#x27;./TodoItem.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      list: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;insertArea&quot;</span>&gt;输入内容&lt;/label&gt;</span><br><span class="line">        &lt;input id=<span class="string">&quot;insertArea&quot;</span></span><br><span class="line">               className=<span class="string">&quot;input&quot;</span></span><br><span class="line">               value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">               onChange=&#123;<span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleBtnClick.bind(<span class="built_in">this</span>)&#125;&gt;</span><br><span class="line">          提交</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> (</span><br><span class="line">                &lt;TodoItem content=&#123;item&#125;</span><br><span class="line">                          index=&#123;index&#125;</span><br><span class="line">                          itemDelete=&#123;<span class="built_in">this</span>.handleItemDelete.bind(<span class="built_in">this</span>)&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">              )</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      inputValue: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleBtnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: [...this.state.list, <span class="built_in">this</span>.state.inputValue],</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleItemDelete</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> list = [...this.state.list];</span><br><span class="line">    list.splice(index, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      list: list</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList;</span><br></pre></td></tr></table></figure><h3 id="子组件"><a href="#子组件" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.content&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.props.itemDelete(<span class="built_in">this</span>.props.index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoItem;</span><br></pre></td></tr></table></figure><hr><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><blockquote><p>这里主要是对之前拆分组件的代码进行优化，既考虑美观更考虑性能上的损耗</p></blockquote><h3 id="父组件-1"><a href="#父组件-1" class="headerlink" title="父组件"></a>父组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoList.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component, Fragment&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">&#x27;./TodoItem.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      list: []</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.handleInputChange = <span class="built_in">this</span>.handleInputChange.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleBtnClick = <span class="built_in">this</span>.handleBtnClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.handleItemDelete = <span class="built_in">this</span>.handleItemDelete.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Fragment&gt;</span><br><span class="line">        &lt;label htmlFor=<span class="string">&quot;insertArea&quot;</span>&gt;输入内容&lt;/label&gt;</span><br><span class="line">        &lt;input id=<span class="string">&quot;insertArea&quot;</span></span><br><span class="line">               className=<span class="string">&quot;input&quot;</span></span><br><span class="line">               value=&#123;<span class="built_in">this</span>.state.inputValue&#125;</span><br><span class="line">               onChange=&#123;<span class="built_in">this</span>.handleInputChange&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="built_in">this</span>.handleBtnClick&#125;&gt;</span><br><span class="line">          提交</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">          &#123;<span class="built_in">this</span>.getTodoItem()&#125;</span><br><span class="line">        &lt;/ul&gt;</span><br><span class="line">      &lt;/Fragment&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getTodoItem</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">this</span>.state.list.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">          &lt;TodoItem key=&#123;index&#125;</span><br><span class="line">                    content=&#123;item&#125;</span><br><span class="line">                    index=&#123;index&#125;</span><br><span class="line">                    itemDelete=&#123;<span class="built_in">this</span>.handleItemDelete&#125;</span><br><span class="line">          /&gt;</span><br><span class="line">        )</span><br><span class="line">      &#125;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = e.target.value;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">() =&gt;</span> (&#123;</span><br><span class="line">      inputValue: value</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleBtnClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> (&#123;</span><br><span class="line">      list: [...prevState.list, prevState.inputValue],</span><br><span class="line">      inputValue: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handleItemDelete</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function">(<span class="params">prevState</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> list = [...prevState.list];</span><br><span class="line">      list.splice(index, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> &#123;list&#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoList;</span><br></pre></td></tr></table></figure><h3 id="子组件-1"><a href="#子组件-1" class="headerlink" title="子组件"></a>子组件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TodoItem.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoItem</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;content&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;li onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;content&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;itemDelete, index&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    itemDelete(index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> TodoItem;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React教程（四）：事件处理</title>
      <link href="3be8c2facc48/"/>
      <url>3be8c2facc48/</url>
      
        <content type="html"><![CDATA[<h3 id="与-DOM-元素事件的区别"><a href="#与-DOM-元素事件的区别" class="headerlink" title="与 DOM 元素事件的区别"></a>与 DOM 元素事件的区别</h3><ol><li><p>这个我们在之前提到过，就是 React 元素的事件必须使用 <code>camelCase</code> 的命名方法（类似 <code>onClick</code> 这种），而不是全小写的形式（类似 <code>onclick</code> 这种）</p></li><li><p>React 元素的事件使用 JSX 语法，传入的是句柄，而不是一个字符串，例如：</p><ul><li><p>React 元素事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击按钮即触发 add 函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意 onClick 大写，以及 add 用花括号括起来 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;add&#125;</span>&gt;</span></span><br><span class="line">    doSomething...</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DOM 元素事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 点击按钮即触发 add 函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意 onclick 小写，以及 add 用字符串表示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;add()&quot;</span>&gt;</span></span><br><span class="line">    doSomething...</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在原生 DOM 中，我们可以通过 <code>false</code> 来阻止 <strong>默认事件</strong>，但这在 React 中行不通，React 中需要使用 <code>preventDefault()</code> 来阻止默认行为，例如，下面都会阻止默认打开指向的网页：</p><ul><li><p>DOM：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.baidu.com/&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;已点击&#x27;); return false&quot;</span>&gt;</span></span><br><span class="line">Click Me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>React：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="comment">// 为了在回调中使用 this，这里必须绑定 this</span></span><br><span class="line">        <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;a href=<span class="string">&quot;https://www.baidu.com/&quot;</span> onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;</span><br><span class="line">            Click Me</span><br><span class="line">            &lt;/a&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;  <span class="comment">// 这里的 e 是一个合成事件</span></span><br><span class="line">        e.preventDefault();  <span class="comment">// 阻止默认事件，使得点击链接不会跳转</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="原生事件与合成事件"><a href="#原生事件与合成事件" class="headerlink" title="原生事件与合成事件"></a>原生事件与合成事件</h3><ol><li><p>原生事件：比如你在 <code>componentDidMount</code> 方法里面通过 <code>addEventListener</code> 绑定的事件就是原生事件，使用原生事件的时候注意在 <code>componentWillUnmount</code> 中解除绑定 <code>removeEventListener</code></p></li><li><p>合成事件：react 实现了一个 “合成事件层”，这个事件模型保证了和 W3C 标准保持一致，这个事件层消除了 IE 与 W3C 标准之间的兼容问题</p></li><li><p>事件委托：合成事件会以事件委托的方式绑定到组件的最上层，并在组件卸载时自动销毁绑定的事件</p></li><li><p>如果混用 “原生事件“ 与 ”合成事件“，比如用原生事件在 document 上面绑定，然后在组件里面绑定的事件想要通过 <code>e.stopPropagation()</code> 来阻止事件冒泡到 document，这是不可以的，因为 <code>e.stopPropagation</code> 是内部 “合成事件” 层面的，解决方法是要用 <code>e.nativeEvent.stopImmediatePropagation()</code></p></li><li><p>合成事件的 <code>event</code> 对象只在当前 <code>event loop</code> 有效，如果你想在事件里面调用一个 promise，在 resolve 之后去拿 <code>event</code> 对象会拿不到（并且没有错误抛出）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handleClick</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">    promise.then(<span class="function">() =&gt;</span> doSomethingWith(e));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参考：<a href="https://react.docschina.org/docs/events.html">React — 合成事件</a></p></li></ol><hr><h3 id="关于-this-的绑定"><a href="#关于-this-的绑定" class="headerlink" title="关于 this 的绑定"></a>关于 this 的绑定</h3><ol><li><p>在用 class 创建组件的时候，函数通常都是声明为 class 中的方法</p></li><li><p>在 react 中，除了构造函数和生命周期钩子函数会自动绑定 <code>this</code>，class 中的方法不会默认绑定 this，在前一个案例中，如果你的 <code>handleClick</code> 方法没有绑定 this，那么会报错 <code>“handleClick is not defined”</code></p></li><li><p>在方法上绑定 this 的途径有：</p><ul><li><p>通过 <code>bind()</code> 在调用时绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>Function.prototype.bind(thisArg [, arg1 [, arg2, …]])</code> 是 ES5 新增的函数扩展方法，bind() 返回一个新的函数对象，该函数的 this 被绑定到 <code>this.Arg</code> 上，并向事件处理器中传入参数</li></ul></li><li><p>在构造函数中绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这样做的好处，如果组件中需要多次使用该方法，那么仅需要在构造函数中绑定一次即可，而不是每次使用时都加上 bind 来绑定</li></ul></li><li><p>用箭头函数绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 这实际上是执行了一个回调函数，在回调函数中执行 handleClick 方法</span></span><br><span class="line">            &lt;button onClick=&#123; <span class="function">() =&gt;</span> &#123;<span class="built_in">this</span>.handleClick()&#125; &#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>箭头函数则会捕获其所在上下文的 this 值，作为自己的 this 值，使用箭头函数就不用担心函数内的this 不是指向组件内部了</li><li>这种语法的问题是每次渲染组件时都会创建不同的回调函数，如果我们将这个回调函数作为 prop 传入子组件，那么这个组件很可能会有额外的重新渲染，所以最佳的方案还是写在构造器中</li></ul></li></ul></li></ol><hr><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><ol><li><p>若采用 bind 绑定 this 的方法，则传参的方式为：<code>this.方法名.bind(this, arg1, arg2, ...)</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">1</span>)&#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params">num</span>)</span> &#123;</span><br><span class="line">        alert(num1 + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若采用构造器中绑定 this 的方法，则传参的方式为：<code>this.方法名(arg1, arg2, ...)</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick&#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params">num1, num2</span>)</span> &#123;</span><br><span class="line">        alert(num1+num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这也是推荐的方式</li></ul></li><li><p>若采用箭头函数绑定 this 的方法，则传参的方式为：<code>() =&gt; &#123;this.方法名(arg1, arg2, ...)&#125;</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;button onClick=&#123; <span class="function">() =&gt;</span> &#123;<span class="built_in">this</span>.handleClick(<span class="number">0</span>, <span class="number">1</span>)&#125; &#125;&gt;Click Me&lt;/button&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params">num1, num2</span>)</span> &#123;</span><br><span class="line">        alert(num1 + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React教程（三）：State与生命周期</title>
      <link href="86e6fb92280e/"/>
      <url>86e6fb92280e/</url>
      
        <content type="html"><![CDATA[<h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="介绍-React-数据流"><a href="#介绍-React-数据流" class="headerlink" title="介绍 React 数据流"></a>介绍 React 数据流</h3><ol><li><p>在 react 中，数据是单向流动的，即从父组件到子组件</p></li><li><p><code>state</code> 与 <code>props</code> 是 react 组件中最重要的概念：</p><ul><li><p>state 只关心每个组件自己内部的状态，这些状态也只能在组件内部改变</p></li><li><p>如果顶层组件初始化 props，那么 react 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件</p></li></ul></li><li><p>把组件看做一个函数，那么 props 可看做这个函数要接收的参数，state 可看做函数的内部参数，总体上返回一个 Virtual DOM 的实现</p></li></ol><h3 id="认识-state"><a href="#认识-state" class="headerlink" title="认识 state"></a>认识 state</h3><ol><li>react 把组件看作是一个状态机：通过与用户的交互，实现不同状态，然后渲染 UI，让用户界面和数据保持一致，组件的任何 UI 改变，组件就会自动调用 <code>render</code> 重新渲染 UI，这个更改的动作会通过 <code>this.setState</code>方法来触发，state中的所有状态都用于反映 UI 的变化，不应有多余状态</li><li>什么样的数据属性可以当作状态？当更改这个状态（数据）需要更新组件 UI 的就可以认为是 <code>state</code>，下面这些可以认为 <strong>不是</strong> 状态：<ul><li>可计算的数据：比如一个数组的长度</li><li>和 props 重复的数据：除非这个数据是要做变更的</li><li>通过 props 从父组件中获取</li><li>在组件的整个生命周期中都保持不变</li><li>通过其他状态（state）或者属性（props）计算得到</li><li>在组件的<code>render</code>方法中使用（这种情况下，这个变量更适合定义为组件的一个普通属性）</li></ul></li><li>state 与 props 的区别：state 和 props 的变化都会触发组件 UI 的重新渲染，区别在于能否自身修改<ul><li>props 是通过父组件传递给子组件的，对于使用它的组件来说是只读的，props 只能在父组件中修改</li><li>state 是组件内部自己维护的状态，使用它的组件在自身就可以修改</li><li>概括起来就类似于，state 是组件对内的接口，props 是组件对外的接口</li></ul></li><li>react 通过 <code>this.state</code> 来访问 state，通过 <code>this.setState</code> 来更新 state，当 <code>this.setState</code> 被调用的时候，react 会重新调用 render 方法来重新渲染 UI</li></ol><h3 id="state-的修改"><a href="#state-的修改" class="headerlink" title="state 的修改"></a>state 的修改</h3><p>state 不能直接修改：直接以赋值的形式修改 state 不会触发组件的 render，修改 state 需要用 <code>setState</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="built_in">this</span>.stae.title = <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">this</span>.setState (&#123;</span><br><span class="line">    title: <span class="string">&quot;react&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="state-的类型"><a href="#state-的类型" class="headerlink" title="state 的类型"></a>state 的类型</h3><blockquote><p>建议把 state 当做是不可变对象，state 中包含的所有状态都应该是不可变对象，当 state 中的某个状态发生变化，我们应该重新创建这个状态对象，而不是直接修改原来的状态</p></blockquote><blockquote><p>根据状态类型，state 可以分为以下三种：</p></blockquote><ol><li><p><strong>数字，字符串，布尔值，null，undefined</strong> 这五种不可变类型：因为其本身就是不可变的，如果要修改状态的话，直接赋新值就可以，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">    c: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><strong>数组</strong> 类型：JS 中数组类型为可变类型，假设现在有一个数组类型的状态 “books”，当你向 “book” 增加一个字符串常量时，需要使用数组的 <code>concat</code> 方法或者 ES6 的数组扩展语法，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：先将 state 赋值给另外的变量，然后使用 concat 创建新数组</span></span><br><span class="line"><span class="keyword">let</span> books = <span class="built_in">this</span>.state.books;</span><br><span class="line"><span class="built_in">this</span>.setState (&#123;</span><br><span class="line">    books: books.concat([<span class="string">&quot;oneBook&quot;</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用 preState、concat 创建数组</span></span><br><span class="line"><span class="built_in">this</span>.setState (<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: preState.books.concat([<span class="string">&quot;oneBook&quot;</span>])</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：ES6 数组扩展语法</span></span><br><span class="line"><span class="built_in">this</span>.setState (<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: [...preState.books, <span class="string">&quot;oneBook&quot;</span>]</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><ul><li><p>当从 books 中截取部分元素作为新状态时，要使用数组的 <code>slice</code> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一：先将 state 赋值给另外的变量，然后使用 slice 创建新数组</span><br><span class="line">let books &#x3D; this.state.books;</span><br><span class="line">this.setState (&#123;</span><br><span class="line">    books: books.slice(1, 3);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法二：使用 preState、slice 创建新数组</span><br><span class="line">this.setState (preState, (&#123;</span><br><span class="line">    books: preState.books.slice(1, 3)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>当从 books 中过滤部分元素后，作为新状态，使用数组的 <code>filter</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：先将 state 赋值给另外的变量，然后使用 filter 创建新数组</span></span><br><span class="line"><span class="keyword">let</span> books = <span class="built_in">this</span>.state.books;</span><br><span class="line"><span class="built_in">this</span>.setState (&#123;</span><br><span class="line">    books: books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item == <span class="string">&quot;oneBook&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用 preState、filter 创建新数组</span></span><br><span class="line"><span class="built_in">this</span>.setState (<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    books: preState.books.filter(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item == <span class="string">&quot;oneBook&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>注意：不要使用 <code>push</code>、<code>pop</code>、<code>shift</code>、<code>unshift</code>、<code>splice</code> 等方法修改数组类型的状态，因为这些方法都是在原数组的基础上修改的，应当使用不会修改原数组而返回一个新数组的方法，例如 <code>concat</code>、<code>slice</code>、<code>filter</code> 等</p></li></ul></li><li><p><strong>普通对象</strong> 类型（不包括字符串、数组）：JS 中对象也是可变类型，修改对象类型的状态时，不要修改原来的状态，可以使用 ES6 的 <code>Object.assign</code> 方法或者对象扩展语法。假设现在有一个对象类型的状态 “owner”，当你向对象中增加一个键值对 <code>name: &quot;ozzie&quot;</code>，时，需要使用 <code>Object.assgin</code> 方法或者对象的扩展语法：</p><ul><li><p>使用 <code>Object.assgin</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：将 state 先赋值给另外的变量，然后使用 Object.assign 创建新对象</span></span><br><span class="line"><span class="keyword">let</span> owner = <span class="built_in">this</span>.state.owner;</span><br><span class="line"><span class="built_in">this</span>.setState (&#123;</span><br><span class="line">    owner: <span class="built_in">Object</span>.assgin(&#123;&#125;, owner, &#123;<span class="attr">name</span>: <span class="string">&quot;ozzie&quot;</span>&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：使用 preState、Object.assgin 创建新对象</span></span><br><span class="line"><span class="built_in">this</span>.setState (preState, (&#123;</span><br><span class="line">    owner: <span class="built_in">Object</span>.assgin(&#123;&#125;, preState.owner, &#123;<span class="attr">name</span>: <span class="string">&quot;ozzie&quot;</span>&#125;)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>使用对象扩展语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：将 state 先赋值给另外的变量，然后使用对象扩展语法创建新对象</span></span><br><span class="line"><span class="keyword">let</span> owner = <span class="built_in">this</span>.state.owner;</span><br><span class="line"><span class="built_in">this</span>.setState (&#123;</span><br><span class="line">    owner: &#123;...owner, <span class="attr">name</span>: <span class="string">&quot;ozzie&quot;</span>&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用 preState、对象扩展语法创建新对象</span></span><br><span class="line"><span class="built_in">this</span>.setState (<span class="function"><span class="params">preState</span> =&gt;</span> (&#123;</span><br><span class="line">    owner: &#123;...preState.owner, <span class="attr">name</span>: <span class="string">&quot;ozzie&quot;</span>&#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure></li><li><p>创建新的状态对象的关键是，避免使用会直接修改原对象的方法，而是使用可以返回一个新对象的方法。当然，也可以使用一些 Immutable 的 JS 库，如 <a href="https://link.jianshu.com/?t=https://github.com/facebook/immutable-js">Immutable.js</a>，实现类似的效果。</p></li></ul></li><li><p>为什么组件的状态最好是不可变对象呢？</p><ul><li>一方面，对不可变对象的修改会返回一个新对象，不需要担心原有对象在不小心的情况下被修改导致的错误，方便程序的管理和调试</li><li>另一方面是出于性能考虑，当对象组件状态都是不可变对象时，在组件的<code>shouldComponentUpdate</code>方法中仅需要比较前后两次状态对象的引用就可以判断状态是否真的改变，从而避免不必要的<code>render</code>调用</li></ul></li></ol><hr><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><blockquote><p>生命周期就是框架会在规定的时间自动触发的函数</p></blockquote><h3 id="React-16-0-之前的生命周期"><a href="#React-16-0-之前的生命周期" class="headerlink" title="React 16.0 之前的生命周期"></a>React 16.0 之前的生命周期</h3><h4 id="生命周期图示"><a href="#生命周期图示" class="headerlink" title="生命周期图示"></a>生命周期图示</h4><ol><li>生命周期函数分类：<br><img src="https://gitee.com/gitee_fanjunyang/JueJin/raw/master/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_1.png" class="lazyload" data-srcset="https://gitee.com/gitee_fanjunyang/JueJin/raw/master/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>生命周期函数的执行流程：<br><img src="https://upload-images.jianshu.io/upload_images/16775500-8d325f8093591c76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" class="lazyload" data-srcset="https://upload-images.jianshu.io/upload_images/16775500-8d325f8093591c76.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/format/webp" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><h4 id="生命周期阶段分析"><a href="#生命周期阶段分析" class="headerlink" title="生命周期阶段分析"></a>生命周期阶段分析</h4><blockquote><p>按执行顺序可大致分为：初始化阶段、挂载阶段、更新阶段、卸载阶段</p></blockquote><ol><li><p>初始化阶段：<code>constructor()</code></p><ul><li><p><code>constructor</code> 是 ES6 对类的默认语法，通过 <code>new</code> 命令生成一个新的对象实例时自动调用方法（调用一次），该方法是必须有的，若没有显式定义，则会默认添加空的 <code>constructor</code> 方法，若有显式定义，则会手动调用 <code>super</code> 方法</p></li><li><p>若在 <code>constructor</code> 中访问 <code>this.props</code>，则需要传入 <code>props</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);  <span class="comment">// 声明 constructor 时必须调用 super 方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.props)  <span class="comment">// 此时可以正常访问 this.props</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>constructor</code> 也常用来初始化  <code>state</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);  <span class="comment">// 声明 constructor 时必须调用 super 方法</span></span><br><span class="line">        <span class="built_in">this</span>.state = &#123;<span class="attr">name</span>: <span class="string">&quot;ozzie&quot;</span>&#125;;  <span class="comment">// 状态初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>挂载阶段：<code>componentWillMount()</code>、<code>render()</code> 和 <code>componentDidMount()</code></p><ul><li><code>componentWillMount()</code>：在组件挂载之前调用，且全局只调用一次，一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经历了 <code>constructor()</code> 初始化数据后，但是还未渲染 DOM时</li><li><code>render()</code>：render 是一个组件必须定义的生命周期函数，用来渲染 DOM，而且它必须返回一个 react 元素（通常返回一个 UI 组件），不负责组件的实际渲染工作，之后由 react 自身根据此元素去渲染出页面 DOM<ul><li>注：render 必须是纯函数，且不能在 render 里面修改 state，这会触发死循环导致栈溢出</li></ul></li><li><code>componentDidMount()</code>：组件第一次渲染完成，此时 DOM 节点已经生成，它在组件挂载完成后调用，且全局只调用一次，可以在这里调用 ajax 请求，返回数据 setState 后组件会重新渲染</li></ul></li><li><p>更新阶段：<code>componentWillReceiveProps(nextProps)</code>、<code>shouldComponentUpdate(nextProps,nextState)</code>、<code>componentWillUpdate(nextProps,nextState)</code> 以及 <code>componentDidUpdate(prevProps, prevState)</code></p><blockquote><p>react 组件渲染机制：无论是 setState 引起的 state 更新，还是父组件重新 render 导致的 props 更新，更新之后的 state 和 props 无论相对之前是否有变化，都将重新 render</p></blockquote><ul><li><p><code>componentWillReceiveProps (nextProps)</code>：props 发生变化或者父组件重新渲染都会触发此函数，该钩子比较 nextProps 与 this.props，将 nextProps 的 state 替换掉当前的 state，从而重新渲染组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps (nextProps) &#123;</span><br><span class="line">   nextProps.num !== <span class="built_in">this</span>.props.num &amp;&amp; <span class="built_in">this</span>.setState (&#123;</span><br><span class="line">       num: nextProps.num</span><br><span class="line">   &#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.num:nextProps)</span><br><span class="line">       <span class="comment">// 将 state 更新为 nextProps，在 setState 的第二个参数（回调）中可打印出新的 state</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>shouldComponentUpdate(nextProps,nextState)</code>：组件挂载后，每次调用 setState 后都会调用此钩子来判断是否需要重新渲染，即用 nextProps、nextState 与 this.props、this.state 比较来判断是否需要重新渲染，需要重新渲染则返回 true，再重新 render，否则返回 false</p><ul><li>一般此钩子用于性能优化：当要更新一个组件时，很可能需要父组件更新自己的状态。而一个父组件的重新更新会造成它所有的子组件重新执行 render，形成新的虚拟DOM，再用 diff 算法对新旧虚拟DOM进行结构和属性的比较，决定组件是否需要重新渲染，这样做会造成性能浪费，所以可以根据需要，在 <code>shouldComponentUpdate()</code> 中加入条件判断，避免不必要的更新</li></ul></li><li><p><code>componentWillUpdate(nextProps,nextState)</code>：在组件即将被更新时触发，<code>shouldComponentUpdate</code> 返回 true 或者调用 <code>forceUpdate</code> 之后，此钩子会被调用。</p><ul><li>注：不能在此钩子中使用 setState，否则会触发重复循环</li></ul></li><li><p><code>componentDidUpdate(prevProps, prevState)</code>：此方法在组件更新之后被调用，除了首次 render 之后调用 <code>componentDidMount</code>，其它 render 结束之后都是调用此钩子，它可以操作组件更新 DOM，<code>preProps</code> 以及 <code>prevState</code> 这两个参数指的是组件更新前的 props 和 state</p><ul><li>注：该钩子内 setState 有可能会触发重复渲染，需要自行判断，否则会进入死循环</li></ul></li></ul></li><li><p>卸载阶段：<code>componentWillUnmount()</code></p><ul><li><code>componentWillUnmount()</code>：此钩子在组件卸载前被调用，可以在这里执行一些清理工作，比如清除组件中使用的定时器、取消 Redux 的订阅事件、清除 <code>componentDidMount</code> 中手动创建的DOM元素等等，以避免引起内存泄漏</li></ul></li></ol><h4 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">         number: <span class="number">0</span>,</span><br><span class="line">         name: <span class="string">&quot;Fan&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: componentWillMount&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: shouldComponentUpdate&quot;</span>) <span class="comment">// </span></span><br><span class="line">      <span class="keyword">if</span>(nextState.number%<span class="number">2</span> === <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: componentWillUpdate&quot;</span>) <span class="comment">// </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: componentDidUpdate&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="built_in">this</span>.state.number</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">         number: num + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: render&quot;</span>)  <span class="comment">// 2</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;hr /&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.state.number%<span class="number">2</span>==<span class="number">0</span> ? <span class="xml"><span class="tag">&lt;<span class="name">Son</span> <span class="attr">number</span>=<span class="string">&#123;this.state.number&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Father: componentDidMount&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">UNSAFE_componentWillMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentWillMount&quot;</span>) <span class="comment">// 1</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentDidMount&quot;</span>) <span class="comment">// 3</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentWillReceiveProps&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: shouldComponentUpdate&quot;</span>)</span><br><span class="line">      <span class="comment">// return false;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentWillUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentWillUpdate&quot;</span>) <span class="comment">// </span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentDidUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentDidUpdate&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: render&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;<span class="built_in">this</span>.props.number&#125;&lt;/p&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">componentWillUnmount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Son: componentWillUnmount&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;Father /&gt;,</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>打开控制台，点击按钮，观察各个钩子的执行顺序</li></ul><h3 id="React-16-4-生命周期"><a href="#React-16-4-生命周期" class="headerlink" title="React 16.4 生命周期"></a>React 16.4 生命周期</h3><h4 id="生命周期图示-1"><a href="#生命周期图示-1" class="headerlink" title="生命周期图示"></a>生命周期图示</h4><p><img src="https://gitee.com/gitee_fanjunyang/JueJin/raw/master/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_4.png" class="lazyload" data-srcset="https://gitee.com/gitee_fanjunyang/JueJin/raw/master/images/React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F_4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h4 id="相对原版的变化对比"><a href="#相对原版的变化对比" class="headerlink" title="相对原版的变化对比"></a>相对原版的变化对比</h4><ol><li>新版移除的三个生命周期钩子：<ul><li><code>componentWillMount</code></li><li><code>componentWillReceiveProps</code></li><li><code>componentWillUpdate</code></li></ul></li><li>新版声明的生命周期钩子：<ul><li><code>static getDerivedStateFromProps(nextProps, prevState)</code></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></li></ul></li></ol><h4 id="为什么需要改变生命周期"><a href="#为什么需要改变生命周期" class="headerlink" title="为什么需要改变生命周期"></a>为什么需要改变生命周期</h4><p>见文章：<a href="https://cloud.tencent.com/developer/article/1385875">新老生命周期对比</a></p><h4 id="新增生命周期钩子的分析"><a href="#新增生命周期钩子的分析" class="headerlink" title="新增生命周期钩子的分析"></a>新增生命周期钩子的分析</h4><ol><li><code>static getDerivedStateFromProps(nextProps, prevState)</code>：<ul><li>每次渲染之前都会调用，不管造成重新渲染的原因是什么，不管初始挂载还是之后更新都会调用，功能可以说是代替了 <code>componentWillReceiveProps()</code>，因为 <code>componentWillReceiveProps()</code> 只有在父组件造成重新渲染时才调用</li><li>两个参数：<code>nextProps </code>表示父组件传入的值，<code>prevState </code>表示组件自身的 state</li><li>使用该方法，需要在该方法中返回一个 <strong>对象或null</strong>：<ul><li>若返回对象，则会更新 state</li><li>若返回 null，则表示不更新</li></ul></li><li>使用钩子时要初始化 state，否则在控制台中会出现警告信息，不能在该方法内部调用 this.state</li></ul></li><li><code>getSnapshotBeforeUpdate(prevProps, prevState)</code>：<ul><li>在 render() 之后，<code>componentDidUpdate()</code> 之前调用，此钩子返回的任何值都将作为参数传递给<code>componentDidUpdate()</code>，功能可以说是代替了 <code>componentWillUpdate</code>，因为常见的  <code>componentWillUpdate</code> 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在  <code>componentDidUpdate</code> 中处理</li><li>两个参数：<code>prevProps</code> 表示更新前的 props，<code>prevState </code>表示更新前的 state</li></ul></li></ol><h4 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">         number: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="built_in">this</span>.state.number</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">         number: num + <span class="number">1</span></span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;父组件&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">            &lt;hr /&gt;</span><br><span class="line">            &lt;Son number=&#123;<span class="built_in">this</span>.state.number&#125;&gt;&lt;/Son&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(props)</span><br><span class="line">      <span class="built_in">this</span>.state = &#123;</span><br><span class="line">         number: <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// nextProps 是父给子传递的过来的新的数据 </span></span><br><span class="line">   <span class="comment">// prevState 是子的上一次的状态</span></span><br><span class="line">   <span class="comment">//每次更新都会触发</span></span><br><span class="line">   <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromProps</span>(<span class="params">nextProps, prevState</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// nextProps 表示父向下传递的新的值 1 2 3 4 5</span></span><br><span class="line">      <span class="comment">// prevState  0 0 0 </span></span><br><span class="line">      <span class="built_in">console</span>.log(nextProps, prevState)  <span class="comment">// &#123;number: 0&#125;  &#123;number: 0&#125;</span></span><br><span class="line">      <span class="keyword">let</span> &#123; number &#125; = nextProps;</span><br><span class="line">      <span class="built_in">console</span>.log(number)</span><br><span class="line">      <span class="comment">// if(number%2 === 0)</span></span><br><span class="line">      <span class="comment">//    return &#123; number:number+10 &#125;</span></span><br><span class="line">      <span class="comment">// else</span></span><br><span class="line">      <span class="comment">//    return &#123; number:number+100 &#125;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// prevState 表示是子组件的上一次状态</span></span><br><span class="line">      <span class="keyword">if</span> (number % <span class="number">2</span> === <span class="number">0</span>) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(prevState.number)</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">number</span>: prevState.number + number + <span class="number">10</span> &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(prevState.number)</span><br><span class="line">         <span class="keyword">return</span> &#123; <span class="attr">number</span>: prevState.number + number + <span class="number">100</span> &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">handleChange</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> num = <span class="built_in">this</span>.state.number</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">         number: num + <span class="number">1000</span></span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">         &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;子组件&lt;/h1&gt;</span><br><span class="line">            &lt;p&gt;&#123;<span class="built_in">this</span>.state.number&#125;&lt;/p&gt;</span><br><span class="line">            &lt;button onClick=&#123;<span class="built_in">this</span>.handleChange.bind(<span class="built_in">this</span>)&#125;&gt;改变状态&lt;/button&gt;</span><br><span class="line">         &lt;/div&gt;</span><br><span class="line">      )</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">   &lt;Father /&gt;,</span><br><span class="line">   <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>打开控制台，点击按钮，观察各个钩子的执行顺序</li></ul><hr><blockquote><p>本节介绍了 state 以及 生命周期，虽然对生命周期还是晕晕的，但是之后遇到案例了会继续分析的，加油！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React教程（二）：初识组件与Props</title>
      <link href="3458eef757e3/"/>
      <url>3458eef757e3/</url>
      
        <content type="html"><![CDATA[<h2 id="组件介绍"><a href="#组件介绍" class="headerlink" title="组件介绍"></a>组件介绍</h2><h3 id="认识组件"><a href="#认识组件" class="headerlink" title="认识组件"></a>认识组件</h3><ol><li>组件（<code>component</code>）能够将 UI 划分为独立的、可复用的部分，这样我们就只需专注于构建每一个单独的部件。从概念上看，组件就像是函数：接受任意的输入（称为属性，即 <code>Props</code>），返回 React 元素。可以说，一个 React 应用就是构建在 React 组件之上的</li><li>组件有两个核心概念：<code>props</code> 与 <code>state</code>，一个组件就是通过这两个属性的值在 <code>render</code> 方法里面生成这个组件对应的 HTML 结构<ul><li>注意：组件生成的 HTML 结构只能有一个单一的根节点</li></ul></li></ol><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><p><code>props</code> 就是组件的属性，在外部通过 JSX 属性传入设置，一旦初识设置完成，那么 <code>this.props</code> 就是不可更改的，所以，不要轻易更改设置 <code>this.props</code> 里面的值</p><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p><code>state</code> 就是组件的当前状态，你可以简单地把组件看做是一个 “状态机”，根据状态 <code>state</code> 呈现不同的 UI 展示，一旦状态（数据）更改，组件就会自动调用 <code>render</code> 重新渲染 UI，这个更改的动作会通过 <code>this.setState</code> 方法来触发</p><h3 id="划分状态数据"><a href="#划分状态数据" class="headerlink" title="划分状态数据"></a>划分状态数据</h3><ol><li>原则：让组件尽可能地少状态（这样组件逻辑就越容易维护）</li><li>什么样的数据属性可以当作状态？当更改这个状态（数据）需要更新组件 UI 时，就可以认为是 <code>state</code>，比如下面这些就可以认为 <strong>不是状态</strong> 的<ul><li>可计算的数据：比如一个数组的长度</li><li>和 <code>props</code> 重复的数据（除非这个数据是要做变更的）</li></ul></li></ol><h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>我们也可以用纯粹的函数来定义无状态的组件（stateless function），这种组件没有状态，没有生命周期，只是简单的接受 <code>props</code> 渲染生成 DOM 结构，无状态组件非常简单，开销很低，如果可能的话尽量使用无状态组件。比如使用箭头函数定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const HelloMessage &#x3D; (props) &#x3D;&gt; &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">render(</span><br><span class="line">    &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>因为无状态组件只是函数，所以它没有实例返回，这点在想用 <code>refs</code> 获取无状态组件的时候要注意，参见<a href="http://caibaojian.com/react/dom.html">DOM 操作</a></p><hr><h2 id="组件的定义"><a href="#组件的定义" class="headerlink" title="组件的定义"></a>组件的定义</h2><blockquote><p>React 中，组件的定义有两种方式：函数定义、类定义</p></blockquote><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>这是最简单的定义组件的方式，就像写一个 JS 函数一样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function HelloMessage(props) &#123;</span><br><span class="line">    return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h3><p>用 ES6 中的类来定义组件，这比函数定义更加灵活：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>注意，组件的名称必须以 <strong>大写字母</strong> 开头，因为 React 会将以小写字母开头的组件视为原生 DOM 标签，比如 <code>&lt;div /&gt;</code> 代表 HTML 的 <code>&lt;div&gt;</code> 标签，而 <code>&lt;Div /&gt;</code> 则代表一个组件，并且需要在作用域内使用组件</p><hr><h2 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h2><p>我们在之前遇到的 React 元素都只是 DOM 标签，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; &lt;div&gt;Hello&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>除此之外，React 元素还能是自定义的组件，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性以及子组件转换为单个对象传递给组件，这个对象被称之为 <code>props</code>，例如下面这段代码会在页面上渲染为 <code>&lt;div&gt;Hello Ozzie&lt;/div&gt;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function HelloMessage(props) &#123;</span><br><span class="line">    return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">&#125;</span><br><span class="line">const element &#x3D; &lt;HelloMessage name&#x3D;&quot;Ozzie&quot;&#x2F;&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ol><li><p>这个 <code>name=&quot;Ozzie&quot;</code> 最终会以 <code>props.name</code> 的方式传递给组件</p></li><li><p>对上述代码，渲染过程如下：</p><ul><li>对 <code>&lt;HelloMessage name=&quot;Ozzie&quot;/&gt;</code> 元素，调用了 <code>ReactDOM.render</code> 方法</li><li>React 将 <code>&#123;name: &quot;Ozzie&quot;&#125;</code> 作为 <code>props</code> 的实参来调用 <code>HelloMessage</code> 组件</li><li><code>HelloMessage</code> 完成渲染，返回 <code>&lt;div&gt;Hello Ozzie&lt;/div&gt;</code> 元素</li><li>ReactDOM 计算最小更新代价，然后更新 DOM</li></ul></li></ol><hr><h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><h3 id="初识组合组件"><a href="#初识组合组件" class="headerlink" title="初识组合组件"></a>初识组合组件</h3><p>使用组件的目的就是通过构建模块化的组件，相互组合组件最后组装成一个复杂的应用</p><p>这就意味着我们可以在一个组件的内部引用其他的组件，在 React 组件中，要想包含其他组件作为子组件，只需要把组件当作一个 DOM 元素引入就可以了，例如下面的代码中，我们会在 <code>&lt;App /&gt;</code> 组件中多次调用 <code>&lt;HelloMessage /&gt;</code> 组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;div&gt;Hello &#123;props.name&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;HelloMessage name&#x3D;&quot;A&quot; &#x2F;&gt;</span><br><span class="line">                &lt;HelloMessage name&#x3D;&quot;B&quot; &#x2F;&gt;</span><br><span class="line">                &lt;HelloMessage name&#x3D;&quot;C&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;App &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注意，在 React 中，组件必须返回单一的根元素，换句话说，就是 <code>render()</code> 的返回内容必须只有一个根标签，所以上面的三个 <code>&lt;HelloMessage /&gt;</code> 组件都被一个 <code>&lt;div&gt;</code> 根标签包裹着，如果是下面这种，就会出错！！！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;HelloMessage name&#x3D;&quot;A&quot; &#x2F;&gt;</span><br><span class="line">        &lt;HelloMessage name&#x3D;&quot;B&quot; &#x2F;&gt;</span><br><span class="line">        &lt;HelloMessage name&#x3D;&quot;C&quot; &#x2F;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里出现了三个根标签，<strong>是错误的写法</strong></li></ul><h3 id="循环插入子元素"><a href="#循环插入子元素" class="headerlink" title="循环插入子元素"></a>循环插入子元素</h3><p>如果组件中存在着需要循环插入的子元素，为了保证重新渲染 UI 时能正确地显示这些子元素，每个元素都需要通过一个特殊的 <code>key</code> 属性去指定一个唯一的值，至于这么做的原因，粗略地说，是为了内部 diff 的效率，详细原因参考：<a href="https://reactjs.org/docs/reconciliation.html">Reconciliation</a></p><p><code>key</code> 必须直接在循环中设置，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const ListItemWrapper &#x3D; (props) &#x3D;&gt; &lt;li&gt;&#123;props.data&#125;&lt;&#x2F;li&gt;</span><br><span class="line">const MyComponent &#x3D; (props) &#x3D;&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;ul&gt;</span><br><span class="line">            &#123;props.array.map((item) &#x3D;&gt; &#123;</span><br><span class="line">                return &lt;ListItemWrapper key&#x3D;&#123;item.id&#125; data&#x3D;&#123;item&#125; &#x2F;&gt;</span><br><span class="line">            &#125;)&#125;</span><br><span class="line">        &lt;&#x2F;ul&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyComponent array&#x3D;&#123;[1, 2, 3]&#125; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>以上过程梳理如下：</p><ul><li><code>&lt;MyComponent /&gt;</code> （父组件）嵌套着 <code>&lt;ListItemWrapper /&gt;</code> （子组件）</li><li>父组件接受外部传入的数据，并放在父组件的 <code>props</code> 中，<code>props</code> 的 <code>array</code> 属性是一个数组</li><li>遍历 <code>props.array</code> 中的每一个元素，赋给 <code>item</code>，再将 <code>item</code> 的下标（也就是 <code>item.id</code>）作为 <code>key</code> 值保证正确渲染，再将 <code>item</code> 通过 <code>data</code> 传给子组件，所以，子组件的 <code>props.data</code> 也就是父组件中的 <code>item</code></li><li>最后在每一个子组件中渲染出来</li></ul><p>你也可以用一个 <code>key</code> 值作为属性，子元素作为属性值的对象字面量来显示子元素列表，虽然这种用法的场景有限，但是在这种情况下要注意生成的子元素重新渲染后在 DOM 中显示的顺序问题，参考：<a href="http://facebook.github.io/react/docs/create-fragment.html">Keyed Fragments</a></p><p>实际上，浏览器在遍历每一个字面量对象的时候都会保持顺序一致，除非属性值可以用整数来替换，这会导致顺序紊乱，为了防止这种情况，我们最好在 <code>key</code> 值前面加上字符串前缀，承接上一个案例，修改如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    const obj &#x3D; &#123;&#125;;</span><br><span class="line">    this.props.array.forEach((item) &#x3D;&gt; &#123;</span><br><span class="line">        obj[&#39;item:&#39; + item.id] &#x3D; &lt;li&gt;&#123;item&#125;&lt;&#x2F;li&gt;</span><br><span class="line">    &#125;)</span><br><span class="line">    return (</span><br><span class="line">        &lt;ol&gt;&#123;obj&#125;&lt;&#x2F;ol&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a>this.props.children</h3><p>组件标签里面包含的子元素会通过 <code>this.props.children</code> 传递进来，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render (</span><br><span class="line">    &lt;Parent&gt;&lt;Child &#x2F;&gt;&lt;&#x2F;Parent&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render (</span><br><span class="line">    &lt;Parent&gt;&lt;span&gt;hello&lt;&#x2F;span&gt;&#123;&#39;World&#39;&#125;&lt;&#x2F;Parent&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>HTML 元素会作为 React 的组件对象，JS 表达式的结果是一个文字结点，都会存入 <code>Parent</code> 组件的 <code>props.children</code></p><p>一般来说，可以直接将 <code>props.children</code> 这个属性作为父组件的子元素来渲染，承接上一段代码，定义父组件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Parent &#x3D; (props) &#x3D;&gt; &lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p><code>props.children</code> 通常是一个组件对象的数组，但是当只有一个子元素的时候，<code>props.children</code> 将是这个唯一的子元素，而不是数组了。</p><hr><h2 id="Props-的只读性"><a href="#Props-的只读性" class="headerlink" title="Props 的只读性"></a>Props 的只读性</h2><p>无论是函数式定义还是类定义组件，<strong>都不能修改自身的 <code>props</code></strong></p><p>来看看下面这个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的函数被称为纯函数，它的特点有：</p><ul><li>函数不会改变入参</li><li>对于相同的输入，函数总会返回相同的值</li></ul><p>与纯函数对应的，是非纯函数，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span> (<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">    account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的非纯函数在函数体内改变了入参</p><p>React 的规定是：<strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改</strong></p><hr><blockquote><p>本节主要认识了 React 组件以及 props 的用法，继续加油吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React教程（一）：JSX的认识与使用</title>
      <link href="6b9099691f77/"/>
      <url>6b9099691f77/</url>
      
        <content type="html"><![CDATA[<h2 id="简单了解-JSX"><a href="#简单了解-JSX" class="headerlink" title="简单了解 JSX"></a>简单了解 JSX</h2><ol><li><p>相关文档：<a href="http://facebook.github.io/jsx/">JSX</a> 、<a href="https://www.tslang.cn/docs/handbook/jsx.html">JSX · TypeScript</a> 、<a href="https://react.docschina.org/docs/introducing-jsx.html">JSX 简介</a></p></li><li><p>虽然 JSX 语法糖并不是必须的，但可以明显地感受到 JSX 很利于提升开发效率，例如：</p><ul><li><p>未使用 JSX：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return React.createElement (</span><br><span class="line">            &quot;div&quot;,</span><br><span class="line">            null,</span><br><span class="line">            &quot;Hello &quot;,</span><br><span class="line">            this.props.name</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement( HelloMessage, &#123; name: &quot;Ozzie&quot; &#125; ),</span><br><span class="line">    document.getElementById(&quot;container&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>使用 JSX：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class HelloMessage extends React.Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            Hello &#123;this.props.name&#125;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage name&#x3D;&#39;ozzie&#39; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;container&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="详谈-JSX-语法"><a href="#详谈-JSX-语法" class="headerlink" title="详谈 JSX 语法"></a>详谈 JSX 语法</h2><blockquote><p>JSX 是 JS 的语法糖，所以在语法上更贴近 JS 而不是 HTML</p></blockquote><ol><li><p>用 JSX 写 DOM 结构，有两种形式：</p><ul><li><p>原生的 HTML 标签，用小写的字符串表示，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">const myDivElement &#x3D; &lt;div className&#x3D;&quot;foo&quot;&#x2F;&gt;  &#x2F;&#x2F;小写字符串是标签</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    myDivElement,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>注意，HTML 的 <code>class</code> 在 JSX 中要写成 <code>className</code>，因为 <code>class</code> 在 JS 中是保留关键字，同理，某些属性也要变化写法，比如 <code>for</code> 要写成 <code>htmlFor</code>，<code>tabindex</code> 要变成 <code>tabIndex</code></li></ul></li><li><p>React 组件，用大写的变量表示，像使用 HTML 标签一样引用 React 组件，例如：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line">import MyComponent from &#39;.&#x2F;MyComponet&#39;;  &#x2F;&#x2F;引入组件</span><br><span class="line"></span><br><span class="line">var myDivElement &#x3D; &lt;MyComponent &#x2F;&gt;  &#x2F;&#x2F;大写变量是组件</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    myDivElement,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>JSX 特定属性：</p><ul><li><p>使用引号将属性值指定为字符串字面量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; &lt;div tabIndex&#x3D;&quot;0&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用大括号将属性值指定为 JS 表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const element &#x3D; &lt;img src&#x3D;&#123;user.avatarUrl&#125;&gt;&lt;&#x2F;img&gt;</span><br></pre></td></tr></table></figure></li><li><p>注：在属性中嵌入 JS 表达式时，不要在大括号外面加上引号，要么使用引号（对于字符串），要么使用大括号（对于表达式），对于同一属性不能同时使用两种符号</p></li></ul></li><li><p>JSX 中的注释</p><ul><li><p>单行注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x2F;* 注释内容 *&#x2F;&#125;</span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#x2F;*</span><br><span class="line">    注释</span><br><span class="line">    内容</span><br><span class="line">*&#x2F;&#125;</span><br></pre></td></tr></table></figure></li><li><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;;</span><br><span class="line"></span><br><span class="line">class Hello extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &#x2F;&#x2F;单行注释</span><br><span class="line">        &#x2F;*</span><br><span class="line">        多行</span><br><span class="line">        注释</span><br><span class="line">        *&#x2F;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;&#x2F;*单行注释*&#x2F;&#125;</span><br><span class="line">                &#123;&#x2F;*</span><br><span class="line">                多行</span><br><span class="line">                注释</span><br><span class="line">                *&#x2F;&#125;</span><br><span class="line">                Hello JSX</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;Hello &#x2F;*组件注释*&#x2F; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>由此可见，只是在原本 JS 注释上加括号即可</li></ul></li></ul></li><li><p>JSX 防止注入攻击 —— HTML 转义：ReactDOM 在渲染所有元素前，会默认进行 <a href="https://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html">转义</a>，防止  <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS（cross-site-scripting, 跨站脚本）</a> 攻击，所以如果 JSX 中包含转义后的实体字符，比如 <code>&amp;copy;</code>，最后显示到 DOM 中不会正确显示，因为 React 自动把 <code>&amp;copy;</code> 中的特殊字符转义了。有几种解决办法：</p><ul><li><p>使用对应字符的 Unicode 编码：<a href="http://www.fileformat.info/info/unicode/char/00a9/index.htm">查询编码</a></p></li><li><p>使用数组组装，如：<code>&lt;div&gt;&#123;[&#39;cc &#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39; 2015&#39;]&#125;&lt;/div&gt;</code></p></li><li><p>直接插入原始 HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;__html:</span> &#x27;<span class="attr">cc</span> &amp;<span class="attr">copy</span>; <span class="attr">2015</span>&#x27;&#125;&#125; /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>直接使用 UTF-8 字符</p></li></ul></li><li><p>JSX 与 HTML 的差异：<a href="http://facebook.github.io/react/docs/dom-differences.html">DOM Differences</a></p></li></ol><hr><h2 id="开始使用-JSX！"><a href="#开始使用-JSX！" class="headerlink" title="开始使用 JSX！"></a>开始使用 JSX！</h2><h3 id="使用-JSX-的相关配置"><a href="#使用-JSX-的相关配置" class="headerlink" title="使用 JSX 的相关配置"></a>使用 JSX 的相关配置</h3><ol><li><p>如何使用 JSX 呢，浏览器并不能直接解析 JSX 代码，我们可以引入 <code>Babel</code> 来编译 JSX 代码</p></li><li><p>了解 <code>Babel</code>：<a href="https://babel.docschina.org/">Babel 官网</a></p></li><li><p>新建目录，并初始化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>在目录下新建文件，使其结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|-dist  #打包文件放置目录</span><br><span class="line">|-index.js  #入口文件</span><br><span class="line">|-index.html  #主html文件</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>webpack</code> 与 <code>webpack-cli</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>react</code>  与 <code>react-dom</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react react-dom --save-dev</span><br></pre></td></tr></table></figure></li><li><p>安装 <code>babel-loader、babel-core、babel-preset-env、babel-preset-react</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader @babel&#x2F;core @babel&#x2F;preset-env @babel&#x2F;preset-react --save-dev</span><br></pre></td></tr></table></figure></li><li><p>配置 <code>webpack.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    entry: <span class="string">&#x27;./index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">        path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [&#123;</span><br><span class="line">            test: <span class="regexp">/.\js$/</span>,</span><br><span class="line">            exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">                presets: [<span class="string">&#x27;@babel/preset-env&#x27;</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            loader: <span class="string">&quot;babel-loader&quot;</span>,</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>此时，还需配置一个 babel 规则，新建一个 <code>.babelrc</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.babelrc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>, <span class="string">&quot;@babel/preset-react&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="主文件"><a href="#主文件" class="headerlink" title="主文件"></a>主文件</h3><ol><li><p>现在配置所需要的包已经全部安装，配置文件也已经写好，我们开始编写主文件</p></li><li><p>编写 <code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写 <code>index.js</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &#39;react&#39;;</span><br><span class="line">import ReactDOM from &#39;react-dom&#39;;</span><br><span class="line"></span><br><span class="line">class HelloMessage extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                Hello &#123;this.props.name&#125;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;HelloMessage name&#x3D;&quot;ozzie&quot; &#x2F;&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ol><li><p>现在配置与主文件都完成了，就需要通过打包，来让主文件来使用这些经过打包后的文件：进入根目录，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure><ul><li>进入 <code>/dist</code> 目录，你会发现多出一个 <code>bundle.js</code>，那就是打包后的文件</li></ul></li><li><p>打开 <code>index.html</code>，就能看到我们的结果</p></li></ol><hr><blockquote><p>以上就是初学者需要掌握的 JSX 知识，继续加油吧ヾ(◍°∇°◍)ﾉﾞ</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue-Cli3构建项目</title>
      <link href="22759e22fe38/"/>
      <url>22759e22fe38/</url>
      
        <content type="html"><![CDATA[<h2 id="项目结构浏览"><a href="#项目结构浏览" class="headerlink" title="项目结构浏览"></a>项目结构浏览</h2><p><img src="https://user-images.githubusercontent.com/49378661/86811468-88325b00-c0b0-11ea-91ef-f22e00426f6e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/86811468-88325b00-c0b0-11ea-91ef-f22e00426f6e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1599581-20191216150924667-392102816"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router（四）：重定向，别名与vue-router传参</title>
      <link href="c239d7aef9ab/"/>
      <url>c239d7aef9ab/</url>
      
        <content type="html"><![CDATA[<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><blockquote><p>一般刚进入应用时，都是进入 <code>/</code> 这个根路由的，若想直接由 <code>/</code> 跳转到 <code>/index</code>，有两种方法：</p><p>一是用重定向，二是用 vue-router 的导航式编程，这里我们讲第一种</p></blockquote><ol><li><p>主 html 文件：<code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>path: /<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路由配置文件：<code>/src/router.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Index <span class="keyword">from</span> <span class="string">&quot;./components/Index&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    redirect: <span class="string">&quot;/index&quot;</span>,  <span class="comment">// 重定向到 &quot;/index&quot; 路由</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/index&quot;</span>,</span><br><span class="line">    component: Index</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>路由文件：<code>/src/components/Index.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;index&quot;&gt;</span><br><span class="line">    &lt;p&gt;Index Page&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;index&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，观察效果，发现我们一打开项目，就直接跳转到了 <code>/index</code> 对应的页面</p><ul><li>这就是因为，我在配置路由时，通过 <code>redirect</code> 将路由 <code>/</code> 重定向到了 <code>/index</code>，所以加载时，直接找 <code>/index</code> 对应的那个组件，渲染出来即可</li></ul></li><li><p>也就是说，重定向的意思是：若将 <code>/a</code> 重定向到 <code>/b</code>，则访问 <code>/a</code> 时 URL 会被自动替换为 <code>/b</code>，然后匹配路由为 <code>/b</code></p></li><li><p>上面的案例中，我们初步接触了重定向，现在总结一下重定向的三个常见用法：</p><ul><li><p>用字符串表示重定向的路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">    redirect: <span class="string">&quot;/b&quot;</span>  <span class="comment">// 将 &quot;/a&quot; 重定向到 &quot;/b&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>重定向的目标也可以是一个命名的路由：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">    redirect: &#123; <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>也可以是通过一个方法来动态地返回重定向的目标：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">    redirect: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 &quot;目标路由&quot; 作为参数</span></span><br><span class="line">      <span class="comment">// return 返回重定向的字符串路径或者路径对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>其他的高级用法，请参考：<a href="https://github.com/vuejs/vue-router/blob/dev/examples/redirect/app.js">vue-router/example/redirect</a></p></li></ul></li></ol><hr><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><blockquote><p>别名也重定向的意义有些相反，对比学习即可</p></blockquote><ol><li><p>解释一下什么是 “别名”：若 <code>/a</code> 的别名是 <code>/b</code>，那么就相当于说，<code>/b</code> 的实质匹配路径其实是 <code>/a</code>，也就是，<code>/a</code> 与 <code>/b</code> 的对应的内容都是一样的，只不过当你访问 <code>/b</code> 时，URL 保持 <code>/b</code>，但是匹配路由为 <code>/a</code></p></li><li><p>设置 <code>/a</code> 的别名为 <code>/b</code> 的方法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/a&quot;</span>,</span><br><span class="line">    component: Index,</span><br><span class="line">    alias: <span class="string">&quot;/b&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意，当你设置了 <code>path: &quot;/&quot;</code> 时，再设置别名是不起作用的</li></ul></li><li><p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构</p></li><li><p>更多高级用法请查：<a href="https://github.com/vuejs/vue-router/blob/dev/examples/route-alias/app.js">vue-router/examples/route-alias</a></p></li></ol><hr><h2 id="vue-router参数传递"><a href="#vue-router参数传递" class="headerlink" title="vue-router参数传递"></a>vue-router参数传递</h2><blockquote><p>声明式导航 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 以及编程式导航 <code>router.push(...)</code> 都可以传参，这里主讲前者，同样的规则也适合编程式的导航</p></blockquote><ol><li><p>通过 <code>&lt;router-link&gt;</code>  中的 <code>to</code> 传参，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&quot;</span><span class="attr">xxx</span>&quot;, <span class="attr">params:</span>&#123;<span class="attr">key:value</span>&#125; &#125;&quot;&gt;</span>example<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>name</code> 就是我们在路由配置文件中设置的 name 值</p><ul><li><p>命名路由就是用一个名称来标识路由，在 <code>&lt;router-link&gt;</code> 中设置 name，最后在路由配置时设置对应的 name 即可，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 匹配路由 &quot;/user/123&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name:&quot;</span><span class="attr">user</span>&quot;, <span class="attr">params:</span>&#123;<span class="attr">id:123</span>&#125; &#125;&quot;&gt;</span></span><br><span class="line">  path: &quot;/user/123&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  path: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;user&quot;</span></span><br><span class="line">  component: User,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>params</code> 就是我们要以对象形式传入的参数，最后用 <code>$route.params.键名</code> 的形式进行接收</p></li></ul></li><li><p>通过 <code>name</code> 传参，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">  component: User,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此时我们就可以用 <code>$route.name</code> 来接收值，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;!-- 接收 name 的值 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;$route.name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>URL 传参：在配置文件里以冒号的形式设置参数，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 匹配路由为 &quot;/ozzie/20&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/ozzie/20&quot;</span>&gt;</span>example<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  path: <span class="string">&quot;/:name/:age&quot;</span>,  <span class="comment">// name 接收值为 &quot;ozzie&quot;，age 接收值为 20</span></span><br><span class="line">  component: User</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;!-- 接收由 router.js 传过来的 name 以及 age 的值 --&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;$route.params.name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;$route.params.age&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>正则表达式在 URL 传值中的应用：我们还可以将正则表达式作为参数匹配路由，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  path: <span class="string">&quot;/:name/:age(\\d+)&quot;</span>,  <span class="comment">// 这里的正则使得 age 只能是数字</span></span><br><span class="line">  component: User</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router（三）：编程式导航、命名路由与命名视图</title>
      <link href="f1f5fb8f3c3f/"/>
      <url>f1f5fb8f3c3f/</url>
      
        <content type="html"><![CDATA[<h2 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h2><h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push"></a>router.push</h3><ol><li><p>之前我们都是用过 <code>&lt;router-link&gt;</code> 来定义的导航链接，它会默认会被渲染成一个 <code>&lt;a&gt;</code> 标签，除此之外，我们还可以借助 router 的实例方法实现：<code>router.push(location, &lt;onComplete&gt;, &lt;onAbort&gt;)</code></p><ul><li>注：在 vue 实例中，可以通过 <code>$router</code> 来访问路由实例，所以你也可以调用 <code>this.$router.push</code></li></ul></li><li><p>其实，当你使用 <code>&lt;router-link&gt;</code> 时，本身就会在内部调用 <code>router.push</code> 方法，所以，使用 <code>&lt;router-link to=&quot;...&quot;&gt;</code> 就等同于 <code>router.push(...)</code></p><table><thead><tr><th align="center">声明式</th><th align="center">编程式</th></tr></thead><tbody><tr><td align="center"><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td><td align="center"><code>router.push(...)</code></td></tr></tbody></table></li><li><p><code>router.push()</code> 方法的参数可以是一个字符串路径，也可以是一个描述地址的对象，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li><li><p>如果在方法中存在了 <code>path</code>，那么就不要另外写 <code>params</code>，它会被自动忽略，需要用另一种写法取代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;)  <span class="comment">// /user/123</span></span><br><span class="line"></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;)  <span class="comment">// /user/123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;)  <span class="comment">// /user</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h3><p>该方法的含参形式为：<code>router.replace(location, &lt;onComplete&gt;, &lt;onAbort&gt;)</code>，它与 <code>router.push</code> 方法的区别是：<code>router.push</code> 会向 history 栈中添加一条新纪录，所以当用户点击浏览器后退按钮时可以返回之前的 URL，而 <code>router.replace</code> 不会，它是直接替换掉当前的 history 记录</p><table><thead><tr><th align="center">声明式</th><th align="center">编程式</th></tr></thead><tbody><tr><td align="center"><code>&lt;router-link to=&quot;...&quot; replace&gt;</code></td><td align="center"><code>router.replace(...)</code></td></tr></tbody></table><h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h3><p>该方法的含参形式为 <code>router.go(n)</code>，n 是一个整数，意思是在 history 记录中向前或者向后退多少步，类似于 <code>window.history.go(n)</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(-<span class="number">100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h2><blockquote><p>我们想用一个名称来标识一个路由，这样会更方便一些</p></blockquote><ol><li><p>我们可以在创建 VueRouter 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  path: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line">  name: <span class="string">&quot;user&quot;</span></span><br><span class="line">  component: User,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在使用这种命名路由时，可以给 <code>&lt;router-link&gt;</code> 的 <code>to</code> 属性传递一个对象，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 匹配路由 &quot;/user/123&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;home&#x27;, params: &#123;id: 123&#125;&#125;&quot;</span>&gt;</span>path: &quot;/user/123<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>若使用 <code>router.push</code>，则为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配路同样是 &quot;/user/123&quot;</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&quot;user&quot;</span>, <span class="attr">params</span>: &#123; <span class="attr">id</span>: <span class="number">123</span> &#125;&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><blockquote><p>若你想在同一路由中同时展示多个视图，例如在同一布局中，有 sidebar（侧导航）和 main（主内容）两个视图，就需要命名视图</p><p>使用命名视图可以让你在页面中拥有多个单独命名的视图，而不是像之前那样，只有单一的出口</p></blockquote><h3 id="感受命名视图"><a href="#感受命名视图" class="headerlink" title="感受命名视图"></a>感受命名视图</h3><ol><li><p>主 html 文件：<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello vue-router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对应 /user 匹配路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/&quot;</span>&gt;</span>path: &quot;/user&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对应 /user/:id 匹配路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/home&quot;</span>&gt;</span>path: &quot;/user/foo&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若没有 name 属性，即没有设置名字，则会默认为 default --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view one&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view two&quot;</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">class</span>=<span class="string">&quot;view three&quot;</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路由配置文件：<code>/src/router.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;./components/User&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&quot;./components/Foo&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&quot;./components/Bar&quot;</span>;</span><br><span class="line"><span class="comment">// import Home from &quot;./components/Home&quot;;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    components: &#123;  <span class="comment">// 注意这里是 components</span></span><br><span class="line">      <span class="keyword">default</span>: User,  <span class="comment">// 若没有 name 属性，默认为 User 组件</span></span><br><span class="line">      a: Foo,  <span class="comment">// name=&quot;a&quot; 时渲染 Foo 组件</span></span><br><span class="line">      b: Bar  <span class="comment">// name=&quot;b&quot; 时渲染 Bar 组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line">    components: &#123;  <span class="comment">// 注意这里是 components</span></span><br><span class="line">      <span class="keyword">default</span>: Foo,  <span class="comment">// 若没有 name 属性，默认为 Foo 组件</span></span><br><span class="line">      a: Bar,  <span class="comment">// name=&quot;a&quot; 时渲染 Bar 组件</span></span><br><span class="line">      b: User  <span class="comment">// name=&quot;b&quot; 时渲染 User 组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>一个视图要用一个组件渲染，对应到这里的多个视图，则需要多个组件，注意这里应该是 <code>components</code> 而不是之前的 <code>component</code></li></ul></li><li><p>路由文件：<code>/src/components/</code></p><ul><li><p><code>User.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;h2&gt;User &#123;&#123; this.$route.params.id &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Foo.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    Foo</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Bar.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">    Bar</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动项目，注意观察两个链接对应的样式，以及为什么会出现这种样式</p></li></ol><h3 id="嵌套命名视图"><a href="#嵌套命名视图" class="headerlink" title="嵌套命名视图"></a>嵌套命名视图</h3><blockquote><p>之前我们只是简单地在一个路由中同时展示了多个独立组件</p><p>有时我们在一个路由中，同时展示的组件之间也可能会有嵌套关系，这时同样需要命名嵌套组件</p></blockquote><ol><li><p>这里以一个设置面板为例：</p><p><img src="https://user-images.githubusercontent.com/49378661/82972429-9c8e2d00-a007-11ea-8184-2cbe3c946e47.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82972429-9c8e2d00-a007-11ea-8184-2cbe3c946e47.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1590545629626"></p><ul><li><code>Home</code>：一个视图组件</li><li><code>User</code>：一个常规组件</li><li><code>A</code>、<code>B</code>、<code>C</code> 是嵌套的视图组件</li><li>这里我们可以先不管 CSS 的具体布局样式，专注到组件上</li></ul></li><li><p>主 html 文件：<code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./src/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nested Named Views<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路由配置文件：<code>/src/router.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">&quot;./components/A&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> B <span class="keyword">from</span> <span class="string">&quot;./components/B&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> C <span class="keyword">from</span> <span class="string">&quot;./components/C&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&quot;/user/foo&quot;</span>,</span><br><span class="line">        component: A</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        path: <span class="string">&quot;/user/bar&quot;</span>,</span><br><span class="line">        components: &#123;</span><br><span class="line">          <span class="keyword">default</span>: B,</span><br><span class="line">          other: C</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>路由文件：<code>/src/components/</code></p><ul><li><p><code>Home.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;home&quot; class&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Home&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;User&#x2F;&gt;</span><br><span class="line">    &lt;router-view class&#x3D;&quot;home_A&quot;&#x2F;&gt;</span><br><span class="line">    &lt;router-view class&#x3D;&quot;home_C&quot; name&#x3D;&quot;other&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import User from &quot;.&#x2F;User&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;home&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    User,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>User.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot; class&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;foo&quot;&gt;path: user&#x2F;foo&lt;&#x2F;router-link&gt;</span><br><span class="line">    &lt;br&gt;&lt;br&gt;</span><br><span class="line">    &lt;router-link to&#x3D;&quot;&#x2F;user&#x2F;bar&quot;&gt;path: user&#x2F;bar&lt;&#x2F;router-link&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>A.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;A&quot;&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      This template is A</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;isA&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>B.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      This template is B</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;isB&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>C.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      This template is C</span><br><span class="line">    &lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;isC&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>样式文件：<code>/src/style.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /src/style.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">h2</span> &#123;</span><br><span class="line">  grid-area: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">  grid-template-rows: auto;</span><br><span class="line">  grid-template-areas: </span><br><span class="line">    <span class="string">&quot;header header&quot;</span></span><br><span class="line">    <span class="string">&quot;nav content&quot;</span></span><br><span class="line">    <span class="string">&quot;nav helper&quot;</span></span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.user</span> &#123;</span><br><span class="line">  grid-area: nav;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> dotted;</span><br><span class="line">  <span class="attribute">margin-right</span>: .<span class="number">75rem</span>;</span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">3rem</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home_A</span> &#123;</span><br><span class="line">  grid-area: content;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home_C</span> &#123;</span><br><span class="line">  grid-area: helper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，观察效果……</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router（二）：动态路由与嵌套路由</title>
      <link href="c2bf453959cb/"/>
      <url>c2bf453959cb/</url>
      
        <content type="html"><![CDATA[<h2 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h2><h3 id="响应路由参数的变化"><a href="#响应路由参数的变化" class="headerlink" title="响应路由参数的变化"></a>响应路由参数的变化</h3><blockquote><p>在之前的案例中，每一个路由都对应着一个单独的组件</p><p>现在我们想，在一个组件中，根据不同的路由响应出不同的结果，这就意味着我们需要响应路由参数的变化</p></blockquote><ol><li><p>主 html 文件：<code>index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello vue-router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 不同的路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/foo&quot;</span>&gt;</span>path: &quot;/user/foo&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/bar&quot;</span>&gt;</span>path: &quot;/user/bar&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路由配置文件：<code>/src/router.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;./components/User&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user/:id&quot;</span>,  <span class="comment">// 以 id 为动态路径参数，映射不同的路由</span></span><br><span class="line">    component: User  <span class="comment">// 不同的路由都对应着同一个组件：User</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>响应不同的路由，需要 <strong>动态路径参数（dynamic segment）</strong>，这个参数要以冒号开头，所以主文件中的 <code>/user/foo</code> 与 <code>user/bar</code> 都可以映射到 User 组件中渲染</li></ul></li><li><p>路由文件：<code>/src/component/User.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    User &#123;&#123; this.$route.params.id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>动态路由参数用 <code>:</code> 标记，当匹配到一个路由时（比如 <code>/user/foo</code>），参数值会被设置到 <code>this.$route.params</code>，这个值可以在每一个组件中使用，所以，在 User 组件中，我们可以用 <code>this.$route/params.id</code> 来对应出具体是哪一个组件</li><li>这里的 <code>this.$route.params.id</code> 可以简写为 <code>$route.params.id</code></li></ul></li><li><p>启动项目：<code>npx webpack</code> 或者 <code>npm run dev</code></p></li><li><p>多段路由参数：<br>你可以在一个路由中设置 <strong>多段路由参数</strong>，而且对应的值都会与仅有一个路由参数一样，会被映射到 <code>$route.params</code>，例如：</p><table><thead><tr><th align="left">模式</th><th align="left">匹配路径</th><th align="left"><strong>$route.params</strong></th></tr></thead><tbody><tr><td align="left">/user/:username</td><td align="left">/user/ozzie</td><td align="left">{ username:  ‘ozzie’ }</td></tr><tr><td align="left">/user/:username/age/:age</td><td align="left">/user/ozzie/age/20</td><td align="left">{ username:  ‘ozzie’ , age: 20}</td></tr></tbody></table><ul><li>除了动态参数的值会被设置到 <code>$route.params</code>，还有其他信息，比如 <code>$route.query</code>（对应查询参数），详情请查：<a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">API 文档</a></li></ul></li><li><p>组件实例的复用：</p><ul><li><p>当使用路由参数时，例如上面例子中，从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，原先的组件实例会被复用，因为这两个路由都对应着同一个组件，复用避免了将组件销毁再创建的过程，不过这也使得组件的生命周期钩子不会再被调用</p></li><li><p>但若你想对路由参数的变化做出相应时，可以使用以下两种方法：</p><ul><li><p>监听 <code>$route</code> 的变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    User &#123;&#123; this.$route.params.id &#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    &#39;$route&#39;(to, from) &#123;</span><br><span class="line">      console.log(&quot;changed...&quot;)  &#x2F;&#x2F; 如果路由变化了，则打印此语句</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>beforeRouteUpdate</code> 导航守卫，这个之后进阶概念中会讲到</p></li></ul></li></ul></li></ol><h3 id="捕获所有路由"><a href="#捕获所有路由" class="headerlink" title="捕获所有路由"></a>捕获所有路由</h3><ol><li><p>常规路由匹配是通过 <code>/</code> 分隔的，如果想匹配任意路由，可以使用通配符 <code>*</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;*&quot;</span>,  <span class="comment">// 会匹配所有的路由，通常用于客户端 404 错误</span></span><br><span class="line">    <span class="comment">// component...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user-*&quot;</span>,  <span class="comment">// 会匹配以 &quot;/user-&quot; 开头的任意路由</span></span><br><span class="line">    <span class="comment">// component...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>当使用通配符路由时，需要确保你的路由顺序是正确的 — 含有通配符的路由应该放在最后</p></li><li><p>当使用一个通配符时，<code>$route.params</code> 会自动添加一个 <code>pathMatch</code> 参数，它包含了 URL 通过通配符将被匹配的部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路由为：&#123; path: &quot;*&quot; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$route.push(<span class="string">&quot;/x&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch;  <span class="comment">// &quot;/x&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由为：&#123; path: &quot;/user-*&quot; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$route.push(<span class="string">&quot;/user-admin&quot;</span>);</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch;  <span class="comment">// &quot;admin&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="匹配的优先级"><a href="#匹配的优先级" class="headerlink" title="匹配的优先级"></a>匹配的优先级</h3><p>若同一个路由指向多个组件，那么匹配的优先级就按照路由定义的时间顺序而定，先定义的优先级就高，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    component: UserA</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">    component: UserB</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>那么对于同一路由 <code>/user</code>，对应着的组件就应该是 UserA 而非 UserB</p><hr><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><ol><li><p>实际的开发中，组件之间是相互嵌套的，那么这也对应着按照某种结构嵌套的路由，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;user&#x2F;foo&#x2F;profile                     &#x2F;user&#x2F;foo&#x2F;posts</span><br><span class="line">+------------------+                  +-----------------+</span><br><span class="line">| User             |                  | User            |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">| | Profile      | |  +------------&gt;  | | Posts       | |</span><br><span class="line">| |              | |                  | |             | |</span><br><span class="line">| +--------------+ |                  | +-------------+ |</span><br><span class="line">+------------------+                  +-----------------+</span><br></pre></td></tr></table></figure></li><li><p>接下来我们使用嵌套路由配置来表达这种关系，在这之前，我们得弄明白 <code>&lt;router-view&gt;&lt;/router-view&gt;</code> 的作用：这对标签是最顶层的出口，它用于渲染最高级路由匹配到的组件，所以，类比组件之间使用 <code>component</code> 来相互嵌套，路由之间也可以用 <code>&lt;router-view&gt;</code> 相互嵌套</p></li><li><p>主 html 文件：<code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello vue-router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对应 /user/:id 匹配路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/home&quot;</span>&gt;</span>path: &quot;/user/foo&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对应 /user/:id/foo 匹配路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/:id/foo&quot;</span>&gt;</span>path: &quot;/user/:id/foo&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 对应 /user/:id/bar 匹配路由 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/user/:id/bar&quot;</span>&gt;</span>path: &quot;/user/:id/bar&quot;<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>路由配置文件：<code>/src/router.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&quot;./components/User&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&quot;./components/Foo&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&quot;./components/Bar&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;./components/Home&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/user/:id&quot;</span>,</span><br><span class="line">    component: User,</span><br><span class="line">    <span class="comment">// 使用嵌套路由时，需要在 VueRouter 的参数中使用 children</span></span><br><span class="line">    children: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id 会匹配成功</span></span><br><span class="line">        <span class="comment">// Home 组件会被渲染在 User 组件的 &lt;router-view&gt; 中</span></span><br><span class="line">        path: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        component: Home</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/foo 匹配成功时</span></span><br><span class="line">        <span class="comment">// Foo 组件会被渲染在 User 组件的 &lt;router-view&gt; 中</span></span><br><span class="line">        path: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">        component: Foo</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 当 /user/:id/bar 匹配成功时</span></span><br><span class="line">        <span class="comment">// Bar 组件会被渲染在 User 组件的 &lt;router-view&gt; 中</span></span><br><span class="line">        path: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">        component: Bar</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>路由文件：</p><ul><li><p><code>User.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;user&quot;&gt;</span><br><span class="line">    &lt;h2&gt;User &#123;&#123; this.$route.params.id &#125;&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;&#x2F;router-view&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;user&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Home.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;home&quot;&gt;</span><br><span class="line">    Home</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;home&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Foo.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    Foo</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>Bar.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">    Bar</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动项目：<code>npx webpack</code> 或者 <code>npm run dev</code></p><ul><li>点击不同的链接，注意显示的内容</li></ul></li><li><p>以 <code>/</code> 开头的嵌套路径会被当作根路径，所以在使用嵌套组件时无需设置嵌套的根路径</p></li><li><p><code>children</code> 的配置就类似于 <code>route</code> 的配置那样，都是数组中嵌套着多重配置对象，所以可以用类似的方法嵌套多重路由</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-router（一）：初识vue-router</title>
      <link href="7285f87f8102/"/>
      <url>7285f87f8102/</url>
      
        <content type="html"><![CDATA[<h2 id="配置项目"><a href="#配置项目" class="headerlink" title="配置项目"></a>配置项目</h2><ol><li><p>创建一个目录 <code>project</code>，并进入，新建几个目录与文件，最后整个 demo 目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-project # 根目录</span><br><span class="line">  |-index.html # 主html文件</span><br><span class="line">  |-dist # 打包文件放置目录</span><br><span class="line">  |-src # 资源文件目录</span><br><span class="line">    |-router.js # 打包入口文件，写路由的文件</span><br><span class="line">    |-components # 单文件组件目录</span><br><span class="line">      |-Foo.vue # 路由组件</span><br><span class="line">      |-Bar.vue # 路由组件</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令初始化 <code>package.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>安装项目依赖：（这里我直接给出 <code>package.json</code> 文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.17&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.26.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span>: <span class="string">&quot;^7.1.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-env&quot;</span>: <span class="string">&quot;^1.7.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-stage-0&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-stage-3&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cross-env&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^1.1.11&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node-sass&quot;</span>: <span class="string">&quot;^4.9.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sass-loader&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.21.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url-loader&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-loader&quot;</span>: <span class="string">&quot;^14.2.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-router&quot;</span>: <span class="string">&quot;^3.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-style-loader&quot;</span>: <span class="string">&quot;^4.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.5.17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^4.16.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.1.5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复制此文件，你可以直接运行 <code>npm install</code></li></ul></li><li><p>配置 webpack：根目录下新建 <code>webpack.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  <span class="comment">//node中的path对象，用于处理目录的对象</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/router&#x27;</span>,  <span class="comment">//入口文件地址</span></span><br><span class="line">  output: &#123;  <span class="comment">//输出</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>),  <span class="comment">//打包输出文件的地址，使用绝对路径</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">//webpack打包后的文件名</span></span><br><span class="line">    publicPath: <span class="string">&#x27;/dist/&#x27;</span>,  <span class="comment">//公共文件生成的地址</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [  <span class="comment">//加载器loader</span></span><br><span class="line">      &#123;  <span class="comment">//编译css</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译scss</span></span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译sass</span></span><br><span class="line">        test: <span class="regexp">/\.sass$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader?indentedSyntax&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译.vue文件</span></span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">            <span class="string">&#x27;scss&#x27;</span>: [</span><br><span class="line">              <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&#x27;sass&#x27;</span>: [</span><br><span class="line">              <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;sass-loader?indentedSyntax&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//转换es6语法</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [[<span class="string">&#x27;env&#x27;</span>, &#123;<span class="attr">modules</span>: <span class="literal">false</span>&#125;], <span class="string">&#x27;stage-0&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//图片转化</span></span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;  <span class="comment">//别名，可以直接使用别名来代表设定的路径以及其他</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">      filter: path.join(__dirname, <span class="string">&#x27;./src/filters&#x27;</span>),</span><br><span class="line">      components: path.join(__dirname, <span class="string">&#x27;./src/components&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//require时省略的扩展名，如require(&#x27;module&#x27;)不需要写成require(&#x27;module.js&#x27;)</span></span><br><span class="line">    extensions: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;  <span class="comment">//服务器配置相关，以实现自动刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//开启source-map，webpack有多种source-map，在官网文档中可以查到</span></span><br><span class="line">  devtool: <span class="string">&#x27;#eval-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="初次感受-vue-router"><a href="#初次感受-vue-router" class="headerlink" title="初次感受 vue-router"></a>初次感受 vue-router</h2><blockquote><p>需要的配置已经完成了，现在开始编写各文件</p></blockquote><ol><li><p>主 html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello vue-router<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 使用 router-link 组件来导航 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 通过 &quot;to&quot; 来指定链接 --&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染为一个 &lt;a&gt; 标签 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/foo&quot;</span>&gt;</span>Go to Foo<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/bar&quot;</span>&gt;</span>Go to Bar<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由匹配到的组件将被渲染到这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写入口文件 <code>router.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/router.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模块</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;  <span class="comment">// 导入 vue</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;  <span class="comment">// 导入 vue-router</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入组件，一个组件一个路由</span></span><br><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">&quot;./components/Foo&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Bar <span class="keyword">from</span> <span class="string">&quot;./components/Bar&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);  <span class="comment">// 路由插件必须在 vue 中注册才能使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [  <span class="comment">// 定义路由</span></span><br><span class="line">  <span class="comment">// 每个路由应该映射一个组件</span></span><br><span class="line">  <span class="comment">// component 可以是用 vue.extend() 创建的组件构造器或者一个组件配置对象</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/foo&quot;</span>,</span><br><span class="line">    component: Foo</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&quot;/bar&quot;</span>,</span><br><span class="line">    component: Bar</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;  <span class="comment">// 创建一个 VueRouter 实例，传入 routes 配置</span></span><br><span class="line">  routes,  <span class="comment">// 相当于 routes: routes</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;  <span class="comment">// 创建和挂载根实例</span></span><br><span class="line">  <span class="comment">// 记得要通过 router 配置参数注入路由，从而让整个应用都有路由功能</span></span><br><span class="line">  router</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>编写两个组件文件，分别对应两个路由：</p><ul><li><p><code>/src/components/Foo.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;foo&quot;&gt;</span><br><span class="line">    Foo</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;foo&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>/src/components/Bar.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;bar&quot;&gt;</span><br><span class="line">    Bar</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;bar&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>启动项目：</p><ul><li>可以用 <code>npx webpack</code> 先将文件编译为静态文件，再打开 <code>index.html</code></li><li>也可以用 <code>npm run dev</code> 打开一个端口热加载此项目</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue-router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex教程（三）：TodoList案例</title>
      <link href="be60763b1592/"/>
      <url>be60763b1592/</url>
      
        <content type="html"><![CDATA[<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><ol><li><p>需要安装的依赖包：<code>vuex</code>、<code>axios</code>、<code>ant-design-vue</code>，vuex 我们已经有了，需要安装另外两个：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios ant-design-vue --save-dev</span><br></pre></td></tr></table></figure></li><li><p>我们承接之前创建过的项目，删除 <code>/src/components</code> 文件夹，清空 <code>/src/App.vue</code> 以及 <code>/src/store/index.js</code> 中的代码</p></li></ol><hr><h3 id="项目的基本-UI-结构"><a href="#项目的基本-UI-结构" class="headerlink" title="项目的基本 UI 结构"></a>项目的基本 UI 结构</h3><h4 id="主文件-src-main-js"><a href="#主文件-src-main-js" class="headerlink" title="主文件 /src/main.js"></a>主文件 <code>/src/main.js</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 ant-design-vue 组件库</span></span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span></span><br><span class="line"><span class="comment">// 导入组件库的样式表</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;ant-design-vue/dist/antd.css&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Vue.use(Antd)  <span class="comment">// 安装组件库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="组件文件-src-App-vue"><a href="#组件文件-src-App-vue" class="headerlink" title="组件文件 /src/App.vue"></a>组件文件 <code>/src/App.vue</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;a-input placeholder&#x3D;&quot;请输入任务&quot; class&#x3D;&quot;my_ipt&quot; &#x2F;&gt;</span><br><span class="line">    &lt;a-button type&#x3D;&quot;primary&quot;&gt;添加事项&lt;&#x2F;a-button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a-list bordered :dataSource&#x3D;&quot;list&quot; class&#x3D;&quot;dt_list&quot;&gt;</span><br><span class="line">      &lt;a-list-item slot&#x3D;&quot;renderItem&quot; slot-scope&#x3D;&quot;item&quot;&gt;</span><br><span class="line">        &lt;!-- 复选框 --&gt;</span><br><span class="line">        &lt;a-checkbox&gt;&#123;&#123;item.info&#125;&#125;&lt;&#x2F;a-checkbox&gt;</span><br><span class="line">        &lt;!-- 删除链接 --&gt;</span><br><span class="line">        &lt;a slot&#x3D;&quot;actions&quot;&gt;删除&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;a-list-item&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!-- footer区域 --&gt;</span><br><span class="line">      &lt;div slot&#x3D;&quot;footer&quot; class&#x3D;&quot;footer&quot;&gt;</span><br><span class="line">        &lt;!-- 未完成的任务个数 --&gt;</span><br><span class="line">        &lt;span&gt;0条剩余&lt;&#x2F;span&gt;</span><br><span class="line">        &lt;!-- 操作按钮 --&gt;</span><br><span class="line">        &lt;a-button-group&gt;</span><br><span class="line">          &lt;a-button type&#x3D;&quot;primary&quot;&gt;全部&lt;&#x2F;a-button&gt;</span><br><span class="line">          &lt;a-button&gt;未完成&lt;&#x2F;a-button&gt;</span><br><span class="line">          &lt;a-button&gt;已完成&lt;&#x2F;a-button&gt;</span><br><span class="line">        &lt;&#x2F;a-button-group&gt;</span><br><span class="line">        &lt;!-- 把已经完成的任务清空 --&gt;</span><br><span class="line">        &lt;a&gt;清除已完成&lt;&#x2F;a&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;a-list&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    name: &#39;app&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        list: [</span><br><span class="line">          &#123;</span><br><span class="line">            id: 0,</span><br><span class="line">            info: &#39;任务A&#39;,</span><br><span class="line">            done: false</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; id: 1, info: &#39;任务B&#39;, done: false &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            id: 2,</span><br><span class="line">            info: &#39;任务C&#39;,</span><br><span class="line">            done: false</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123; id: 3, info: &#39;任务D&#39;, done: false &#125;,</span><br><span class="line">          &#123; id: 4, info: &#39;任务E&#39;, done: false &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  #app &#123;</span><br><span class="line">    padding: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .my_ipt &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    margin-right: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .dt_list &#123;</span><br><span class="line">    width: 500px;</span><br><span class="line">    margin-top: 10px;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .footer &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">    align-items: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>用 <code>npm run serve</code> 启动，如下：</p><p><img src="https://user-images.githubusercontent.com/49378661/82122504-ad000580-97c6-11ea-95a8-f62858bb8695.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122504-ad000580-97c6-11ea-95a8-f62858bb8695.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1588997135918"></p><hr><h3 id="逻辑实现"><a href="#逻辑实现" class="headerlink" title="逻辑实现"></a>逻辑实现</h3><h4 id="列表数据的动态加载"><a href="#列表数据的动态加载" class="headerlink" title="列表数据的动态加载"></a>列表数据的动态加载</h4><blockquote><p>目的：上面的列表数据都是已经写死了的，现在我们要将数据专门放到一个 json 文件中，再通过 axios 动态获取</p></blockquote><ol><li><p>将 <code>App.vue</code> 中的 <code>list</code> 清空，再在 <code>public</code> 目录下新建 <code>list.json</code> 文件，粘贴原 list 中的元素，即：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /public/list.json</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务A&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务B&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务C&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务D&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务E&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>我们将通过 <code>axios</code> 请求 <code>list.json</code>，将数据挂载到 store 中进行存储，需要注意，axios 发起请求是一个异步操作，所以我们要将获取数据的异步操作定义到 actions 中，所以我们打开 <code>/store/index.js</code>，导入 axios 并添加 actions 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">getList</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">        axios.get(<span class="string">&#x27;../../list.json&#x27;</span>).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(data)  <span class="comment">// 测验是否拿到数据</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>App.vue</code> 中调用 actions 中的 getList 函数，并且由于获取数据需要最开始执行，所以我们新建一个生命周期函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;getList&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，打开控制台，结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/82122509-b9845e00-97c6-11ea-9c28-f1d8b1eafa26.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122509-b9845e00-97c6-11ea-9c28-f1d8b1eafa26.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589617423242"></p></li></ol><ul><li>这说明数据请求成功</li></ul><ol start="5"><li><p>现在需要将拿到的数据放在 state 中存储，我们通过在 actions 中调用对应的 mutations 来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line">  list: []  <span class="comment">// 所有的任务列表</span></span><br><span class="line">&#125;,</span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">initList</span>(<span class="params">state, list</span>)</span> &#123;  <span class="comment">// 第一个参数只能是 state</span></span><br><span class="line">    state.list = list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">getList</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    axios.get(<span class="string">&quot;../../list.json&quot;</span>).then(<span class="function">(<span class="params">&#123;data&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将 data 传给 initList</span></span><br><span class="line">      context.commit(<span class="string">&quot;initList&quot;</span>, data) </span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把整个 list 存储到了 list 中，打开控制台，查看 vuex 状态如下：<br><img src="https://user-images.githubusercontent.com/49378661/82122517-c5702000-97c6-11ea-91d1-3195309ddfdd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122517-c5702000-97c6-11ea-91d1-3195309ddfdd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589623544105"></p></li></ol><ol start="6"><li><p>现在 state 中已经存在了 list，现在我们将 list 渲染到 App 组件中，现在我们将 state 中的 list 映射到组件中，即可使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;getList&quot;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&quot;list&quot;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，渲染成功：<br><img src="https://user-images.githubusercontent.com/49378661/82122525-cc972e00-97c6-11ea-9c1a-b807ce2ab26b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122525-cc972e00-97c6-11ea-9c1a-b807ce2ab26b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589630382508"></p></li></ol><h4 id="文本输入框的双向同步"><a href="#文本输入框的双向同步" class="headerlink" title="文本输入框的双向同步"></a>文本输入框的双向同步</h4><blockquote><p>目的：在文本输入框输入内容时，state 中的数据可以同步更新</p></blockquote><ol><li><p>在 state 中新增一条状态，用于监听输入内容，并映射到组件中，并在 input 中绑定值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line">  <span class="comment">// 所有的任务列表</span></span><br><span class="line">  list: [],</span><br><span class="line">  <span class="comment">// 文本框的内容，并赋初值</span></span><br><span class="line">  inputValue: <span class="string">&quot;something...&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&quot;list&quot;</span>, <span class="string">&quot;inputValue&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入任务&quot;</span> <span class="attr">class</span>=<span class="string">&quot;my_ipt&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;inputValue&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>启动项目，查看结果：<br><img src="https://user-images.githubusercontent.com/49378661/82122527-d6b92c80-97c6-11ea-804e-10765aed8595.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122527-d6b92c80-97c6-11ea-804e-10765aed8595.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589631466499"></p></li></ol><ul><li>输入框中默认出现了 “something”</li></ul><ol start="2"><li><p>为文本框绑定输入事件，并在方法中定义该事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入任务&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">class</span>=<span class="string">&quot;my_ipt&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">:value</span>=<span class="string">&quot;inputValue&quot;</span></span></span><br><span class="line"><span class="tag">         @<span class="attr">change</span>=<span class="string">&quot;handleInputChange&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;  <span class="comment">// e 是事件参数</span></span><br><span class="line">    <span class="comment">// 拿到输入框中的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义函数来改变 store 中的 inputValue 值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="function"><span class="title">initList</span>(<span class="params">state, list</span>)</span> &#123;  <span class="comment">// 第一个参数只能是 state</span></span><br><span class="line">    state.list = list</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">setInputValue</span>(<span class="params">state, value</span>)</span> &#123;</span><br><span class="line">    state.inputValue = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再在函数中触发 setInputValue 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">handleInputChange</span>(<span class="params">e</span>)</span> &#123;  <span class="comment">// e 是事件参数</span></span><br><span class="line">    <span class="comment">// 拿到输入框中的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value);</span><br><span class="line">    <span class="comment">// 触发 setInputValue 函数</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;setInputValue&quot;</span>, e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/82122535-df116780-97c6-11ea-8be8-7e1e058ba315.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122535-df116780-97c6-11ea-8be8-7e1e058ba315.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589633036898"></p></li></ol><h4 id="点击添加事项"><a href="#点击添加事项" class="headerlink" title="点击添加事项"></a>点击添加事项</h4><blockquote><p>目的：点击 “添加事项” 即能新增一个任务项</p></blockquote><ol><li><p>在按钮处添加事件，并在方法中写入事件内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;addItemToList&quot;</span>&gt;</span>添加事项<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>如果用户输入为空的话，那么不应该添加该项，否则就应该触发 mutations 中的函数来添加新的项：<br>（下面的 addItem 我们待会儿会定义，现在先写着）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">addItemToList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果用户输入内容为空，则不应该添加此项</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.inputValue.trim().length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 弹出一个警告框，表示不能为空</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$message.warning(<span class="string">&quot;文本框内容不能为空&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则就触发 mutations 中的函数 addItem</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addItem&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>之前我们的数据中，id 最大值为4，那么新的项的 id 应该为5：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line">  <span class="comment">// 下一个 id</span></span><br><span class="line">  nextId: <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义 addItem 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 添加列表项</span></span><br><span class="line">  <span class="function"><span class="title">addItem</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;  <span class="comment">// 定义一个对象用来存储新的项</span></span><br><span class="line">      id: state.nextId,  <span class="comment">// id 为新的 id</span></span><br><span class="line">      info: state.inputValue.trim(),  <span class="comment">// 内容为输入内容</span></span><br><span class="line">      done: <span class="literal">false</span>  <span class="comment">// 完成状态初始设置为未完成</span></span><br><span class="line">    &#125;</span><br><span class="line">    state.list.push(obj)  <span class="comment">// 在 list 中添加新的项</span></span><br><span class="line">    state.nextId ++  <span class="comment">// 新的 id 自增，为继续添加项做准备</span></span><br><span class="line">    state.inputValue = <span class="string">&quot;&quot;</span>  <span class="comment">// 清空输入框</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，点击 “添加事项”，查看结果：</p><ul><li><p>点击前：<br><img src="https://user-images.githubusercontent.com/49378661/82122527-d6b92c80-97c6-11ea-804e-10765aed8595.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82122527-d6b92c80-97c6-11ea-804e-10765aed8595.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589631466499"></p></li><li><p>点击后：<br><img src="https://user-images.githubusercontent.com/49378661/82186133-f5313c00-991c-11ea-921d-c04f3e6504a3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186133-f5313c00-991c-11ea-921d-c04f3e6504a3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589678836135"></p></li></ul></li></ol><ul><li>当输入框为空，我仍然点击 “添加事项” 时，会弹出警告框：<br><img src="https://user-images.githubusercontent.com/49378661/82186153-ff533a80-991c-11ea-9a23-5a6cc51c05a0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186153-ff533a80-991c-11ea-9a23-5a6cc51c05a0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589678953903"></li></ul><h4 id="删除对应事项"><a href="#删除对应事项" class="headerlink" title="删除对应事项"></a>删除对应事项</h4><blockquote><p>目的：点击 ”删除“，既能删除对应项</p></blockquote><ol><li><p>在按钮中添加删除元素事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">&quot;actions&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;deleteItemById(item.id)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在方法中定义事件，触发 mutations 中的函数（并给该函数传入参数 id）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 根据 id 删除 item 项</span></span><br><span class="line">  <span class="function"><span class="title">deleteItemById</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 触发 deleteItem 函数，并传参为 id</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;deleteItem&quot;</span>, id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义 deleteItem 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 删除列表项</span></span><br><span class="line">  <span class="function"><span class="title">deleteItem</span>(<span class="params">state, id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 id 来查找对应项的索引</span></span><br><span class="line">    <span class="comment">// 如果未找到，那么 findIndex 方法会返回给 index 的值为 -1</span></span><br><span class="line">    <span class="keyword">const</span> index = state.list.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line">    <span class="comment">// 根据索引查找对应元素</span></span><br><span class="line">    <span class="keyword">if</span>(index != -<span class="number">1</span>) &#123;  <span class="comment">// 找到就删除</span></span><br><span class="line">      state.list.splice(index, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，查看结果：点击 “删除” 检验</p></li></ol><h4 id="复选框状态的绑定"><a href="#复选框状态的绑定" class="headerlink" title="复选框状态的绑定"></a>复选框状态的绑定</h4><blockquote><p>目的：将每一项的状态（“完成” 或者 “未完成”）与页面上的复选框做绑定</p></blockquote><ol><li><p>打开 <code>/public/list.json</code> 文件，目前所有的项的状态我们都默认为 “未完成”，即 <code>&quot;done&quot;: false</code>，现在我们手动定义两个已完成的项：我们将前面两项改为 <code>&quot;done&quot;: true</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /public/list.json</span></span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务A&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;done&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务B&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;done&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务C&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务D&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">&quot;info&quot;</span>: <span class="string">&quot;任务E&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;done&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在 <code>App.vue</code> 中，给复选框绑定一个值，来判断该项的状态：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-checkbox</span> <span class="attr">:checked</span>=<span class="string">&quot;item.done&quot;</span>&gt;</span>&#123;&#123;item.info&#125;&#125;<span class="tag">&lt;/<span class="name">a-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动项目，前面两项已选中：<br><img src="https://user-images.githubusercontent.com/49378661/82186199-0ed28380-991d-11ea-9343-6c40aeec8148.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186199-0ed28380-991d-11ea-9343-6c40aeec8148.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589760526788"></p></li><li><p>现在我们来完成修改任务状态的功能</p></li><li><p>给复选框绑定一个事件，监听变化：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-checkbox</span> <span class="attr">:checked</span>=<span class="string">&quot;item.done&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">change</span>=<span class="string">&quot;checkedChange($event, item.id)&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;item.info&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">a-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 methods 中定义该方法，并触发 mutation 函数，传参为该项的 id，以此来改变 state 中 done 的状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 根据 id 改变复选框</span></span><br><span class="line">  <span class="function"><span class="title">checkedChange</span>(<span class="params">e, id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;changeChecked&quot;</span>, id)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义 changeChecked 函数，改变状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 改变复选框状态</span></span><br><span class="line">  <span class="function"><span class="title">changeChecked</span>(<span class="params">state, id</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 根据 id 来查找对应项的索引</span></span><br><span class="line">    <span class="comment">// 如果未找到，那么 findIndex 方法会返回给 index 的值为 -1</span></span><br><span class="line">    <span class="keyword">const</span> index = state.list.findIndex(<span class="function"><span class="params">item</span> =&gt;</span> item.id === id)</span><br><span class="line">    <span class="comment">// 根据索引查找对应元素</span></span><br><span class="line">    <span class="keyword">if</span>(index != -<span class="number">1</span>) &#123;  <span class="comment">// 找到就改变状态</span></span><br><span class="line">      state.list[id].done = !state.list[id].done</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，之前是前两项勾选，现在取消前两项勾选，并勾选第三项<br><img src="https://user-images.githubusercontent.com/49378661/82186238-1bef7280-991d-11ea-89d3-e89614256ef5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186238-1bef7280-991d-11ea-89d3-e89614256ef5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589764286472"></p></li></ol><h4 id="统计未完成的任务条数"><a href="#统计未完成的任务条数" class="headerlink" title="统计未完成的任务条数"></a>统计未完成的任务条数</h4><blockquote><p>目的：统计出 “未完成” 状态的任务项的条数，并渲染该数据</p></blockquote><ol><li><p>之前介绍过，getters 起着一个装饰的作用，类似于组件中的计算属性，现在我们就借助 getters 完成此功能</p></li><li><p>在 store 中定义一个 getters 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">unDoneLength</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// 过滤出未完成的项，返回已完成的项的个数</span></span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.done===<span class="literal">false</span>).length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>映射为组件的计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按需导入 mapGetters 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义计算属性</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapGetters([<span class="string">&quot;unDoneLength&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在组件中使用该值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;unDoneLength&#125;&#125;条剩余<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动项目，查看结果：<br><img src="https://user-images.githubusercontent.com/49378661/82186276-2a3d8e80-991d-11ea-9440-f99730e06588.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186276-2a3d8e80-991d-11ea-9440-f99730e06588.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589765030221"></p></li></ol><h4 id="清楚已完成的任务项"><a href="#清楚已完成的任务项" class="headerlink" title="清楚已完成的任务项"></a>清楚已完成的任务项</h4><blockquote><p>目的：点击 “清除已完成”，即会清除所有的完成项</p></blockquote><ol><li><p>给 “清除已完成” 链接绑定事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;clean&quot;</span>&gt;</span>清除已完成<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 methods 中定义该方法，并触发 mutation 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 清楚已完成项</span></span><br><span class="line">  <span class="function"><span class="title">clean</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;cleanDone&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义该函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 清除已完成项</span></span><br><span class="line">  <span class="function"><span class="title">cleanDone</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 过滤掉已完成的项，返回未完成的项</span></span><br><span class="line">    state.list = state.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.done===<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目，查看结果：之前默认是前两项勾选，现在我点击 “清除已完成”，得到结果：<br><img src="https://user-images.githubusercontent.com/49378661/82186316-3cb7c800-991d-11ea-9044-eae78a9bd69e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186316-3cb7c800-991d-11ea-9044-eae78a9bd69e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589765848882"></p></li></ol><h4 id="底部样式的切换"><a href="#底部样式的切换" class="headerlink" title="底部样式的切换"></a>底部样式的切换</h4><blockquote><p>目的：现在只有底部的 “全部” 按钮才有高亮显示，其余按钮没有样式，现在我们要实现点击就切换高亮显示</p></blockquote><ol><li><p>在三个按钮中添加事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-button-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;all&#x27;)&quot;</span>&gt;</span>全部<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;unDone&#x27;)&quot;</span>&gt;</span>未完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">type</span>=<span class="string">&quot;default&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;done&#x27;)&quot;</span>&gt;</span>已完成<span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a-button-group</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注：&quot;primary&quot;表示有高亮样式，&quot;default&quot;表示没有高亮样式 --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 state 中定义不同的数据列表：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">state: &#123;</span><br><span class="line">  viewKey: <span class="string">&quot;all&quot;</span>  <span class="comment">// 默认为全部数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 methods 中定义方法，触发 mutation 函数，并传入参数 key：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 修改页面上的显示列表</span></span><br><span class="line">  <span class="function"><span class="title">changeStyle</span>(<span class="params">key</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&quot;changeView&quot;</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 mutations 中定义函数 changeStyle，并修改 state 中 viewKey 的值为 key：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;</span><br><span class="line">  <span class="comment">// 修改视图的关键字</span></span><br><span class="line">  <span class="function"><span class="title">changeView</span>(<span class="params">state, key</span>)</span> &#123;</span><br><span class="line">    state.viewKey = key</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射为组件的计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line"> computed: &#123;</span><br><span class="line">   ...mapState([<span class="string">&quot;list&quot;</span>, <span class="string">&quot;inputValue&quot;</span>, <span class="string">&quot;viewKey&quot;</span>])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>用三元表达式为每个按钮设置样式，确定是否高亮显示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-button-group</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">&quot;viewKey===&#x27;all&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;all&#x27;)&quot;</span>&gt;</span></span><br><span class="line">      全部</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">&quot;viewKey===&#x27;unDone&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;unDone&#x27;)&quot;</span>&gt;</span></span><br><span class="line">      未完成</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a-button</span> <span class="attr">:type</span>=<span class="string">&quot;viewKey===&#x27;done&#x27;?&#x27;primary&#x27;:&#x27;default&#x27;&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;changeStyle(&#x27;done&#x27;)&quot;</span>&gt;</span></span><br><span class="line">      已完成</span><br><span class="line">  <span class="tag">&lt;/<span class="name">a-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a-button-group</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击样式查看结果：</p><ul><li>点击 “未完成”：<br><img src="https://user-images.githubusercontent.com/49378661/82186338-43463f80-991d-11ea-975b-29baefb8599d.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186338-43463f80-991d-11ea-975b-29baefb8599d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589772681690"></li></ul></li></ol><ul><li>点击 “已完成”：<br><img src="https://user-images.githubusercontent.com/49378661/82186341-46413000-991d-11ea-9136-47ff646b2182.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82186341-46413000-991d-11ea-9136-47ff646b2182.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1589772696402"></li></ul><h4 id="列表数据的切换"><a href="#列表数据的切换" class="headerlink" title="列表数据的切换"></a>列表数据的切换</h4><blockquote><p>目的：现在我们绑定的数据源是 state 中的 list，不管你点击 “未完成” 还是 “已完成”，都会显示全部数据，所以现在我们要按需渲染出列表数据</p><p>我们借助 getters 来显示需要的数据</p></blockquote><ol><li><p>在 getters 中定义函数，实现按需返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /store/index.js</span></span><br><span class="line"></span><br><span class="line">getters: &#123;</span><br><span class="line">  <span class="function"><span class="title">infoList</span>(<span class="params">state</span>)</span> &#123;  <span class="comment">// 根据按钮返回对应的数据</span></span><br><span class="line">    <span class="keyword">if</span>(state.viewKey === <span class="string">&quot;all&quot;</span>) &#123;  <span class="comment">// 全部</span></span><br><span class="line">      <span class="keyword">return</span> state.list</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(state.viewKey === <span class="string">&quot;unDone&quot;</span>) &#123;  <span class="comment">// 未完成</span></span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.done===<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(state.viewKey === <span class="string">&quot;done&quot;</span>) &#123;  <span class="comment">// 已完成</span></span><br><span class="line">      <span class="keyword">return</span> state.list.filter(<span class="function"><span class="params">item</span> =&gt;</span> item.done===<span class="string">&quot;unDone&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>映射为组件的计算属性，另外，由于我们将用 infoList 代替 list，所以计算属性中映射的 list 可以删除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.vue</span></span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  ...mapState([<span class="string">&quot;inputValue&quot;</span>, <span class="string">&quot;viewKey&quot;</span>]),</span><br><span class="line">  ...mapGetters([<span class="string">&quot;unDoneLength&quot;</span>, <span class="string">&quot;infoList&quot;</span>])</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>将数据源由 list 切换为 infoList：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- App.vue --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a-list</span> <span class="attr">bordered</span> <span class="attr">:dataSource</span>=<span class="string">&quot;infoList&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dt_list&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ...此处内容省略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a-list</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="整体代码："><a href="#整体代码：" class="headerlink" title="整体代码："></a>整体代码：</h3><p>以上便是此 demo 的详细说明，下面直接给出全部代码：<a href="https://github.com/OzzieNicholas/vuex-todolist">vuex-todolist</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex教程（二）：几大核心概念</title>
      <link href="75f824da8763/"/>
      <url>75f824da8763/</url>
      
        <content type="html"><![CDATA[<h2 id="核心概念概述"><a href="#核心概念概述" class="headerlink" title="核心概念概述"></a>核心概念概述</h2><p>vuex 的核心概念如下：</p><ul><li>State</li><li>Mutation</li><li>Action</li><li>Getter</li></ul><hr><h2 id="State"><a href="#State" class="headerlink" title="State"></a>State</h2><h3 id="认识state"><a href="#认识state" class="headerlink" title="认识state"></a>认识state</h3><p>state 提供唯一的公共数据源，所有共享的数据都要放在 store 的 state 中进行存储</p><h3 id="创建-state"><a href="#创建-state" class="headerlink" title="创建 state"></a>创建 state</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 store 数据源，提供唯一的公共数据</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;  <span class="comment">// 创建一个新的 store 实例对象</span></span><br><span class="line">    state: &#123;  <span class="comment">// store 的 state 属性用来创建公共数据源</span></span><br><span class="line">        count: <span class="number">0</span>  <span class="comment">// state 中的这些数据就是需要全局共享的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件访问-state-中的数据"><a href="#组件访问-state-中的数据" class="headerlink" title="组件访问 state 中的数据"></a>组件访问 state 中的数据</h3><h4 id="方式一：this-store-state-全局数据名称"><a href="#方式一：this-store-state-全局数据名称" class="headerlink" title="方式一：this.$store.state.全局数据名称"></a>方式一：this.$store.state.全局数据名称</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br><span class="line"><span class="comment">// 组件中的 &lt;template&gt; 部分里面省略 this，直接写成 $store.state.全局数据名称</span></span><br></pre></td></tr></table></figure><h4 id="方式二：映射为计算属性"><a href="#方式二：映射为计算属性" class="headerlink" title="方式二：映射为计算属性"></a>方式二：映射为计算属性</h4><ol><li><p>从 vuex 中按需导入 mapState 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过刚才导入的 mapState 函数，将当前组件需要的全局数据，映射为当前组件的 computed 计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&quot;count&quot;</span>])  <span class="comment">// 将 count 映射为计算属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当有多个全局数据要导出的时候，建议用这一种方式</p></li></ol><hr><h2 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h2><h3 id="认识-mutation"><a href="#认识-mutation" class="headerlink" title="认识 mutation"></a>认识 mutation</h3><ol><li>不能用方法来改变全局数据，vue 不允许组件直接修改 store 中的数据</li><li>只能通过 mutation 来变更 store 中的数据，不可以直接操作 store 中的数据</li><li>虽然这种方式操作起来稍微繁琐，但是可以集中监控所有数据的变化</li><li>不能在 mutations 函数中执行异步操作</li></ol><h3 id="定义-mutation"><a href="#定义-mutation" class="headerlink" title="定义 mutation"></a>定义 mutation</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;  <span class="comment">//此对象里面可以定义很多的事件处理函数</span></span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            <span class="comment">//变更状态: count += 1</span></span><br><span class="line">            state.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在组件中调用-mutations-中的函数"><a href="#在组件中调用-mutations-中的函数" class="headerlink" title="在组件中调用 mutations 中的函数"></a>在组件中调用 mutations 中的函数</h3><h4 id="方式一：this-store-commit-“函数名”"><a href="#方式一：this-store-commit-“函数名”" class="headerlink" title="方式一：this.$store.commit(“函数名”)"></a>方式一：this.$store.commit(“函数名”)</h4><p>触发 mutations 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// &quot;add&quot;即为 mutations 中的函数名</span></span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&quot;add&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向 mutations 函数中传递参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 mutations 函数</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 变更状态: count += step</span></span><br><span class="line">            state.count += step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 mutations 函数</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 用 commit 函数触发 mutations 函数时传递参数</span></span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&quot;addN&quot;</span>, <span class="number">3</span>)  <span class="comment">// 向 addN 函数传参为3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：映射为方法"><a href="#方式二：映射为方法" class="headerlink" title="方式二：映射为方法"></a>方式二：映射为方法</h4><ol><li><p>从 vuex 中按需导入 mapMutations 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>通过 mapMutations 函数，将需要的 mutations 函数映射为 methods 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapMutations([<span class="string">&quot;addN&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h2><h3 id="认识-action"><a href="#认识-action" class="headerlink" title="认识 action"></a>认识 action</h3><ol><li>action 用于处理异步任务，如果通过异步操作处理变更数据，必须通过 action，而不能使用 mutation</li><li>但是在 action 中还是要通过触发 mutation 的方式间接变更数据，action 本身并不能改变 state 中的数据</li></ol><h3 id="定义-action"><a href="#定义-action" class="headerlink" title="定义 action"></a>定义 action</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">            state.count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    action: &#123;</span><br><span class="line">        <span class="function"><span class="title">addAsync</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">            <span class="comment">// 把 context 看作是 store 的一个实例对象</span></span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;  <span class="comment">// 延时 1 秒后触发 add 函数</span></span><br><span class="line">                context.commit(<span class="string">&quot;add&quot;</span>)  <span class="comment">// mutations 中的函数</span></span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="触发-action"><a href="#触发-action" class="headerlink" title="触发 action"></a>触发 action</h3><h4 id="方式一：this-store-dispatch-“函数名”"><a href="#方式一：this-store-dispatch-“函数名”" class="headerlink" title="方式一：this.$store.dispatch(“函数名”)"></a>方式一：this.$store.dispatch(“函数名”)</h4><p>触发 actions 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;addAsync&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>触发 actions 函数时携带参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 actions 函数</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        <span class="function"><span class="title">addN</span>(<span class="params">state, step</span>)</span> &#123;</span><br><span class="line">            state.count += step;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        <span class="function"><span class="title">addNAsync</span>(<span class="params">context, step</span>)</span> &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 将参数 step 传给要触发的 addN 函数</span></span><br><span class="line">                context.commit(<span class="string">&quot;addN&quot;</span>, step)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 actions 函数</span></span><br><span class="line">methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 将参数 2 传给要触发的 addNAsync 函数</span></span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&quot;addNAsync&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方式二：映射为方法-1"><a href="#方式二：映射为方法-1" class="headerlink" title="方式二：映射为方法"></a>方式二：映射为方法</h4><ol><li><p>从 vuex 中按需导入 mapActions 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>将指定的 actions 函数映射为当前组件的 methods 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    ...mapActions([<span class="string">&quot;addNAsync&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h2><h3 id="认识-getter"><a href="#认识-getter" class="headerlink" title="认识 getter"></a>认识 getter</h3><ol><li>getter 不会改变 store 中的数据，仅仅是起到一个包装的作用</li><li>getter 用于对 store 中的数据进行加工处理形成新的数据，类似于组件中的计算属性，store 中的数据发生变化时，getter 的数据也会跟着变化</li></ol><h3 id="定义-getter"><a href="#定义-getter" class="headerlink" title="定义 getter"></a>定义 getter</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    getters: &#123;</span><br><span class="line">        showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;当前的 count 值为：&quot;</span> + state.count</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用-getter"><a href="#使用-getter" class="headerlink" title="使用 getter"></a>使用 getter</h3><h4 id="方式一：this-store-getters-”名称”"><a href="#方式一：this-store-getters-”名称”" class="headerlink" title="方式一：this.$store.getters.”名称”"></a>方式一：this.$store.getters.”名称”</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> this.$store.getters.showNum <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="方式二：映射为计算属性-1"><a href="#方式二：映射为计算属性-1" class="headerlink" title="方式二：映射为计算属性"></a>方式二：映射为计算属性</h4><ol><li><p>从 vuex 中按需导入 mapGetters 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>将指定的 getters 函数映射为当前组件的计算属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&quot;showNum&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex教程（一）：初次感受Vuex</title>
      <link href="c6eabb17a429/"/>
      <url>c6eabb17a429/</url>
      
        <content type="html"><![CDATA[<h2 id="vuex-概述"><a href="#vuex-概述" class="headerlink" title="vuex 概述"></a>vuex 概述</h2><h3 id="回顾组件传值"><a href="#回顾组件传值" class="headerlink" title="回顾组件传值"></a>回顾组件传值</h3><ol><li>父组件向子组件传值：一般用 <code>v-bind</code> 属性绑定实现</li><li>子组件向父组件传值：一般同 <code>v-on</code> 事件绑定实现</li><li>兄弟组件间共享数据：一般用 <code>EventBus</code> 实现</li></ol><h3 id="引入-vuex"><a href="#引入-vuex" class="headerlink" title="引入 vuex"></a>引入 vuex</h3><ol><li><p>什么是 vuex：它是实现组件全局状态（数据）管理的一种机制，可以很方便地实现组件之间数据的共享</p></li><li><p>不使用 vuex 对比 使用 vuex：<br><img src="https://user-images.githubusercontent.com/49378661/80388775-df5fc680-88dc-11ea-98be-87ff48bccd58.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388775-df5fc680-88dc-11ea-98be-87ff48bccd58.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587988238138"></p><ul><li>可见，在不使用 vuex 时，要使用大范围或者频繁的数据共享是很麻烦的</li></ul></li><li><p>使用 vuex 统一管理状态的好处：</p><ul><li>能够在 vuex 中集中管理共享的数据，易于开发和后期维护</li><li>能高效地实现组件之间的数据共享，提高开发效率</li><li>存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步</li></ul></li><li><p>什么样的数据适合存储到 vuex 中</p><ul><li>一般情况下，只有组件之间共享的数据，才有必要存储到 vuex 中；而对于组件私有的数据，存储在组件自身的 data 中即可</li><li>但在实际上，把组件中所有的数据存到 vuex 中也是可以的</li></ul></li></ol><hr><h2 id="vuex-的基本使用"><a href="#vuex-的基本使用" class="headerlink" title="vuex 的基本使用"></a>vuex 的基本使用</h2><ol><li><p>安装 vuex 依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vuex --save-dev</span><br></pre></td></tr></table></figure></li><li><p>导入 vuex 包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span></span><br><span class="line">Vue.use(Vuex)  <span class="comment">//将导入的 vuex 安装到项目中使用</span></span><br></pre></td></tr></table></figure></li><li><p>创建 store 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    <span class="comment">// state 中存放的就是全局共享的数据</span></span><br><span class="line">    state: &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>将 store 对象挂载到 vuex 实例中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line">    <span class="comment">// 将创建的共享数据对象，挂载到 vue 实例中</span></span><br><span class="line">    <span class="comment">// 所有的组件，就可以直接从 store 中获取全局的数据了</span></span><br><span class="line">    store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="创建-vuex-项目"><a href="#创建-vuex-项目" class="headerlink" title="创建 vuex 项目"></a>创建 vuex 项目</h2><ol><li><p>在 <code>cmd</code> 中输入 <code>vue ui</code> 来打开 vue 的可视化面板<br><img src="https://user-images.githubusercontent.com/49378661/80388798-e686d480-88dc-11ea-8e11-34d06810e8f4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388798-e686d480-88dc-11ea-8e11-34d06810e8f4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587989431130"></p></li><li><p>点击 “创建”，选择或输入自己要将项目放置的目录</p></li><li><p>跳转到对应目录下之后，点击 “在此创建新项目”</p></li><li><p>如图所示：<br><img src="https://user-images.githubusercontent.com/49378661/80388811-ea1a5b80-88dc-11ea-80e8-b7114d64e20b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388811-ea1a5b80-88dc-11ea-80e8-b7114d64e20b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587989858084"></p><ul><li>名称：这个自定义即可</li><li>包管理器：选择 npm 管理</li><li>Git：我们选择初始化一个 git 仓储，初始化的提交消息我们暂且写为 “init project”</li><li>点击 “下一步”</li></ul></li><li><p>选择 “手动”，我们来自定义安装哪些依赖项，再点击 “下一步”</p></li><li><p>需要确定安装的有以下四项：</p><ul><li>“Babel”</li><li>“Vuex”</li><li>“Linter / Formatter”</li><li>“使用配置文件”</li><li>勾选好后点击 “下一步”</li></ul></li><li><p>在 <code>Select...</code> 选项中，我们选择 “ESLint with error prevention only” 这一项，再点击 “创建项目”</p></li><li><p>会弹出一个 “保存为预设” 的窗口，我们暂且点击 “创建项目，不保存预设”</p></li><li><p>以上便是全部步骤，现在开始创建，可能需要等待一会儿……</p></li><li><p>创建成功时，你的浏览器会显示：（先暂时不关终端以及这个窗口，我们马上就会用到）<br><img src="https://user-images.githubusercontent.com/49378661/80388826-eedf0f80-88dc-11ea-914f-4b3f16f57b0d.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388826-eedf0f80-88dc-11ea-914f-4b3f16f57b0d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587990726062"></p></li></ol><hr><h2 id="感受-vuex-的功能"><a href="#感受-vuex-的功能" class="headerlink" title="感受 vuex 的功能"></a>感受 vuex 的功能</h2><h3 id="查看项目效果"><a href="#查看项目效果" class="headerlink" title="查看项目效果"></a>查看项目效果</h3><ol><li><p>回到浏览器中，点击 “任务”，再点击 “serve”，最后点击 “运行”：<br><img src="https://user-images.githubusercontent.com/49378661/80388859-f999a480-88dc-11ea-9f0c-f6446d1787a9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388859-f999a480-88dc-11ea-9f0c-f6446d1787a9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587991787552"></p><ul><li>等到右边的显示完成后，即为完成</li></ul></li><li><p>点击 “启动 app”，即可看到此项目的效果<br><img src="https://user-images.githubusercontent.com/49378661/80388870-fd2d2b80-88dc-11ea-9f76-3704a758e479.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388870-fd2d2b80-88dc-11ea-9f76-3704a758e479.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587991905389"></p></li><li><p>现在我们关闭浏览器和终端，开始重新编辑项目</p></li></ol><h3 id="重新编辑项目"><a href="#重新编辑项目" class="headerlink" title="重新编辑项目"></a>重新编辑项目</h3><blockquote><p>现在我们想感受一个 vuex 的功能<br>目标是：我们在整个项目中共享一个 count 值，然后用按钮操控 count 的加减</p></blockquote><ol><li>整个项目的文件结构如下：<br><img src="https://user-images.githubusercontent.com/49378661/80388902-061dfd00-88dd-11ea-8c17-df3088f66ff6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80388902-061dfd00-88dd-11ea-8c17-df3088f66ff6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587991008382"></li></ol><ol start="2"><li><p>同时打开 <code>/src/store/index.js</code> 以及 <code>/src/main.js</code>，你会发现，vuex 如何被使用的呢：</p><ul><li><code>/src/store/index.js</code>：初始化 vuex，并导出 store</li><li><code>/src/main.js</code>：导入 store，并在 vue 实例中使用</li></ul></li><li><p>删除 <code>/src/components/HelloWorld.vue</code></p></li><li><p>定义 store，对 <code>/src/components/store/index.js</code> 修改如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.count ++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">sub</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.state --</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 <code>/src/components</code> 下创建 <code>Addition.vue</code> 以及 <code>Subtract.vue</code>，分别用来控制 count 的增加和减少：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Addtion.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;当前最新的 count 值为：&#123;&#123; this.$store.state.count &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;add&quot;&gt;加1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    add() &#123;</span><br><span class="line">      this.$store.commit(&quot;add&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Substract.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;当前最新的 count 值为：&#123;&#123; this.$store.state.count &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;sub&quot;&gt;减1&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sub() &#123;</span><br><span class="line">      this.$store.commit(&quot;sub&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>将 <code>/src/App.vue</code> 替换为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;my-addtion &#x2F;&gt;</span><br><span class="line">    &lt;hr &#x2F;&gt;</span><br><span class="line">    &lt;my-substract &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Addition from &quot;.&#x2F;components&#x2F;Addtion&quot;  &#x2F;&#x2F; 导入 Addtion 组件</span><br><span class="line">import Substract from &quot;.&#x2F;components&#x2F;Substract&quot;  &#x2F;&#x2F; 导入 Substract 组件</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;  &#x2F;&#x2F; 将导入的组件注册为私有的子组件</span><br><span class="line">    &quot;my-addtion&quot;: Addition,</span><br><span class="line">    &quot;my-substract&quot;: Substract</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>我们之前在创建项目时不小心使用了 <code>ESLint</code>，现在我们在根目录下创建 <code>vue.config.js</code> 来消除这个效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">   lintOnSave: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure></li><li><p>至此，你可以打开浏览器查看效果了，如果通过按钮可以实现对 state 的控制，那么这个 demo 就成功了</p></li></ol><hr><blockquote><p>本节只是引入了 vuex 的概念以及简单地使用了 vuex，体验 demo 即可，代码部分之后详细说明，加油！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（十）：详解生命周期</title>
      <link href="41065790d3f7/"/>
      <url>41065790d3f7/</url>
      
        <content type="html"><![CDATA[<blockquote><p>生命周期钩子，也叫  “生命周期函数”、“生命周期事件”，<br>之前在 <a href="https://github.com/OzzieNicholas/Blog/issues/40">Vue教程（三）：实例与模板语法</a> 中简单介绍了生命周期，现在详细解释</p></blockquote><ol><li><p>之前说过，在 Vue 中要渲染一块页面内容的时候，会有这么几个过程：</p><ul><li>① 解析语法生成 AST。</li><li>② 根据 AST 结果，完成 data 数据初始化。</li><li>③ 根据 AST 结果和 data 数据绑定情况，生成虚拟 DOM。</li><li>④ 将虚拟 DOM 生成真正的 DOM 插入到页面中，此时页面会被渲染。</li></ul></li><li><p>但是，不只是有上面四个过程，接下来，当我们绑定的数据进行更新的时候，又会产生以下这些过程：</p><ul><li>⑤ 框架接收到数据变更的事件，根据数据生成新的虚拟 DOM 树。比较新旧两棵虚拟 DOM 树，得到差异。</li><li>⑥ 把差异应用到真正的 DOM 树上，即根据差异来更新页面内容。</li><li>⑦ 注销实例，清空页面内容，移除绑定事件、监听器等。</li></ul></li><li><p>所以，在整个页面或是某块页面内容（组件）中，Vue 提供了以下的一些关键的生命周期钩子：</p><table><thead><tr><th align="center">生命周期钩子函数</th><th align="center">该函数的说明</th><th align="center">对应上述步骤</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">初始化实例前，<code>data</code>、<code>methods </code>等不可获取</td><td align="center">①之后，②之前</td></tr><tr><td align="center">created</td><td align="center">实例初始化完成，此时可获取 <code>data</code> 里数据和<code>methods</code>事件，无法获取 DOM</td><td align="center">②之后，③ 之前</td></tr><tr><td align="center">beforeMount</td><td align="center">虚拟 DOM 创建完成，此时未挂载到页面中，<code>vm.$el </code>可获取未挂载模板</td><td align="center">③ 之后，④ 之前</td></tr><tr><td align="center">mounted</td><td align="center">数据绑定完成，真实 DOM 已挂载到页面，<code>vm.$el </code>可获取真实 DOM</td><td align="center">④ 之后</td></tr><tr><td align="center">beforeUpdate</td><td align="center">数据更新，DOM Diff 得到差异，未更新到页面</td><td align="center">⑤ 之后，⑥  之前</td></tr><tr><td align="center">updated</td><td align="center">数据、页面均已更新</td><td align="center">⑥ 之后</td></tr><tr><td align="center">beforeDestroy</td><td align="center">实例销毁前</td><td align="center">⑦ 之前</td></tr><tr><td align="center">destroyed</td><td align="center">实例销毁完成</td><td align="center">⑦ 之后</td></tr></tbody></table></li><li><p>我们可以更新官方的生命周期图如下：<br><img src="https://user-images.githubusercontent.com/49378661/95237528-ed762380-083a-11eb-97d7-019bef9762b8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95237528-ed762380-083a-11eb-97d7-019bef9762b8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007003903032"></p><pre><code>    ![image-20201007004027110](https://user-images.githubusercontent.com/49378661/95237553-f36c0480-083a-11eb-8fba-a0db3711b86d.png)</code></pre></li></ol><ol start="5"><li><p>生命周期钩子的使用案例如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        message: <span class="string">&quot;欢迎来到Vue的世界&quot;</span></span></span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;&#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    beforeCreate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;beforeCreate&quot;</span>, <span class="built_in">this</span>.message, <span class="built_in">this</span>.test, <span class="built_in">this</span>.$el);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在实例创建完成后被立即调用</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 挂载阶段还没开始，$el 属性目前不可见</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;created&quot;</span>, <span class="built_in">this</span>.message, <span class="built_in">this</span>.test, <span class="built_in">this</span>.$el);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    beforeMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在挂载开始之前被调用：相关的 render 函数首次被调用</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;beforeMount&quot;</span>, <span class="built_in">this</span>.message, <span class="built_in">this</span>.test, <span class="built_in">this</span>.$el);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// mounted 不会承诺所有的子组件也都一起被挂载</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 如果希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;mounted&quot;</span>, <span class="built_in">this</span>.message, <span class="built_in">this</span>.test, <span class="built_in">this</span>.$el);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 此处整个视图已渲染完毕</span></span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    beforeUpdate: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 数据更新时调用，发生在虚拟 DOM 打补丁之前</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    updated: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    beforeDestroy: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 实例销毁之前调用。在这一步，实例仍然完全可用</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    destroyed: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// Vue 实例销毁后调用</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看控制台的输出：</p><p><img src="https://user-images.githubusercontent.com/49378661/95237609-07176b00-083b-11eb-8ba0-0b89378b4785.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95237609-07176b00-083b-11eb-8ba0-0b89378b4785.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007004346309"></p></li></ol><ol start="6"><li><p>可以大致分为三个阶段：创建阶段、运行阶段、销毁阶段</p><ul><li><p>创建阶段：beforeCreated、created、beforeMount、mounted</p><ul><li><p>beforeCreate：实例刚刚从内存中创建出来，还没有初始化 data 以及 methods，只包含一些自带的其他生命周期函数。</p></li><li><p>created：实例已经从内存中创建完成，此时，data 和 methods 都已经创建完成。</p></li><li><p>boforeMount：此处已经完成了模板的编译，但还未渲染到界面中去。</p></li><li><p>mounted：模板已经渲染到了浏览器，创建阶段结束，接下来进入运行阶段。</p></li><li><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> v = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&quot;hello world!&quot;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 如果没有template,则会将 el 中元素当作 template，如果有 template，则会覆盖 el 中的 dom</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;color: red;&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// Vue实例刚刚被初始化，data和methods还没有值</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;1. beforeCreate=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置debugger</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// Vue实例创建完成，data和methods可以被使用了</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;2. created=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置debugger</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 内存中的Dom已经渲染完成，还没有显示到浏览器</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;3. beforeMount=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置debugger</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">//模版已经渲染到浏览器，创建阶段结束</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置debugger</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;4. mounted=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/95237637-0d0d4c00-083b-11eb-96b9-d05e3dbb43a4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95237637-0d0d4c00-083b-11eb-96b9-d05e3dbb43a4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007010017449"></p></li></ul></li></ul></li></ol><ul><li><p>运行阶段：beforeUpdate、updated</p><ul><li><p>beforeUpdate：实例中的 data 已经更新，但是页面中的数据未更新，也就是，实例的 data 比页面的数据先更新。</p><ul><li>可以多想一点的是，在 updated 之后存在一个过渡阶段：先根据 data 中的数据，在内存中渲染出一个新的DOM，当新的DOM树更新之后，会重新渲染到真实的界面中去，从而实现了从数据层（model）到视图层（view）的转换。这个阶段不属于生命周期，只是便于学习抽象化的中间处理过程。</li></ul></li><li><p>updated：页面重新渲染，页面数据与 data 保持一致。</p></li><li><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&quot;hello world!&quot;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 如果没有template,则会将el中元素当作template，如果有template，则会覆盖el中的dom</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;color: red;&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">h1</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">message</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;1. beforeCreate=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;2. created=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;3. beforeMount=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;4. mounted=====&#x27;</span> + <span class="built_in">this</span>.message)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;此时的message已经更新，但是浏览器页面上的数据没有发生变化&quot;</span>, <span class="built_in">this</span>.message)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 修改数据之后，添加断点，页面上的数据和当前message不一致</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 设置debugger</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;更新结束，页面数据已更新&quot;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// 在修改数据之前，添加断点</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置debugger</span></span></span><br><span class="line"><span class="javascript">  vm.message = <span class="string">&#x27;这是 Vue 的生命周期的运行阶段&#x27;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/95237656-126a9680-083b-11eb-996f-73b9137858ef.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95237656-126a9680-083b-11eb-996f-73b9137858ef.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007011113091"></p></li></ul></li></ul><ul><li><p>销毁阶段：beforeDestroy、destroyed</p><ul><li>beforeDestroy：此时 Vue 的生命周期已经进入销毁阶段，但是实例上的各种数据还处于可用的状态。</li><li>destroyed：组件已全部销毁，Vue 实例也被销毁，所有数据均不可用。</li></ul></li></ul><ol start="7"><li>更详细的参考图：<br><img src="https://user-gold-cdn.xitu.io/2019/9/19/16d48805a7890b16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/9/19/16d48805a7890b16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（九）：组件终结篇</title>
      <link href="d955e5aaf64c/"/>
      <url>d955e5aaf64c/</url>
      
        <content type="html"><![CDATA[<h2 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a>Prop</h2><h3 id="使用-Prop-传递数据"><a href="#使用-Prop-传递数据" class="headerlink" title="使用 Prop 传递数据"></a>使用 Prop 传递数据</h3><ol><li><p>组件实例的作用域是孤立的。这意味着不能（也不应该）在子组件的模板内直接引用父组件的数据。要让子组件使用父组件的数据，我们需要通过子组件的 props 选项，子组件要显示地用 props 选项声明它期望获得的数据。</p></li><li><p>组件获得了 prop 之后，它就如同该组件的 data 一样，可以在模板内使用，而对于根组件，也可以如同 <code>vm.prop</code> 一样使用。</p></li><li><p>关于 Prop 的大小写：HTML 对大小写是不敏感的，也就是说，在浏览器解析时，会把所有的大写字符解释成小写字符，所以，当你使用 DOM 中的模板时，所以，以驼峰命名法（camelCase）命名的字符需要被替换为对应的短横线分割命名（kebab-case）。</p></li><li><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;!-- test-msg 是短横线命名法 --&gt;</span><br><span class="line">    &lt;child test-msg&#x3D;&quot;This is testMsg&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;, &#123;</span><br><span class="line">        &#x2F;&#x2F; testMsg 是驼峰命名法</span><br><span class="line">        props: [&quot;testMsg&quot;],   &#x2F;&#x2F; 声明 props</span><br><span class="line">        template: &quot;&lt;div&gt;&#123;&#123;testMsg&#125;&#125;&lt;&#x2F;div&gt;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>注意，如果你使用的是字符串模板，那么上述限制是不存在的。</p><ul><li><p>字符串模板：指的是组件选项中用 <code>template</code> 引出来的模板，例如下面的 <code>&lt;div&gt;Hello World&lt;/div&gt;</code> 就是字符串模板</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;example&quot;</span>, &#123;</span><br><span class="line">    template: <span class="string">&quot;&lt;div&gt;Hello World&lt;/div&gt;&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>非字符串模板：单文件组件中，用 <code>&lt;template&gt;</code> 指定的模板，也就是说，写在 HTML 中的就是非模板字符串，这也与官网说的 <strong>“HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名”</strong> 吻合。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;Hello World&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="动态-Prop"><a href="#动态-Prop" class="headerlink" title="动态 Prop"></a>动态 Prop</h3><p>在模板中，若要动态地将父组件的数据传给子组件，就直接使用 <code>v-bind</code> 即可，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;input v-model&#x3D;&quot;inputValue&quot;&gt;</span><br><span class="line">    &lt;hr &#x2F;&gt;</span><br><span class="line">    &lt;child :child-msg&#x3D;&quot;inputValue&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    Vue.component(&quot;child&quot;, &#123;</span><br><span class="line">        props: [&quot;childMsg&quot;],</span><br><span class="line">        template: &quot;&lt;span&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;span&gt;&quot;</span><br><span class="line">    &#125;)</span><br><span class="line">    var app &#x3D; new Vue(&#123;</span><br><span class="line">        el: &quot;#app&quot;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            inputValue: &quot;This is inputValue&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="字面量语法与动态语法"><a href="#字面量语法与动态语法" class="headerlink" title="字面量语法与动态语法"></a>字面量语法与动态语法</h3><ol><li><p>这里要说的是一个常见的错误，那就是错误地以为使用字面量语法能传递数值，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">msg</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>其实这里是用字面量语法来传递的，它是一个字面量的 Prop，这里的 msg 传递的是字符串 “100” 而非 数值 100。</p></li><li><p>若想传递数值 100，则要使用 <code>v-bind</code>，它的值也会被当作 JS 表达式计算。</p></li></ol><h3 id="单向数据流"><a href="#单向数据流" class="headerlink" title="单向数据流"></a>单向数据流</h3><ol><li><p>prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态。</p></li><li><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你 <strong>不应该</strong> 在子组件内部改变 prop 。否则，Vue 会在控制台给出警告。</p></li><li><p>然而，我们要修改 prop 中数据，通常是因为这两种原因：</p><ul><li>prop 作为初始值传入后，子组件想把它当作局部数据来用</li><li>prop 作为初始值传入，由子组件处理成其它数据输出</li></ul></li><li><p>对于上述原因，解决的方式是：</p><ul><li><p>定义一个局部变量，并用 prop 的值初始化它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&quot;parentMsg&quot;</span>],</span><br><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        childMsg: <span class="built_in">this</span>.parentMsg</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在父组件接收到 parentMsg 的值，最后在子组件中把值赋给 childMsg，再使用 childMsg 即可</li></ul></li><li><p>定义一个计算属性，处理 prop 的值并返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">&quot;parentMsg&quot;</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">    funMsg: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.trim().toLowerCase()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在父组件接收到 parentMsg 的值，最后在子组件中映射为计算属性</li><li>另外要注意，在 JS 中，对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态</li></ul></li></ul></li></ol><h3 id="Prop-验证"><a href="#Prop-验证" class="headerlink" title="Prop 验证"></a>Prop 验证</h3><ol><li><p>我们可以为组件的 props 指定规格来进行验证，换句话说，就是子组件来接收父组件时，子组件可以检查该值是不是需要的 prop，如果传入的数据不符合规格，Vue 会发出警告。尤其是开发组件给其他人使用时，这很有用。</p></li><li><p>之前接收 prop 没有考虑到规格验证，所以一直都是 <code>props: [&quot;A&quot;, &quot;B&quot;]</code> 这种字符串数组的形式，但现在要指定验证规格，则要用对象的形式，而不能用字符串数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">     <span class="comment">// 基础类型检测（若是 &quot;null&quot; 或 &quot;undefined&quot;，则是任何类型都可以）</span></span><br><span class="line">        <span class="comment">// 此处规定 propA 必须是数值类型</span></span><br><span class="line">        propA: <span class="built_in">Number</span>,</span><br><span class="line">        <span class="comment">// 多种类型检测，满足一种即可</span></span><br><span class="line">        propB: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">        <span class="comment">// 规定必传，且必须为字符串</span></span><br><span class="line">        propC: &#123;</span><br><span class="line">            type: <span class="built_in">String</span>,</span><br><span class="line">            required: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 必须是数值类型，若不传则默认为 100</span></span><br><span class="line">        propD: &#123;</span><br><span class="line">            type: <span class="built_in">Number</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="number">100</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 注意，若要限定为数组或对象，则默认值应由一个工厂函数返回</span></span><br><span class="line">        propE: &#123;</span><br><span class="line">            type: <span class="built_in">Object</span>,</span><br><span class="line">            <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    msg: <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 自定义验证函数</span></span><br><span class="line">        propF: &#123;</span><br><span class="line">            validator: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value &gt; <span class="number">10</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>type</code> 可以是下面的原生构造器：</p><ul><li><p>String</p></li><li><p>Number</p></li><li><p>Boolean</p></li><li><p>Function</p></li><li><p>Object</p></li><li><p>Array</p></li><li><p>type 也可以是一个自定义构造器函数，使用 instanceof 检测，若使用开发版本，当 prop 验证失败时，Vue会在抛出警告，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后再使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;example&quot;</span>, &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">        ret: Add</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以此来验证 ret 对应的 prop 值是否是 <code>new Add</code> 创建的</p></li></ul></li></ol><h3 id="非-Prop-的-属性"><a href="#非-Prop-的-属性" class="headerlink" title="非 Prop 的 属性"></a>非 Prop 的 属性</h3><p>组件是可以接收任意的属性的，但是当一个非 prop 的属性传入组件，而该组件又没有对应的 prop 定义时，这些属性会被添加到这个组件的根元素上，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">msg</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开控制台，查看元素：</p><p><img src="https://user-images.githubusercontent.com/49378661/87612866-4ce1fd00-c73e-11ea-973d-a313a9a03eda.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/87612866-4ce1fd00-c73e-11ea-973d-a313a9a03eda.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200716074652980"></p><h4 id="替换-合并已有的属性"><a href="#替换-合并已有的属性" class="headerlink" title="替换/合并已有的属性"></a>替换/合并已有的属性</h4><p>观察下面的案例，我们在组件内部已经设置好了 <code>type=&quot;b&quot; class=&quot;B&quot;</code>，但是在外部又传入了 <code>type=&quot;a&quot; class=&quot;A&quot;</code> ：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .A &#123;</span><br><span class="line"><span class="css">            <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        .B &#123;</span><br><span class="line"><span class="css">            <span class="attribute">color</span>: red;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 外部传入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">type</span>=<span class="string">&quot;a&quot;</span> <span class="attr">class</span>=<span class="string">&quot;A&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 内部设置</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            template: &quot;<span class="tag">&lt;<span class="name">div</span> <span class="attr">type</span>=<span class="string">&#x27;b&#x27;</span> <span class="attr">class</span>=<span class="string">&#x27;B&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;</span></span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开控制台：</p><p><img src="https://user-images.githubusercontent.com/49378661/87612880-53707480-c73e-11ea-81f8-9bb3427efd79.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/87612880-53707480-c73e-11ea-81f8-9bb3427efd79.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200716075447873"></p><p>对于绝大部分属性，从外部传入的会替换掉组件自身设置的，但是 class 与 style 属性会合并，不过，若是外部 class/style 与 内部 class/style 相冲突，优先的仍是外部</p><h4 id="禁用属性继承"><a href="#禁用属性继承" class="headerlink" title="禁用属性继承"></a>禁用属性继承</h4><p>前面提到过，非 prop 属性会被挂载到根组件上，但如果你不想组件的根元素继承属性，可以在组件选项中设置 <code>inheritAttrs: false</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>inheritAttrs 非常适合与实例的 <code>$attrs</code> 搭配使用，$attrs 属性包含了传递给一个组件的属性名和属性值，有了 inheritAttrs 和 $attrs，你就可以亲自决定这些属性会被挂载到哪个元素上，这在写 <a href="https://cn.vuejs.org/v2/style-guide/#%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6%E5%90%8D%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90">基础组件</a> 时常会用到，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-input&quot;</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    props: [<span class="string">&quot;label&quot;</span>, <span class="string">&quot;value&quot;</span>],</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;label&gt;&#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;input  v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">                v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">                v-on:input=&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span><br><span class="line"><span class="string">        &gt;</span></span><br><span class="line"><span class="string">        &lt;/label&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>注意，inheritAttrs 不会影响到 style 与 class 的绑定</p><hr><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><h3 id="事件的命名"><a href="#事件的命名" class="headerlink" title="事件的命名"></a>事件的命名</h3><ol><li>不同于组件名以及 prop 名，事件名不存在任何大小写转化，也就是说，只需要保证前后使用的事件名是完全一致的即可，因为事件名不会被用作一个 JS 变量名或者 property 名，所以就不需要使用 camelCase（驼峰命名法）以及 PascalCase（帕斯卡命名法）</li><li><code>v-on</code> 事件监听器在 DOM 模板中会自动转换为全小写（因为 HTML 对大小写是不铭感的），例如 <code>v-on:myEvent</code> 会被转换为 <code>v-on:myevent</code>，这将导致 <code>myEvent</code> 不会被监听到。</li><li>所以，综合组件名与 prop 名的命名规则，最佳的方案是一直使用 kebab-case 命名法</li></ol><h3 id="用-v-on-绑定自定义事件"><a href="#用-v-on-绑定自定义事件" class="headerlink" title="用 v-on 绑定自定义事件"></a>用 v-on 绑定自定义事件</h3><blockquote><p>父组件是使用 props 将数据传递给子组件，若是子组件把数据传递出去，就应该使用自定义事件</p></blockquote><ol><li><p>每个 Vue 实例都实现了事件接口，即：</p><ul><li>使用 <code>$on(eventName)</code> 监听事件</li><li>使用 <code>$emit(eventName)</code> 触发事件</li></ul></li><li><p>Vue 的事件系统分离自浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventTarget">EventTarget</a>，不过，他们的运行虽然类似，但是 $on 与 $emit 并不是 <code>addEventListener</code> 以及 <code>dispatchEvent</code> 的别名</p></li><li><p>关于 v-on 绑定自定义事件的例子，可以查看另一篇博文：<a href="https://github.com/OzzieNicholas/Blog/issues/45">组件通信详解</a></p></li></ol><h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h3><h4 id="官网案例"><a href="#官网案例" class="headerlink" title="官网案例"></a>官网案例</h4><p>默认情况下，组件的 v-model 会利用属性 value 以及 事件 input，但是，像单选框、复选框这类型的输入控件可能会将 value 的属性用作不同的目的（比如 <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value"><code>&lt;input type=&quot;checkbox&quot;&gt;</code> 中的 value</a>），model 选项可以用来避免此类冲突：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-checkbox&quot;</span>, &#123;</span><br><span class="line">    model: &#123;</span><br><span class="line">        prop: <span class="string">&quot;checked&quot;</span>,</span><br><span class="line">        event: <span class="string">&quot;change&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">        checked: <span class="built_in">Boolean</span></span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;input  type=&quot;checkbox&quot;</span></span><br><span class="line"><span class="string">                v-bind:checked=&quot;checked&quot;</span></span><br><span class="line"><span class="string">                v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span></span><br><span class="line"><span class="string">        &gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意，在组件的 props 选项里声明 <code>checked</code> 这个 prop 是必须的</li></ul><p>在这个组件上使用 v-model 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-checkbox</span> <span class="attr">v-model</span>=<span class="string">&quot;testValue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>testValue</code> 的值会传入名为 checked 的 prop，同时，当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新值的时候，这个 testValue 的 property 将会被更新</p><h4 id="自理解案例"><a href="#自理解案例" class="headerlink" title="自理解案例"></a>自理解案例</h4><p>自定义事件也可以用来创建自定义的表单输入组件，使用 v-model 来进行数据的双向绑定，牢记：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;something&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>仅仅是一个语法糖：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something=$event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，在组件中使用，相当于下面的简写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component-input</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;something&quot;</span> <span class="attr">v-on:input</span>=<span class="string">&quot;something=arguments[0]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-input</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以，要让 v-model 生效，必须：</p><ul><li>接受一个 value 属性</li><li>在有新的 value 时触发 input 事件</li></ul><p>简单的案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component-input</span> <span class="attr">v-model</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;component-input&quot;</span>, &#123;</span></span><br><span class="line">        template: `</span><br><span class="line"><span class="javascript">            &lt;input  ref=<span class="string">&quot;input&quot;</span></span></span><br><span class="line"><span class="javascript">                    v-bind:value=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="javascript">                    v-on:input=<span class="string">&quot;updateValue($event.target.value)&quot;</span></span></span><br><span class="line">            &gt;</span><br><span class="line">        `,</span><br><span class="line"><span class="javascript">        props: [<span class="string">&quot;value&quot;</span>],</span></span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">// 此函数不是直接更新值，而是用来对输入值进行格式化和位数限制</span></span></span><br><span class="line"><span class="javascript">            updateValue: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">// 删除两侧的空格，并保留2位小数</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> formattedValue = value.trim().slice(<span class="number">0</span>, value.indexOf(<span class="string">&quot;.&quot;</span>) + <span class="number">3</span>)</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 若值不统一，则手动覆盖以保证一致</span></span></span><br><span class="line">                if (formattedValue != value) &#123;</span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$refs.input.value = formattedValue</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">                <span class="comment">// 通过 input 事件发出数值</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.$emit(<span class="string">&quot;input&quot;</span>, <span class="built_in">Number</span>(formattedValue))</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span></span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>上述的案例中仍有漏洞，比如输入的可能是标点符号之类的</p><p>下面是一个更完善的货币过滤器的案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.rawgit.com/chrisvfritz/5f0a639590d6e648933416f90ba7ae4e/raw/974aa47f8f9c5361c5233bd56be37db8ed765a09/currency-validator.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">label</span>=<span class="string">&quot;Price&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;price&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">label</span>=<span class="string">&quot;Shipping&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;shipping&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">label</span>=<span class="string">&quot;Handling&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;handling&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">currency-input</span> <span class="attr">label</span>=<span class="string">&quot;Discount&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;discount&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">currency-input</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Total: $&#123;&#123; total &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;currency-input&quot;</span>, &#123;</span></span><br><span class="line">            template: `</span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-if</span>=<span class="string">&quot;label&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">label</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">                &lt;input  ref=<span class="string">&quot;input&quot;</span></span></span><br><span class="line"><span class="javascript">                        v-bind:value=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="javascript">                        v-on:input=<span class="string">&quot;updateValue($event.target.value)&quot;</span></span></span><br><span class="line"><span class="javascript">                        v-on:focus=<span class="string">&quot;selectAll&quot;</span></span></span><br><span class="line"><span class="javascript">                        v-on:blur=<span class="string">&quot;formatValue&quot;</span></span></span><br><span class="line">                &gt;</span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `,</span><br><span class="line">            props: &#123;</span><br><span class="line">                value: &#123;</span><br><span class="line"><span class="javascript">                    type: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">default</span>: <span class="number">0</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">                label: &#123;</span><br><span class="line"><span class="javascript">                    type: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">default</span>: <span class="string">&quot;&quot;</span></span></span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line"><span class="javascript">            mounted: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.formatValue()</span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                updateValue: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> result = currencyValidator.parse(value, <span class="built_in">this</span>.value)</span></span><br><span class="line">                    if (result.warning) &#123;</span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.$refs.input.value = result.value</span></span><br><span class="line">                    &#125;</span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$emit(<span class="string">&#x27;input&#x27;</span>, result.value)</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                formatValue: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$refs.input.value = currencyValidator.format(<span class="built_in">this</span>.value)</span></span><br><span class="line">                &#125;,</span><br><span class="line"><span class="javascript">                selectAll: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">                        event.target.select()</span><br><span class="line">                    &#125;, 0)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line">                price: 0,</span><br><span class="line">                shipping: 0,</span><br><span class="line">                handling: 0,</span><br><span class="line">                discount: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            computed: &#123;</span><br><span class="line"><span class="javascript">                total: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> ((</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.price * <span class="number">100</span> +</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.shipping * <span class="number">100</span> +</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.handling * <span class="number">100</span> -</span></span><br><span class="line"><span class="javascript">                        <span class="built_in">this</span>.discount * <span class="number">100</span></span></span><br><span class="line">                    ) / 100).toFixed(2)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个接口不仅可以用来连接组件内部的表单输入，也很容易集成你自己创造的输入类型，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">voice-recognizer</span> <span class="attr">v-model</span>=<span class="string">&quot;question&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">voice-recognizer</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webcam-gesture-reader</span> <span class="attr">v-model</span>=<span class="string">&quot;gesture&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">webcam-gesture-reader</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">webcam-retinal-scanner</span> <span class="attr">v-model</span>=<span class="string">&quot;retinalImage&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">webcam-retinal-scanner</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="非父子组件通信"><a href="#非父子组件通信" class="headerlink" title="非父子组件通信"></a>非父子组件通信</h3><p>关于非父子组件通信的例子，可以查看另一篇博文：<a href="https://github.com/OzzieNicholas/Blog/issues/45">组件通信详解</a></p><h3 id="将原生事件绑定到组件"><a href="#将原生事件绑定到组件" class="headerlink" title="将原生事件绑定到组件"></a>将原生事件绑定到组件</h3><ol><li><p>若想把原生事件绑定到根组件上，可以用 v-on 的 <code>.native</code> 修饰符，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>不过需要注意，在尝试监听类似 <code>&lt;input&gt;</code> 这类非常特殊的元素时，可能会失效，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base-input</span> <span class="attr">v-on:focus.native</span>=<span class="string">&quot;onFocus&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">base-input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&quot;base-input&quot;</span>, &#123;</span></span><br><span class="line">        template: `</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            </span><span class="template-variable">&#123;&#123; <span class="name">label</span> &#125;&#125;</span></span></span><br><span class="line"><span class="javascript">            &lt;input  v-bind=<span class="string">&quot;$attrs&quot;</span></span></span><br><span class="line"><span class="javascript">                    v-bind:value=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="javascript">                    v-on:input=<span class="string">&quot;$emit(&#x27;input&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line">            &gt;</span><br><span class="line"><span class="handlebars"><span class="xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span></span><br><span class="line">        `</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>此时，父级的 .native 将会默默失败，<code>onFocus</code> 将不会被调用，但是这并不会报任何错</li></ul></li><li><p>为解决此问题，vue 提供了一个 <code>$listeners</code> 的属性，它是一个对象，里面包含了作用在组件上的所有监听器，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    focus: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;<span class="comment">/*...*/</span>&#125;,</span><br><span class="line">    input: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 $listeners 与 <code>v-on=&quot;$listeners&quot;</code> 配合，将所有的事件监听器指向这个组件的某个特定元素，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;base-input&quot;</span>, &#123;</span><br><span class="line">    inheritAttrs: <span class="literal">false</span>,</span><br><span class="line">    props: [<span class="string">&quot;label&quot;</span>, <span class="string">&quot;value&quot;</span>],</span><br><span class="line">    computed: &#123;</span><br><span class="line">        inputListeners: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> vm = <span class="built_in">this</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;,</span><br><span class="line">                <span class="comment">// 从父级添加所有的监听器</span></span><br><span class="line">                <span class="built_in">this</span>.$listeners,</span><br><span class="line">                <span class="comment">// 再添加自定义监听器，或覆写一些行为</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 这里确保组件配合 v-model 的工作</span></span><br><span class="line">                    input: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">                        vm.$emit(<span class="string">&quot;input&quot;</span>, $event.target.value)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;label&gt;</span></span><br><span class="line"><span class="string">        &#123;&#123; label &#125;&#125;</span></span><br><span class="line"><span class="string">        &lt;input  v-bind=&quot;$attrs&quot;</span></span><br><span class="line"><span class="string">                v-bind:value=&quot;value&quot;</span></span><br><span class="line"><span class="string">                v-on=&quot;inputListeners&quot;</span></span><br><span class="line"><span class="string">        &gt;</span></span><br><span class="line"><span class="string">    &lt;/label&gt;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>现在 <code>&lt;base-input&gt;</code> 组件完全可以像一个普通的 <code>&lt;input&gt;</code> 元素一样使用了，即，所有跟它相同的属性和监听器都可以工作，不必再使用 <code>.native</code>监听器</li></ul></li></ol><h3 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h3><ol><li><p>一个组件只能定义一个 v-model，但若其他的 prop 也需要双向绑定呢？之前的自定义事件告诉我们，可以通过子组件发射一个事件，再用父组件监听一个事件，再更新 prop，例如：</p><ul><li><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;myValue&quot;</span> <span class="attr">v-on:valueChanged</span>=<span class="string">&quot;e =&gt; myValue = e&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Chlid <span class="keyword">from</span> <span class="string">&quot;./Child.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        child: Child</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            myValue: 1234,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onInput&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line">        value: &#123;</span><br><span class="line"><span class="javascript">            type: <span class="built_in">String</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">onInput</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;valueChanged&quot;</span>, e.target.value)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>但是这样未免太麻烦，我们可以通过 <code>.sync</code> 简化过程：</p><ul><li>组件内触发的事件以 <code>update: myPropName</code> 命名，相应地，上述子组件改为 <code>update: value</code></li><li>父组件的 v-bind:value 加上 .sync 修饰符，即 <code>v-bind:value.sync</code></li></ul></li><li><p>在修改之前，我们好好地认识一下 .sync：</p><ul><li><p>阅读官方文档：<a href="https://cn.vuejs.org/v2/guide/components-custom-events.html#sync-%E4%BF%AE%E9%A5%B0%E7%AC%A6">.sync 修饰符</a>，vue 2.3.0 时，我们重新引入了 .sync 修饰符，它只是作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器</p></li><li><p>例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:foo.sync</span>=<span class="string">&quot;bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会被扩展为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">:foo</span>=<span class="string">&quot;bar&quot;</span> @<span class="attr">update:foo</span>=<span class="string">&quot;val =&gt; bar = val&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在子组件需要更新 <code>foo</code> 的值时，它需要显式地触发一个更新事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$emit(<span class="string">&quot;update: foo&quot;</span>, newValue)</span><br></pre></td></tr></table></figure></li><li><p>可能上述的过程还是有点晕，请看下面这个案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        .btn &#123;</span><br><span class="line"><span class="css">            <span class="attribute">padding</span>: <span class="number">30px</span> <span class="number">20px</span> <span class="number">30px</span> <span class="number">5px</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span></span><br><span class="line"><span class="css">            <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:show.sync</span>=<span class="string">&quot;valueChild&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeValue&quot;</span>&gt;</span>toggle<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">            props: [<span class="string">&quot;show&quot;</span>],</span></span><br><span class="line">            template: `</span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;show&quot;</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">p</span>&gt;</span>默认值是 </span><span class="template-variable">&#123;&#123;<span class="name">show</span>&#125;&#125;</span><span class="xml">，所以是显示的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;closeDiv&quot;</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">button</span>&gt;</span>    </span></span></span><br><span class="line"><span class="handlebars"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">            `,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">closeDiv</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="comment">// 触发 input 事件，改变 show 的值为 false</span></span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.$emit(<span class="string">&quot;update:show&quot;</span>, <span class="literal">false</span>)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">            el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">            data: &#123;</span><br><span class="line"><span class="javascript">                valueChild: <span class="literal">true</span></span></span><br><span class="line">            &#125;,</span><br><span class="line">            methods: &#123;</span><br><span class="line"><span class="javascript">                <span class="function"><span class="title">changeValue</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="built_in">this</span>.valueChild = !<span class="built_in">this</span>.valueChild</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>.sync 的功能是：当子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。如果不用 .sync，那么上面的那个弹窗功能，我们也可以通过父子组件通信来解决，只是稍微有点麻烦。</p></li></ul></li><li><p>回到之前的父子组件中，我们不采用 <code>props/$emit</code>，而是用 .sync，那么就应该修改为：</p><ul><li><p>父组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:value.sync</span>=<span class="string">&quot;myValue&quot;</span> <span class="attr">v-on:valueChanged</span>=<span class="string">&quot;e =&gt; myValue = e&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Chlid <span class="keyword">from</span> <span class="string">&quot;./Child&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">            myValue: 1234,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">        child: Child</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>子组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:input</span>=<span class="string">&quot;onInput&quot;</span> <span class="attr">v-bind:value</span>=<span class="string">&quot;value&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&quot;value&quot;</span>],</span></span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">onInput</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">this</span>.$emit(<span class="string">&quot;update: value&quot;</span>, e.target.value)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注意，.sync 修饰符的 v-bind 不能和表达式一起使用，这是无效的，例如 <code>v-bind:type.sync=&quot;doc.type + &#39;!&#39;&quot;</code> 是无效的，与 v-model 类似，你只能提供你想要绑定的属性名</p></li><li><p>当我们需要同时将 .sync 绑定到多个属性上时，可以将多个属性整合到一个对象中，再对此对象使用 .sync，这样就会把对象中的每一个属性都作为独立的 prop 传递出去，且每一个 prop 都已经绑定为：<code>v-bind:prop.sync</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（八）：ToDoList案例</title>
      <link href="34ed31bc146a/"/>
      <url>34ed31bc146a/</url>
      
        <content type="html"><![CDATA[<h2 id="ToDoList"><a href="#ToDoList" class="headerlink" title="ToDoList"></a>ToDoList</h2><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul><li>目标：<ul><li>显示一个输入框，一个按钮</li><li>在输入框中输入内容，点击按钮即在页面中显示出该内容，之后输入框恢复空白<br><img src="https://s2.ax1x.com/2019/11/16/MBnxAg.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/11/16/MBnxAg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>若要完全理解这个小demo，需要一些前提条件：<ul><li><code>vue</code>基础指令</li><li>初步理解<code>JavaScript</code>中的作用域以及<code>this</code>关键字</li><li>Vue全局组件以及局部组件的用法</li></ul></li></ul><hr><h3 id="最普通的方式"><a href="#最普通的方式" class="headerlink" title="最普通的方式"></a>最普通的方式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- v-model实现双向数据绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;buttonClick&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  <span class="comment">&lt;!-- @click触发点击事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>  <span class="comment">&lt;!-- v-for绑定数据来循环渲染 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 引入Vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;  <span class="comment">//创建一个新的实例对象</span></span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,  <span class="comment">//el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素）</span></span></span><br><span class="line"><span class="javascript">    data: &#123;  <span class="comment">//data:data就是Vue实例中的数据</span></span></span><br><span class="line"><span class="javascript">      list: [],  <span class="comment">//对应到v-for指令的数据</span></span></span><br><span class="line"><span class="javascript">      inputValue: <span class="string">&#x27;&#x27;</span>  <span class="comment">//对应到v-model的数据绑定</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    methods: &#123;  <span class="comment">//方法</span></span></span><br><span class="line"><span class="javascript">      buttonClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//对应到@click的方法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//将input框中的内容添加到list中，this指向的是这个app实例</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.inputValue);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//添加完之后清空input框</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="全局组件实现"><a href="#全局组件实现" class="headerlink" title="全局组件实现"></a>全局组件实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- v-model实现双向数据绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;buttonClick&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  <span class="comment">&lt;!-- @click触发点击事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用组件 --&gt;</span> <span class="comment">&lt;!-- 注意命名规则，全局组件的TodoItem在这里要写成todo-item --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-bind:content</span>=<span class="string">&#x27;item&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 引入Vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//用Vue中的component方法用来定义一个全局组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;TodoItem&#x27;</span>, &#123;  <span class="comment">//组件名为TodoItem</span></span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&#x27;content&#x27;</span>],  <span class="comment">//来自父组件的传值，即要渲染的content值</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">content</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;,  //HTML模板，在其中仍然用插值表达式来显示content值</span></span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;  <span class="comment">//创建一个新的实例对象</span></span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,  <span class="comment">//el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素）</span></span></span><br><span class="line"><span class="javascript">    data: &#123;  <span class="comment">//data:data就是Vue实例中的数据</span></span></span><br><span class="line"><span class="javascript">      list: [],  <span class="comment">//对应到v-for指令的数据</span></span></span><br><span class="line"><span class="javascript">      inputValue: <span class="string">&#x27;&#x27;</span>  <span class="comment">//对应到v-model的数据绑定</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    methods: &#123;  <span class="comment">//方法</span></span></span><br><span class="line"><span class="javascript">      buttonClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//对应到@click的方法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//将input框中的内容添加到list中，this指向的是这个app实例</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.inputValue);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//添加完之后清空input框</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其实，对比我们之前用最普通的方式，这里无非就是把之前的<code>&lt;li v-for=&quot;item in list&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</code><br>  换成了<code>&lt;todo-item v-bind:content=&#39;item&#39; v-for=&#39;item in list&#39;&gt;&lt;/todo-item&gt;</code>，<br>  然后定义了一个全局的组件<code>TodoItem</code></li><li>那么，组件与普通方式之间，分别对应着什么呢？<ul><li>我们用<code>Vue.component</code>方法定义了一个叫<code>TodoItem</code>的全局组件，它的<code>template</code>属性的值，就是用来替换<code>&lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;</code>的</li><li>注册组件之后我们就可以使用啦，我们在<code>div</code>中直接用<code>&lt;todo-item&gt;&lt;/todo-item&gt;</code>即可</li><li>另外，为了替换掉普通方法中的<code>v-for=&#39;item in list&#39;</code>，<br>  我们在组件中使用了<code>v-bind:content=&#39;item&#39;</code>以及<code>v-for=&#39;item in list&#39;</code></li><li>最后一步：组件传值，我们现在只有<code>v-bind:connent</code>和<code>content</code>，还没传值呢，所以我们用<code>props</code>属性来接受父组件的传值（也就是这里的<code>input</code>框中的输入，另外，实际上这里的Vue实例最外层就是父组件）</li></ul></li><li>来梳理一下整个过程：<ul><li>在<code>input</code>框中输入内容，并点击<code>添加</code>，触发<code>buttonClick()</code>，<code>data.list</code>添加<code>input</code>框中的内容</li><li><code>v-for</code>用<code>item</code>遍历了<code>data.list</code>，并将值通过<code>v-bind:content</code>传给<code>&lt;todo-item&gt;&lt;/todo-item&gt;</code>标签</li><li>最后用插值表达式将<code>content</code>打印出来</li></ul></li></ul><hr><h3 id="局部组件实现"><a href="#局部组件实现" class="headerlink" title="局部组件实现"></a>局部组件实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span>/&gt;</span>  <span class="comment">&lt;!-- v-model实现双向数据绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;buttonClick&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  <span class="comment">&lt;!-- @click触发点击事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意命名，这里的名称以Vue实例中的components的属性名为准 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo</span> <span class="attr">v-bind:content</span>=<span class="string">&#x27;item&#x27;</span> <span class="attr">v-for</span>=<span class="string">&#x27;item in list&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">todo</span>&gt;</span>  <span class="comment">&lt;!-- 使用组件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>  <span class="comment">&lt;!-- 引入Vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> TodoItem = &#123;  <span class="comment">//定义局部组件的名称为TodoItem</span></span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&#x27;content&#x27;</span>],  <span class="comment">//接受父组件传值</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">li</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">content</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;,  //HTML模板</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;  <span class="comment">//创建一个新的实例对象</span></span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,  <span class="comment">//el:element 的简写，用来指定Vue应用程序接管的元素（包括所有的子元素）</span></span></span><br><span class="line"><span class="javascript">    components: &#123;  <span class="comment">//注册组件</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//定义时为TodoItem，现在在实例中另外取名为todo，使用时以后者为准</span></span></span><br><span class="line">      todo: TodoItem,</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    data: &#123;  <span class="comment">//data:data就是Vue实例中的数据</span></span></span><br><span class="line"><span class="javascript">      list: [],  <span class="comment">//对应到v-for指令的数据</span></span></span><br><span class="line"><span class="javascript">      inputValue: <span class="string">&#x27;&#x27;</span>  <span class="comment">//对应到v-model的数据绑定</span></span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    methods: &#123;  <span class="comment">//方法</span></span></span><br><span class="line"><span class="javascript">      buttonClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//对应到@click的方法</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">//将input框中的内容添加到list中，this指向的是这个app实例</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.inputValue);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//添加完之后清空input框</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>其实这里的局部组件已经很容易掌握了，对比之前，全局组件是用<code>Vue.component</code>方法定义的，而局部组件直接将整个内容写成了一个<strong>对象</strong></li><li>然后在Vue实例中，通过<code>components</code>属性，将该组件作为属性值注册了该组件，最后直接使用组件</li></ul><hr><h2 id="增加一个功能"><a href="#增加一个功能" class="headerlink" title="增加一个功能"></a>增加一个功能</h2><h3 id="要求-1"><a href="#要求-1" class="headerlink" title="要求"></a>要求</h3><ul><li>在之前的<code>ToDoList</code>基础上，要增加一项功能：<ul><li>点击一项内容，点击后即消失</li><li>在输入框中回车即可添加一项<br><img src="https://s2.ax1x.com/2019/11/16/MBuZEF.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/11/16/MBuZEF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>知识前提：<ul><li>组件传值</li><li>JavaScript字符串方法</li><li>Vue按键修饰符</li></ul></li></ul><hr><h3 id="组件实现"><a href="#组件实现" class="headerlink" title="组件实现"></a>组件实现</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 事件修饰符将回车事件keyup.enter指向buttonClick函数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;buttonClick&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;buttonClick&quot;</span>&gt;</span>添加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-item</span> <span class="attr">v-bind:content</span> = <span class="string">&#x27;item&#x27;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">v-for</span> = <span class="string">&#x27;(item, index) in list&#x27;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">v-bind:index</span> = <span class="string">&#x27;index&#x27;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">v-on:delete</span> = <span class="string">&#x27;parentDelete&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/vue&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;TodoItem&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;index&#x27;</span>],  <span class="comment">//接受来自父组件的传值</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//点击元素，触发子组件的childDelete事件</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &#x27;<span class="tag">&lt;<span class="name">li</span> @<span class="attr">click</span>=<span class="string">&quot;childDelete&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123; <span class="name">content</span> &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span>&#x27;,</span></span></span><br><span class="line">    methods: &#123;</span><br><span class="line">      /*子组件向外触发一个名为delete的事件，这个事件将会被父组件监听，从而触发parentDelete</span><br><span class="line"><span class="javascript">      子组件向父组件传的值不仅有事件名称<span class="keyword">delete</span>，还有一个index来表示该元素的下标*/</span></span><br><span class="line"><span class="javascript">      childDelete: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;delete&#x27;</span>, <span class="built_in">this</span>.index);  <span class="comment">//this.index来自于props接受的值</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      list: [],</span><br><span class="line"><span class="javascript">      inputValue: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      buttonClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.inputValue);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="comment">//父组件监听到子组件的delete事件被触发时</span></span></span><br><span class="line"><span class="javascript">      parentDelete: <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123; <span class="comment">//接受子组件的传值，index来自于子组件的this.index</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.list.splice(index, <span class="number">1</span>); <span class="comment">//js字符串方法删除指定下标的元素</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>很明显，我们不该从上往下读代码，这样是自己为难自己，我们应该从功能的角度考虑.</li><li>我们要实现的功能是：点击元素，让它消失，但是元素在子组件中，消失与否是受父组件的<code>list</code>与<code>v-for</code>共同确定渲染的</li><li>所以，我们的大概思路应该是：<ul><li>点击元素，让子组件将该元素的下标都传给父组件</li><li>然后父组件删除在<code>list</code>中该下标的元素，即可实现整个过程</li></ul></li><li>所以，我们的关键操作是：<ul><li>在定义局部组件时，给<code>template</code>属性的HTML模板添加<code>childDelete</code>，点击时触发</li><li>通过<code>this.$emit</code>将<code>this.index</code>传给父组件，但是我们需要为此绑定一个事件，以供父组件实时监听，我们命名为<code>delete</code></li><li>父组件通过<code>v-on:delete</code>监听到时，触发<code>parentDelete</code>来删除该元素</li><li>但是<code>parentDelete</code>肯定需要知道该元素下标，所以我们在最开始就要把下标传给子组件，子组件再返回给<code>parentDelete</code></li></ul></li><li>子组件与父组件之间的传值，个人感觉取决于什么时候用，比如这里的多个事件对应的多个传值，也就是说，我们在传值时务必弄清楚这个值所对应的事件是什么</li></ul><hr><h2 id="单文件组件重构"><a href="#单文件组件重构" class="headerlink" title="单文件组件重构"></a>单文件组件重构</h2><h3 id="安装-vue-cli"><a href="#安装-vue-cli" class="headerlink" title="安装@vue/cli"></a>安装<code>@vue/cli</code></h3><ol><li>现在，我们完全建立一个新文件 <code>project</code>，并进入该目录下</li><li>卸载旧版本的 <code>vue-cli</code>，并下载新版本的 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g vue-cli</span><br><span class="line">npm install -g @vue/cli</span><br><span class="line">vue -V  // 检查vue-cli版本</span><br></pre></td></tr></table></figure></li></ol><h3 id="构建项目"><a href="#构建项目" class="headerlink" title="构建项目"></a>构建项目</h3><ol><li>进入 <code>/project</code> 中，输入以下命令并一直默认即可 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-app</span><br></pre></td></tr></table></figure></li><li>启动项目 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure> 打开 <a href="http://localhost:8080/">http://localhost:8080</a> 查看初始效果</li></ol><h3 id="开始写组件"><a href="#开始写组件" class="headerlink" title="开始写组件"></a>开始写组件</h3><ol><li>进入 <code>src/APP.vue</code>，删除所有代码，重写： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">&quot;app&quot;</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123;msg&#125;&#125;&lt;/h1&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">&quot;text&quot;</span> v-model=<span class="string">&quot;info&quot;</span>&gt;</span><br><span class="line">      &lt;button @click=<span class="string">&quot;handleClick&quot;</span>&gt;添加&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;h2&gt;Vue 组件 dom 结构&lt;/h2&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;todo-item v-<span class="keyword">for</span>=<span class="string">&quot;(item, key) in list&quot;</span> :key=<span class="string">&quot;key&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 具名插槽 v-slot:item 是 vue2<span class="number">.6</span> 的新语法 --&gt;</span><br><span class="line">        &lt;template v-slot:item=<span class="string">&quot;itemProps&quot;</span>&gt;</span><br><span class="line">          &lt;span :style=<span class="string">&quot;&#123;fontSize: &#x27;20px&#x27;, color: itemProps.checked ? &#x27;red&#x27;: &#x27;blue&#x27;&#125;&quot;</span>&gt;</span><br><span class="line">            &#123;&#123;item&#125;&#125;</span><br><span class="line">          &lt;/span&gt;</span><br><span class="line">        &lt;/template&gt;</span><br><span class="line">      &lt;/todo-item&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> TodoItem <span class="keyword">from</span> <span class="string">&#x27;./components/TodoItem.vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">      info: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">      list: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.info)</span><br><span class="line">      <span class="built_in">this</span>.info = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    TodoItem</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li>新建 <code>components/TodoItem.vue</code>： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;item&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;checkbox&quot;</span> v-model=<span class="string">&quot;checked&quot;</span>&gt;</span><br><span class="line">    &lt;slot name=<span class="string">&quot;item&quot;</span> v-bind=<span class="string">&quot;&#123;checked&#125;&quot;</span>&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;item&#x27;</span>,</span><br><span class="line">  props: [<span class="string">&#x27;item&#x27;</span>],</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      checked: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .item &#123;</span><br><span class="line">    color: red;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li>重新输入 <code>npm run serve</code> 查看结果</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（七）：组件通信详解</title>
      <link href="47a92c648838/"/>
      <url>47a92c648838/</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-images.githubusercontent.com/49378661/86891457-75ac3600-c131-11ea-9f2f-2c61a77ef22a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/86891457-75ac3600-c131-11ea-9f2f-2c61a77ef22a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1"></p><h2 id="Props-emit"><a href="#Props-emit" class="headerlink" title="Props / $emit"></a>Props / $emit</h2><blockquote><p>父传子用 <code>props</code>：父组件通过 <code>v-bind</code> 将数据传递出去，子组件通过 <code>props</code> 接收数据<br>子传父用 <code>$emit</code>：子组件通过 <code>emit</code> 将数据传递出去，父组件通过事件接收数据</p></blockquote><h3 id="Props：父组件传给子组件"><a href="#Props：父组件传给子组件" class="headerlink" title="Props：父组件传给子组件"></a>Props：父组件传给子组件</h3><ul><li><p>父组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;section&quot;&gt;</span><br><span class="line">    &lt;child :list&#x3D;&quot;list&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &quot;.&#x2F;Child&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Father&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child: Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;list&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上述过程是：</p><ul><li>父组件通过 <code>v-bind</code> 将数组绑定到 <code>list</code> 上</li><li>子组件通过 <code>props</code> 接收传过来的 <code>list</code>，并循环数组渲染出每个元素</li></ul></li><li><p>注：<code>Props</code> 只能从父组件传向子组件，即单向数据流，而且 <code>Props</code> 是只读的，所有的尝试修改都会报错</p></li></ul><h3 id="emit：子组件传给父组件"><a href="#emit：子组件传给父组件" class="headerlink" title="$emit：子组件传给父组件"></a>$emit：子组件传给父组件</h3><p><code>$emit</code> 会绑定一个自定义事件，当语句被执行时，就会将该事件中的参数传递给父组件，父组件通过 <code>v-on</code> 接收参数，我们承接上一个案例，在渲染每个子组件的同时，在父组件中显示出该元素的下标：</p><ul><li><p>父组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;section&quot;&gt;</span><br><span class="line">    &lt;child :list&#x3D;&quot;list&quot; @printIndex&#x3D;&quot;printIndex&quot;&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &quot;.&#x2F;Child&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Father&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child: Child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;点击元素即显示对应下标&quot;,</span><br><span class="line">      list: [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    printIndex(idx) &#123;</span><br><span class="line">      this.msg &#x3D; idx</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p v-for&#x3D;&quot;(item, index) in list&quot; :key&#x3D;&quot;index&quot; @click&#x3D;&quot;emitIndex(index)&quot;&gt;&#123;&#123;item&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&quot;list&quot;],</span><br><span class="line">  methods: &#123;</span><br><span class="line">    emitIndex(index) &#123;</span><br><span class="line">      this.$emit(&quot;printIndex&quot;, index)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>上述过程是：</p><ul><li>子组件先是接收父组件传递过来的 <code>list</code>，再遍历数组渲染元素</li><li>渲染时绑定点击事件，触发函数 <code>emitIndex</code></li><li>通过 <code>$emit</code>  向父组件传递事件 <code>printIndex</code>，并将 <code>index</code> 参数传入该事件中</li><li>父组件监听着 <code>printIndex</code> 事件，最后再使用接收到的 <code>index</code></li></ul></li></ul><hr><h2 id="Parent-children"><a href="#Parent-children" class="headerlink" title="$Parent / $children"></a>$Parent / $children</h2><blockquote><p>$parent：</p><ul><li>当前组件树的根 Vue 实例，如果当前实例没有父实例，此实例将会是其自己。</li><li>获取之后，我们可以使用它的属性和方法。</li></ul><p>$children：</p><ul><li>当前实例的直接子组件，需要注意，<code>$children</code> 并不保证顺序，也不是响应式的。如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</li><li>获取的是子组件实例的集合，返回的是一个数组</li><li>同样，获取成功之后我们可以使用它的实例和方法</li></ul></blockquote><ul><li><p>父组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;parent&quot;&gt;</span><br><span class="line">    &lt;child&gt;&lt;&#x2F;child&gt;</span><br><span class="line">    &lt;p&gt;在父组件中改变子组件的值：&lt;button @click&#x3D;&quot;changeVal&quot;&gt;点击改变子组件的值&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import child from &quot;.&#x2F;child&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;parent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      parentMsg: &quot;this is parent&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeVal() &#123;</span><br><span class="line">      this.$children[0].childMsg &#x3D; &quot;this is new child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;childMsg&#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;p&gt;在子组件中获取父组件的值：&#123;&#123;parent&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;在子组件中改变父组件的值：&lt;button @click&#x3D;&quot;change&quot;&gt;点击改变父组件的值&lt;&#x2F;button&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;child&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      childMsg: &quot;this is child&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    parent() &#123;</span><br><span class="line">      return this.$parent.parentMsg</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    change() &#123;</span><br><span class="line">      this.$parent.parentMsg &#x3D; &quot;this is new parent&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>另外，如果子组件是公共组件，会被多个父组件调用，那么，针对不同的父组件调用，子组件会每次都会生成一个实例，这也是Vue的重要机制，<code>$parent</code> 会获取每个调用它的父组件实例，子组件中通过 <code>$parent</code> 会改变每个调用它的父组件中的对应属性。</p></li></ul><hr><h2 id="eventBus-总线"><a href="#eventBus-总线" class="headerlink" title="eventBus 总线"></a>eventBus 总线</h2><blockquote><p>通过一个空的 vue 实例作为中央事件总线，就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或者接收事件，所有组件都可通知其他组件</p></blockquote><ul><li><p>初始化：创建一个事件总线，并将其导出，以便其他模块可以使用它或者监听它</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br></pre></td></tr></table></figure></li><li><p>根组件：将两个子组件渲染出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;child_a&gt;&lt;&#x2F;child_a&gt;</span><br><span class="line">    &lt;child_b&gt;&lt;&#x2F;child_b&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildA from &quot;.&#x2F;ChildA&quot;</span><br><span class="line">import ChildB from &quot;.&#x2F;ChildB&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child_a: ChildA,</span><br><span class="line">    child_b: ChildB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件 <code>ChildA</code>：此组件的功能是：通过 <code>EventBus.$emit</code> 发送事件（即此处的 addtion ），即点击按钮就触发 numA 加 1 的事件,将 numA 的最新值传给总线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ChildA&quot;&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;addtion&quot;&gt;点击递增&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ChildA&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      numA: 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addtion() &#123;</span><br><span class="line">      EventBus.$emit(&quot;addtion&quot;, &#123;</span><br><span class="line">        numA: this.numA++</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件 <code>ChildB</code>：此组件的功能是：通过 <code>EventBus.$on</code> 接收事件，接收到最新值，并将其通过计算，再渲染出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ChildB&quot;&gt;</span><br><span class="line">    ChildB 组件中 numB 的值（也就是 ChildA 组件中 numA 的值）：&#123;&#123;numB&#125;&#125;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ChildB&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      numB: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    EventBus.$on(&quot;addtion&quot;, param &#x3D;&gt; &#123;</span><br><span class="line">      &#x2F;&#x2F; 这里的 param 是一个对象，属性是 numA</span><br><span class="line">      this.numB &#x3D; param.numA</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="attrs-listeners"><a href="#attrs-listeners" class="headerlink" title="$attrs / $listeners"></a>$attrs / $listeners</h2><blockquote><p>在 vue2.4 中，为了解决跨级之间的数据传递需求，引入了 <code>$attrs</code> 和 <code>$listeners</code>，新增了 <code>inheritAttrs</code> 选项，在 vue2.4 之前默认父作用域不作为 prop 被识别以及被获取的特性绑定（class 与 style 除外），将会出现 “回退”，从而作为普通的 HTML 特性引用在子组件的根元素上</p><p>$attrs：包含了父作用域不作为 prop 被识别以及被获取的特性绑定（class 与 style 除外）</p><ul><li>当一个组件没有声明任何 prop 时，这里会包含所有在父作用域的绑定（class 与 style 除外），并且可通过 <code>v-bind=&quot;$attrs&quot;</code> 传入内部组件，通常配合 inheritAttrs 一起使用</li></ul><p>$listeners：包含了父作用域中的 <code>v-on</code> 事件监听器（不包含 .native），它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件</p></blockquote><ul><li><p>根组件：将数据传给子组件 <code>ChildA.vue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;child_a  :name &#x3D; &quot;name&quot;</span><br><span class="line">              :age &#x3D; &quot;age&quot;</span><br><span class="line">              :gender &#x3D; &quot;gender&quot;</span><br><span class="line">              :height &#x3D; &quot;height&quot;</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;&#x2F;child_a&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildA from &quot;.&#x2F;ChildA&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;app&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child_a: ChildA,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      name: &quot;ozzie&quot;,</span><br><span class="line">      age: 20,</span><br><span class="line">      gender: &quot;男&quot;,</span><br><span class="line">      height: &quot;178&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件 <code>ChildA.vue</code>：将数据传递给孙组件 <code>ChildB.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ChildA&quot;&gt;</span><br><span class="line">    &lt;p&gt;ChildA 部分：&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;name: &#123;&#123;name&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;ChildA 中的 $attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;child_b v-bind&#x3D;&quot;$attrs&quot;&gt;&lt;&#x2F;child_b&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ChildB from &quot;.&#x2F;ChildB&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ChildA&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    child_b: ChildB</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,  &#x2F;&#x2F; 关闭了挂载到组件根元素上的没有在 props 声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    name: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs)  &#x2F;&#x2F; &#123;age: 20, gender: &quot;男&quot;, height: &quot;178&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>孙组件 <code>ChildB.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;ChildB&quot;&gt;</span><br><span class="line">    &lt;p&gt;ChildB 部分：&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;age: &#123;&#123;age&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;ChildB 中的 $attrs: &#123;&#123;$attrs&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;EventBus&#125; from &quot;.&#x2F;event&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ChildB&quot;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    age: Number</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs)  &#x2F;&#x2F; &#123;gender: &quot;男&quot;, height: &quot;178&quot;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/86891342-439ad400-c131-11ea-9870-c51c930c3313.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/86891342-439ad400-c131-11ea-9870-c51c930c3313.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200708153615709"></p></li></ul><hr><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote><p>此部分我已放在了：<a href="https://github.com/OzzieNicholas/Blog/issues/48">Vuex教程（二）：几大核心概念</a></p></blockquote><hr><blockquote><p>暂时说到这里，之后会陆续补充</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（六）：组件的理解、定义、使用</title>
      <link href="114013a3cada/"/>
      <url>114013a3cada/</url>
      
        <content type="html"><![CDATA[<h2 id="组件的理解"><a href="#组件的理解" class="headerlink" title="组件的理解"></a>组件的理解</h2><h3 id="什么是组件？"><a href="#什么是组件？" class="headerlink" title="什么是组件？"></a>什么是组件？</h3><ol><li>组件其实就是页面中的一部分，它是一个具有独立的逻辑和功能或界面，同时又能根据规定的接口规则进行相互融合，变成一个完整的应用。就好比电脑的鼠标、硬盘等一个个元件</li><li>前端组件化的核心思路就是将一个巨大复杂的东西才分成粒度合理的小东西</li></ol><h3 id="使用组件的好处"><a href="#使用组件的好处" class="headerlink" title="使用组件的好处"></a>使用组件的好处</h3><ol><li>提高开发效率</li><li>方便重复使用</li><li>简化调试步骤</li><li>提升项目的可维护性</li><li>便于协同开发</li></ol><h3 id="Vue-中的组件"><a href="#Vue-中的组件" class="headerlink" title="Vue 中的组件"></a>Vue 中的组件</h3><ol><li>Vue 允许我们使用小型、独立和通常可复用的组件构建大型应用，几乎任意类型的应用界面都可以抽象为一个组件树<br><img src="https://cn.vuejs.org/images/components.png" class="lazyload" data-srcset="https://cn.vuejs.org/images/components.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Component Tree"></li><li>Vue 中的组件可以理解为预先定义好的 ViewModel 类</li><li>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例，一个 Vue 组件可以预先定义很多个选项，但最核心的是：<ul><li><strong>模板（template）</strong>：模板声明了数据和最终展现给用户的 DOM 之间的映射关系，注意，组件的<code>template</code>模板必须有且仅有一个根标签，即在<code>template</code>中，所有的内容都要用一个标签包裹起来</li><li><strong>初始数据（data）</strong>：这是一个组件的初始数据状态，对于可复用的组件来说，这通常是私有的状态，</li><li><strong>接收的外部参数（props）</strong>：组件之间通过参数来进行数据的传递和共享，参数传递遵循单向数据流的规则（即只能从上至下传递）</li><li><strong>方法（methods）</strong>：对组件中数据的改动操作一般都在组件的方法内进行，可以通过 <code>v-on</code> 指令将用户输入事件与组件方法进行绑定</li><li><strong>生命周期钩子（lifecycle hooks）</strong>：一个组件会触发多个生命周期钩子函数，比如 created、attached、destroyed 等等，在这些钩子函数中，我们可以封装一些自己的逻辑，和传统的 MVC 相比，这也可以理解为 Controller 的逻辑被分化到了这些钩子函数中</li></ul></li></ol><hr><h2 id="组件的使用"><a href="#组件的使用" class="headerlink" title="组件的使用"></a>组件的使用</h2><blockquote><p>这里大致地将组件分为：全局组件、局部组件、嵌套组件、单文件组件</p></blockquote><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><ol><li><p>认识全局组件：全局组件即为所有 Vue 实例都可以使用的组件</p></li><li><p>全局组件的注册与使用：</p><ul><li><p>注册：要注册一个全局组件，你可以使用 <code>Vue.component(tagName, options)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">    template: <span class="string">&#x27;&lt;div&gt;Hello Vue&lt;/div&gt;&#x27;</span></span><br><span class="line">    <span class="comment">//其他选项...</span></span><br><span class="line">&#125;)  <span class="comment">//注意:组件名不要有大写字母，多个单词使用中划线 &#x27;-&#x27;隔开</span></span><br></pre></td></tr></table></figure></li><li><p>使用：组件注册之后，便可以在 <strong>父实例</strong> 的模块中以自定义元素的形式来使用，注意，要确保在初始化根实例之前注册了组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;example&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>完整代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;  <span class="comment">//在根实例之前注册</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">// 创建根实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#example&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>应用场景：若该组件的功能需在任何被Vue实例挂载的标签中引用，则建议用全局组件</p></li></ol><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><ol><li><p>认识局部组件：局部组件的优点是相对于全局组件而言的，例如，当你使用 webpack 这样的构件系统时，如果注册的是全局组件，就意味着不管你是否使用，此组件都会存在于你构件的系统中，造成无谓的 js加载，而局部组件只需要在你的根实例里面去调用这个定义的组件即可。</p></li><li><p>局部组件的注册与使用：</p><ul><li><p>注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Child = &#123;</span><br><span class="line">    template: <span class="string">&quot;&lt;div&gt;A custom component!&lt;/div&gt;&quot;</span></span><br><span class="line">    <span class="comment">// 其他选项...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    components: &#123;</span><br><span class="line">        <span class="string">&#x27;my-component&#x27;</span>: Child</span><br><span class="line">        <span class="comment">// &lt;my-component&gt; 将只在父模板可用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>完整代码示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> Child = &#123;  <span class="comment">//在根实例之前注册</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">        template: &quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="comment">// 创建根实例</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#example&quot;</span>,</span></span><br><span class="line">        components: &#123;</span><br><span class="line"><span class="javascript">            <span class="string">&#x27;my-component&#x27;</span>: Child</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>A custom component!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="嵌套组件"><a href="#嵌套组件" class="headerlink" title="嵌套组件"></a>嵌套组件</h3><ol><li><p>认识嵌套组件：如下图所示，组件之间是可以相互嵌套的<br><img src="https://img-blog.csdnimg.cn/20191008215231784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NDA2OTgx,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20191008215231784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NDA2OTgx,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p></li><li><p>父组件中嵌套子组件的方法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我爱吃什么水果有这些：<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todolist</span>&gt;</span><span class="tag">&lt;/<span class="name">todolist</span>&gt;</span> <span class="comment">&lt;!-- 引用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//定义子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> child = Vue.component(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template: &quot;<span class="tag">&lt;<span class="name">div</span>&gt;</span>嵌套的子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&quot;,</span></span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="comment">//定义父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> todolist = Vue.component(&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">    template:&#x27;<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in datas&quot;</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">item.text</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#x27;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//组件中的数据必须是函数，而不是对象！</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span>&#123;</span></span><br><span class="line">        datas: [</span><br><span class="line"><span class="javascript">          &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&#x27;苹果&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;香蕉&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;雪梨&#x27;</span> &#125;,</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line"><span class="javascript">      <span class="string">&#x27;child&#x27;</span>: child,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="javascript">  <span class="comment">//定义一个Vue实例</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;                </span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#container&#x27;</span>,</span></span><br><span class="line">    data: &#123;&#125;,</span><br><span class="line"><span class="javascript">    components: &#123; <span class="comment">//注册(当然也可以用&quot;Vue.component(&#x27;todolist&#x27;,todolist);&quot;全局注册)</span></span></span><br><span class="line"><span class="javascript">      <span class="string">&#x27;todolist&#x27;</span>: todolist,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注意：在使用子组件之前必须先定义子组件，否则会报错</li><li>为什么这里的 <code>data</code> 的值是一个函数呢，因为我们这里定义的组件很有可能被复用，如果像普通的一个Vue实例，那么改动一个地方，就会引起整个组件的改变，但是我们每次复用组建的情况都可能不同，所以用一个 <code>function</code> 来返回对象，换句话说，组件的 <code>data</code> 是私有的，该 <code>data</code> 中的数据只能在对应的组件模板中使用</li></ul></li></ol><h3 id="webpack-打包单文件组件"><a href="#webpack-打包单文件组件" class="headerlink" title="webpack 打包单文件组件"></a>webpack 打包单文件组件</h3><blockquote><p>注：这里不阐述 webpack 的安装之类的，若需要请阅读：<a href="https://github.com/OzzieNicholas/Blog/projects/8">webpack 笔记</a></p><p>了解单文件组件：官网 &gt;&gt;&gt; <a href="https://cn.vuejs.org/v2/guide/single-file-components.html">https://cn.vuejs.org/v2/guide/single-file-components.html</a></p></blockquote><ol><li><p>创建一个目录 <code>test</code>，并进入，新建几个目录与文件，最后整个 demo 目录如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-test # 根目录</span><br><span class="line">  |-index.html # 主html文件</span><br><span class="line">  |-dist # 打包文件放置目录</span><br><span class="line">  |-src # 资源文件目录</span><br><span class="line">    |-main.js # 打包入口文件</span><br><span class="line">    |-components # 单文件组件目录</span><br><span class="line">      |-app.vue # 单文件组件</span><br></pre></td></tr></table></figure></li><li><p>运行以下命令初始化 <code>package.json</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>安装项目依赖：想要编译其他的文件比如 <code>react</code>，<code>coffce</code> 等，就必须要加载很多对应的 <code>loader</code>，而 <code>.vue</code> 文件也是同样的道理。</p><ul><li><p>这里我就不一一列出来需要加载哪些包了，因为最后的安装包都会在 <code>package.json</code> 中显示，所以我直接展示 <code>package.json</code> 文件，如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --open --hot&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.5.17&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;babel-core&quot;</span>: <span class="string">&quot;^6.26.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-loader&quot;</span>: <span class="string">&quot;^7.1.5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-env&quot;</span>: <span class="string">&quot;^1.7.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-stage-0&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;babel-preset-stage-3&quot;</span>: <span class="string">&quot;^6.24.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;cross-env&quot;</span>: <span class="string">&quot;^5.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;css-loader&quot;</span>: <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;file-loader&quot;</span>: <span class="string">&quot;^1.1.11&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;node-sass&quot;</span>: <span class="string">&quot;^4.9.2&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;sass-loader&quot;</span>: <span class="string">&quot;^7.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;style-loader&quot;</span>: <span class="string">&quot;^0.21.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url-loader&quot;</span>: <span class="string">&quot;^1.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-loader&quot;</span>: <span class="string">&quot;^14.2.3&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-style-loader&quot;</span>: <span class="string">&quot;^4.1.1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;vue-template-compiler&quot;</span>: <span class="string">&quot;^2.5.17&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack&quot;</span>: <span class="string">&quot;^4.16.4&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-cli&quot;</span>: <span class="string">&quot;^3.1.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;webpack-dev-server&quot;</span>: <span class="string">&quot;^3.1.5&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>按照这份 <code>package.json</code> 文件直接输入 <code>npm install</code> 即可</p></li></ul></li><li><p>配置 webpack：依赖项我们已经全部安装好了，那么下一步就是在根目录下新建 <code>webpack.config.js</code> 来进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);  <span class="comment">//node中的path对象，用于处理目录的对象</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/main&#x27;</span>,  <span class="comment">//入口文件地址</span></span><br><span class="line">  output: &#123;  <span class="comment">//输出</span></span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>),  <span class="comment">//打包输出文件的地址，使用绝对路径</span></span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,  <span class="comment">//webpack打包后的文件名</span></span><br><span class="line">    publicPath: <span class="string">&#x27;/dist/&#x27;</span>,  <span class="comment">//公共文件生成的地址</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [  <span class="comment">//加载器loader</span></span><br><span class="line">      &#123;  <span class="comment">//编译css</span></span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译scss</span></span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译sass</span></span><br><span class="line">        test: <span class="regexp">/\.sass$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;sass-loader?indentedSyntax&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//编译.vue文件</span></span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;vue-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          loaders: &#123;</span><br><span class="line">            <span class="string">&#x27;scss&#x27;</span>: [</span><br><span class="line">              <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;sass-loader&#x27;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&#x27;sass&#x27;</span>: [</span><br><span class="line">              <span class="string">&#x27;vue-style-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;css-loader&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;sass-loader?indentedSyntax&#x27;</span></span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//转换es6语法</span></span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          presets: [[<span class="string">&#x27;env&#x27;</span>, &#123;<span class="attr">modules</span>: <span class="literal">false</span>&#125;], <span class="string">&#x27;stage-0&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;  <span class="comment">//图片转化</span></span><br><span class="line">        test: <span class="regexp">/\.(png|jpg|gif|svg)$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;url-loader&#x27;</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">&#x27;[name].[ext]?[hash]&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;  <span class="comment">//别名，可以直接使用别名来代表设定的路径以及其他</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">      filter: path.join(__dirname, <span class="string">&#x27;./src/filters&#x27;</span>),</span><br><span class="line">      components: path.join(__dirname, <span class="string">&#x27;./src/components&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//require时省略的扩展名，如require(&#x27;module&#x27;)不需要写成require(&#x27;module.js&#x27;)</span></span><br><span class="line">    extensions: [<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;  <span class="comment">//服务器配置相关，以实现自动刷新</span></span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">    overlay: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  performance: &#123;</span><br><span class="line">    hints: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//开启source-map，webpack有多种source-map，在官网文档中可以查到</span></span><br><span class="line">  devtool: <span class="string">&#x27;#eval-source-map&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们已经配置好了所有，现在开始编写主 html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    #app &#123;</span><br><span class="line"><span class="css">      <span class="attribute">font-size</span>: <span class="number">30px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写入口文件 <code>/src/main.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;  <span class="comment">//RS6语法</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/app&#x27;</span>;  <span class="comment">//引入vue文件</span></span><br><span class="line"></span><br><span class="line">Vue.config.debug = <span class="literal">true</span>;  <span class="comment">//开启错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>编写组件文件 <code>/src/components/app.vue</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- &#x2F;src&#x2F;components&#x2F;app.vue --&gt;</span><br><span class="line">  &lt;div id&#x3D;&#39;app&#39;&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;  </span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;#app&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;Hello Vue&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&#39;scss&#39;&gt;</span><br><span class="line">  $example: red;</span><br><span class="line">  body &#123;</span><br><span class="line">    p &#123;</span><br><span class="line">      color: $example;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li><li><p>最后在根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><ul><li>可以查看到的结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/79726323-2f5aee00-831d-11ea-8aa8-8b94f2f57d5e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79726323-2f5aee00-831d-11ea-8aa8-8b94f2f57d5e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a"></li><li>由于我们配置了热更新，所以在改代码时页面会同步变化</li></ul></li></ol><hr><blockquote><p>本篇主要目的是入门如何使用组件，而关于组件通信，以及单文件组件的更多的配置会在之后说明</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（五）：Class与Style绑定</title>
      <link href="e7c6b30a13d6/"/>
      <url>e7c6b30a13d6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>绑定元素的 class 列表以及它的内联样式常常通过数据绑定来实现，因为它们都是属性，所以我们可以用 <code>v-bind</code> 来实现，用 <code>v-bind</code> 来绑定 class 与 style 时，表达式的类型可以是：字符串、对象、数组</p></blockquote><h2 id="绑定-Class"><a href="#绑定-Class" class="headerlink" title="绑定 Class"></a>绑定 Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><ol><li><p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;style&gt;</span><br><span class="line">    .active &#123;</span><br><span class="line">      color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">       &lt;p :class&#x3D;&quot;&#123; active: isActive &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">       &lt;button @click&#x3D;&quot;changeClass&quot;&gt;是否绑定active&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    var vm &#x3D; new Vue(&#123;</span><br><span class="line">       el: &quot;#example&quot;,</span><br><span class="line">       data: &#123;</span><br><span class="line">          isActive: true</span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line">          changeClass: function() &#123;</span><br><span class="line">             this.isActive &#x3D; (this.isActive &#x3D;&#x3D; true ? false : true)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><ul><li>是否绑定 <code>active</code> 这个 class，取决于 <code>isActive</code> 的值是否为真</li></ul></li><li><p>我们也可以传入多个属性来动态地切换 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &lt;p :class&#x3D;&quot;&#123; classOne: isClassOne, classTwo: isClassTwo &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      isClassOne: true,</span><br><span class="line">      isClassTwo: true</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;classOne classTwo&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>你也可以直接绑定一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;classObj&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      classObj: &#123;</span><br><span class="line">         A: true,</span><br><span class="line">         B: true,</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;A B&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用计算属性：可以通过计算属性返回的对象来确定需要绑定的 class，这是一个常用且强大的模式，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;classObj&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      A: true,</span><br><span class="line">      B: true,</span><br><span class="line">   &#125;,</span><br><span class="line">   computed: &#123;</span><br><span class="line">      classObj: function() &#123;  &#x2F;&#x2F;这将决定绑定的class</span><br><span class="line">         return &#123;</span><br><span class="line">            classA: this.A &amp;&amp; !this.B,</span><br><span class="line">            classB: this.A &amp;&amp; this.B</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;classB&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h3><ol><li><p>我们将一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;[ classA, classB ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      classA: &quot;A&quot;,</span><br><span class="line">      classB: &quot;B&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;A B&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>数组中仍然可以使用三元表达式，这可以切换列表中的 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;[ classA?classB:classA, classC ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      classA: &quot;A&quot;,</span><br><span class="line">      classB: &quot;B&quot;,</span><br><span class="line">      classC: &quot;C&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>数组中的三元表达式确定了绑定 <code>classA</code> 还是 <code>classB</code>，但是 <code>classC</code> 是肯定会绑定的</p></li><li><p>渲染结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;B C&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当有多个条件 class 需要处理时，写三元表达式有些繁琐，可以在数组中嵌套对象语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;[ &#123;A:isClassA, B:isClassB&#125;, classC ]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      isClassA: &quot;A&quot;,</span><br><span class="line">      isClassB: &quot;B&quot;,</span><br><span class="line">      classC: &quot;C&quot;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :class&#x3D;&quot;A B C&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="绑定组件上的-class"><a href="#绑定组件上的-class" class="headerlink" title="绑定组件上的 class"></a>绑定组件上的 class</h3><blockquote><p>提示：若未了解过组件，请阅读第七节</p></blockquote><ol><li><p>当你在自定义的组件上绑定 class 时，那些添加的 class 值会添加到组件根元素上，而根元素上已存在的 class 值也不会被覆盖，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;my-component class&#x3D;&quot;classB&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(&quot;my-component&quot;, &#123;</span><br><span class="line">   template: &quot;&lt;p class&#x3D;&#39;classA&#39;&gt;Hello Vue&lt;&#x2F;p&gt;&quot;</span><br><span class="line">&#125;)</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;classA classB&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>我们同样可以用之前学到的对象语法来绑定 class：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;my-component class&#x3D;&quot;classC&quot;&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">Vue.component(&quot;my-component&quot;, &#123;</span><br><span class="line">   template: &quot;&lt;p :class&#x3D;&#39;&#123; classA:isClassA, classB:isClassB &#125;&#39;&gt;Hello Vue&lt;&#x2F;p&gt;&quot;,</span><br><span class="line">   data: function() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">         isClassA: true,</span><br><span class="line">         isClassB: true</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;classA classB classC&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>这种用法仅适用于自定义组件的最外层是一个根元素，否则会无效，当不满足这种条件或需要给具体的子元素设置类名时，应当使用组件的 props 来传递。这些用法也适用于绑定内联样式 style</p></li></ul></li></ol><hr><h2 id="绑定-Style"><a href="#绑定-Style" class="headerlink" title="绑定 Style"></a>绑定 Style</h2><blockquote><p>在用 <code>v-bind</code> 绑定时，用法其实和绑定 class 大致相同<br>注意 css 的属性命名，可以用驼峰式（camelCase）或短横线分隔（kebab-case，记得用引号括起来）</p></blockquote><h3 id="对象语法-1"><a href="#对象语法-1" class="headerlink" title="对象语法"></a>对象语法</h3><p>用对象绑定 style，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :style&#x3D;&quot;&#123; color:activeColor, fontSize:fontSize+&#39;px&#39; &#125;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      activeColor: &quot;red&quot;,</span><br><span class="line">      fontSize: 50</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-size: 50px;&quot;</span>&gt;</span>Hello Vue<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>当然，这同样可以结合计算属性使用，这里就不举例了……</p></li></ul><h3 id="数组语法-1"><a href="#数组语法-1" class="headerlink" title="数组语法"></a>数组语法</h3><p>用数组语法也可以将多个样式对象应用到同一个元素上，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p :style&#x3D;&quot;[styleA, styleB]&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">   el: &quot;#example&quot;,</span><br><span class="line">   data: &#123;</span><br><span class="line">      styleA: &#123;</span><br><span class="line">         color: &quot;red&quot;,</span><br><span class="line">         fontSize: &quot;50px&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      styleB: &#123;</span><br><span class="line">         fontWeight: 200,</span><br><span class="line">         fontFamily: &quot;cursive&quot;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">   &lt;p style&#x3D;&quot;color: red; font-size: 50px;&quot;&gt;Hello Vue&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="自动加前缀"><a href="#自动加前缀" class="headerlink" title="自动加前缀"></a>自动加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Vendor_Prefix">浏览器引擎前缀</a> 的 CSS 属性时，如 <code>transform</code>，Vue.js 会自动侦测并添加相应的前缀</p><hr><blockquote><p>本节主要介绍了如何绑定 class 与 style，加油！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（四）：过滤器、计算属性与侦听器</title>
      <link href="ffb8c7466790/"/>
      <url>ffb8c7466790/</url>
      
        <content type="html"><![CDATA[<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><ol><li><p>Vue.js 允许你自定义过滤器，可被用于一些常见的文本格式化。</p></li><li><p>过滤器可以用在两个地方：双花括号插值 和 v-bind 表达式</p></li><li><p>过滤器应该被添加在 JavaScript 表达式的尾部，由 “管道” 符号指示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在双花括号中 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &#123;&#123;&#125;&#125;中的 &quot;|&quot; 表示过滤器管道符，过滤器后面的为过滤函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; 数据 | 过滤器&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 在 v-bind 表达式中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;数据 | 过滤器&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>过滤器支持全局定义和组件中定义：</p><ul><li><p>可以在一个组件的选项中定义本地的过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filters: &#123;</span><br><span class="line">  test: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    value = value.toString();</span><br><span class="line">    <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以在创建 Vue 实例之前全局定义过滤器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vue.filter(<span class="string">&#x27;test&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!value) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  value = value.toString();</span><br><span class="line">  <span class="keyword">return</span> value.charAt(<span class="number">0</span>).toUpperCase() + value.slice(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当全局过滤器和局部过滤器重名时，会采用局部过滤器。</p></li><li><p>过滤器函数接收表达式的值作为第一个参数，在上述例子中，过滤器函数 test 将会收到 message 的值作为第一个参数。</p></li></ul></li><li><p>过滤器可以串联：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA | filterB &#125;&#125;</span><br></pre></td></tr></table></figure><ul><li>filterA 被定义为接收单个参数的过滤器函数，表达式 message 的值将作为参数传入到函数中。</li><li>然后将 filterA 的结果传递到 filterB 中，继续调用同样被定义为接收单个参数的过滤器函数 filterB。</li></ul></li><li><p>过滤器是 JS 函数，因此可以接收参数：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; message | filterA(&#x27;arg1&#x27;, arg2) &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>案例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &#123;&#123;&#125;&#125;中的|表示过滤器管道符,过滤器后面的为过滤函数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg | msgFormat(&#x27;疯狂+1&#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 多个过滤函数进行调用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg | msgFormat(&#x27;疯狂+1&#x27;) | test&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;time | dateFormat&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    /*过滤器的定义语法：</span><br><span class="line"><span class="javascript">    Vue.filter(<span class="string">&#x27;过滤器的名称&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;)</span></span><br><span class="line"><span class="javascript">    过滤器中的<span class="function"><span class="keyword">function</span>,第一个参数<span class="title">data</span>，已经被规定死，永远都是过滤器管道符前面传递过来的数据</span></span></span><br><span class="line">    从第二个参数开始就是传值</span><br><span class="line"><span class="javascript">    例如：Vue.filter(<span class="string">&#x27;过滤器名称&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> data+<span class="number">123</span></span></span><br><span class="line">        &#125;);*/</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 定义一个叫做 msgFormat 的 Vue 全局过滤器</span></span></span><br><span class="line"><span class="javascript">    Vue.filter(<span class="string">&#x27;msgFormat&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg, param</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//字符出中的replace方法，第一个参数，出了写一个字符串之外，还可以定义一个正则</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> msg.replace(<span class="regexp">/单纯/g</span>, param)</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    Vue.filter(<span class="string">&#x27;test&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> msg + <span class="string">&#x27;love&#x27;</span></span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="comment">//如何定义一个私有过滤器（局部）</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            msg: <span class="string">&#x27;Hello World&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            time: <span class="keyword">new</span> <span class="built_in">Date</span>(),</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        <span class="comment">//定义私有过滤器，过滤器有两个条件：&quot;过滤器名称&quot; 和 &quot;处理函数&quot;</span></span></span><br><span class="line">        filters: &#123;</span><br><span class="line">            /*</span><br><span class="line">            过滤器调用的时候，采用的是就近原则，</span><br><span class="line">            如果私有过滤器和全局过滤器名称一致了，这时候优先调用私有过滤器</span><br><span class="line">            */</span><br><span class="line"><span class="javascript">            <span class="comment">//param = &#x27;&#x27;;es6的初始化值</span></span></span><br><span class="line"><span class="javascript">            dateFormat: <span class="function"><span class="keyword">function</span>(<span class="params">time, param = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> dt = <span class="keyword">new</span> <span class="built_in">Date</span>(time);</span></span><br><span class="line"><span class="javascript">                <span class="comment">// yyyy-mm-dd</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> y = dt.getFullYear();</span></span><br><span class="line"><span class="javascript">                <span class="comment">// var m = dt.getMonth()+1;</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> m = (dt.getMonth() + <span class="number">1</span>).toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> d = dt.getDate();</span></span><br><span class="line"><span class="javascript">                <span class="comment">// return y+&#x27;-&#x27;+m+&#x27;-&#x27;+d;</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">//模板字符串</span></span></span><br><span class="line"><span class="javascript">                <span class="comment">// return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`;</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (param.toLowerCase() === <span class="string">&#x27;yyyy-mm-dd&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> hh = dt.getHours();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> mm = (dt.getMinutes()).toString().padStart(<span class="number">2</span>, <span class="string">&#x27;0&#x27;</span>);</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> ss = dt.getSeconds();</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;y&#125;</span>-<span class="subst">$&#123;m&#125;</span>-<span class="subst">$&#123;d&#125;</span> <span class="subst">$&#123;hh&#125;</span>:<span class="subst">$&#123;mm&#125;</span>:<span class="subst">$&#123;ss&#125;</span>`</span></span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="概述计算属性和侦听器"><a href="#概述计算属性和侦听器" class="headerlink" title="概述计算属性和侦听器"></a>概述计算属性和侦听器</h2><p>computed 和 watch 大概是 Vue 里除了 data、methods、props 之外，用的最多的选项了。Vue 中数据变更之所以能更新到页面里，因为对 data 执行 getter/setter 转化，然后进行侦听，而 computed 和 watch 属性都是基于此，我们看看一个 Watcher 是怎样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?<span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    vm: Component,</span></span><br><span class="line"><span class="params">    expOrFn: string | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">    options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">    isRenderWatcher?: boolean</span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算getter，重新收集依赖</span></span><br><span class="line">  get () &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addDep (dep: Dep) &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清理依赖集合</span></span><br><span class="line">  cleanupDeps () &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 订阅接口，将在依赖项更新时调用</span></span><br><span class="line">  update () &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用接口，将被调配者调用</span></span><br><span class="line">  run () &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 该watcher的所有依赖</span></span><br><span class="line">  depend () &#123; <span class="comment">//... &#125;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从所有依赖项的订户列表中删除自己</span></span><br><span class="line">  teardown () &#123; <span class="comment">//... &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算属性和侦听器都离不开数据监听。</p><hr><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><blockquote><p>之前我们提到过，模板是可以使用 JS 表达式的，通常使用 JS 表达式、过滤器就可以处理数据，但如果表达式过于复杂，在模板中放入过多的逻辑会导致模板过重且难以维护，此时可以使用计算属性。</p></blockquote><h3 id="初识计算属性"><a href="#初识计算属性" class="headerlink" title="初识计算属性"></a>初识计算属性</h3><ol><li><p>例如下面这段代码，模板就显得很笨重：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li><li><p>此时，我们引入了一个叫做 <code>computed</code> 的选项，专门用于处理这些复杂的逻辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &lt;p&gt;正常顺序的字符串：&#123;&#123;message&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;翻转之后的字符串：&#123;&#123;reverseMessage&#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        message: &quot;Hello Vue&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        reverseMessage: function() &#123;</span><br><span class="line">            &#x2F;&#x2F;this 指向的是 vm 实例</span><br><span class="line">            return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>渲染结果为：</p><p><img src="https://user-images.githubusercontent.com/49378661/80324659-7fc5d480-8864-11ea-95ec-ca1d7c4d7237.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324659-7fc5d480-8864-11ea-95ec-ca1d7c4d7237.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587712127627"></p></li></ul></li></ol><ol start="3"><li><p>计算属性支持读取设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 仅读取</span></span><br><span class="line">    read: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.a * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取和设置</span></span><br><span class="line">    change: &#123;</span><br><span class="line">      get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      set: <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.a = value - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/95838387-4a5e6600-0d74-11eb-96fd-7ac749d0adc8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95838387-4a5e6600-0d74-11eb-96fd-7ac749d0adc8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201013164830836"></p></li></ol><h3 id="getter-与-setter"><a href="#getter-与-setter" class="headerlink" title="getter 与 setter"></a>getter 与 setter</h3><ol><li><p>我们再看一个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; fullName &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Ozzie&quot;,</span><br><span class="line">        lastName: &quot;Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName: function() &#123;</span><br><span class="line">            &#x2F;&#x2F;this 指向的是 vm 实例</span><br><span class="line">            return this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>页面中显示：”Ozzie Nicholas”，这说明我们结果是正确的</p></li><li><p>现在的逻辑是：我们在 <code>data</code> 中定义了 <code>firstName</code> 和 <code>lastName</code>，通过计算属性计算出 <code>fullName</code> 的值，打开控制台，我们可以明显地看到各个值<br><img src="https://user-images.githubusercontent.com/49378661/80324684-979d5880-8864-11ea-87ca-786912d10ccf.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324684-979d5880-8864-11ea-87ca-786912d10ccf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587722401218"></p></li><li><p>我们尝试着在控制台改变 <code>fullName</code> 的值，会报错如下，而且，页面上仍然显示的是 “Ozzie Nicholas” 而非 “change value”<br><img src="https://user-images.githubusercontent.com/49378661/80324695-a4ba4780-8864-11ea-9b7e-3723490d66da.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324695-a4ba4780-8864-11ea-9b7e-3723490d66da.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587722551725"></p></li></ul></li></ol><ol start="2"><li><p>上面的尝试失败，是因为我们没有设置 <code>set</code></p></li><li><p>计算属性由两部分组成：<code>get</code> 和 <code>set</code>，默认只有 get，比如上个案例中，函数 <code>reverseMessage</code> 就是计算属性的 get 部分，若要设置 set，则需要我们自己手动添加，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; fullName &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Ozzie&quot;,</span><br><span class="line">        lastName: &quot;Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">        fullName: &#123;</span><br><span class="line">            &#x2F;&#x2F;getter</span><br><span class="line">            get: function() &#123;</span><br><span class="line">                console.log(&quot;计算了一次&quot;);  &#x2F;&#x2F;调用了一次 getter</span><br><span class="line">                return this.firstName + &quot; &quot; + this.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F;setter</span><br><span class="line">            set: function(value) &#123;</span><br><span class="line">                &#x2F;&#x2F;注意这里不能直接使用 this</span><br><span class="line">                const arr &#x3D; value.split(&quot; &quot;)</span><br><span class="line">                this.firstname &#x3D; arr[0]  &#x2F;&#x2F;对它的依赖进行赋值</span><br><span class="line">                this.lastName &#x3D; arr[1]  &#x2F;&#x2F;对它的依赖进行赋值</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>我们再次尝试修改，页面如愿地变化了，而且控制台还打印了，这说明了过程大致是：先在 set 中改变 firstName 与 lastName，再调用 getter 将值返回给 fullName<br><img src="https://user-images.githubusercontent.com/49378661/80324714-b0a60980-8864-11ea-9763-37a24e41cc6b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324714-b0a60980-8864-11ea-9763-37a24e41cc6b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587723232628"></li></ul></li></ol><ul><li>注意，set 设置属性，并不是直接修改计算属性，而是修改它的依赖（fullName 依赖于 firstName 以及 lastName），当依赖发生了变化，computed 就会重新计算，所以 fullName 也会更新</li></ul><ol start="4"><li><p>Vue 里数据的变更检测是来自于 getter/setter，从而让 data 的属性能够响应数据变化。Vue 将遍历 data 选项的 JavaScript 对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 响应式的变更检测</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// getter</span></span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="comment">// 依赖检测</span></span><br><span class="line">      dep.depend();</span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          dependArray(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// setter，最终更新后会通知</span></span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value = getter ? getter.call(obj) : val;</span><br><span class="line">    <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&quot;production&quot;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">      customSetter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">    <span class="comment">// 会通知</span></span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>Vue 会在初始化实例时对属性执行 getter/setter 转化，所以，只有当实例被创建时就已经存在于 data 中的属性才是响应式的，而新增的属性等都不会触发视图的更新，那么，Vue 无法检测到对象属性的添加或删除，也无法检测一些特殊的数组变动：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有这些操作会通知变更</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">&quot;push&quot;</span>,</span><br><span class="line">  <span class="string">&quot;pop&quot;</span>,</span><br><span class="line">  <span class="string">&quot;shift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;unshift&quot;</span>,</span><br><span class="line">  <span class="string">&quot;splice&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sort&quot;</span>,</span><br><span class="line">  <span class="string">&quot;reverse&quot;</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截上述这些操作方法，然后通知变更</span></span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method];</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__;</span><br><span class="line">    <span class="keyword">let</span> inserted;</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;unshift&quot;</span>:</span><br><span class="line">        inserted = args;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;splice&quot;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted);</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>所以在更新 data 中绑定的对象或者数组的时候需要注意：除了使用可触发变更检测的特殊方法之外，也可以使用 <code>vm.$set(Vue.set)</code> 实例方法，该方法用于向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新数组</span></span><br><span class="line">vm.$set(vm.items, indexOfItem, newValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新对象</span></span><br><span class="line">vm.$set(vm.someObject, keyOfObject, newValue);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="计算属性-VS-方法"><a href="#计算属性-VS-方法" class="headerlink" title="计算属性 VS 方法"></a>计算属性 VS 方法</h3><ol><li><p>我们用 “方法” 也同样可以实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; fullName() &#125;&#125;</span><br><span class="line">    &#123;&#123; age &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Ozzie&quot;,</span><br><span class="line">        lastName: &quot;Nicholas&quot;,</span><br><span class="line">        age: 20</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        fullName: function() &#123;</span><br><span class="line">            console.log(&quot;调用了一次&quot;);</span><br><span class="line">            return this.firstName + &quot; &quot; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/80324747-d501e600-8864-11ea-9f4a-5635cf1a08d0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324747-d501e600-8864-11ea-9f4a-5635cf1a08d0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587724985965"></p></li><li><p>可以看到，只要页面重新渲染，就会调用方法</p></li></ul></li><li><p>而用计算属性的结果如下：（代码略）<br><img src="https://user-images.githubusercontent.com/49378661/80324761-e3e89880-8864-11ea-90a6-3ff98fd88103.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324761-e3e89880-8864-11ea-90a6-3ff98fd88103.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587724890419"></p></li></ol><ul><li>也就是说，只要不修改依赖项，计算属性就会使用之前缓存的值，这也就是 <strong>计算属性的缓存机制</strong>，如果没有缓存机制，那么我们会不可避免地多次执行计算属性的 getter</li></ul><hr><h2 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h2><h3 id="认识侦听器"><a href="#认识侦听器" class="headerlink" title="认识侦听器"></a>认识侦听器</h3><ol><li><p>除了计算属性，Vue 还提供了一种更通用的方法来观察和响应数据变动，即侦听属性 <code>watch</code>，侦听属性可以执行任何逻辑，比如函数节流，Ajax 异步获取数据，甚至操作 DOM（不推荐），当需要在数据变化时执行异步操作或者开销大的操作时，使用侦听器往往最有效</p></li><li><p>我们简单地使用一下侦听器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; fullName &#125;&#125;</span><br><span class="line">    &#123;&#123; age &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Ozzie&quot;,</span><br><span class="line">        lastName: &quot;Nicholas&quot;,</span><br><span class="line">        fullname: &quot;Ozzie Nicholas&quot;,  &#x2F;&#x2F;不可避免地做这个冗余的初始化</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: function() &#123;  &#x2F;&#x2F;firstName 改变时，需要重新渲染 fullName</span><br><span class="line">            console.log(&quot;侦听了一次&quot;);</span><br><span class="line">            this.fullname &#x3D; this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">        lastName: function() &#123;  &#x2F;&#x2F;lastName 改变时，需要重新渲染 fullName</span><br><span class="line">            console.log(&quot;侦听了一次&quot;);</span><br><span class="line">            this.fullname &#x3D; this.firstName + &#39; &#39; + this.lastName</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>与计算属性相同，侦听器也有缓存机制，比如我们改变 <code>age</code> 并不会引起 watch 的重新计算<br><img src="https://user-images.githubusercontent.com/49378661/80324780-f4990e80-8864-11ea-9973-4c32dc537bb9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324780-f4990e80-8864-11ea-9973-4c32dc537bb9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587865791844"></p></li><li><p>当依赖项改变时，侦听器会重新执行<br><img src="https://user-images.githubusercontent.com/49378661/80324794-fd89e000-8864-11ea-8cb1-a4d945e4105f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80324794-fd89e000-8864-11ea-8cb1-a4d945e4105f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587865934838"></p></li></ul></li><li><p>侦听器是可以执行异步任务的，例如下面这个例子，效果是用户停止输入 1 秒之后才会更新视图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;</span><br><span class="line">    &#123;&#123; fullName &#125;&#125;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      firstName: &lt;input v-model&#x3D;&quot;firstName&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      lastName: &lt;input v-model&#x3D;&quot;lastName&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm &#x3D; new Vue(&#123;</span><br><span class="line">    el: &quot;#example&quot;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        firstName: &quot;Ozzie&quot;,</span><br><span class="line">        lastName: &quot;Nicholas&quot;,</span><br><span class="line">        fullName: &quot;Ozzie Nicholas&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        firstName: function(val) &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                this.fullName &#x3D; val + &quot; &quot; + this.lastName</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">        &#125;,</span><br><span class="line">        lastName: function(val) &#123;</span><br><span class="line">            setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">                this.fullName &#x3D; this.firstName + &quot; &quot; + val</span><br><span class="line">            &#125;, 1000)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。watch支持的方式有好几种，回调函数得到的参数为新值和旧值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span>,</span><br><span class="line">    c: <span class="number">3</span>,</span><br><span class="line">    d: <span class="number">4</span>,</span><br><span class="line">    e: &#123;</span><br><span class="line">      f: &#123;</span><br><span class="line">        g: <span class="number">5</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;new: %s, old: %s&quot;</span>, val, oldVal);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 方法名</span></span><br><span class="line">    b: <span class="string">&quot;someMethod&quot;</span>,</span><br><span class="line">    <span class="comment">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span></span><br><span class="line">    c: &#123;</span><br><span class="line">      handler: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 该回调将会在侦听开始之后被立即调用</span></span><br><span class="line">    d: &#123;</span><br><span class="line">      handler: <span class="string">&quot;someMethod&quot;</span>,</span><br><span class="line">      immediate: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    e: [</span><br><span class="line">      <span class="string">&quot;handle1&quot;</span>,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">handle2</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        handler: <span class="function"><span class="keyword">function</span> <span class="title">handle3</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">          <span class="comment">/* ... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// watch vm.e.f&#x27;s value: &#123;g: 5&#125;</span></span><br><span class="line">    <span class="string">&quot;e.f&quot;</span>: <span class="function"><span class="keyword">function</span>(<span class="params">val, oldVal</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">someMethod</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">vm.a = <span class="number">2</span>; <span class="comment">// =&gt; new: 2, old: 1</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="计算属性-VS-侦听器"><a href="#计算属性-VS-侦听器" class="headerlink" title="计算属性 VS 侦听器"></a>计算属性 VS 侦听器</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/13/16b4e78acdcb3f7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/6/13/16b4e78acdcb3f7b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><ol><li><p>watch：监测的是属性值，只要属性值变化，就会触发执行回调函数</p></li><li><p>computed：监测的是依赖值，依赖值不变的情况下会直接读取缓存，否则会重新计算然后重新渲染</p></li><li><p>注意：计算属性是不能执行异步任务的，计算属性必须同步执行，计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性，watch 也可以检测 computed 属性，</p></li><li><p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑</p><ul><li>computed 能做的，watch 都能做，反之则不行</li><li>能用 computed 尽量用 computed</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（三）：实例与模板语法</title>
      <link href="f7fd555ae7a3/"/>
      <url>f7fd555ae7a3/</url>
      
        <content type="html"><![CDATA[<h2 id="Vue-实例"><a href="#Vue-实例" class="headerlink" title="Vue 实例"></a>Vue 实例</h2><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><ol><li><p>每个 Vue 应用都是通过用 Vue 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">//选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>当创建一个实例时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项，全部的选项可以在 <a href="http://caibaojian.com/vue/api">API 文档</a> 中查看</p></li><li><p>一个 Vue 应用由一个 <code>new Vue</code> 创建的 <strong>根 vue 实例</strong>，以及众多组件组成</p></li></ol><h3 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h3><ol><li><p>每个 Vue 实例都会代理其 <code>data</code> 对象里所有的属性，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: test</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.a === test.a  <span class="comment">//true</span></span><br><span class="line"><span class="comment">//设置属性也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span>;</span><br><span class="line">test.a  <span class="comment">//2</span></span><br><span class="line"><span class="comment">//反之亦然</span></span><br><span class="line">test.a = <span class="number">3</span>;</span><br><span class="line">vm.a  <span class="comment">//3</span></span><br></pre></td></tr></table></figure><ul><li>注意，只有这些被代理的属性才是响应的，若在实例创建之后再添加新的属性到实例上，那么这个新属性不会引起视图更新</li></ul></li><li><p>除了 <code>data</code> 之外，Vue 暴露了一些有用的实例属性与方法，这些属性与方法都有前缀 <code>$</code>，以便与代理的 <code>data</code> 属性区分，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    data: test</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === test  <span class="comment">//true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//$watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">newVal, oldVal</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这个回调将在 vm.a 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>注意，不要在实例属性或者回调函数中（比如 <code>vm.$watch(&#39;a&#39;, newVal =&gt; this.myMethod())</code>）使用箭头函数，因为箭头函数绑定上下文，所以 <code>this</code> 没有指向的是 Vue 实例，而是指向未定义的 <code>this.method</code></li></ul></li></ol><h3 id="实例基本选项"><a href="#实例基本选项" class="headerlink" title="实例基本选项"></a>实例基本选项</h3><ol><li><p>Vue 实例提供了非常丰富的选项（<code>new Vue()</code>时传入的选项），除了生命周期外，最常见的如下：</p><table><thead><tr><th align="center">选项名</th><th align="center">说明</th><th align="center">类型</th></tr></thead><tbody><tr><td align="center">el</td><td align="center">通过 CSS 选择器或者 HTMLElement 实例的方式，<br />提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标</td><td align="center">string / Element</td></tr><tr><td align="center">template</td><td align="center">字符串模板，将会替换挂载的元素</td><td align="center">string</td></tr><tr><td align="center">render</td><td align="center">字符串模板的代替方案，<br />该渲染函数接收一个 createElement 方法，<br />作为第一个参数用来创建 VNode</td><td align="center">(createElement: () =&gt; VNode) =&gt; VNode</td></tr><tr><td align="center">data</td><td align="center">Vue 实例的数据对象，用于数据绑定</td><td align="center">Object / Function<br/>（组件只支持 Function）</td></tr><tr><td align="center">props</td><td align="center">用于接收来自父组件的数据</td><td align="center">Array(string) / Object</td></tr><tr><td align="center">methods</td><td align="center">Vue 实例的事件，可用于事件绑定</td><td align="center">[key: string]: Function</td></tr><tr><td align="center">computed</td><td align="center">计算属性，用于简化模板的复杂数据计算</td><td align="center">[key: string]: Function<br />或者<br />{ get: Function, <br />set: Function }</td></tr><tr><td align="center">watch</td><td align="center">观察 Vue 实例变化的表达式或计算属性函数</td><td align="center">[key: string] : string<br />或者 Function<br />或者 Object<br />或者 Array</td></tr><tr><td align="center">directives</td><td align="center">自定义指令</td><td align="center">Object</td></tr><tr><td align="center">filters</td><td align="center">过滤器</td><td align="center">Object</td></tr><tr><td align="center">components</td><td align="center">组件</td><td align="center">Object</td></tr></tbody></table></li><li><p>以上的实例选项，大多可以作为全局实例属性来获取或者访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// ... 选项</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$el;  <span class="comment">// 获取挂载元素</span></span><br><span class="line">vm.$data;  <span class="comment">// 获取 data</span></span><br><span class="line">vm.$props;  <span class="comment">// 获取 props</span></span><br><span class="line">vm.$refs;  <span class="comment">// 获取注册过 ref 特性的所有 dom 元素和组件实例</span></span><br><span class="line">vm.$watch;  <span class="comment">// 观察 vue 实例变量的表达式或者计算属性函数</span></span><br><span class="line"></span><br><span class="line">vm.$options;  <span class="comment">// 获取 vue 实例的初识选项</span></span><br><span class="line">vm.$root;  <span class="comment">// 获取根实例</span></span><br><span class="line">vm.$parent;  <span class="comment">// 获取父实例</span></span><br><span class="line">vm.children;  <span class="comment">// 获取当前实例的直接子组件</span></span><br><span class="line"></span><br><span class="line">vm.$set;  <span class="comment">// 向响应式对象中添加一个响应式的新属性，且触发视图更新</span></span><br><span class="line">vm.$delete;  <span class="comment">// 删除对象的属性，如果对象是响应式的，删除能触发视图更新</span></span><br></pre></td></tr></table></figure></li><li><p>与 DOM 相关的选项：</p><ul><li><p>el：在 Vue 实例中，el 选项提供一个页面中已存在的 DOM 元素作为实例的挂载目标。挂载的意思是，在选中的该元素所在的位置进行页面渲染，该元素会被替换成需要渲染的页面内容。我们可以传入一个 CSS 选择器，也可以传入一个 DOM 元素，以下方式都是可以的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 传入 Element 元素方式一</span></span><br><span class="line">  el: <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>),</span><br><span class="line">  <span class="comment">// 传入 Element 元素方式二</span></span><br><span class="line">  el: <span class="built_in">document</span>.getElementByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 传入 CSS 选择器方式一</span></span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="comment">// 传入 CSS 选择器方式二（最好选择唯一的元素，不推荐此方式）</span></span><br><span class="line">  el: <span class="string">&quot;div&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>所谓挂载元素，在实例挂载之后，元素可以用 <code>vm.$el</code> 访问。严谨地追溯到生命周期中，需要在<code>mounted</code> 之后才能获取到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  template: <span class="string">&quot;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;欢迎来到Vue的世界&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译，也就是这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 注意这里没有 el 选项</span></span><br><span class="line">  template: <span class="string">&quot;&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;&quot;</span>,</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">&quot;欢迎来到Vue的世界&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$el);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要的时候使用</span></span><br><span class="line">vm.$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果 render 函数和 template 属性都不存在，挂载 DOM 元素的 HTML 会被提取出来用作模板，此时，必须使用 编译器（Compiler） + 运行时（Runtime） 构建的 Vue 库。关于这个库，理解下面这些：</p><ul><li>编译器（Compiler）: 我们可以理解为用来将模板字符串编译成为 JavaScript 渲染函数的代码，也就是之前提到的 AST 解析部分。</li><li>运行时（Runtime）：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。</li><li>一般来说，我们在部署生产代码的时候，已经将需要的代码解析编译好，这个时候我们只需要运行时的 Vue 库。在特殊情况下，有需要运行时解析编译的情况，如在线平台编写代码的时候，我们需要引入编译器的 Vue 库，该部分占完整版（Runtime + Compiler）的 30%。上面说到，如果我们需要使用挂载 DOM 元素的 HTML 作为模板，则需要运行时编译，也就需要编译器了。</li></ul></li></ul></li><li><p>template：给 Vue 实例提供字符串模板，该模板将会替换挂载的元素，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">      template: &quot;<span class="tag">&lt;<span class="name">p</span>&gt;</span></span><span class="template-variable">&#123;&#123;<span class="name">message</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span>&quot;,</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          message: <span class="string">&quot;欢迎来到Vue的世界&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;beforeMount:&quot;</span>, <span class="built_in">this</span>.$el)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;mounted:&quot;</span>, <span class="built_in">this</span>.$el)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>这里挂载的元素指的是 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>，使用了 template 之后，该部分已经被替换成 template 中的 <code>&lt;p&gt;&lt;/p&gt;</code>，并将 message 中的内容替换成绑定的数据了：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vue-3-4.jpg" class="lazyload" data-srcset="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vue-3-4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li>查看控制台，在 beforeMount 中，<code>vm.$el</code> 获取的是挂载的元素模板，而在 mounted 后则变成了 template 中的真实 DOM 元素：<br><img src="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vue-3-5.jpg" class="lazyload" data-srcset="https://github-imglib-1255459943.cos.ap-chengdu.myqcloud.com/vue-3-5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li></ul></li><li><p>render：字符串模板 template 的代替方案，该渲染函数接收一个  createElement 方法作为第一个参数用来创建 VNode（createElement 创建的便是虚拟 DOM，在 Vue 里称为 VNode），使用案例如下（实现一个 v-if）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">/*该段实现：</span></span><br><span class="line"><span class="comment">  &lt;p v-if=&#x27;condition&#x27;&gt;condition work!&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  &lt;p v-else&gt;condition not work!&lt;/p&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.condition) &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;condition work!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;condition not work!&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*该段实现：</span></span><br><span class="line"><span class="comment">  &lt;ul&gt;</span></span><br><span class="line"><span class="comment">    &lt;li v-for=&#x27;item in list&#x27;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">  &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;ul&#x27;</span>, <span class="built_in">this</span>.list.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&#x27;li&#x27;</span>, item)</span><br><span class="line">    &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>一般来说，我们可以结合 JSX 来使用（需要添加 Babel 插件）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MyComponent <span class="keyword">from</span> <span class="string">&quot;./MyComponent.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;MyComponent&gt;</span><br><span class="line">          &lt;p&gt;Hello world!&lt;/p&gt;</span><br><span class="line">      &lt;/MyComponent&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="实例生命周期"><a href="#实例生命周期" class="headerlink" title="实例生命周期"></a>实例生命周期</h3><blockquote><p>这里只是简单地引入生命周期，之后会详细探讨</p></blockquote><p><img src="https://cn.vuejs.org/images/lifecycle.png" class="lazyload" data-srcset="https://cn.vuejs.org/images/lifecycle.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><p><img src="https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png" class="lazyload" data-srcset="https://cloud.githubusercontent.com/assets/12537013/17702060/f847b38a-63fe-11e6-9c29-38e58d46f036.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程，例如，实例需要配置数据观测、编译模版、挂载实例到 DOM ，然后在数据变化时更新 DOM，这就给了我们自定义逻辑的机会，例如，<code>created</code> 这个钩子在实例被创建之后被调用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        a: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    created: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">//this 指向 Vue 实例</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;a is: &#x27;</span> + <span class="built_in">this</span>.a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然，除了 <code>created</code> 之外，还有一些其他的钩子，这是在实例的生命周期调用的，钩子的 <code>this</code> 指向调用它的 Vue 实例。</p><p>注意，不要因为这些生命周期钩子就误以为 Vue 有 “控制器” 的概念，这是没有的，组件的自定义逻辑可以分布在这些钩子中。</p><hr><h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><h3 id="认识模板语法"><a href="#认识模板语法" class="headerlink" title="认识模板语法"></a>认识模板语法</h3><ol><li>Vue.js 使用了基于 HTML 的模板语法，允许我们声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。</li><li>在底层的实现上， Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</li><li>如果你熟悉虚拟 DOM 并且偏爱 JavaScript 的原始力量，你也可以不用模板，<a href="http://caibaojian.com/vue/guide/render-function.html">直接写渲染（render）函数</a>，使用可选的 JSX 语法。</li></ol><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><blockquote><p>这里的很多用法在前一节的内置指令一节中已经详细说过，这里就当时复习吧！</p></blockquote><ol><li><p>文本：最常见的数据绑定方式就是使用 “Mustache” 语法（双大括号）的文本插值：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>Mutache 标签会被替换成对应数据上的 <code>msg</code> 属性的值，只要绑定的数据对象上 <code>msg</code> 属性发生改变，插值处的内容都会更新</p></li><li><p>通过使用 <code>v-once</code> 指令，能实现一次性插值，当数据改变时，插值处的内容不会更新，但请注意这会影响到该节点上所有数据的绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>纯 HTML：双大括号会将数据解析成纯文本，而非 HTML，如要输出 HTML，需要使用 <code>v-html</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-html&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>msg</code> 仍然是绑定在属性上的</li><li>被插入的内容都会被当做 HTML —— 数据绑定会被忽略</li><li>注意，不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎，组件更适合担任 UI 重用与复合的基本单元</li><li>另外，在网站上动态渲染 HTML 是一件很危险的事情，这容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>，请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值</li></ul></li><li><p>属性：Mutache 语法不能在 HTML 属性中使用，应使用 <code>v-bind</code> 指令，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>属性也是可以是布尔值，例如对下面这段来说，<code>isButtonDisabled</code> 的值如果是 <code>null</code>、<code>undefined</code> 或者是 <code>false</code>，那么这个 <code>disabled</code> 属性是不会被包含在 <code>&lt;button&gt;</code> 中的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用 JS 表达式：对于所有的数据绑定，Vue 都提供了完整的 JS 表达式支持，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line">&#123;&#123; ok ? &#39;YES&#39; : &#39;NO&#39; &#125;&#125;</span><br><span class="line">&#123;&#123; message.split(&#39;&#39;).reverse().join(&#39;&#39;) &#125;&#125;</span><br><span class="line">&lt;div v-bind:id&#x3D;&quot;&#39;list: &#39; + id&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ul><li><p>这些表达式会在所属 Vue 实例的数据作用域下作为 JS 被解析</p></li><li><p>注意，每个限制都只能包含 <strong>单个表达式</strong>，所以下面的例子都 <strong>不会生效</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; var a &#x3D; 1 &#125;&#125;</span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; if(ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ol><li><p>指令（Directives）是带有 <code>v-</code> 前缀的特殊属性，指令属性的值预期是<strong>单一 JavaScript 表达式</strong>（<code>v-for</code> 是个例外，之后再讨论），指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你能看到我么？&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><ul><li>在这里，<code>v-if</code> 会根据 <code>seen</code> 的值的真假来插入或者移除 <code>&lt;p&gt;</code> 元素</li></ul></li><li><p>参数：一些指令能够接收一个“参数”，在指令名称之后以冒号表示。</p><ul><li><p>例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML  属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li>这里的 <code>href</code> 是参数，告知 <code>v-bind</code> 指令，将元素的 <code>href</code> 属性与 <code>url</code> 进行绑定</li></ul></li><li><p>再比如 <code>v-on</code> 指令，它用于监听 DOM 事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li>在这里，参数是监听名</li></ul></li></ul></li><li><p>动态参数：从 <code>Vue 2.6.0</code> 开始，可以用方括号括起来的 JS 表达式作为一个指令的参数，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注意，参数表达式的写法存在一些约束，之后会详细探讨 --&gt;</span><br><span class="line">&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt;&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li><p>这里的 <code>attributeName</code> 会作为一个 JS 表达式进行动态求值，求得的值将会作为最终的参数来使用，例如，如果你的实例中的 <code>data</code> 有一个键值对是：<code>attributeName: &quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code></p></li><li><p>你也可以把动态参数作为一个动态的事件名绑定到处理函数上，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li>例如，当 <code>eventName=&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 也就等价于 <code>v-on:focus</code></li></ul></li><li><p>对动态参数的约束：动态参数预期会求出一个字符串，异常情况下为 <code>null</code>。这个特殊的 <code>null</code> 值可以用于移除绑定，例如下面这个 <code>doSomething</code> 事件将移除绑定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;button v-on:null&#x3D;&quot;doSomething&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">&lt;!-- 不管 doSomething 事件会触发什么，都不会被绑定到这个 &lt;button&gt; 标签上 --&gt;</span><br></pre></td></tr></table></figure></li><li><p>对动态参数表达式的约束：动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML 属性名里是无效的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="line">&lt;a v-bind:[&quot;foo&quot; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><ul><li>解决的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式</li></ul></li><li><p>在 DOM 中使用模板时（直接在一个 HTML 文件里撰写模板），还需要避免使用大写字符来命名键名，因为浏览器会把属性名全部强制转为小写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">在 DOM 中使用模板时这段代码会被转换为 v-bind:[someattr]</span><br><span class="line">除非在实例中有一个名为 &quot;someattr&quot; 的 property，否则代码不会工作</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>修饰符：修饰符是以 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定，这里只是引入这个概念在，之后我们会详细说明 <code>v-on</code> 以及 <code>v-for</code> 等等指令的修饰符的具体用法</p><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3></li></ol><blockquote><p><code>v-</code> 前缀在模板中是作为一个标示 Vue 特殊属性的明显标识。当你使用 Vue.js 为现有的标记添加动态行为时，它会很有用，但对于一些经常使用的指令来说有点繁琐。同时，当搭建 Vue.js 管理所有模板的 <a href="https://en.wikipedia.org/wiki/Single-page_application">SPA</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue.js 为两个最为常用的指令提供了特别的缩写</p></blockquote><ol><li><p><code>v-bind</code> 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li><li><p><code>v-on</code> 缩写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure></li></ol><hr><blockquote><p>本节大概讲了 Vue 实例中的重要选项 以及 模板语法的知识点，加油！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue教程（二）：Vue内置指令详解</title>
      <link href="8a495401b398/"/>
      <url>8a495401b398/</url>
      
        <content type="html"><![CDATA[<h3 id="插值表达式"><a href="#插值表达式" class="headerlink" title="插值表达式"></a>插值表达式</h3><ol><li><p>数据绑定最常见的形式就是<code>“Mustache”语法 (双大括号)</code> 的文本插值，<code>Mustache</code> 标签将会被对应数据对象上属性的值替代。只要绑定的数据对象上属性发生了改变，插值处的内容都会更新。</p></li><li><p>用过 <strong>vue</strong> 的盆友都清楚，<code>message</code> 是将数据解析成纯文本的，也就是说，就算<code>message</code> 中含有了 <strong>html</strong> 标签，它也是只看做纯文本的，不能输出真正的 html。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">            message: &#x27;<span class="tag">&lt;<span class="name">h1</span>&gt;</span>asc<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--页面显示为: &lt;h1&gt;asc&lt;/h1&gt;--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3></li><li><p><code>v-text</code> 简介: </p><ul><li><code>v-text</code>与插值表达式相同的地方是，它也是将数据解析成纯文本（解释html标签可能导致<strong>xss攻击</strong>）</li><li>但它与花括号的区别是: 使用<code>v-text</code>在页面加载时不会显示**’message’**，解决了插值表达式闪烁问题，因为他是属性而不是插值表达式</li></ul></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>这里的内容会被替换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">           msg: &quot;Hello! <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-text<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--页面显示为: Hello! &lt;h1&gt;v-text&lt;/h1&gt;--&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注: “页面闪烁” 指的是在加载插值表达式时，会先直接在页面显示**’message’**，然后再编译对应的数据</p></li></ol><h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ol><li><p>简介: 为了输出真正的HTML，可以用v-html指令。它等同于JS的innerHtml属性，会将数据解析成html形式。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>这里的内容会被替换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">           msg: &quot;Hello! <span class="tag">&lt;<span class="name">h1</span>&gt;</span>v-html<span class="tag">&lt;/<span class="name">h1</span>&gt;</span>&quot;,</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--页面显示为: Hello! v-html --&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>另外，使用 v-html 时请只对可信内容使用 HTML 插值，绝不要对用户提供的内容使用插值，因为它很容易导致 XSS 攻击。</p></li></ol><h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ol><li><p>简介: <code>v-if</code> 指令用于<strong>条件性地渲染</strong>一块内容。这块内容只会在指令的表达式返回 <strong>truthy</strong> 值的时候被渲染。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;true&quot;</span>&gt;</span> v-if 为 true 时显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--页面显示为:  v-if 为 true 时显示 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;false&quot;</span>&gt;</span> v-if 为 false 时显示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           <span class="literal">true</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">           <span class="literal">false</span>: <span class="literal">false</span>,</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中 <strong>条件块内的事件监听器</strong> 和 <strong>子组件</strong> 适当地被销毁和重建。</p></li><li><p><code>v-if</code> 是惰性的，如果初始渲染时条件为 <strong>假</strong>，那么就什么也不用做，直到第一次条件变为 <strong>真</strong>，才开始渲染条件块。</p></li><li><p><code>v-if</code> 通常用于以下两种情况: </p><ul><li><p>多个元素之间，通过条件判断，来 <strong>展示</strong> 或者 <strong>隐藏</strong> 某个或多个元素。</p></li><li><p>进行两个视图的切换。</p></li><li><p>例如下面的代码分别实现了: ①type不同值时元素的展示情况；②点击按钮切换视图</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>v-if的简单实用<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type == &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type==&#x27;B&#x27;&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>C<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">p</span>&gt;</span>v-if的弹框切换<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span>&gt;</span>用户名: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeloginType&quot;</span>&gt;</span>切换状态<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           type: <span class="string">&#x27;C&#x27;</span>,</span></span><br><span class="line"><span class="javascript">           loginType: <span class="string">&#x27;username&#x27;</span></span></span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           <span class="function"><span class="title">changeloginType</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">let</span> self = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">if</span> (self.loginType == <span class="string">&#x27;username&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                   self.loginType = <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">               &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                   self.loginType = <span class="string">&#x27;username&#x27;</span></span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>拓展了解 — 官方文档: <a href="https://cn.vuejs.org/v2/guide/conditional.html">条件渲染 — Vue.js</a></p></li></ol><h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ol><li><p>简介: 个人感觉 <code>v-else</code> 并不像一个单独功能的指令，而是偏辅助功能的，而且 <code>v-else</code> <strong>必须和</strong> <code>v-if</code> <strong>连用</strong>，否则会报错。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;msg1&quot;</span>&gt;</span>The msg1 is true<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>The msg1 is false<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Button&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           msg1: <span class="literal">true</span>,</span></span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           button: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.msg1 = !<span class="built_in">this</span>.msg1;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>上述过程即为 <code>v-if</code> 与 <code>v-else</code> 连用，若<strong>去掉</strong> <code>v-if</code> 部分，则报错为: 编译模板时出错<pre><code>![](https://s2.ax1x.com/2019/11/04/KxOMh8.png)</code></pre></li></ul></li></ol><h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><ol><li><p>简介: 与<code>v-else</code>相同，<code>v-else-if</code>也必须和<code>v-if</code>连用，其实道理很简单，类比 <strong>C语言</strong>的<code>if</code>、<code>else</code>、<code>else if</code>，这里的<code>v-else-if</code>也是用在<code>v-if</code>和<code>v-else</code>中间，实现多次判断</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;10&gt;20&quot;</span>&gt;</span>v-if 赢了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else-if</span>=<span class="string">&quot;10&gt;5&quot;</span>&gt;</span>v-else-if 赢了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>好吧，v-else 赢了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>如果没有<code>v-if</code>，那么也会和上面的<code>v-else</code>一样报错: 编译模板时出错<pre><code>![](https://s2.ax1x.com/2019/11/04/KxO5ge.png)</code></pre></li></ul></li></ol><h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ol><li><p>简介: <code>v-show</code>也是用来 <strong>控制元素是否显示</strong> 的，其功能与<code>v-if</code>指令相似。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-show</span>=<span class="string">&quot;msg&quot;</span>&gt;</span>显示成功<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;show&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Do you want to hide it?&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            msg: <span class="literal">true</span>,</span></span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line"><span class="javascript">            show: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">this</span>.msg = !<span class="built_in">this</span>.msg;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>那么，<code>v-show</code>与<code>v-if</code>有什么 <strong>联系</strong> 呢？</p><ul><li><code>v-show</code>与<code>v-if</code>都是通过 <strong>动态地操作DOM</strong> 来实现显示与隐藏的</li></ul></li><li><p><code>v-show</code>与<code>v-if</code>的 <strong>区别</strong> 是什么呢？</p><ul><li><strong>手段的不同</strong>: <code>v-if</code>是动态地向DOM树内动态地添加或删除DOM元素，如果<code>v-if</code>的值是<code>false</code>就会在DOM中删除，相当于<code>visibility:hidden;</code>，如果是<code>true</code>把元素克隆到相应的DOM树上去，支持加在<code>&lt;template&gt;</code>标签上；而<code>v-show</code>是动态地设置DOM元素的<code>display</code>属性，而不会删除DOM元素，是<code>display:none;</code>，不支持加在<code>&lt;template&gt;</code>标签上。</li><li><strong>编译过程的不同</strong>: <code>v-if</code>在切换时会有一个局部编译/卸载的过程，在切换时适当地销毁和重建内部的事件监听 和 子组件，因为<code>v-if</code>可能是数据绑定或者子组件；而<code>v-show</code>只是简单地进行 CSS 属性的切换。</li><li><strong>编译条件的不同</strong>: <code>v-if</code>是真真正正的条件渲染，但它是惰性的，如果初始条件为假，则什么也不用做，只有在第一次条件变为真时才开始局部编译，编译会被缓存，之后等到再切换时再进行局部卸载；而<code>v-show</code>不管其值是否为真，都进行编译，然后编译被缓存，而且DOM元素也保留。</li><li><strong>性能消耗不同</strong>: <code>v-if</code>有着更高的切换消耗，<code>v-show</code>有着更高的初识渲染消耗<br>由此，就引发出了使用问题: <ul><li>当组件的某块内容切换很少，那么切换消耗也就很少，此时用<code>v-if</code>来渲染更加合适</li><li>如果频繁地切换着条件，那么就用<code>v-show</code>更加合适，实现一次渲染，多次切换</li><li>为什么这么说呢，因为频繁操作DOM会很影响性能，如果频繁切换，就意味着频繁地创建、删除DOM，为减少消耗就更该用<code>v-show</code>；如果是要么显示要么隐藏的情况下，那么<code>v-if</code>更加合理，因为借助<code>v-if</code>的惰性，如果一开始它的值即为false，那么甚至都不需要创建DOM，如果其值为true，则效果与<code>v-show</code>完全一样。</li></ul></li><li>补充: <code>display:none</code> 与 <code>visibility:hidden</code>的区别: <ul><li><code>display:none</code>是彻底消失，不在文档流中占位，浏览器也不会解析该元素；</li><li><code>visibility:hidden</code>可以理解为透明度为0的效果，它只是视觉上的消失，在文档流中是占位的，浏览器也会解析该元素。</li><li>使用<code>visibility:hidden</code>要比<code>display:none</code>性能更好，用<code>display</code>切换时，页面会产生 <strong>回流</strong> （当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面需要 <strong>重新构建</strong>，即为回流。所有页面第一次加载时需要产生一次回流），而用<code>visibility</code>切换时不会产生回流。</li></ul></li><li>补充: 若一个元素在CSS中已设置<code>display:none</code>，则无法通过设置<code>v-if</code>或者<code>v-show</code>来让元素显示，因为切换时只会修改元素 element.style 的“display”属性为“none”或者“block”，并不会覆盖或者修改已经存在的CSS属性<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3></li></ul></li><li><p><code>v-for</code>循环普通数组: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;value in list&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,i) in list&quot;</span>&gt;</span>索引: &#123;&#123;i&#125;&#125; =&gt; 值: &#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意: 值与索引的顺序为 : (value,i) --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line">           list: [1,2,3,4,5]</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-for</code>循环对象数组: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,i) in list&quot;</span>&gt;</span></span><br><span class="line">        索引: &#123;&#123;i&#125;&#125; —— Id: &#123;&#123;value.id&#125;&#125; —— Name: &#123;&#123;value.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line">            list: [</span><br><span class="line"><span class="javascript">                &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;first&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;second&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">                &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;third&#x27;</span> &#125;,</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-for</code>循环对象: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,i) in student&quot;</span>&gt;</span></span><br><span class="line">       索引: &#123;&#123;i&#125;&#125; —— 键: &#123;&#123;key&#125;&#125; —— 值: &#123;&#123;value&#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line">           student: &#123;</span><br><span class="line">               id: 0,</span><br><span class="line"><span class="javascript">               name: <span class="string">&#x27;Tom&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               gender: <span class="string">&#x27;男&#x27;</span></span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-for</code>迭代数字: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;count in 10&quot;</span>&gt;</span>这是第&#123;&#123;count&#125;&#125;次循环<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>v-for</code>中的<code>key</code>属性的使用: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span>&gt;</span>Id:</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:</span><br><span class="line">           <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;item in list&quot;</span> <span class="attr">:key</span>=<span class="string">&#x27;item.id&#x27;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> /&gt;</span>&#123;&#123;item.id&#125;&#125; --- &#123;&#123;item.name&#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           id: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">           name: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line">           list: [</span><br><span class="line"><span class="javascript">               &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;李斯&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">               &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;嬴政&#x27;</span> &#125;,</span></span><br><span class="line"><span class="javascript">               &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;赵高&#x27;</span> &#125;,</span></span><br><span class="line">           ]</span><br><span class="line">       &#125;,</span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="built_in">this</span>.list.unshift(&#123; <span class="attr">id</span>: <span class="built_in">this</span>.id, <span class="attr">name</span>: <span class="built_in">this</span>.name &#125;);</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3></li><li><p>简介: 它是来 <strong>绑定事件监听器</strong> 的，这样我们就可以进行一下交互。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">v-on:click</span>=<span class="string">&quot;click&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点此弹出语句&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       methods: &#123;</span><br><span class="line"><span class="javascript">           <span class="function"><span class="title">click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">               alert(<span class="string">&#x27;Hello Vue!&#x27;</span>);</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li><code>v-on</code> 可简写为 <code>@</code></li></ul><h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ol><li><p>简介: <code>v-bind</code>指令主要用于 <strong>绑定属性</strong>，可以动态地绑定一个或多个属性，比如 class属性、style属性、value属性、href 属性，只要是属性，就可以用<code>v-bind</code>进行绑定。它的语法是: <code>v-bind:属性名 = &quot;变量名&quot;</code>，规定<code>v-bind</code>可以缩写为<code>:</code>，如语法可以缩写为<code>:属性名 = &quot;变量名&quot;</code>。</p></li><li><p>绑定 HTML Class: </p><ul><li><p>对象语法: 我们可以传给<code>v-bind:class</code>一个对象，以动态地切换 class属性，如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           isActive: <span class="literal">true</span>    <span class="comment">//此时可以展示active</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>上述表示 active 是否被展现取决于 isActive 是否为真。</p></li><li><p>此外，可以在对象中传入多个属性来动态地切换 class，例如下面的模板: </p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static&quot;</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; A:isA, &#x27;B&#x27;: isB &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           isA: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">           isB: <span class="literal">false</span>,</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="handlebars"><span class="xml">//结果渲染为: <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static isA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>当然，绑定的对象也不必内联定义在模板里，而是用一个对象名代替: </p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line">           classObject&#123;</span><br><span class="line"><span class="javascript">               isA: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">               isB: <span class="literal">false</span>,</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>我们也可以绑定一个返回对象的计算属性，这是一个强大而且常用的模式: </p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;classObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           isA: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">           isB: <span class="literal">false</span>,</span></span><br><span class="line">       &#125;,</span><br><span class="line">       computed: &#123;</span><br><span class="line"><span class="javascript">           classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">               <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">                   active: <span class="built_in">this</span>.isA &amp;&amp; !<span class="built_in">this</span>.isB,</span></span><br><span class="line"><span class="javascript">                   statiq: <span class="built_in">this</span>.isB &amp;&amp; <span class="built_in">this</span>.isB.type === <span class="string">&#x27;fatal&#x27;</span></span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>数组语法: 我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class列表: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">        data: &#123;</span><br><span class="line"><span class="javascript">            activeClass: <span class="string">&#x27;active&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        errorClass: <span class="string">&#x27;text-danger&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="handlebars"><span class="xml">    //渲染为  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>注：关于<code>v-bind</code>指令详解请参考: <a href="https://www.jb51.net/article/139306.htm">详解v-bind指令</a> 以及 <a href="https://blog.csdn.net/qq_39207948/article/details/80938972">vue.js中的v-bind语法的使用详解</a></p></li><li><p>案例集合：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imageSrc&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imageSrc&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最终会生成 `&lt;img src=&quot;$&#123;imageSrc&#125;&quot;&gt;` 这样的模板 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态特性名 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-bind:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 动态特性名缩写 (2.6.0+) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">:</span>[<span class="attr">key</span>]=<span class="string">&quot;value&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 最终会生成 `&lt;button $&#123;key&#125;=&quot;$&#123;value&#125;&quot;&gt;` 这样的模板 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 内联字符串拼接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;&#x27;/path/to/images/&#x27; + fileName&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;&#123; red: isRed &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, classB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[classA, &#123; classB: isB, classC: isC &#125;]&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- style 绑定 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; fontSize: size + &#x27;px&#x27; &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;[styleObjectA, styleObjectB]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">&quot;&#123; id: someProp, &#x27;other-attr&#x27;: otherProp &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ol><li><p>简介: 这个指令用于 <strong>在表单上创建双向数据绑定</strong>，<code>v-model</code>会忽略所有表单元素的 value、checked、selected特性的初始值，因为<code>v-model</code>选择Vue实例数据来作为具体的值。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;somebody&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>hello &#123;&#123;somebody&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           somebody: <span class="string">&#x27;小明&#x27;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3></li><li><p>简介: <code>v-pre</code>会 <strong>按原样输出</strong>，标签中的内容是什么就输出什么，主要用来跳过这个元素以及它的子元素的编译过程，可以用来显示原始的Mustache标签。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           msg:<span class="string">&quot;&#x27;v-pre&#x27;是不会管我的...&quot;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3></li><li><p>简介: 还记得上文中提到的 <strong>页面闪烁</strong> 吗，我们也可以用<code>v-cloak</code>来解决这一问题。<br> 这个指令用来保持在元素上直到关联实例结束时进行编译。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span> &#123;&#123;context&#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           context:<span class="string">&#x27;Hello Vue!&#x27;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="javascript"><span class="comment">//用&#x27;v-cloak&#x27;则不会出现闪烁</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3></li><li><p><code>v-once</code> 关联的实例 <strong>只会渲染一次</strong>，执行 <strong>一次性地插值</strong>，当数据改变时，插值处的内容不会更新，v-once 所定义的元素或组件只会渲染一次，首次渲染后，不再随着数据的改变而重新渲染。若之后牵涉到重新渲染，那么 <strong>它关联的实例及其所有子节点</strong> 会被视为 <strong>静态内容</strong> 而被跳过，这可以用来优化更新性能。</p></li><li><p>例如: </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">p</span>&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;msg&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">       el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">       data: &#123;</span><br><span class="line"><span class="javascript">           msg: <span class="string">&quot;hello&quot;</span></span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 Vue 生命周期钩子中，真实 DOM 挂载发生在 beforeMount 之后、mounted 之前，也就是说，我们可以在 mounted 之前的生命周期中更改 data 中 message 的值，所以关于插值，需要注意：v-once 在 mounted 生命周期之后，不可再更改。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多角度认识 Vue</title>
      <link href="5f4f362d2c70/"/>
      <url>5f4f362d2c70/</url>
      
        <content type="html"><![CDATA[<h2 id="认识-Vue-与-渐进式"><a href="#认识-Vue-与-渐进式" class="headerlink" title="认识 Vue 与 渐进式"></a>认识 Vue 与 渐进式</h2><ol><li>渐进式代表的含义大概是：主张最少。</li><li>每个框架都会有自己的一些特点，而对使用框架的人会有一定要求，而这种要求就是主张，对于不同的框架来说，主张有强有弱，主张的强弱也会影响在开发中的使用方式。</li><li>比如 Angular，它的两个版本都是强主张的，若要使用它，你必须要做到：<ul><li>使用它的模块机制</li><li>使用它的依赖注入</li><li>使用它的特殊形式定义的组件（这点其实每个框架都有）</li><li>从以上三点可以看出，Angular 有着比较强的排他性，如果你的应用不是从头开始，而是要不断考虑是否要和其他东西集成，这些主张会给你带来一些困扰</li></ul></li><li>又比如 React，它的主张主要是函数式编程的理念，比如说，你使用 React，就需要知道什么是副作用，什么是纯函数，如何隔离副作用等等，它的侵入性看似没有Angular那么强，主要因为它是软性侵入。</li><li>当然，实际上你也可以只使用 React 视图层，但是几乎没有人这么做，因为只使用 React 视图层总感觉是比较别扭的，于是你要引入 Flux、Redux、Mbox 中的一个，甚至你在选择了一个之后会再引入更多。</li><li>而 Vue.js 是一套构建用户界面的 <strong>渐进式框架</strong>，核心主要关注视图层，而渐进式框架给予了开发者很多灵活性，如图所示<br><img src="https://user-images.githubusercontent.com/49378661/79626226-055ccc80-8161-11ea-8d12-f8f95db37682.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79626226-055ccc80-8161-11ea-8d12-f8f95db37682.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587175225419"></li></ol><ul><li>Vue从设计角度来讲， 虽然能够涵盖这张图上所有的东西，但是你并不需要一上手就把所有东西全用上 ，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。<ul><li><strong>声明式渲染</strong> 和 <strong>组件系统</strong> 是Vue的核心库所包含内容，而 <strong>客户端路由</strong>、<strong>状态管理</strong>、<strong>构建工具</strong> 都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起</li></ul></li></ul><ol start="7"><li>其实，这些主张性只是有种影响作用，相比个人而言，尤其在团队中会放大，对于不同的人，它的喜好也是不同的，比如对有些人来说，有些人觉得大量的 DSL 学习成本太高，有些人觉得函数式编程很头疼，具体的主张性还和使用者有关。</li><li>当然，可能有些方面是不如 React，不如 Angular，但它是渐进的，没有强主张，你可以在原有大系统的上面，把一两个组件改用它实现，当 JQuery 用；也可以整个用它全家桶开发，当Angular用；还可以用它的视图，搭配你自己设计的整个下层用。你可以在底层数据逻辑的地方用 OO 和设计模式的那套理念，也可以函数式，都可以，它只是个轻量视图而已，只做了自己该做的事，没有做不该做的事。</li><li>Vue 渲染一块内容，一般会有以下流程：<ul><li>（1）解析语法生成 AST。</li><li>（2）根据 AST 结果，完成 data 数据初始化。</li><li>（3）根据 AST 结果和 data 数据绑定情况，生成虚拟 DOM。</li><li>（4）将虚拟 DOM 生成真正的 DOM 插入到页面中，此时页面会被渲染。</li><li>以上四步会在下面分别提出</li></ul></li><li>其他链接：<ul><li><a href="https://segmentfault.com/a/1190000006875885">DSL 概述</a></li><li><a href="https://www.zhihu.com/question/51907207">Vue2.0 中，“渐进式框架” 和 “自底向上增量开发的设计” 这两个概念是什么？</a></li></ul></li></ol><hr><h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><ol><li>模板引擎大概是 Vue 里最主要、最核心的一个能力，在模板引擎还没有出现的时候，前端需要手动更新前端页面的内容，需要维护一大堆的 HTML 和变量拼接的动态内容，虽然 JQuery 的出现提升了 DOM 元素的操作性，但依然难以避免代码的可读性、可维护性上存在的一些问题。</li><li>以前更新页面的内容时的大致流程是：<code>监听操作 -&gt; 获取数据变量 -&gt; 使用数据拼接成 HTML 模板 -&gt; 将 HTML 内容塞到页面对应的地方 -&gt; 将 HTML 片段内需要监听的点击等事件进行绑定</code>，如今使用 Vue，就可以方便地在模板里用插值表达式 <code>&#123;&#123;&#125;&#125;</code>、<code>v-bind </code>绑定变量来展示，同时配合 <code>v-if</code>、<code>v-for</code> 等内置指令即可。</li><li>其他了解：<ul><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/1.html#_1-3-%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A">数据绑定</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/1.html#_1-4-xss-%E6%BC%8F%E6%B4%9E%E5%A1%AB%E8%A1%A5">XSS 漏洞填补</a></li></ul></li></ol><hr><h2 id="解析语法生成-AST"><a href="#解析语法生成-AST" class="headerlink" title="解析语法生成 AST"></a>解析语法生成 AST</h2><ol><li>抽象语法树（Abstract Syntax Tree）也称为 AST 语法树，指的是源代码语法所对应的树状结构。<ul><li>对于一种具体编程语言下的源代码，可以通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。</li></ul></li><li>DOM 结构树也是 AST 的一种，把 HTML DOM 语法解析并生成最终的页面。而模板引擎中常用的，则是将模板语法解析，分别生成 HTML DOM，使用像 HTML 拼接这样的方式（在对应的位置绑定变量、指令解析获取拼接逻辑等等），同时配合事件的管理、虚拟 DOM 的设计，可以最大化地提升页面的性能。</li><li>至于具体的过程，暂时不做仔细探讨，可以查看：<ul><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/1.html#_1-1-%E8%A7%A3%E6%9E%90%E8%AF%AD%E6%B3%95%E7%94%9F%E6%88%90-ast">解析语法生成 AST</a></li><li><a href="https://juejin.im/post/6844903942178996238">浅析Vue编译原理—AST语法树</a></li></ul></li></ol><hr><h2 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h2><ol><li>虚拟 DOM 大概可分成三个过程：<ul><li>用 JS 对象模拟 DOM 树，得到一棵虚拟 DOM 树。</li><li> 当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。</li><li>把差异应用到真正的 DOM 树上。</li></ul></li><li>详细了解请查：<ul><li><a href="https://www.zhihu.com/question/29504639">如何理解虚拟DOM?</a></li><li><a href="https://www.kancloud.cn/dataoedu/vue/327304">理解虚拟DOM</a></li><li><a href="https://www.jianshu.com/p/af0b398602bc">Vue 核心之虚拟DOM（vdom）</a></li><li><a href="https://godbasin.github.io/vue-ebook/vue-ebook/1.html#_1-2-%E8%99%9A%E6%8B%9F-dom">虚拟 DOM</a></li></ul></li></ol><hr><h2 id="MVVM-设计模式"><a href="#MVVM-设计模式" class="headerlink" title="MVVM 设计模式"></a>MVVM 设计模式</h2><ol><li>由于MVP、MVVM的兴起，MVC 在 Android 中的应用变得越来越少了，但 MVC 是基础，理解好 MVC才能更好的理解 MVP、MVVM。因为后两种都是基于 MVC 发展而来的。</li><li>详细了解请查：<ul><li><a href="https://juejin.im/post/5b3a3a44f265da630e27a7e6">MVC、MVP、MVVM，我到底该怎么选？</a></li><li><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1108898947791072">廖雪峰：MVVM</a></li><li><a href="https://segmentfault.com/a/1190000015895017">MVVM框架理解及其原理实现</a></li><li><a href="https://www.kancloud.cn/dataoedu/vue/327305">MVVM模式</a></li></ul></li></ol><hr><h2 id="声明式渲染"><a href="#声明式渲染" class="headerlink" title="声明式渲染"></a>声明式渲染</h2><ol><li><p>声明式渲染指的是采用简洁的模板语法声明式地将数据渲染进 DOM</p></li><li><p>现在基本所有的框架都已经认同这个看法 —— DOM 应尽可能是一个函数式到状态的映射。状态即是唯一的真相，而DOM 状态只是数据状态的一个映射</p></li><li><p>如下图所示，我们可以将声明式渲染理解为：<br><img src="https://box.kancloud.cn/0db2c5568d34ec4e8916790862013241_550x332.png" class="lazyload" data-srcset="https://box.kancloud.cn/0db2c5568d34ec4e8916790862013241_550x332.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><ul><li>DOM 状态只是数据状态的一个映射</li><li>所有的逻辑尽可能在状态的层面去进行</li><li>当状态改变了，View 会被框架自动更新到合理的状态，而不是说当你观测到数据变化之后手动选择一个元素，再命令式地去改动它的属性</li></ul></li><li><p>区别声明式渲染和命令式渲染</p><ul><li><p>命令式：需要以具体代码表达在哪里做什么？它是如何实现的</p></li><li><p>声明式：只需要声明在哪里需要做什么？不需要关心具体怎么实现的</p></li><li><p>举例：假设有一个数组，我们要让里面的每个数字乘以2</p><ul><li><p>命令式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr1.length; i++) &#123;</span><br><span class="line">    arr2.push(arr1[i]*<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure></li><li><p>声明式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr1.map( <span class="function"><span class="params">item</span> =&gt;</span> item*<span class="number">2</span> )</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>详细了解请查：</p><ul><li><a href="https://www.zhihu.com/question/68121329?sort=created">怎么理解“声明式渲染”？</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串的扩展</title>
      <link href="1e94d8438000/"/>
      <url>1e94d8438000/</url>
      
        <content type="html"><![CDATA[<h2 id="字符的-Unicode-表示法"><a href="#字符的-Unicode-表示法" class="headerlink" title="字符的 Unicode 表示法"></a>字符的 Unicode 表示法</h2><blockquote><p>注意，JS 是 unicode 编码的，不是 ASCII，所以不要用 ASCII 码值去查对应字符</p></blockquote><ol><li><p>JavaScript允许采用 <code>\uxxxx</code> 形式表示一个字符，其中 “xxxx” 表示字符的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u0061&#x27;</span></span><br><span class="line"><span class="comment">// &quot;a&quot;</span></span><br></pre></td></tr></table></figure><ul><li>但是，这种表示法只限于 <code>\u0000</code> 到 <code>\uFFFF</code> 之间的字符，超出这个范围的字符，必须用两个双字节的形式表达。</li></ul></li><li><p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;\u&#123;6F&#125;&quot;</span></span><br><span class="line"><span class="string">&quot;o&quot;</span></span><br><span class="line"><span class="keyword">let</span> hello = <span class="number">123</span>;</span><br><span class="line">hell\u&#123;6F&#125; <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u&#123;1F680&#125;&#x27;</span> === <span class="string">&#x27;\uD83D\uDE80&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\z&#x27;</span> === <span class="string">&#x27;z&#x27;</span>  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制的 unicode 编码表对应的值</span></span><br><span class="line"><span class="string">&#x27;\172&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制的 unicode 编码表对应的值，&#x27;\x7a&#x27; = &#x27;\x7A&#x27;</span></span><br><span class="line"><span class="string">&#x27;\x7A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制的 unicode 编码表对应的值</span></span><br><span class="line"><span class="string">&#x27;\u007A&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 中的写法</span></span><br><span class="line"><span class="string">&#x27;\u&#123;7A&#125;&#x27;</span> === <span class="string">&#x27;z&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h2><ol><li><p>ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被 <code>for...of</code> 循环遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> str <span class="keyword">of</span> <span class="string">&#x27;abc&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">a</span></span><br><span class="line"><span class="comment">b</span></span><br><span class="line"><span class="comment">c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>这个遍历器最大的优点是可以识别大于 <code>0xFFFF</code> 的码点，传统的 for 循环无法识别这样的码点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通 for 循环</span></span><br><span class="line"><span class="keyword">let</span> txt = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; txt.length; x++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text[x])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">undefined</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for...of 循环</span></span><br><span class="line"><span class="keyword">let</span> txt = <span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> txt) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 𠮷</span></span><br></pre></td></tr></table></figure><ul><li>上面代码中，字符串 txt 只有一个字符，但是 for 循环会认为它包含两个字符（都不可打印），而 for…of 循环会正确识别出这一个字符。</li></ul></li></ul></li></ol><h2 id="includes-、startsWith-、endsWith"><a href="#includes-、startsWith-、endsWith" class="headerlink" title="includes()、startsWith()、endsWith()"></a>includes()、startsWith()、endsWith()</h2><ol><li><p>JavaScript 只有 <code>indexOf</code> 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法：</p><ul><li><p>**includes()**：返回布尔值，表示是否找到了参数字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>);  <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;hello&#x27;</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>**startsWith()**：返回布尔值，表示参数字符串是否在源字符串的头部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>);  <span class="comment">// true</span></span><br><span class="line">s.startsWith(<span class="string">&#x27;ello&#x27;</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li><li><p>**endsWith()**：返回布尔值，表示参数字符串是否在源字符串的尾部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">s.endsWith(<span class="string">&#x27;World&#x27;</span>);  <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>这三个方法都支持第二个参数，表示开始搜索的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;Hello World!&#x27;</span>;</span><br><span class="line"></span><br><span class="line">s.startsWith(<span class="string">&#x27;World&#x27;</span>, <span class="number">6</span>);  <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">5</span>);  <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">6</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>注意：使用第二个参数时：<ul><li>endsWith 是针对前 n 个字符。</li><li>startsWith 和 includes 都是针对从第 n 个位置直到字符串结束。</li></ul></li></ul></li></ol><h2 id="常用-API-总结"><a href="#常用-API-总结" class="headerlink" title="常用 API 总结"></a>常用 API 总结</h2><p><a href="https://github.com/OzzieNicholas/Blog/issues/8">JS 字符串总结</a></p><h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><ol><li><p>传统的 JS，输出模板通常是这样写的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(</span><br><span class="line">  <span class="string">&#x27;My name is &#x27;</span> + name + <span class="string">&#x27; .&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><p>ES6 的模板字符串解决了这种繁琐的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#result&#x27;</span>).append(<span class="string">`</span></span><br><span class="line"><span class="string">  My name is <span class="subst">$&#123;name&#125;</span> .</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>模板字符串都是用反引号表示，如果需要单独输出反引号，则前面要用反斜杠转义。</p></li><li><p>使用模板字符串表示的多行字符串，所有的空格和缩进都会被保留在输出之中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;First&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;Second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">`</span>)</span><br></pre></td></tr></table></figure><ul><li><p>上面代码中的空格和换行都会原封不动地保留下来，再解析为 html，可以用 <code>trim</code> 方法来消除这个换行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;#list&#x27;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">&lt;ul&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;First&lt;/li&gt;</span></span><br><span class="line"><span class="string">  &lt;li&gt;Second&lt;/li&gt;</span></span><br><span class="line"><span class="string">&lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>.trim())</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在模板字符串中嵌入变量，需要将变量名写在 <code>$&#123;&#125;</code> 之中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">info</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;name&#125;</span>, my age is <span class="subst">$&#123;age&#125;</span>.`</span>);</span><br><span class="line">&#125;</span><br><span class="line">info(<span class="string">&#x27;ozzie&#x27;</span>, <span class="number">20</span>);  <span class="comment">// My name is Ozzie, my age is 20.</span></span><br></pre></td></tr></table></figure><p><code>$&#123;&#125;</code> 之中可以：</p><ul><li><p>嵌入任何的 JS 表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span>);  <span class="comment">// 1 + 2 = 3</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y*<span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y*<span class="number">2</span>&#125;</span>`</span>);  <span class="comment">// 1 + 4 = 5</span></span><br></pre></td></tr></table></figure></li><li><p>嵌入对象属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&#x27;ozzie&#x27;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;obj.name&#125;</span>, my age is <span class="subst">$&#123;obj.age&#125;</span>.`</span>);</span><br><span class="line"><span class="comment">// My name is ozzie, my age is 20.</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;num.length&#125;</span>`</span>);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;fun()&#125;</span>`</span>);  <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>$&#123;&#125;</code> 与字符串：由于会将 <code>$&#123;&#125;</code> 中的内容按照 JS 代码来解析执行，所以：</p><ul><li><p>若其中是字符串，那么保持原样地输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;<span class="string">&#x27;World&#x27;</span>&#125;</span>`</span>);  <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></li><li><p>若其中不是字符串，则会默认调用 <code>toString()</code> 方法来转为字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;ozzie&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;str&#125;</span>`</span>);  <span class="comment">// My name is ozzie</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`My name is <span class="subst">$&#123;value&#125;</span>`</span>);  <span class="comment">// 报错: value is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>模板字符串甚至还能嵌套，也就是模板字符串中再嵌套另一个模板字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123;<span class="attr">first</span>: <span class="string">&#x27;ozzie&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;nicholas&#x27;</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">first</span>: <span class="string">&#x27;foo&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;bar&#x27;</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">const</span> tem = <span class="function"><span class="params">arrs</span> =&gt;</span> <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;table&gt;</span></span><br><span class="line"><span class="string">    <span class="subst">$&#123;arrs.map(arr =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;arr.first&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">      &lt;tr&gt;&lt;td&gt;<span class="subst">$&#123;arr.last&#125;</span>&lt;/td&gt;&lt;/tr&gt;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">    `</span>).join(<span class="string">&#x27;&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string">  &lt;/table&gt;</span></span><br><span class="line"><span class="string">`</span>;  <span class="comment">// 另外，注意这里 join() 的作用</span></span><br><span class="line"><span class="built_in">console</span>.log(tem(data));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&lt;table&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;tr&gt;&lt;td&gt;ozzie&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">      &lt;tr&gt;&lt;td&gt;nicholas&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      &lt;tr&gt;&lt;td&gt;foo&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment">      &lt;tr&gt;&lt;td&gt;bar&lt;/td&gt;&lt;/tr&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  &lt;/table&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>如果需要引用模板字符串本身，在需要时执行，则可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;return &#x27;</span> + <span class="string">&#x27;`Hello $&#123;name&#125;!`&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;name&#x27;</span>, str);</span><br><span class="line">func(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;(name) =&gt; `Hello $&#123;name&#125;!`&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="built_in">eval</span>.call(<span class="literal">null</span>, str);</span><br><span class="line">func(<span class="string">&#x27;Jack&#x27;</span>) <span class="comment">// &quot;Hello Jack!&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>模板编译：这是一个模板字符串生成正式模板的实例：</p><ul><li><p>示例代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> template = `</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;% <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123; %&gt;</span><br><span class="line">    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;</span><br><span class="line">  &lt;% &#125; %&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure></li><li><p>模板规则：</p><ul><li>使用 <code>&lt;%...%&gt;</code> 输出 JS 语句</li><li>使用 <code>&lt;%= ... %&gt;</code> 输出 JS 表达式</li></ul></li><li><p>编译模板字符串的规则：其中一种是将其转换为 JS 表达式字符串：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">&#x27;&lt;ul&gt;&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  echo(<span class="string">&#x27;&lt;li&gt;&#x27;</span>);</span><br><span class="line">  echo(data.supplies[i]);</span><br><span class="line">  echo(<span class="string">&#x27;&lt;/li&gt;&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">echo(<span class="string">&#x27;&lt;/ul&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><p>这个转换使用正则表达式即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line"><span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">template = template</span><br><span class="line">  .replace(evalExpr, <span class="string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)</span><br><span class="line">  .replace(expr, <span class="string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);</span><br><span class="line"></span><br><span class="line">template = <span class="string">&#x27;echo(`&#x27;</span> + template + <span class="string">&#x27;`);&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>然后将 <code>template</code> 封装在一个函数里面返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script =</span><br><span class="line"><span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">  var output = &quot;&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function echo(html)&#123;</span></span><br><span class="line"><span class="string">    output += html;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return output;</span></span><br><span class="line"><span class="string">&#125;)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure></li><li><p>将上面的两步总结到一起：一个模板编译函数 <code>compile</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span>(<span class="params">template</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> evalExpr = <span class="regexp">/&lt;%=(.+?)%&gt;/g</span>;</span><br><span class="line">  <span class="keyword">let</span> expr = <span class="regexp">/&lt;%([\s\S]+?)%&gt;/g</span>;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">&#x27;`); \n  echo( $1 ); \n  echo(`&#x27;</span>)</span><br><span class="line">    .replace(expr, <span class="string">&#x27;`); \n $1 \n  echo(`&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">&#x27;echo(`&#x27;</span> + template + <span class="string">&#x27;`);&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> script =</span><br><span class="line">  <span class="string">`(function parse(data)&#123;</span></span><br><span class="line"><span class="string">    var output = &quot;&quot;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function echo(html)&#123;</span></span><br><span class="line"><span class="string">      output += html;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    <span class="subst">$&#123; template &#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return output;</span></span><br><span class="line"><span class="string">  &#125;)`</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用此函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> parse = <span class="built_in">eval</span>(compile(template));</span><br><span class="line">div.innerHTML = parse(&#123; <span class="attr">supplies</span>: [ <span class="string">&quot;broom&quot;</span>, <span class="string">&quot;mop&quot;</span>, <span class="string">&quot;cleaner&quot;</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>标签模板：</p><ul><li><p>模板字符串还可以跟在函数名的后面，此时，这个模板字符串会被看作该函数的参数，这被称为 “标签模板” 功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照模板字符串的规则</span></span><br><span class="line">alert(<span class="number">123</span>);  <span class="comment">// 弹出 123 的弹窗</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">alert<span class="string">`123`</span>;  <span class="comment">// 弹出 123 的弹窗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>);  <span class="comment">// 打印 123</span></span><br><span class="line"><span class="comment">// 却不等同于</span></span><br><span class="line"><span class="built_in">console</span>.log<span class="string">`123`</span>;  <span class="comment">// 打印 [&#x27;123&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>但如果模板字符里面有变量，就会将模板字符串先处理成多个参数，再调用函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line">alert<span class="string">`Hello <span class="subst">$&#123;a+b&#125;</span> world <span class="subst">$&#123;a*b&#125;</span>`</span>;  <span class="comment">// 弹出 &quot;Hello , world ,&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>该函数的第一个参数是数组，该数组的成员是原先模板字符串中没有被变量替换的部分，以 <code>$&#123;a+b&#125;</code> 和 <code>$&#123;a*b&#125;</code> 为参考，将 <code>Hello $&#123;a+b&#125; world $&#123;a*b&#125;</code> 划分为四部分，也就是没有被替换掉的部分：</p><ul><li><code>&#39;Hello &#39;</code></li><li><code>&#39;&#39;</code></li><li><code>world</code></li><li><code>&#39;&#39;</code></li></ul></li><li><p>该函数的其他参数，都是模板字符串各个变量被替换后的值，上面的例子中，模板字符串含有两个变量，因此 <code>alert</code> 会接受到 <code>value1</code> 和 <code>value2</code> 两个参数</p></li><li><p>综上，该函数的所有参数实际值如下：</p><ul><li>第一个参数：<code>[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;]</code></li><li>第二个参数：15</li><li>第三个参数：50</li></ul></li><li><p>所以，该函数实际上以下面的形式调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line">alert([<span class="string">&#x27;Hello &#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27; world &#x27;</span>, <span class="string">&#x27;&#x27;</span>], <span class="number">15</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标签模板的作用：</p><ul><li><p>过滤HTML字符串，防止用户输入恶意内容，这也是标签模板的一个重要应用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> msg = SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message&lt;/p&gt;`</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line">    <span class="comment">// 在替换中转义特殊字符</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">&quot;&amp;amp;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">&quot;&amp;lt;&quot;</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">&quot;&amp;gt;&quot;</span>)</span><br><span class="line">    <span class="comment">// 不要在模板中转义特殊字符</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码中，<code>sender</code> 变量往往是用户提供的，经过 <code>SaferHTML</code> 函数处理，里面的特殊字符都会被转义。</li></ul></li><li><p>多语言转换（国际化处理）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n<span class="string">`Welcome to <span class="subst">$&#123;siteName&#125;</span>, you are visitor number <span class="subst">$&#123;visitorNumber&#125;</span>!`</span></span><br><span class="line"><span class="comment">// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>因为没有条件判断和循环处理功能，所以模板字符串本身并不能取代 Mustache 之类的模板库，但是，通过标签函数，你可以自己添加这些功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">var</span> libraryHtml = hashTemplate<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;ul&gt;</span></span><br><span class="line"><span class="string">    #for book in <span class="subst">$&#123;myBooks&#125;</span></span></span><br><span class="line"><span class="string">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="string">    #end</span></span><br><span class="line"><span class="string">  &lt;/ul&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure></li><li><p>使用标签模板时，也可以在 JS 语言中嵌入其他语言：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jsx<span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      ref=&#x27;input&#x27;</span></span><br><span class="line"><span class="string">      onChange=&#x27;<span class="subst">$&#123;<span class="built_in">this</span>.handleChange&#125;</span>&#x27;</span></span><br><span class="line"><span class="string">      defaultValue=&#x27;<span class="subst">$&#123;<span class="built_in">this</span>.state.value&#125;</span>&#x27; /&gt;</span></span><br><span class="line"><span class="string">      <span class="subst">$&#123;<span class="built_in">this</span>.state.value&#125;</span></span></span><br><span class="line"><span class="string">   &lt;/div&gt;</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure><ul><li>通过 <code>jsx</code> 函数，将一个 DOM 字符串转为 Reac t对象，在 Github 上找到 JSX 函数的具体实现：<a href="https://gist.github.com/lygaret/a68220defa69174bdec5">JSX Quasi-Literal</a></li></ul></li></ul></li><li><p>模板字符串的限制：标签模板里面可以内嵌其他语言，但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。</p><ul><li><p>尝试在标签模板里面可以嵌入Latex语言：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">document</span> = latex<span class="string">`</span></span><br><span class="line"><span class="string">\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  // 正常工作</span></span><br><span class="line"><span class="string">\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125;  // 报错</span></span><br><span class="line"><span class="string">\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125;  // 报错</span></span><br><span class="line"><span class="string">Breve over the h goes \u&#123;h&#125;ere  // 报错</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码中，变量 <code>document</code> 内嵌的模板字符串，对于 Latex 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p></li><li><p>模板字符串会将<code>\u00FF</code>和<code>\u&#123;42&#125;</code>当作Unicode字符进行转义，所以<code>\unicode</code>解析时报错；而<code>\x56</code>会被当作十六进制字符串转义，所以<code>\xerxes</code>会报错。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量的解构赋值</title>
      <link href="89926b1f71ad/"/>
      <url>89926b1f71ad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>解构赋值的规则：只要等号右边的值不是对象，就先将其转为对象</p></blockquote><h2 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 之前</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 之后</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p></li><li><p>本质上，这种写法属于 “模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p></li><li><p>下面是一些使用嵌套数组进行解构的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [a, [b, [c]]] = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>]]];  <span class="comment">// a=1, b=2, c=3</span></span><br><span class="line"><span class="keyword">let</span> [ , ,str] = [<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>];  <span class="comment">// str=&quot;c&quot;</span></span><br><span class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// x=1, y=3</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  <span class="comment">// head=1, tail=[2,3,4]</span></span><br><span class="line"><span class="keyword">let</span> [i, j, ...k] = [<span class="string">&quot;a&quot;</span>];  <span class="comment">// i=&quot;a&quot;, j=undefined, k=[]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果解构不成功，变量的值就等于undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [foo] = [];  <span class="comment">// foo=undefined</span></span><br><span class="line"><span class="keyword">var</span> [bar, foo] = [<span class="number">1</span>];  <span class="comment">// bar=1, foo=undefined</span></span><br></pre></td></tr></table></figure></li><li><p>另一种情况是不完全解构，即左边的模式只匹配右边的一部分数组（左比右少，匹配过剩）。这种情况下，解构依然可以成功：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];  <span class="comment">// x=1, y=2</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], c] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];  <span class="comment">// a=1, b=2, c=4</span></span><br></pre></td></tr></table></figure></li><li><p>如果右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》），那么将会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>上面的表达式都会报错，因为对于等号右边的值，前五个表达式转为对象以后不具备 Iterator  接口，最后一个表达式本身就不具备 Iterator 接口。</li></ul></li><li><p>解构赋值不仅适用于 var 命令，也适用于 let 和 const 命令。</p></li><li><p>对于 Set 结构，也可以使用数组的解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);  <span class="comment">// x=&quot;a&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">0</span>,</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">yield</span> a;</span><br><span class="line">        [a, b] = [b, a + b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="comment">// sixth=5</span></span><br></pre></td></tr></table></figure><ul><li>上面代码中，fibs 是一个 Generator 函数，原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</li></ul></li></ol><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ol><li><p>解构赋值允许指定默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo=<span class="literal">true</span>] = [];  <span class="comment">// foo=true</span></span><br><span class="line"><span class="keyword">let</span> [x, y=<span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>];  <span class="comment">// x=&quot;a&quot;, y=&quot;b&quot;</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="string">&quot;b&quot;</span>, y] = [<span class="string">&quot;a&quot;</span>];  <span class="comment">// x=&quot;a&quot;, y=&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">let</span> [x, y=<span class="string">&quot;b&quot;</span>] = [<span class="string">&quot;a&quot;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&quot;a&quot;, y=&quot;b&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>注意，ES6 内部使用严格相等运算符（<code>===</code>）来判断一个位置是否有值。所以，如果一个数组成员不严格等于 <code>undefined</code>，默认值是不会生效的。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">undefined</span>];  <span class="comment">// x=1</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>] = [<span class="literal">null</span>];  <span class="comment">// x=null</span></span><br></pre></td></tr></table></figure><ul><li>上面代码中，如果一个数组成员是 null，默认值就不会生效，因为 null 不严格等于 undefined。</li></ul></li><li><p>如果默认值是一个表达式，那么这个表达式是惰性求值的（即只有在用到的时候，才会求值）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [x=f()] = [<span class="number">1</span>];  <span class="comment">// x=1</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，因为 x 能取到值（即为1），所以函数 f 根本不会执行。上面的代码其实等价于下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">1</span>][<span class="number">0</span>] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    x = f();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    x = [<span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>, y=x] = [];  <span class="comment">// x=1, y=1</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>, y=x] = [<span class="number">2</span>];  <span class="comment">// x=2, y=2</span></span><br><span class="line"><span class="keyword">let</span> [x=<span class="number">1</span>, y=x] = [<span class="number">1</span>, <span class="number">2</span>];  <span class="comment">// x=1, y=2</span></span><br><span class="line"><span class="keyword">let</span> [x=y, y=<span class="number">1</span>] = [];  <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><ul><li>上面最后一个表达式之所以会报错，是因为 x 用到默认值 y 时，y 还没有声明。</li></ul></li></ol><hr><h2 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h2><ol><li><p>对象的解构与数组有一个重要的不同：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;a&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;b&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// foo=&quot;a&quot;, bar=&quot;b&quot;</span></span><br><span class="line"><span class="keyword">var</span> &#123; str &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// str=undefined</span></span><br></pre></td></tr></table></figure><ul><li>第一个例子中，属性的次序虽然不一致，但是对取值完全没有影响，但第二个例子的变量没有对应的同名属性，就会取不到值。</li></ul></li><li><p>如果变量名与属性名不一致，必须写成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>:baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;  <span class="comment">// baz=&quot;aaa&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>:f, <span class="attr">last</span>:l &#125; = obj;</span><br><span class="line"><span class="comment">// f=&quot;hello&quot;, l=&quot;world&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>:foo, <span class="attr">bar</span>:bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(baz);  <span class="comment">// &quot;aaa&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo);  <span class="comment">// foo is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。</p></li><li><p>注意，采用这种写法时，变量的声明和赋值是一体的。对于 let 和 const 来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo;</span><br><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">foo</span>: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration &quot;foo&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> baz;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">bar</span>: baz&#125; = &#123;<span class="attr">bar</span>: <span class="number">1</span>&#125;; <span class="comment">// SyntaxError: Duplicate declaration &quot;baz&quot;</span></span><br></pre></td></tr></table></figure><ul><li>上面代码中，解构赋值的变量都会重新声明，所以报错了。</li><li>但是因为 var 命令允许重新声明，所以这个错误只会在使用 let 和 const 命令时出现。</li></ul></li><li><p>let 命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。</p></li></ul></li><li><p>和数组一样，解构也可以用于嵌套结构的对象。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    p: [<span class="string">&quot;Hello&quot;</span>, &#123; <span class="attr">y</span>: <span class="string">&quot;World&quot;</span> &#125;]</span><br><span class="line">&#125;  <span class="comment">// p 是模式，不是变量，因此不会被赋值。</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// Hello</span></span><br><span class="line"><span class="built_in">console</span>.log(y);  <span class="comment">// World</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> node = &#123;</span><br><span class="line">    loc: &#123;</span><br><span class="line">        start: &#123;</span><br><span class="line">            line: <span class="number">1</span>,</span><br><span class="line">            column: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: &#123; line &#125; &#125; &#125; = node</span><br><span class="line"><span class="built_in">console</span>.log(line);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(loc);  <span class="comment">// loc is undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(start);  <span class="comment">// start is undefined</span></span><br></pre></td></tr></table></figure></li><li><p>下面是嵌套赋值的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">(&#123; <span class="attr">foo</span>: obj.prop, <span class="attr">bar</span>: arr[<span class="number">0</span>] &#125; = &#123; <span class="attr">foo</span>: <span class="number">123</span>, <span class="attr">bar</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj);  <span class="comment">// &#123; prop: 123 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);  <span class="comment">// [ true ]</span></span><br></pre></td></tr></table></figure></li><li><p>对象的解构也可以指定默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x = <span class="number">3</span> &#125; = &#123;&#125;;  <span class="comment">// x=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, y = <span class="number">5</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;  <span class="comment">// x=1, y=5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123;&#125;;  <span class="comment">// y=3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">x</span>: y = <span class="number">3</span> &#125; = &#123; <span class="attr">x</span>: <span class="number">5</span> &#125;;  <span class="comment">// y=5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">message</span>: msg = <span class="string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;</span><br><span class="line"><span class="comment">// msg=&quot;Something went wrong&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>默认值生效的条件是，对象的属性值严格等于 undefined，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;x=<span class="number">3</span>&#125; = &#123;<span class="attr">x</span>:<span class="literal">undefined</span>&#125;;  <span class="comment">// x=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 不严格相等于 undefined</span></span><br><span class="line"><span class="keyword">let</span> &#123;x=<span class="number">3</span>&#125; = &#123;<span class="attr">x</span>:<span class="literal">null</span>&#125;;  <span class="comment">// x=null</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果解构失败，变量的值等于 undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;  <span class="comment">// foo=undefined</span></span><br></pre></td></tr></table></figure></li><li><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">foo</span>: &#123;bar&#125;&#125; = &#123;<span class="attr">baz</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;  <span class="comment">// Cannot read property &#x27;bar&#x27; of undefined</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性在解构时会报错。因为 foo 这时等于 undefined，再取子属性就会报错，再例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tmp = &#123;<span class="attr">baz</span>: <span class="string">&#x27;baz&#x27;</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(tmp.foo.bar);  <span class="comment">// Cannot read property &#x27;bar&#x27; of undefined</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;  <span class="comment">// SyntaxError: Unexpected token &#x27;=&#x27;</span></span><br></pre></td></tr></table></figure><ul><li><p>JavaScript 引擎会将 <code>&#123;x&#125;</code> 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题，所以我们要加上 <code>()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123; x &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;);  <span class="comment">// x=1</span></span><br></pre></td></tr></table></figure><ul><li>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</li></ul></li></ul></li><li><p>解构赋值允许在等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>]);</span><br><span class="line">(&#123;&#125; = <span class="string">&#x27;abc&#x27;</span>);</span><br><span class="line">(&#123;&#125; = []);</span><br></pre></td></tr></table></figure><ul><li>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</li></ul></li><li><p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure><ul><li>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上。</li></ul></li><li><p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="number">0</span>: first, [arr.length - <span class="number">1</span>]: last &#125; = arr;</span><br><span class="line"><span class="comment">// first=1, last=3</span></span><br></pre></td></tr></table></figure><ul><li>上面代码对数组进行对象解构。数组 arr 的 0 键对应的值是 1，[arr.length - 1] 就是 2 键，对应的值是3。</li><li>方括号这种写法，属于 “属性名表达式”。</li></ul></li></ol><hr><h2 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h2><ol><li><p>字符串也可以解构赋值，因为字符串被转换成了一个类似数组的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log([a, b, c, d, e][x])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">H</span></span><br><span class="line"><span class="comment">e</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">l</span></span><br><span class="line"><span class="comment">o</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span>:len&#125; = <span class="string">&#x27;Hello&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(len);  <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="headerlink" title="数值和布尔值的解构赋值"></a>数值和布尔值的解构赋值</h2><ol><li><p>根据解构赋值的规则，如果等号右边是数值和布尔值，则会先转为对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数值</span></span><br><span class="line"><span class="keyword">let</span> x = ( &#123;<span class="attr">toString</span>:s&#125; = <span class="number">123</span> );</span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// [Function: toString]</span></span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// 123</span></span><br><span class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值</span></span><br><span class="line"><span class="keyword">let</span> x = ( &#123;<span class="attr">toString</span>:s&#125; = <span class="literal">true</span> );</span><br><span class="line"><span class="built_in">console</span>.log(s);  <span class="comment">// [Function: toString]</span></span><br><span class="line"><span class="built_in">console</span>.log(x);  <span class="comment">// true</span></span><br><span class="line">s === <span class="built_in">Boolean</span>.prototype.toString  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>数值和布尔值的包装对象都有 toString 属性，因此变量 s 都能取到值。</li></ul></li><li><p>由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x);</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property `prop` of &#x27;undefined&#x27; or &#x27;null&#x27;.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">prop</span>: x &#125; = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(x)；</span><br><span class="line"><span class="comment">// TypeError: Cannot destructure property `prop` of &#x27;undefined&#x27; or &#x27;null&#x27;.</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h2><ol><li><p>函数的参数也可以使用解构赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">3</span>, <span class="number">5</span>]);  <span class="comment">// 3, 5</span></span><br></pre></td></tr></table></figure><ul><li>传入参数时，数组参数就被解构成变量 x 和 y，对于函数内部的代码来说，它们能感受到的参数就是 x 和 y。</li></ul></li><li><p>函数参数的解构也可以使用默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;));  <span class="comment">// [ 3, 8 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;));  <span class="comment">// [ 3, 0 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;&#125;));  <span class="comment">// [ 0, 0 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move());  <span class="comment">// [ 0, 0 ]</span></span><br></pre></td></tr></table></figure><ul><li><p>函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。</p></li><li><p>换一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;));  <span class="comment">// [ 3, 8 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;));  <span class="comment">// [ 3, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;&#125;));  <span class="comment">// [ undefined, undefined ]</span></span><br><span class="line"><span class="built_in">console</span>.log(move());  <span class="comment">// [ 0, 0 ]</span></span><br></pre></td></tr></table></figure><ul><li>与之前不同的是，上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。</li></ul></li></ul></li><li><p>undefined 就会触发函数参数的默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function">(<span class="params">x = <span class="string">&#x27;yes&#x27;</span></span>) =&gt;</span> x);</span><br><span class="line"><span class="comment">// [ 1, &#x27;yes&#x27;, 3 ]</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h2><p>解构赋值虽然很方便，但是解析起来并不容易。</p><p>编译器并不能从一开始就知道该式子是模式还是表达式，必须解析到（或解析不到）等号才能知道。</p><p>那么问题是，该怎么处理模式中的圆括号，ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p><p>因此，只要有可能，就不要在模式中放置圆括号。</p><p>不能使用圆括号的情况有以下：</p><ul><li><p>变量声明语句中，模式不能带有圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [(a)] = <span class="number">1</span>;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: (c)&#125; = &#123;&#125;;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br><span class="line"><span class="keyword">let</span> (&#123;<span class="attr">x</span>: c&#125;) = &#123;&#125;;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br></pre></td></tr></table></figure></li><li><p>函数参数中，模式不能带有圆括号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[(x)]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;  <span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br></pre></td></tr></table></figure></li><li><p>赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中：</p><ul><li><p>将整个模式放在圆括号之中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">x</span>: a &#125;) = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// SyntaxError: Invalid left-hand side in assignment</span></span><br><span class="line"></span><br><span class="line">([x]) = [<span class="number">1</span>];</span><br><span class="line"><span class="comment">// SyntaxError: Invalid left-hand side in assignment</span></span><br></pre></td></tr></table></figure></li><li><p>将嵌套模式的一层放在圆括号之中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[(&#123; <span class="attr">p</span>: a &#125;), &#123; <span class="attr">x</span>: c &#125;] = [&#123;&#125;, &#123;&#125;]</span><br><span class="line"><span class="comment">// SyntaxError: Invalid destructuring assignment target</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>可以使用圆括号的情况只有一种：就是在赋值语句的非模式部分使用圆括号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[(b)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line">(&#123; <span class="attr">p</span>: (d) &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[(<span class="built_in">parseInt</span>.prop)] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><hr><h2 id="变量的解构赋值用途"><a href="#变量的解构赋值用途" class="headerlink" title="变量的解构赋值用途"></a>变量的解构赋值用途</h2><ol><li><p>交换变量的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x]</span><br></pre></td></tr></table></figure></li><li><p>从函数返回多个值：函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回，此时用解构赋值来取出这些值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);  <span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="number">1</span>,</span><br><span class="line">        b: <span class="number">2</span>,</span><br><span class="line">        c: <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; a, b, c &#125; = f();</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c);  <span class="comment">// 1 2 3</span></span><br></pre></td></tr></table></figure></li><li><p>定义函数参数：解构赋值可以方便地将一组参数与变量名对应起来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123; x, y, z &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">f(&#123; <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>提取 JSON 数据：解构赋值经常应用在对 JSON 对象的提取中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">    id: <span class="number">001</span>,</span><br><span class="line">    name: <span class="string">&quot;ozzie&quot;</span>,</span><br><span class="line">    score: <span class="number">90</span>,</span><br><span class="line">    number: [<span class="number">90</span>, <span class="number">95</span>, <span class="number">100</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; id, name, score, <span class="attr">number</span>: data &#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, name, score, data);  <span class="comment">// 1 ozzie 90 [ 90, 95, 100 ]</span></span><br></pre></td></tr></table></figure></li><li><p>设置函数参数的默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">&#123; a, b = <span class="number">1</span>, c = <span class="literal">true</span>, d = <span class="keyword">function</span>() &#123;&#125;, e = <span class="string">&#x27;ozzie&#x27;</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c, d, e)</span><br><span class="line">&#125;</span><br><span class="line">fun();  <span class="comment">// undefined 1 true [Function: d] ozzie</span></span><br></pre></td></tr></table></figure><ul><li>指定参数的默认值，就避免了在函数体内部再写 <code>var foo = config.foo || &#39;default foo&#39;;</code> 这样的语句。</li></ul></li><li><p>遍历 Map 结构：任何部署了Iterator接口的对象，都可以用 <code>for...of</code> 循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key + <span class="string">&#x27; is &#x27;</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first is hello </span></span><br><span class="line"><span class="comment">second is world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>如果只想获取键名，或者只想获取键值，可以写成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [, value] <span class="keyword">of</span> map) &#123;  <span class="comment">// 注意这里有个逗号，否则还是会打印 key 的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">first</span></span><br><span class="line"><span class="comment">second</span></span><br><span class="line"><span class="comment">hello</span></span><br><span class="line"><span class="comment">world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>输入模块的指定方法：加载模块时，通常需要指定输入的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">&quot;source-map&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>var、let、const-及-块级作用域</title>
      <link href="ee1bae1a2f17/"/>
      <url>ee1bae1a2f17/</url>
      
        <content type="html"><![CDATA[<h2 id="var-命令"><a href="#var-命令" class="headerlink" title="var 命令"></a>var 命令</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li><p>可以使用 var 操作符定义变量（注意 var 是一个关键字），后跟变量名（即标识符）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message;</span><br></pre></td></tr></table></figure></li><li><p>定义了一个名为 message 的变量，可以用它保存任何类型的值。</p></li><li><p>不初始化的情况下，变 量会保存一个特殊值 undefined。</p></li><li><p>可以同时定义变量并设置它的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">message = <span class="number">0</span>; <span class="comment">//  合法，但不推荐</span></span><br></pre></td></tr></table></figure><ul><li>变量 message 首先被定义为一个保存字符串值 ‘Hello World’ 的变量，然后又被重写为保存了 数值 0。虽然不推荐改变变量保存值的类型，但这在 ECMAScript 中是完全有效的。</li></ul></li></ol><h3 id="声明作用域"><a href="#声明作用域" class="headerlink" title="声明作用域"></a>声明作用域</h3><ol><li><p>使用 var 操作符定义的变量会成为包含它的函数的局部变量，比如，使用 var 在一个函数内部定义一个变量，就意味着该变量将在函数退出时被销毁：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> message = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// message is not defined</span></span><br></pre></td></tr></table></figure><ul><li><p>但是，如果在函数内部定义变量时省略 var 操作符，就可以创建一个全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  message = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></li><li><p>虽然可以通过省略 var 操作符定义全局变量，但不推荐这么做。在局部作用域中定 义的全局变量很难维护，也会造成困惑。这是因为不能一下子断定省略 var 是不是有意而 为之。在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出 ReferenceError：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  message = <span class="string">&#x27;Hello World&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br><span class="line"><span class="built_in">console</span>.log(message); <span class="comment">// message is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>在严格模式下，不能定义名为 eval 和 arguments 的变量，否则会导致语法错误。</p></li></ul></li><li><p>var 声明提升：</p><ul><li><p>使用 var 时，下面的代码不会报错。这是因为使用这个关键字声明的变量会自动提升到函数作用域顶部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>这就是所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部。此外，反复多次 使用 var 声明同一个变量也没有问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">30</span>;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">40</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(age);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//40</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="let-命令"><a href="#let-命令" class="headerlink" title="let 命令"></a>let 命令</h2><h3 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h3><ol><li><p>let 类似于 var，但是声明的变量，只在 ler 所在的代码块内有效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a)  <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(b)  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>结果表明，ket 声明的变量只在自己所在的代码块内有效</li></ul></li><li><p>所以，for 循环的计数器就很适合 let 命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 打印 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)  <span class="comment">// ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure><ul><li>计数器只在 for 循环内部有效，循环体外就会报错</li></ul></li><li><p>观察下面的结果</p><ul><li><p>用 var 声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]()  <span class="comment">// 分别打印出 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]()  <span class="comment">// 3</span></span><br><span class="line">a[<span class="number">1</span>]()  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>上述代码中，i 是 var 声明的，在全局范围内都有效，所以全局只有一个变量 i，每次循环，i 的值都在改变，所有数组 a 的成员里面的 i，指的都是同一个 i，所以最后两个结果都是 3</li></ul></li><li><p>用 let 声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">    a[i]()  <span class="comment">// 分别打印出 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>]()  <span class="comment">// 0</span></span><br><span class="line">a[<span class="number">1</span>]()  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>上述的 i 是用 let 声明的，只在该轮循环中有效，所以每一次循环的 i 都是新的变量，至于如何记住上一轮循环的值，是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算</li></ul></li><li><p>另外，for 循环有个特点：设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">// 打印出 3 次 &quot;abc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h3><p>var 是有变量提升的，你可以在声明变量前就使用该变量，只不过值为 undefined，但是 let 必须要在声明之后才能使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var：有变量提升</span></span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let：没有变量提升</span></span><br><span class="line"><span class="built_in">console</span>.log(b);  <span class="comment">// ReferenceError: Cannot access &#x27;b&#x27; before initializatio</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h3><ol><li><p>若块级作用域内存在 let，那么，用 let 声明的变量就会 “绑定” 这个区域，不会受到外部影响，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)  <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">let</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ES6 规定，若在块级作用域中存在 let 和 const，那么用它们声明的变量，也是被封闭到该作用域内的，在 let 命令声明之前，该变量都不可用，这称为 “暂时性死区”</p></li><li><p>暂时性死区也意味着 typeof 不再是绝对安全的操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x;  <span class="comment">// ReferenceError:</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure><ul><li><p>若该变量根本没有被声明，typeof 反而不会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x)  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>这样看来，let 的存在约束了原先的不规范的操作，只要有 let 存在，typeof 就不是绝对安全的</li></ul></li></ul></li><li><p>隐蔽的死区：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line">fun() <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure><ul><li><p>x 的值默认来源于 y，但是 y 还没有声明，属于 “死区”，下面则不会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x = <span class="number">2</span>, y = x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x + y)</span><br><span class="line">&#125;</span><br><span class="line">fun() <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>另外，下面的代码也会报错，也是因为暂时性死区：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var：不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"><span class="comment">// let：报错</span></span><br><span class="line"><span class="keyword">let</span> y = y;  <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure></li><li><p>ES6 规定暂时性死区和 let、const 语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为</p></li></ol><h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h3><p>let 不允许在同一作用域内重复声明同一个变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错：SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：SyntaxError: Identifier &#x27;a&#x27; has already been declared</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>所以要注意，不能在函数内部重复声明参数</li></ul><hr><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h3><p>ES5 只有全局作用域和函数作用域，没有块级作用域，带来很多不合理的场景</p><ol><li><p>场景一：内层变量可能会覆盖外层变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);  <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure><ul><li>变量提升，导致内层的变量覆盖了外层的变量</li></ul></li><li><p>场景二：用来计数的循环变量泄露为全局变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);  <span class="comment">// 分别打印出 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>变量 i 本身只用来控制循环，但是之后他没有消失，泄漏成了全局变量</li></ul></li></ol><h3 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h3><ol><li><p><code>let </code> 为 JS 新增了块级作用域：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(n);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外层代码块不受内层代码块的影响。如果使用 <code>var</code> 定义变量 <code>n</code>，最后输出的值就是10。</li></ul></li><li><p>ES6允许块级作用域的任意嵌套：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123; <span class="keyword">let</span> n = <span class="number">10</span>; &#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><ul><li><p>外层作用域无法读取内层作用域的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">    &#123; <span class="keyword">let</span> n = <span class="number">10</span>; &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(n);  <span class="comment">// 5</span></span><br><span class="line">&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>内层可以定义外层作用域的同名变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">    &#123; <span class="keyword">let</span> n = <span class="number">10</span>; &#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure></li><li><p>立即执行函数表达式（IIFE）不再必要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 的写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h3><ol><li><p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>上面代码的两种函数声明，根据 ES5 的规定都是非法的。</li><li>但是浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式” 下还是会报错。</li></ul></li><li><p>ES6 明确允许在块级作用域之中声明函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>即使在 ES6 严格模式中也不会报错</li></ul></li><li><p>ES6 规定，块级作用域之中，函数声明语句的行为类似于 <code>let</code>，在块级作用域之外不可引用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        <span class="comment">// 再次声明 f 函数</span></span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><ul><li><p>上面代码在 ES5 中运行，会得到 “B”，因为在 <code>if</code> 内声明的函数会被提升到函数头部，实际运行的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;B&quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    f();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>而 ES6 的运行结果会得到 “A”。因为块级作用域内声明的函数类似于<code>let</code>，对作用域之外没有影响，实际运行的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;A&quot;</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    f();</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure></li><li><p>这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在 <a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics">附录B</a> 里面规定，浏览器的实现可以不遵守上面的规定，有自己的 <a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6">行为方式</a>，但是考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p></li><li><p>注意，ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="do-表达式"><a href="#do-表达式" class="headerlink" title="do 表达式"></a>do 表达式</h3><ol><li><p>本质上块级作用域是一个语句，将多个操作封装在一起，没有返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> t = f();</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码中，块级作用域将两个语句封装在一起。但在块级作用域以外，没有办法得到 <code>t</code> 的值，因为块级作用域不返回值，除非 <code>t</code>是全局变量。</li></ul></li><li><p>现在有一个<a href="http://wiki.ecmascript.org/doku.php?id=strawman:do_expressions">提案</a>：在块级作用域之前加上 <code>do</code>，使它变为 <code>do</code> 表达式。这使得块级作用域可以变为表达式，也就是说可以返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> t = f();</span><br><span class="line">    t = t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面代码中，变量 <code>x</code> 会得到整个块级作用域的返回值。</li></ul></li></ol><hr><h2 id="const-命令"><a href="#const-命令" class="headerlink" title="const 命令"></a>const 命令</h2><ol><li><p>const 声明一个只读的常量，一旦声明，常量的值就不能改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">console</span>.log(PI);  <span class="comment">// 3.1415926</span></span><br><span class="line">PI = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(PI);  <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure></li><li><p>const 一旦声明变量，就必须立即初始化，不能留到以后赋值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x;</span><br><span class="line"><span class="comment">// SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure></li><li><p>const 的作用域与 let 命令相同 —— 只在声明所在的块级作用域内有效：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">x  <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure></li><li><p>const 命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);  <span class="comment">// ReferenceError: Cannot access &#x27;x&#x27; before initialization</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>const 声明的常量，也与 let 一样不可重复声明。</p></li><li><p>将一个对象声明为常量必须非常小心：因为，对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址，const 命令只是保证变量名指向的地址不变，并不保证该地址的数据不变。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> f = &#123;&#125;;</span><br><span class="line">f.num = <span class="number">123</span>;</span><br><span class="line"><span class="built_in">console</span>.log(f.num);  <span class="comment">// 123</span></span><br><span class="line">f = &#123;&#125;;  <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，常量 f 储存的是一个地址，这个地址指向一个对象，不可变的只是这个地址，即不能把 f 指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p></li><li><p>例如下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">a.length = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);  <span class="comment">// []</span></span><br><span class="line">a = [<span class="string">&quot;hello&quot;</span>];  <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><ul><li>常量 a 是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给 a，就会报错。</li></ul></li><li><p>如果想将对象冻结，应使用 <code>Object.freeze</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常量 f 指向一个冻结的对象，所以添加新属性不起作用</span></span><br><span class="line"><span class="keyword">const</span> f = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">f.num = <span class="number">123</span>;  <span class="comment">// 常规模式下不起作用，严格模式下会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(f);  <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p>将对象彻底冻结（冻结对象本身以及对象属性）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> constance = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] === <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">            constance(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><hr><h2 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a>顶层对象的属性</h2><ol><li><p>顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是 global 对象。ES5 之中，顶层对象的属性与全局变量是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 中</span></span><br><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>  <span class="comment">// window 中的 a</span></span><br><span class="line">a = <span class="number">2</span>  <span class="comment">// 全局的 a</span></span><br><span class="line"><span class="built_in">window</span>.a  <span class="comment">// window 中的 a 就是全局的 a</span></span><br></pre></td></tr></table></figure><ul><li><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p></li><li><p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题：</p><ul><li>首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；</li><li>其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；</li><li>最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window 对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</li></ul></li></ul></li><li><p>ES6 中，一方面规定，为了保持兼容性，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let、const、class 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.a  <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.b  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>全局变量 a 由 var 命令声明，所以它是顶层对象的属性；</li><li>全局变量 b 由 let 命令声明，所以它不是顶层对象的属性，返回 undefined。</li></ul></li></ol><hr><h2 id="global-对象"><a href="#global-对象" class="headerlink" title="global 对象"></a>global 对象</h2><ol><li><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的：</p><ul><li>浏览器里面，顶层对象是 window，但 Node 和 Web Worker 没有 window。</li><li>浏览器和 Web Worker 里面，self 也指向顶层对象，但是 Node 没有 self。</li><li>Node 里面，顶层对象是 global，但其他环境都不支持。</li></ul></li><li><p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用 this 变量，但是有局限性：</p><ul><li>全局环境中，this 会返回顶层对象。但是，Node 模块和 ES6 模块中，this 返回的是当前模块。</li><li>函数里面的 this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this 会指向顶层对象。但是，严格模式下，this 会返回 undefined。</li><li>不管是严格模式，还是普通模式，<code>new Function(&#39;return this&#39;)()</code>，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么 <code>eval</code>、<code>new Function </code>这些方法都可能无法使用。</li></ul></li><li><p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象，以下是两种勉强可以使用的方法：</p><ul><li><p>方法一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span> ? <span class="built_in">window</span> :</span><br><span class="line">    (<span class="keyword">typeof</span> process === <span class="string">`object`</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">`function`</span> &amp;&amp;</span><br><span class="line">        <span class="keyword">typeof</span> <span class="built_in">global</span> === <span class="string">`object`</span></span><br><span class="line">    ) ? <span class="built_in">global</span> : <span class="built_in">this</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>方法二：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">&quot;undefined&quot;</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">&quot;undefined&quot;</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">global</span> !== <span class="string">&quot;undefined&quot;</span>) &#123; <span class="keyword">return</span> <span class="built_in">global</span>; &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;unable to locate global object&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>现在有一个 <a href="https://github.com/tc39/proposal-global">提案</a>，在语言标准的层面，引入 global 作为顶层对象。也就是说，在所有环境下，global 都是存在的，都可以从它拿到顶层对象。</p><ul><li><p>垫片库 <a href="https://github.com/ljharb/System.global">system.global</a> 模拟了这个提案，可以在所有环境拿到 global：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;system.global/shim&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">&#x27;system.global/shim&#x27;</span>; shim();</span><br></pre></td></tr></table></figure><ul><li><p>上面代码可以保证各种环境里面，global 对象都是存在的。</p></li><li><p>将顶层对象放入变量 global：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">global</span> = <span class="built_in">require</span>(<span class="string">&#x27;system.global&#x27;</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6模块的写法</span></span><br><span class="line"><span class="keyword">import</span> getGlobal <span class="keyword">from</span> <span class="string">&#x27;system.global&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">global</span> = getGlobal();</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（五）：数据类型与字面量</title>
      <link href="623f1f08afb9/"/>
      <url>623f1f08afb9/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型概述"><a href="#数据类型概述" class="headerlink" title="数据类型概述"></a>数据类型概述</h2><p>JavaScript 语言的每一个值都属于一种数据类型，最新的 ECMAScript 指出，JavaScript 共有 <strong>8种</strong> 数据类型，分别是：</p><ul><li>七种基本数据类型：<ul><li>布尔值（Boolean）<ul><li>有2个值分别是：true 和 false</li></ul></li><li>null<ul><li>一个表明 null 值的特殊关键字。 JavaScript 是大小写敏感的，因此 null 与 Null、NULL或变体完全不同。</li></ul></li><li>undefined<ul><li>和 null 一样是一个特殊的关键字，undefined 表示变量未赋值时的属性。</li></ul></li><li>数字（Number）<ul><li>整数或浮点数，例如： 42 或者 3.14159。</li></ul></li><li>任意精度的整数 (BigInt) <ul><li>可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。</li></ul></li><li>字符串（String）<ul><li>字符串是一串表示文本值的字符序列，例如：”Hello World” 。</li></ul></li><li>代表（Symbol）<ul><li>在 ECMAScript 6 中新添加的类型。</li><li>一种实例是唯一且不可改变的数据类型。</li></ul></li></ul></li><li>以及对象（Object）</li></ul><hr><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>JavaScript是一种动态类型语言。这意味着你在声明变量时可以不必指定数据类型，而数据类型会在代码执行时会根据需要自动转换。因此，可以按照如下方式来定义变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>再给同一个变量赋予一个字符串值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure><p>因为 JavaScript 是动态类型的，这种赋值方式并不会提示出错。</p><p>在包含的数字和字符串的表达式中使用加法运算符（+），JavaScript 会把数字转换成字符串。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;The value of x is &#x27;</span> + <span class="number">1</span>; <span class="comment">// The value of x is 1</span></span><br></pre></td></tr></table></figure><p>在涉及其它运算符（译注：如下面的减号’-‘）时，JavaScript语言不会把数字变为字符串。例如（译注：第一例是数学运算，第二例是字符串运算）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;30&#x27;</span> + <span class="number">10</span>; <span class="comment">// &#x27;3010&#x27;</span></span><br><span class="line"><span class="string">&#x27;30&#x27;</span> - <span class="number">10</span>; <span class="comment">// 20</span></span><br><span class="line"><span class="string">&#x27;30&#x27;</span> * <span class="number">10</span>; <span class="comment">// 300</span></span><br><span class="line"><span class="string">&#x27;30&#x27;</span> / <span class="number">10</span>; <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>有一些方法可以用于数据类型之间的转换，各种对应类型的转换如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/4/30/16a6a294a0a2e539?imageslim" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/4/30/16a6a294a0a2e539?imageslim" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p><h3 id="补充：强制类型转换"><a href="#补充：强制类型转换" class="headerlink" title="补充：强制类型转换"></a>补充：强制类型转换</h3><p>JavaScript 中的强制类型转换主要指的是基本数据类型之间值的转换，而基本数据类型转成引用数据类型，则是一种封装，并非实际意义的类型转换。</p><ol><li><p>转换成 String：</p><ul><li><p>规则：</p><table><thead><tr><th align="center">类型</th><th align="center">原值</th><th align="center">string 值</th></tr></thead><tbody><tr><td align="center">Boolean</td><td align="center">true | false</td><td align="center">‘true’ | ‘false’</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td><td align="center">‘undefined’</td></tr><tr><td align="center">Symbol</td><td align="center">Symbol(‘name’)</td><td align="center">‘Symbol(name)’</td></tr><tr><td align="center">Number</td><td align="center">22</td><td align="center">‘22’</td></tr><tr><td align="center">Null</td><td align="center">null</td><td align="center">‘null’</td></tr><tr><td align="center">Object</td><td align="center">{name:’bob’}</td><td align="center">‘[object Object]’</td></tr></tbody></table></li><li><p>方法：</p><ul><li><p>原生函数 String()，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>); <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>利用 + 号运算符，其中只要运算符两侧有一个操作数为字符串，该运算符将是字符串拼接功能，那么另一个操作数就会进行字符串的类型转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;string&#x27;</span> + <span class="number">234</span>; <span class="comment">// &#x27;string234&#x27;</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;string&#x27;</span> + <span class="literal">null</span>; <span class="comment">// &#x27;stringnull&#x27;</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;string&#x27;</span> + &#123;&#125;; <span class="comment">//&#x27;string[object Object]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//实际应用</span></span><br><span class="line"><span class="keyword">var</span> d = <span class="literal">true</span> + <span class="string">&#x27;&#x27;</span>; <span class="comment">// &#x27;true&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>除了 undefined、null 数据类型外，其它数据类型都可以使用 toString() 方法</p></li></ul></li></ul></li><li><p>转成 Number：</p><ul><li><p>规则：</p><table><thead><tr><th align="center">类型</th><th align="center">原值</th><th align="center">number值</th></tr></thead><tbody><tr><td align="center">Boolean</td><td align="center">true | false</td><td align="center">1 | 0</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td><td align="center">NaN</td></tr><tr><td align="center">Symbol</td><td align="center">Symbol(‘name’)</td><td align="center">不能转换</td></tr><tr><td align="center">string</td><td align="center">‘22’ | ‘23fds’ | ‘’</td><td align="center">22 | NaN | 0</td></tr><tr><td align="center">Null</td><td align="center">null</td><td align="center">0</td></tr><tr><td align="center">Object</td><td align="center">{name:’bob’}</td><td align="center">NaN</td></tr></tbody></table></li><li><p>方法：</p><ul><li><p>原生函数 Number()，例如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;234&#x27;</span>); <span class="comment">// 234</span></span><br></pre></td></tr></table></figure><ul><li>这个需要注意一下将字符串转化为数字：如果传入的不是只包含数字的字符串，如 ‘234fasd’,那么 Number 函数会将其转成 NaN。</li></ul></li><li><p>parseInt：是全局对象的一个属性，在浏览器中也就是 window 对象的方法。</p><ul><li><p>它看似也实现了数据类型的转换，但实则不是，它是一种数据的解析，并且只能正常解析数字和字符串的数据类型。</p></li><li><p>当传入上述中既包含数字也包含字母的字符串时，它会判断，当遇到第一个非数字的字符时，那么就会将后面的字符全抛弃掉，然后转化之前全为数字的字符串，该函数第二个参数为进制数，默认以十进制，来解析传入的值。</p></li><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;234fasd&#x27;</span>,<span class="number">10</span>)  <span class="comment">// 234</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;234fasd&#x27;</span>)    <span class="comment">//NaN</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>在所要转换的数据前加上 <code>~~</code>，~ 是一个取反运算法，这种方式的感觉就像负负得正一样，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~~<span class="string">&#x27;2434&#x27;</span>; <span class="comment">// 2434</span></span><br><span class="line">~~<span class="literal">null</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>+</code>  运算符，这个并不是用来计算数字加减或字符串拼接用的那个，而是直接放在被转换数据的前面，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+<span class="string">&#x27;123&#x27;</span>; <span class="comment">// 123</span></span><br><span class="line">+<span class="literal">true</span>;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>-</code>、 <code>*</code> 、 <code>/</code> 、 <code>%</code> 运算符，和转字符串的 + 运算符，道理类似，若两侧的操作数中含有非numbe 类型时，会先转换成 number，再运算，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;123&#x27;</span> - <span class="string">&#x27;3&#x27;</span>; <span class="comment">// 120</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">&#x27;45&#x27;</span> - <span class="number">5</span>; <span class="comment">// 40</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">60</span> - <span class="literal">undefined</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="comment">//实际使用</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="string">&#x27;123&#x27;</span> - <span class="number">0</span>; <span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>转成 Boolean：</p><ul><li><p>规则：</p><table><thead><tr><th align="center">类型</th><th align="center">原值</th><th align="center">boolean值</th></tr></thead><tbody><tr><td align="center">Number</td><td align="center">非0 | 0</td><td align="center">true | false</td></tr><tr><td align="center">Undefined</td><td align="center">undefined</td><td align="center">false</td></tr><tr><td align="center">Symbol</td><td align="center">Symbol(‘name’)</td><td align="center">true</td></tr><tr><td align="center">string</td><td align="center">‘22sd’ | ‘’</td><td align="center">true | false</td></tr><tr><td align="center">Null</td><td align="center">null</td><td align="center">false</td></tr><tr><td align="center">Object</td><td align="center">{name:’bob’} | {} | []</td><td align="center">true | true | true</td></tr></tbody></table></li><li><p>方法：</p><ul><li><p>原生函数 Boolean()，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Boolean</span>(<span class="string">&#x27;test&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>在转换的数据前加上 <code>!!</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="string">&#x27;test&#x27;</span>; <span class="comment">// true  </span></span><br></pre></td></tr></table></figure></li><li><p>各种条件判断语句（<code>if()</code>、<code>else if()</code>、<code>while()</code>、<code>?: 左侧的操作数</code>、<code>&amp;&amp;, || 左侧的操作数</code>）都会对传入的数据进行转 Boolean 操作。</p></li></ul></li></ul></li><li><p>转成 Object：</p><ul><li><p>将其它基本数据类型转成引用数据类型，并不是真正的数据转换，而是一种封装。</p><ul><li>简单说一下什么是封装：例如，我们通常会写这么一句代码：<code>&#39; thisString &#39;.trim()</code> 来清除字符串左右两侧的空格，但 <code>.</code> 运算符明明是作用在 Object 上，用来访问该对象的属性和方法的，为什么字符串这种基本数据类型也可以这么用，答案就是封装对象。</li></ul></li><li><p>除了普通的对象外，其实还有四种基本包装对象，分别对应着基本数据类型中的 <code>Number</code>、<code>String</code> 、<code>Boolean</code>、<code>Symbol</code>，除了 Symbol，另外三种我们可以通过 new 来获取到相应的实例对象。</p></li><li><p><code>&#39; thisString &#39;.trim()</code> 的详细执行过程是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27; thisString &#x27;</span>);</span><br><span class="line">str.trim();</span><br><span class="line"><span class="comment">// 销毁对象</span></span><br><span class="line">str = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><ul><li><p>也就是它会创建一个基本包装对象，然后调用该对象上的方法，执行完成，销毁这个包装对象。那么这种基本包装对象的生命周期只存在于代码执行的那么一瞬间，之后我们不可以在运行的时候为其添加方法与属性。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27; this String &#x27;</span>;</span><br><span class="line">s.trim();</span><br><span class="line"><span class="comment">// 下面的操作无效</span></span><br><span class="line">s.name = <span class="string">&#x27;ozzie&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(s.name);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>封装方法：直接使用js提供的Object原生函数，当传入的是上面那四种基本数据类型时，它会转成对应的基本包装对象：<br><img src="https://user-gold-cdn.xitu.io/2020/5/5/171e44ea757727fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2020/5/5/171e44ea757727fd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="img"></p></li></ul></li><li><p>引用类型转基本数据类型：</p><ul><li><p>与前面封装的操作相反，对象转成基本数据类型，则是拆封。在JavaScript 标准中，规定了 ToPrimitive 函数，来实现拆封。</p></li><li><p>拆封的方法就是 Number()、String()、Boolean() 这些用来转类型的原生函数</p></li><li><p>具体的拆封过程，其实是涉及到对象valueOf和toSting函数的调用，当将一个对象转换基本数据类型时，会先调用该对象的valueOf，如果能返回基本数据类型，则进行后续的数据类型转换，否则，就继续调用toString，拿到字符串，然后进行数据类型转换。如果这两个方法都没返回基本数据类型，则抛出异常。案例如下：</p><ul><li><p>先定义一个返回基本数据类型的 valueOf 方法的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个对象，自定义 valueOf 和 toString 方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 valueOf 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 toString 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用之前转 number 的原生函数来拆箱</span></span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用了 valueOf 方法</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>说明只执行了 valueOf 方法。</li></ul></li><li><p>定义一个返回引用数据类型的 valueOf 方法的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个对象，自定义 valueOf 和 toString 方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 valueOf 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 toString 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;123&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用之前转 number 的原生函数来拆箱</span></span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用了 valueOf 方法</span></span><br><span class="line"><span class="comment">调用了 toString 方法</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>说明执行了 valueOf 方法以及 toString 方法。</li></ul></li><li><p>定义一个 valueOf、toString 都返回基本数据类型的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先定义一个对象，自定义 valueOf 和 toString 方法</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 valueOf 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;调用了 toString 方法&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用之前转 number 的原生函数来拆箱</span></span><br><span class="line"><span class="built_in">Number</span>(obj);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">调用了 valueOf 方法</span></span><br><span class="line"><span class="comment">调用了 toString 方法</span></span><br><span class="line"><span class="comment">Uncaught TypeError: Cannot convert object to primitive value</span></span><br><span class="line"><span class="comment">    at Number (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">    at &lt;anonymous&gt;:1:1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li>说明执行了 valueOf 方法以及 toString 方法，之后抛出了错误。</li></ul></li><li><p>上述的几个过程就是 ToPrimitive 拆箱函数的过程。</p></li><li><p>但是，有一种特殊情况，如果是使用String()函数，它会直接调用对象的 toString 方法，而不是先 valueOf()。</p></li><li><p>4种基本包装对象都已经实现了自己的 valueOf 和 toString 方法，因此在拆箱时，能正常返回其基本数据的值。<br><img src="https://user-images.githubusercontent.com/49378661/103031491-e5579580-4598-11eb-8f29-a8be562a6b6e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103031491-e5579580-4598-11eb-8f29-a8be562a6b6e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201224030148743"></p></li></ul></li><li><p>另外，当我们对普通对象转 String 时，会看到这个东西：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a.toString(); <span class="comment">// &quot;[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">b.toString(); <span class="comment">// &quot;[object Set]&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>其中第二个 Object 和 Set，实际是对象的一个私有属性 <code>[[Class]]</code> 的值，这个值并不能直接访问并且修改，只能通过 <code>Object.prototype.toString()</code> 来获取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;); <span class="comment">//&quot;[object Object]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">new</span> <span class="built_in">Set</span>()); <span class="comment">//&quot;[object Set]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">123</span>); <span class="comment">//&quot;[object Number]&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><hr><h2 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h2><blockquote><p>字面量是由语法表达式定义的常量，或通过由一定字词组成的语词表达式定义的常量</p></blockquote><p>在 JavaScript 中，可以使用各种字面量。这些字面量是脚本中按字面意思给出的固定的值，而不是变量。</p><p>字面量是常量，其值是固定的，而且在程序脚本运行中不可更改。</p><h3 id="数组字面量"><a href="#数组字面量" class="headerlink" title="数组字面量"></a>数组字面量</h3><ol><li><p>数组字面值是一个封闭在方括号对 <code>[]</code> 中的包含有零个或多个表达式的列表，其中每个表达式代表数组的一个元素。</p></li><li><p>当使用数组字面值创建一个数组时，该数组将会以指定的值作为其元素进行初始化，而其长度被设定为元素的个数，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coffees = [<span class="string">&quot;French Roast&quot;</span>, <span class="string">&quot;Colombian&quot;</span>, <span class="string">&quot;Kona&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(a[<span class="number">0</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li>注意，这里的数组字面值也是一种对象初始化器。</li></ul></li><li><p>若在顶层（全局）脚本里用字面值创建数组，JavaScript 将会在每次对包含该数组字面值的表达式求值时解释该数组。另一方面，在函数中使用的数组，将在每次调用函数时都会被创建一次。</p></li><li><p>数组字面值同时也是数组对象。</p></li><li><p>数组字面值中的多余逗号：不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没有被指定的元素，其初始值是<code>undefined</code>，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fish = [<span class="string">&quot;Lion&quot;</span>, , <span class="string">&quot;Angel&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fish[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>如果你在元素列表的尾部添加了一个逗号，它将会被忽略。</li></ul></li></ol><h3 id="布尔字面量"><a href="#布尔字面量" class="headerlink" title="布尔字面量"></a>布尔字面量</h3><ol><li>布尔类型有两种字面量：<code>true</code> 和 <code>false</code>。</li><li>不要混淆作为布尔对象的真和假与布尔类型的原始值 true 和 false。布尔对象是原始布尔数据类型的一个包装器。</li></ol><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ol><li>整数可以用十进制（基数为10）、十六进制（基数为16）、八进制（基数为8）以及二进制（基数为2）表示：<ul><li>十进制整数字面量由一串数字序列组成，且没有前缀0。</li><li>八进制的整数以 0（或0O、0o）开头，只能包括数字0-7。</li><li>十六进制整数以0x（或0X）开头，可以包含数字（0-9）和字母 a<del>f 或 A</del>F。</li><li>二进制整数以0b（或0B）开头，只能包含数字0和1。</li></ul></li><li>严格模式下，八进制整数字面量必须以0o或0O开头，而不能以0开头。</li></ol><h3 id="浮点数字面量"><a href="#浮点数字面量" class="headerlink" title="浮点数字面量"></a>浮点数字面量</h3><ol><li><p>浮点数字面值可以有以下的组成部分：</p><ul><li>一个十进制整数，可以带正负号（即前缀“+”或“ - ”）；</li><li>小数点（“.”）；</li><li>小数部分（由一串十进制数表示）；</li><li>指数部分。</li></ul></li><li><p>指数部分以“e”或“E”开头，后面跟着一个整数，可以有正负号（即前缀“+”或“-”）。浮点数字面量至少有一位数字，而且必须带小数点或者“e”（大写“E”也可）。简言之，其语法是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[(+|-)][digits][.digits][(E|e)[(+|-)]digits]</span><br></pre></td></tr></table></figure><ul><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br><span class="line">-<span class="number">.2345789</span> <span class="comment">// -0.23456789</span></span><br><span class="line">-<span class="number">3.12e+12</span>  <span class="comment">// -3.12*1012</span></span><br><span class="line"><span class="number">.1e-23</span>    <span class="comment">// 0.1*10-23=10-24=1e-24</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><ol><li><p>对象字面值是封闭在花括号对 <code>&#123;&#125;</code> 中的一个对象的零个或多个 <code>&quot;属性名-值&quot;对</code> 的（元素）列表。</p></li><li><p>不能在一条语句的开头就使用对象字面值，这将导致错误或产生超出预料的行为， 因为此时左花括号 <code>&#123;</code> 会被认为是一个语句块的起始符号。</p></li><li><p>以下是一个对象字面值的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Sales = <span class="string">&quot;Toyota&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CarTypes</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (name === <span class="string">&quot;Honda&quot;</span>) ?</span><br><span class="line">    name :</span><br><span class="line">    <span class="string">&quot;Sorry, we don&#x27;t sell &quot;</span> + name + <span class="string">&quot;.&quot;</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> car = &#123;</span><br><span class="line">  myCar: <span class="string">&quot;Saturn&quot;</span>,</span><br><span class="line">  getCar: CarTypes(<span class="string">&quot;Honda&quot;</span>),</span><br><span class="line">  special: Sales</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car.myCar);   <span class="comment">// Saturn</span></span><br><span class="line"><span class="built_in">console</span>.log(car.getCar);  <span class="comment">// Honda</span></span><br><span class="line"><span class="built_in">console</span>.log(car.special); <span class="comment">// Toyota</span></span><br></pre></td></tr></table></figure></li><li><p>也可以使用数字或字符串字面值作为属性的名字，或者在另一个字面值内嵌套上一个字面值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">  manyCars: &#123;</span><br><span class="line">    a: <span class="string">&quot;Saab&quot;</span>,</span><br><span class="line">    <span class="string">&quot;b&quot;</span>: <span class="string">&quot;Jeep&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">7</span>: <span class="string">&quot;Mazda&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(car.manyCars.b); <span class="comment">// Jeep</span></span><br><span class="line"><span class="built_in">console</span>.log(car[<span class="number">7</span>]); <span class="comment">// Mazda</span></span><br></pre></td></tr></table></figure></li><li><p>对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的 javascript 标识符，它必须用 <code>&quot;&quot;</code> 包裹。属性的名字不合法，那么便不能用 <code>.</code> 访问属性值，而是通过类数组标记 <code>[]</code> 访问和赋值，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unusualPropertyNames = &#123;</span><br><span class="line">  <span class="string">&quot;&quot;</span>: <span class="string">&quot;An empty string&quot;</span>,</span><br><span class="line">  <span class="string">&quot;!&quot;</span>: <span class="string">&quot;Bang!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(unusualPropertyNames.<span class="string">&quot;&quot;</span>);   <span class="comment">// 语法错误: Unexpected string</span></span><br><span class="line"><span class="built_in">console</span>.log(unusualPropertyNames[<span class="string">&quot;&quot;</span>]);  <span class="comment">// An empty string</span></span><br><span class="line"><span class="built_in">console</span>.log(unusualPropertyNames.!);    <span class="comment">// 语法错误: Unexpected token !</span></span><br><span class="line"><span class="built_in">console</span>.log(unusualPropertyNames[<span class="string">&quot;!&quot;</span>]); <span class="comment">// Bang!</span></span><br></pre></td></tr></table></figure></li><li><p>增强的对象字面量：在ES2015，对象字面值扩展支持在创建时设置原型，简写了 <code>foo: foo</code> 形式的属性赋值，方法定义，支持父方法调用，以及使用表达式动态计算属性名。总之，这些也使对象字面值和类声明更加紧密地联系起来，让基于对象的设计从这些便利中更加受益，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="comment">// __proto__</span></span><br><span class="line">    __proto__: theProtoObj,</span><br><span class="line">    <span class="comment">// Shorthand for ‘handler: handler’</span></span><br><span class="line">    handler,</span><br><span class="line">    <span class="comment">// Methods</span></span><br><span class="line">    <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="comment">// Super calls</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;d &quot;</span> + <span class="built_in">super</span>.toString();</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Computed (dynamic) property names</span></span><br><span class="line">    [ <span class="string">&#x27;prop_&#x27;</span> + (<span class="function">() =&gt;</span> <span class="number">42</span>)() ]: <span class="number">42</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>需要注意：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  a: <span class="string">&quot;alpha&quot;</span>,</span><br><span class="line">  <span class="number">2</span>: <span class="string">&quot;two&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.a);    <span class="comment">// alpha</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="number">2</span>]);   <span class="comment">// two</span></span><br><span class="line"><span class="comment">//console.log(foo.2);  // SyntaxError: missing ) after argument list</span></span><br><span class="line"><span class="comment">//console.log(foo[a]); // ReferenceError: a is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="string">&quot;a&quot;</span>]); <span class="comment">// alpha</span></span><br><span class="line"><span class="built_in">console</span>.log(foo[<span class="string">&quot;2&quot;</span>]); <span class="comment">// two</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="RegExp-字面量"><a href="#RegExp-字面量" class="headerlink" title="RegExp 字面量"></a>RegExp 字面量</h3><p>一个正则表达式是字符被正斜杠 <code>/</code> 围成的表达式。</p><p>下面是一个正则表达式文字的一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure><h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>字符串字面量是由双引号（”）对或单引号（’）括起来的零个或多个字符。</p><p>字符串被限定在同种引号之间；也就是说，必须是成对单引号或成对双引号。下面的例子都是字符串字面值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;foo&quot;</span></span><br><span class="line"><span class="string">&#x27;bar&#x27;</span></span><br><span class="line"><span class="string">&quot;1234&quot;</span></span><br><span class="line"><span class="string">&quot;one line \n another line&quot;</span></span><br><span class="line"><span class="string">&quot;John&#x27;s cat&quot;</span></span><br></pre></td></tr></table></figure><p>你可以在字符串字面值上使用字符串对象的所有方法——JavaScript会自动将字符串字面值转换为一个临时字符串对象，调用该方法，然后废弃掉那个临时的字符串对象。你也能用对字符串字面值使用类似String.length的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;John&#x27;s cat&quot;</span>.length)</span><br><span class="line"><span class="comment">// 将打印字符串中的字符个数（包括空格）</span></span><br><span class="line"><span class="comment">// 结果为：10</span></span><br></pre></td></tr></table></figure><p>在ES2015中，还提供了一种模板字面量，模板字符串提供了一些语法糖来帮你构造字符串。这与Perl、Python还有其他语言中的字符串插值的特性非常相似。除此之外，你可以在通过模板字符串前添加一个tag来自定义模板字符串的解析过程，这可以用来防止注入攻击，或者用来建立基于字符串的高级数据抽象。</p><p>除非有特别需要使用字符串对象，否则，最好始终使用字符串字面值。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（七）：正则的扩展</title>
      <link href="6a62e21367ac/"/>
      <url>6a62e21367ac/</url>
      
        <content type="html"><![CDATA[<h2 id="RegExp-构造函数"><a href="#RegExp-构造函数" class="headerlink" title="RegExp 构造函数"></a>RegExp 构造函数</h2><ol><li><p>在ES5中，RegExp构造函数的参数有两种情况：</p><ul><li><p>第一种情况：参数是字符串，这时第二个参数表示正则表达式的修饰符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;xyz&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure></li><li><p>第二种情况：参数是正则表示式，这时会返回一个原有正则表达式的拷贝。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> Regexp(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regexp = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure><ul><li><p>但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure></li><li><p>ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/ig</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(regexp); <span class="comment">// /xyz/i</span></span><br><span class="line"><span class="built_in">console</span>.log(regexp.flags); <span class="comment">// i</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>source</code> 属性：返回正则表达式的正文。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/ig</span>);</span><br><span class="line"><span class="built_in">console</span>.log(regexp.source); <span class="comment">// xyz</span></span><br></pre></td></tr></table></figure></li><li><p><code>flags</code> 属性：ES6为正则表达式新增了<code>flags</code>属性，会返回正则表达式的修饰符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regexp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/ig</span>);</span><br><span class="line"><span class="built_in">console</span>.log(regexp.flags); <span class="comment">// gi</span></span><br></pre></td></tr></table></figure></li><li><p><code>RegExp.escape()</code>：</p><ul><li><p>字符串必须转义，才能作为正则模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeRegExp</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.replace(<span class="regexp">/[\-\[\]\/\&#123;\&#125;\(\)\*\+\?\.\\\^\$\|]/g</span>, <span class="string">&#x27;\\$&amp;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;/path/to/resource.html?search=query&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(escapeRegExp(str));</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"><span class="comment">// \/path\/to\/resource\.html\?search=query</span></span><br><span class="line"><span class="comment">// /path/to/resource.html?search=query</span></span><br></pre></td></tr></table></figure><ul><li>上面代码中，<code>str</code>是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。</li></ul></li><li><p>有提议将这个需求标准化，作为RegExp对象的静态方法<a href="https://github.com/benjamingr/RexExp.escape">RegExp.escape()</a>，放入ES7。但是 TC39 认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入ES7，但这不失为一个真实的需求。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">&#x27;The Quick Brown Fox&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;The Quick Brown Fox&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">&#x27;Buy it. use it. break it. fix it.&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;Buy it\. use it\. break it\. fix it\.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.escape(<span class="string">&#x27;(*.*)&#x27;</span>);</span><br><span class="line"><span class="comment">// &quot;\(\*\.\*\)&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>字符串转义以后，可以使用RegExp构造函数生成正则模式。</p></li></ul></li></ol><hr><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法, 以及 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法。</p><h2 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h2><p>你可以使用以下两种方法构建一个正则表达式：</p><ul><li><p>方法一：使用一个正则表达式字面量，其由包含在斜杠之间的模式组成，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="regexp">/ab+c/</span>;</span><br></pre></td></tr></table></figure><ul><li>脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能，也就是说，正则表达式字面量适用于该正则表达式不变的情况。</li></ul></li><li><p>方法二：调用<code>RegExp</code>对象的构造函数，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;ab+c&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将会改变，或者它将会从用户输入等来源中动态地产生，就需要使用构造函数来创建正则表达式，也就是说，RegExp 构造函数更适用于该正则表达式会变的情况。</li></ul></li></ul><hr><h2 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h2><ol><li><p>一个正则表达式模式是由简单的字符所构成的，比如 <code>/abc/</code>；或者是简单和特殊字符的组合，比如 <code>/ab*c/</code> 或 <code>/Chapter (\d+)\.\d*/</code>。</p></li><li><p>最后的例子中用到了括号，它在正则表达式中常用作记忆设备。即这部分所匹配的字符将会被记住以备后续使用，例如<a href="https://developer.mozilla.org/zh-cn/docs/Web/JavaScript/Guide/Regular_Expressions#%E4%BD%BF%E7%94%A8%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">使用括号的子字符串匹配</a>。</p></li></ol><h3 id="使用简单模式"><a href="#使用简单模式" class="headerlink" title="使用简单模式"></a>使用简单模式</h3><ol><li><p>简单模式是由你想直接找到的字符构成。</p></li><li><p>比如，<code>/abc/</code> 这个模式就能且仅能匹配 “abc” 字符按照顺序同时出现的情况，例如 “xxxabcxx”。</p></li></ol><h3 id="使用特殊字符"><a href="#使用特殊字符" class="headerlink" title="使用特殊字符"></a>使用特殊字符</h3><ol><li><p>当你需要匹配一个不确定的字符串时，可以在模式中使用特殊字符。</p></li><li><p>比如，你可以使用 <code>/ab*c/</code> 去匹配一个单独的 “a” 后面跟了零个或者多个 “b”，同时后面跟着 “c” 的字符串。<code>*</code> 的意思是前一项出现零次或者多次。在字符串 “cbbabbbbcdebc” 中，<code>/ab*c/</code> 模式匹配到的子字符串是 “abbbbc”。</p></li><li><p>正则表达式中的特殊字符及其描述如下：</p><ul><li><p><code>\</code>：</p><ul><li>在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解；但如果前面加了 <code>\</code>，它将不再匹配任何字符，而是表示一个字符边界。<ul><li>所以，如果你想将字符串传递给 RegExp 构造函数，不要忘记在字符串字面量中反斜杠是转义字符。如果你只想表达一个 <code>\</code>，那就请写成 <code>\\</code>，所以，<code>/[a-z]\s/i</code> 等价于 <code>new RegExp(&#39;[a-z]\\s&#39;, &#39;i&#39;)</code>，即匹配到的是：在 a-z 范围内的任意字符并且后面紧跟着空白字符的表达式，这个常用作搜索字符。</li><li>若你真的想在 RegExp 构造函数中包含反斜杠的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如：<code>/[a-z]:\\/i</code> 等价于 <code>new RegExp(&#39;[a-z]:\\\\&#39;, &#39;i&#39;)</code>，即匹配类似 <code>c:\</code> 的字符串。</li></ul></li><li>在特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解，意思就是字面意思。</li></ul></li><li><p><code>^</code>：</p><ul><li> 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</li><li>例如，<code>/^A/</code> 并不会匹配 “an A” 中的 ‘A’，但是会匹配 “An E” 中的 ‘A’。</li><li>当 ‘<code>^</code>‘ 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义。</li></ul></li><li><p><code>$</code>：</p><ul><li>匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。</li><li>例如，<code>/t$/</code> 并不会匹配 “eater” 中的 ‘t’，但是会匹配 “eat” 中的 ‘t’。</li></ul></li><li><p><code>*</code>：</p><ul><li>匹配前一个表达式 0 次或多次。等价于 <code>&#123;0,&#125;</code>。</li><li>例如，<code>/bo*/</code> 会匹配 “A ghost boooooed” 中的 ‘booooo’ 和 “A bird warbled” 中的 ‘b’，但是在 “A goat grunted” 中不会匹配任何内容。</li></ul></li><li><p><code>+</code>：</p><ul><li> 匹配前面一个表达式 1 次或者多次。等价于 <code>&#123;1,&#125;</code>。</li><li>例如，<code>/a+/</code> 会匹配 “candy” 中的 ‘a’ 和 “caaaaaaandy” 中所有的 ‘a’，但是在 “cndy” 中不会匹配任何内容。</li></ul></li><li><p><code>?</code>：</p><ul><li>匹配前面一个表达式 0 次或者 1 次。等价于 <code>&#123;0,1&#125;</code>。</li><li>例如，<code>/e?le?/</code> 匹配 “angel” 中的 ‘el’、”angle” 中的 ‘le’ 以及 “oslo’ 中的 ‘l’。</li><li>如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 “123abc” 使用 <code>/\d+/</code> 将会匹配 “123”，而使用 <code>/\d+?/</code> 则只会匹配到 “1”。</li><li>还用于先行断言中，如本表的 <code>x(?=y)</code> 和 <code>x(?!y)</code> 条目所述。</li></ul></li><li><p><code>.</code>：</p><ul><li>（小数点）默认匹配除换行符之外的任何单个字符。</li><li>例如，<code>/.n/</code> 将会匹配 “nay, an apple is on the tree” 中的 ‘an’ 和 ‘on’，但是不会匹配 ‘nay’。</li><li>如果 <code>s</code> (“dotAll”) 标志位被设为 true，它也会匹配换行符。</li></ul></li><li><p><code>(x)</code>：</p><ul><li>像下面的例子展示的那样，它会匹配 ‘x’ 并且记住匹配项。其中括号被称为捕获括号。</li><li>模式 <code>/(foo) (bar) \1 \2/</code> 中的 ‘<code>(foo)</code>‘ 和 ‘<code>(bar)</code>‘ 匹配并记住字符串 “foo bar foo bar” 中前两个单词。模式中的 <code>\1</code> 和 <code>\2</code> 表示第一个和第二个被捕获括号匹配的子字符串，即 <code>foo</code> 和 <code>bar</code>，匹配了原字符串中的后两个单词。注意 <code>\1</code>、<code>\2</code>、…、<code>\n</code> 是用在正则表达式的匹配环节，详情可以参阅后文的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions$edit#special-backreference">\n</a> 条目。而在正则表达式的替换环节，则要使用像 <code>$1</code>、<code>$2</code>、…、<code>$n</code> 这样的语法，例如，<code>&#39;bar foo&#39;.replace(/(...) (...)/, &#39;$2 $1&#39;)</code>。<code>$&amp;</code> 表示整个用于匹配的原字符串。</li></ul></li><li><p><code>(?:x)</code>：</p><ul><li> 匹配 ‘x’ 但是不记住匹配项。这种括号叫作<em>非捕获括号</em>，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo)&#123;1,2&#125;/</code>。如果表达式是 <code>/foo&#123;1,2&#125;/</code>，<code>&#123;1,2&#125;</code> 将只应用于 ‘foo’ 的最后一个字符 ‘o’。如果使用非捕获括号，则 <code>&#123;1,2&#125;</code> 会应用于整个 ‘foo’ 单词。</li></ul></li><li><p><code>x(?=y)</code>：</p><ul><li>匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。</li><li>例如，/Jack(?=Sprat)/会匹配到’Jack’仅当它后面跟着’Sprat’。/Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着’Sprat’或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。</li></ul></li><li><p><code>(?&lt;=y)x</code>：</p><ul><li>匹配’x’仅当’x’前面是’y’.这种叫做后行断言。</li><li>例如，/(?&lt;=Jack)Sprat/会匹配到’ Sprat ‘仅仅当它前面是’ Jack ‘。/(?&lt;=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是’Jack’或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。</li></ul></li><li><p><code>x(?|y)</code>：</p><ul><li>仅仅当’x’后面不跟着’y’时匹配’x’，这被称为正向否定查找。</li><li>例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!.)/ 匹配一个数字。正则表达式/\d+(?!.)/.exec(“3.141”)匹配‘141’而不是‘3.141’。</li></ul></li><li><p><code>(?&lt;!y)x</code>：</p><ul><li>仅仅当’x’前面不是’y’时匹配’x’，这被称为反向否定查找。</li><li>例如, 仅仅当这个数字前面没有负号的时候，<code>/(?&lt;!-)\d+/</code> 匹配一个数字。<ul><li><code>/(?&lt;!-)\d+/.exec(&#39;3&#39;)</code> 匹配到 “3”</li><li><code>/(?&lt;!-)\d+/.exec(&#39;-3&#39;)</code> 因为这个数字前有负号，所以没有匹配到</li></ul></li></ul></li><li><p><code>x|y</code>：</p><ul><li>匹配‘x’或者‘y’。</li><li>例如，<code>/green|red/</code> 匹配 “green apple ”中的 ‘green’ 和 “red apple” 中的 ‘red’。</li></ul></li><li><p><code>&#123;n&#125;</code>：</p><ul><li>n 是一个正整数，匹配了前面一个字符刚好出现了 n 次。</li><li>比如，<code>/a&#123;2&#125;/</code> 不会匹配 “candy” 中的 ‘a’，但是会匹配 “caandy” 中所有的 a，以及 “caaandy” 中的前两个’a’。</li></ul></li><li><p><code>&#123;n,&#125;</code>：</p><ul><li> n是一个正整数，匹配前一个字符至少出现了n次。</li><li>例如，<code>/a&#123;2,&#125;/</code> 匹配 “aa”, “aaaa” 和 “aaaaa” 但是不匹配 “a”。</li></ul></li><li><p><code>&#123;n,m&#125;</code>：</p><ul><li>n 和 m 都是整数。匹配前面的字符至少n次，最多m次。如果 n 或者 m 的值是0， 这个值被忽略。</li><li>例如，<code>/a&#123;1, 3&#125;/</code> 并不匹配“cndy”中的任意字符，匹配“candy”中的a，匹配“caandy”中的前两个a，也匹配“caaaaaaandy”中的前三个a。注意，当匹配”caaaaaaandy“时，匹配的值是“aaa”，即使原始的字符串中有更多的a。</li></ul></li><li><p><code>[xyz]</code>：</p><ul><li>一个字符集合。匹配方括号中的任意字符，包括<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types">转义序列</a>。你可以使用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊的意义。他们不必进行转义，不过转义也是起作用的。</li><li>例如，[abcd] 和[a-d]是一样的。他们都匹配”brisket”中的‘b’,也都匹配“city”中的‘c’。/[a-z.]+/ 和/[\w.]+/与字符串“test.i.ng”匹配。</li></ul></li><li><p><code>[*xyz]</code>：</p><ul><li>一个反向字符集。也就是说， 它匹配任何没有包含在方括号中的字符。你可以使用破折号（-）来指定一个字符范围。任何普通字符在这里都是起作用的。</li><li>例如，<code>[^abc]</code> 和 <code>[^a-c]</code> 是一样的，他们匹配”brisket”中的‘r’，也匹配“chop”中的‘h’。</li></ul></li><li><p><code>[\b]</code>：</p><ul><li>匹配一个退格(U+0008)。</li><li>注意，记得不要和 <code>\b</code> 混淆了。</li></ul></li><li><p><code>\b</code>：</p><ul><li><p>匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者前面跟其他“字”字符的位置，例如在字母和空格之间。注意，匹配中不包括匹配的字边界。换句话说，一个匹配的词的边界的内容的长度是0。（不要和 <code>[\b]</code> 混淆了）</p></li><li><p>使用”moon”举例：</p><ul><li>/\bm/匹配“moon”中的‘m’；</li><li>/oo\b/并不匹配”moon”中的’oo’，因为’oo’被一个“字”字符’n’紧跟着。</li><li>/oon\b/匹配”moon”中的’oon’，因为’oon’是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。</li><li>/\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。</li></ul></li><li><p>注意：</p><blockquote><p>JavaScript的正则表达式引擎将特定的字符集定义为“字”字符。</p><p>不在该集合中的任何字符都被认为是一个断词。</p><p>这组字符相当有限：它只包括大写和小写的罗马字母，十进制数字和下划线字符。不幸的是，重要的字符，例如“é”或“ü”，被视为断词。</p></blockquote></li></ul></li><li><p><code>\B</code>：</p><ul><li>匹配一个非单词边界。匹配如下几种情况：<ul><li>字符串第一个字符为非“字”字符</li><li>字符串最后一个字符为非“字”字符</li><li>两个单词字符之间</li><li>两个非单词字符之间</li><li>空字符串</li></ul></li><li>例如，<code>/\B../</code> 匹配”noonday”中的’oo’, 而 <code>/y\B../</code> 匹配”possibly yesterday”中的’yes‘</li></ul></li><li><p><code>\cX</code>：</p><ul><li>当X是处于A到Z之间的字符的时候，匹配字符串中的一个控制符。</li><li>例如，<code>/\cM/</code> 匹配字符串中的 control-M (U+000D)。</li></ul></li><li><p><code>\d</code>：</p><ul><li>匹配一个数字，等价于 <code>[0-9]</code>。</li><li>例如， <code>/\d/</code> 或者 <code>/[0-9]/</code> 匹配”B2 is the suite number.”中的’2’。</li></ul></li><li><p><code>\D</code>：</p><ul><li>匹配一个非数字字符，等价于<code>[^0-9]</code>。</li><li>例如， <code>/\D/</code> 或者 <code>/[^0-9]/</code> 匹配”B2 is the suite number.”中的’B’ 。</li></ul></li><li><p><code>\f</code>：</p><ul><li>匹配一个换页符 (U+000C)。</li></ul></li><li><p><code>\n</code>：</p><ul><li>匹配一个换行符 (U+000A)。</li></ul></li><li><p><code>\r</code>：</p><ul><li> 匹配一个回车符 (U+000D)。</li></ul></li><li><p><code>\s</code>：</p><ul><li><p>匹配一个空白字符，包括空格、制表符、换页符和换行符。</p></li><li><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</span><br></pre></td></tr></table></figure></li><li><p>例如, <code>/\s\w*/</code> 匹配”foo bar.”中的’ bar’。</p></li></ul></li><li><p><code>\S</code>：</p><ul><li><p>匹配一个非空白字符。</p></li><li><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^ \f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</span><br></pre></td></tr></table></figure></li><li><p>例如，<code>/\S\w*/</code> 匹配”foo bar.”中的’foo’。</p></li></ul></li><li><p><code>\t</code>：</p><ul><li>匹配一个水平制表符 (U+0009)。</li></ul></li><li><p><code>\v</code>：</p><ul><li>匹配一个垂直制表符 (U+000B)。</li></ul></li><li><p><code>\w</code>：</p><ul><li><p>匹配一个单字字符（字母、数字或者下划线）。</p></li><li><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A-Za-z0-9_]</span><br></pre></td></tr></table></figure></li><li><p>例如, <code>/\w/</code> 匹配 “apple,” 中的 ‘a’，”$5.28,”中的 ‘5’ 和 “3D.” 中的 ‘3’。</p></li></ul></li><li><p><code>\W</code>：</p><ul><li><p>匹配一个非单字字符。</p></li><li><p>等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^A-Za-z0-9_]</span><br></pre></td></tr></table></figure></li><li><p>例如, <code>/\W/</code> 或者 <code>/[^A-Za-z0-9_]/</code> 匹配 “50%.” 中的 ‘%’。</p></li></ul></li><li><p><code>\n</code>：</p><ul><li>在正则表达式中，它返回最后的第n个子捕获匹配的子字符串(捕获的数目以左括号计数)。</li><li>比如 <code>/apple(,)\sorange\1/</code> 匹配”apple, orange, cherry, peach.”中的’apple, orange,’ 。</li></ul></li><li><p><code>\0</code>：</p><ul><li>匹配 NULL（U+0000）字符， 不要在这后面跟其它小数，因为 <code>\0&lt;digits&gt;</code> 是一个八进制转义序列。</li></ul></li><li><p><code>\xhh</code>：</p><ul><li> 匹配一个两位十六进制数（\x00-\xFF）表示的字符。</li></ul></li><li><p><code>\uhhh</code>：</p><ul><li>匹配一个四位十六进制数表示的 UTF-16 代码单元。</li></ul></li><li><p><code>u&#123;hhhh&#125;</code> 或者 <code>\u&#123;hhhhh&#125;</code>：</p><ul><li>（仅当设置了u标志时）匹配一个十六进制数表示的 Unicode 字符。</li></ul></li></ul></li></ol><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><ol><li><p>如果你需要使用任何特殊字符的字面值（例如，搜索字符’*’）</p><ul><li>你必须通过在它前面放一个反斜杠来转义它。 例如，要搜索’a’后跟 <code>*</code> 后跟’b’，你应该使用 <code>/a\*b/-</code> 反斜杠“转义”字符’*’，使其成为文字而非特殊符号。</li></ul></li><li><p>类似地，如果您正在编写正则表达式文字并且需要匹配斜杠（’/‘），那么需要转义它（否则，斜杠是正则终止符）。 例如，要搜索字符串“/ example /”后跟一个或多个字母字符，您需要使用<code>/\/example\/[a-z]+/i</code>——每个斜杠之前使用反斜杠使它们成为普通字符。</p></li><li><p>要匹配文本符号反斜杠，您需要转义反斜杠。 例如，要匹配字符串“C:\”，其中“C”可以是任何字母，您将使用<code>/[A-Z]:\\/</code> —— 第一个反斜杠转义后面的那个反斜杠，因此表达式搜索单个普通字符反斜杠。</p></li><li><p>如果将RegExp构造函数与字符串文字一起使用，请记住反斜杠是字符串文字中的转义，因此要在正则表达式中使用它，您需要在字符串文字级别转义它。 <code>/a\*b/</code> 和<code>new RegExp(&quot;a\\*b&quot;)</code>创建的表达式是相同的，搜索“a”后跟文字“*”后跟“b”。</p></li><li><p>将用户输入转义为正则表达式中的一个字面字符串，可以通过简单的替换来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escapeRegExp</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> string.replace(<span class="regexp">/[.*+?^$&#123;&#125;()|[\]\\]/g</span>, <span class="string">&quot;\\$&amp;&quot;</span>);</span><br><span class="line">  <span class="comment">// $&amp; 表示整个被匹配的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则表达式后的”g”是一个表示全局搜索选项或标记，将在整个字符串查找并返回所有匹配结果。</li></ul></li></ol><h2 id="使用插入语"><a href="#使用插入语" class="headerlink" title="使用插入语"></a>使用插入语</h2><ol><li>任何正则表达式的插入语都会使这部分匹配的副字符串被记忆。一旦被记忆，这个副字符串就可以被调用于其它用途。</li><li>比如， <code>/Chapter (\d+)\.\d*/</code> 解释了额外转义的和特殊的字符，并说明了这部分pattern应该被记忆。它精确地匹配后面跟着一个以上数字字符的字符 ‘Chapter ‘ (<code>\d</code> 意为任何数字字符，<code>+ 意为1次以上</code>)，跟着一个小数点（在这个字符中本身也是一个特殊字符；小数点前的 \ 意味着这个pattern必须寻找字面字符 ‘.’)，跟着任何数字字符0次以上。 (<code>\d</code> 意为数字字符， <code>*</code> 意为0次以上)。另外，插入语也用来记忆第一个匹配的数字字符。</li><li>此模式可以匹配字符串”Open Chapter 4.3, paragraph 6”，并且’4’将会被记住。此模式并不能匹配”Chapter 3 and 4”，因为在这个字符串中’3’的后面没有点号’.’。</li><li>括号中的”?:”，这种模式匹配的子字符串将不会被记住。比如，(?:\d+)匹配一次或多次数字字符，但是不能记住匹配的字符。</li></ol><h2 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h2><blockquote><p>正则表达式可以被用于 <code>RegExp</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a> 方法以及 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a>、<a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a> 和 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a> 方法，如下：</p></blockquote><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>exec</code></a></td><td align="center">一个在字符串中执行查找匹配的RegExp方法，<br />它返回一个数组（未匹配到则返回 null）。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>test</code></a></td><td align="center">一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/match"><code>match</code></a></td><td align="center">一个在字符串中执行查找匹配的String方法，<br />它返回一个数组，在未匹配到时会返回 null。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/matchAll"><code>matchAll</code></a></td><td align="center">一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/search"><code>search</code></a></td><td align="center">一个在字符串中测试匹配的String方法，<br />它返回匹配到的位置索引，或者在失败时返回-1。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace</code></a></td><td align="center">一个在字符串中执行查找匹配的String方法，<br />并且使用替换字符串替换掉匹配到的子字符串。</td></tr><tr><td align="center"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/split"><code>split</code></a></td><td align="center">一个使用正则表达式或者一个固定字符串分隔一个字符串，<br />并将分隔后的子字符串存储到数组中的 <code>String</code> 方法。</td></tr></tbody></table><p>在接下来的例子中，脚本将使用exec方法在一个字符串中查找一个匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myRe = <span class="regexp">/d(b+)d/g</span>;</span><br><span class="line"><span class="keyword">var</span> myArray = myRe.exec(<span class="string">&quot;cdbbdbsbz&quot;</span>);</span><br></pre></td></tr></table></figure><p>总结如下：</p><ul><li>当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；</li><li>想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。</li><li>如果你使用exec 或 match 方法并且匹配成功了，那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象。</li><li>如果匹配失败，那么 exec 方法返回 null（也就是false）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（六）：语句与声明</title>
      <link href="2ca46689117e/"/>
      <url>2ca46689117e/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript 应用程序是由许多语法正确的语句组成的。单个语句可以跨多行。</p><p>如果每个语句用分号隔开，那么多个语句可以在一行中出现。</p><p>以下内容按类别分类叙述</p></blockquote><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><ol><li><p>描述：一个块语句可以用来管理零个或多个语句，该区块是由一对大括号分隔，也可以是 label 语句。</p></li><li><p>语法：</p><ul><li><p>块声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; StatementList &#125;</span><br></pre></td></tr></table></figure><ul><li>StatementList：在块语句中分组的语句。</li></ul></li><li><p>标记声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LabelIdentifier: &#123; StatementList &#125;</span><br></pre></td></tr></table></figure><ul><li>LabelIdentifier：用于视觉识别的可选 label 或 break 的目标。</li></ul></li></ul></li><li><p>块级作用域：</p><ul><li><p>通过 <code>var</code> 声明的变量或者非严格模式下创建的函数声明没有块级作用域。此时，在语句块里声明的变量的作用域不仅是其所在的函数或者 script 标签内，所设置变量的影响会在超出语句块本身之外持续存在。</p></li><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用 let 与 const：</p><ul><li><p>与 <code>var</code> 相比，使用 <code>let</code> 和 <code>const</code> 声明的变量是有块级作用域的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><ul><li>注意这里的两次 const 声明并没有报错，并没有报出 <code>SyntaxError: Identifier &#39;x&#39; has already been declared</code> 的语法错误提示信息，因为 const 是有块级作用域的，而在它自己的块内，它是唯一被声明的常量。</li></ul></li><li><p>使用 let 声明的变量在块级作用域内能强制执行更新变量，下面的两个例子对比：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> a = [];</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> a[<span class="number">0</span>](); <span class="comment">// 10</span></span><br><span class="line"> a[<span class="number">1</span>](); <span class="comment">// 10</span></span><br><span class="line"> a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>](); <span class="comment">// 0</span></span><br><span class="line">a[<span class="number">1</span>](); <span class="comment">// 1</span></span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>使用 function：函数声明同样也被限制在其他的语句块内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun(<span class="string">&#x27;ozzie&#x27;</span>); <span class="comment">// TypeError: fun is not a function</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line">  fun(<span class="string">&#x27;nicholas&#x27;</span>); <span class="comment">// 打印 nicholas</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><ol><li><p>描述：终止当前的循环，例如 switch 或 label 语句，使程序跳到下一个语句执行。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> [label];</span><br></pre></td></tr></table></figure><ul><li>label：可选，这是与语句标签相关联的标识符。如果 break 语句不在一个循环或 switch 语句中，则该项是必须的。</li><li>break语句包含一个可选的标签，可允许程序摆脱一个被标记的语句。break语句需要内嵌在引用的标签中。被标记的语句可以是任何块语句，不一定是循环语句。</li><li>break语句不能在function函数体中直接使用，break语句应嵌套在要中断的当前循环、switch或label语句中。</li></ul></li><li><p>案例：</p><ul><li><p>在 while 语句中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">10</span>)); <span class="comment">// 30</span></span><br></pre></td></tr></table></figure></li><li><p>在 switch 语句中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fruit = <span class="string">&#x27;apple&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>(fruit) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;apple&#x27;</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;apple&#x27;</span>); <span class="comment">// apple</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;orange&#x27;</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;orange&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;no answer&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 label 语句中：下面的代码中一起使用 break 语句和被标记的块语句。一个 break 语句必须内嵌在它引用的标记中。注意，inner_block 内嵌在 outer_block 中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">outer_block: &#123;</span><br><span class="line">  inner_block: &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// a</span></span><br><span class="line">    <span class="keyword">break</span> inner_block;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>); <span class="comment">// c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 label 语句中使用时发生了异常错误：下面的代码同样使用了 break 语句和被标记的块语句，但是产生了一个语法错误，因为它的 break 语句在 block_1 中，但是引用了 block_2。break 语句必须内嵌在它引用的标签中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">block_1: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">break</span> block_2;</span><br><span class="line">&#125;</span><br><span class="line">block_2: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Undefined label &#x27;block_2&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在函数体中使用时也发生了异常错误：在下面的代码同样会产生SyntaxError，因为它并没被正确的使用在循环、switch或label语句中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">      (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i*x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fun(<span class="number">10</span>));</span><br><span class="line"><span class="comment">// SyntaxError: Illegal break statement</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">block_1: &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">break</span> block_1;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Undefined label &#x27;block_1&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><ol><li><p>描述：</p><ul><li>与 break 语句的区别在于， continue 并不会终止循环的迭代，而是：<ul><li>在 while 循环中，控制流跳转回条件判断；</li><li>在 for 循环中，控制流跳转到更新语句。</li></ul></li><li>continue 语句可以包含一个可选的标号以控制程序跳转到指定循环的下一次迭代，而非当前循环。此时要求 continue 语句在对应的循环内部。</li></ul></li><li><p>案例：</p><ul><li><p>在 while 语句中：下述例子展示了一个在 i 为 3时执行continue 语句的 while 循环。最终 n 为 0+1+2+4+5 = 12。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">5</span>) &#123;</span><br><span class="line">  i ++;</span><br><span class="line">  <span class="keyword">if</span>(i == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  n += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(n); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></li><li><p>在 label 语句中：在下面的例子中，被标记为 check_i_j 的语句包含一个被标记为 check_j 的语句。当遇到 continue 语句时，程序回到 check_j 语句的开始继续执行。每次遇到 continue 时，再次执行 check_j ，直到条件判断返回 false 。之后完成 check_i_j 语句剩下的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>,</span><br><span class="line">    j = <span class="number">8</span>;</span><br><span class="line">check_i_j: <span class="keyword">while</span>(i&lt;<span class="number">4</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;i = &#x27;</span> + i, <span class="string">&#x27;j = &#x27;</span> + j);</span><br><span class="line">  i += <span class="number">1</span>;</span><br><span class="line">  check_j: <span class="keyword">while</span>(j&gt;<span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;i = &#x27;</span> + i, <span class="string">&#x27;j = &#x27;</span> + j);</span><br><span class="line">    j -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((j%<span class="number">2</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span> check_j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(j + <span class="string">&#x27; is odd&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i = 0 j = 8</span></span><br><span class="line"><span class="comment">i = 1 j = 8</span></span><br><span class="line"><span class="comment">7 is odd   </span></span><br><span class="line"><span class="comment">i = 1 j = 7</span></span><br><span class="line"><span class="comment">i = 1 j = 6</span></span><br><span class="line"><span class="comment">5 is odd   </span></span><br><span class="line"><span class="comment">i = 1 j = 5</span></span><br><span class="line"><span class="comment">i = 1 j = 4</span></span><br><span class="line"><span class="comment">i = 2 j = 4</span></span><br><span class="line"><span class="comment">i = 3 j = 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><ol><li><p>描述：空语句用来表明没有语句。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">;</span><br></pre></td></tr></table></figure><ul><li>空语句是一个分号（;），表示不会执行任何语句，即使 JavaScript 语法需要一个语句。 相反，当你需要多行语句，但 JavaScript 只允许一个时，可以使用语句块；语句块可以将多条语句合并为一个。</li></ul></li><li><p>案例：</p><ul><li><p>空语句有时与循环语句一起使用。以下示例使用空循环体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; arr[i++]=<span class="number">0</span>); <span class="comment">// 此处为空语句</span></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [0, 0, 0]</span></span><br></pre></td></tr></table></figure><ul><li>在使用空语句时，尽量专门为其写上注释，因为不是很容易区分空语句和普通的分号。</li></ul></li><li><p><code>if...else</code> 语句不带花括号（<code>&#123;&#125;</code>）。如果<code>three</code>为<code>true</code>, 不会发生任何事，<code>four</code>不会执行，同时<code>else</code>从句中的<code>launchRocket()</code>函数也不会执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(one)</span><br><span class="line">  doOne();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(two)</span><br><span class="line">  doTwo();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(three)</span><br><span class="line">  ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(four)</span><br><span class="line">  doFour();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  launchRocket();</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h4><ol><li><p>描述：当指定条件为真，if 语句会执行一段语句。如果条件为假，则执行另一段语句。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">   statement1</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">   statement2]</span><br></pre></td></tr></table></figure><ul><li>condition：值为真或假的表达式</li><li>statement1：当 condition 为真时执行的语句。<ul><li>可为任意语句，包括更深层的内部 if 语句。</li><li>要执行多条语句，使用块语句（{ … }）将这些语句分组；</li><li>若不想执行语句，则使用空语句。</li></ul></li><li>statement2：如果 condition 为假且 else 从句存在时执行的语句。<ul><li>可为任意语句，包括块语句和嵌套的 if 语句。</li></ul></li></ul></li><li><p>说明：</p><ul><li><p>多层 <code>if...else</code> 语句可使用 <code>else if</code> 从句。注意：在 Javascript 中没有 <code>elseif</code> （一个单词）关键字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">   statement2</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition3)</span><br><span class="line">   statement3</span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   statementN</span><br></pre></td></tr></table></figure><ul><li><p>要看看它如何工作，可以调整下嵌套的缩进：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition1)</span><br><span class="line">   statement1</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">if</span> (condition2)</span><br><span class="line">      statement2</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">if</span> (condition3)</span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>要在一个从句中执行多条语句，尽量使用语句块（<code>&#123; ... &#125;</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">   statements1</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   statements2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不要将原始布尔值的<code>true</code>和<code>false</code>与Boolean对象的真或假混淆。任何一个值，只要它不是 <code>undefined</code>、<code>null</code>、 <code>0</code>、<code>NaN</code>或空字符串（<code>&quot;&quot;</code>），那么无论是任何对象，即使是值为假的Boolean对象，在条件语句中都为真。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span>(x) <span class="comment">// 表达式的值为true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>案例：</p><ul><li><p>使用 if…else：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;yes&#x27;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;no&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 else…if：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="number">1</span> &gt; <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 &gt; 2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 == 2&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 &lt; 2&#x27;</span>);</span><br><span class="line">&#125; <span class="comment">// 1 &lt; 2</span></span><br></pre></td></tr></table></figure><ul><li>注意，Javascript中没有<code>elseif</code>语句。但可以使用<code>else</code>和<code>if</code>中间有空格的语句。</li></ul></li><li><p>关于条件表达式中的赋值运算：建议不要在条件表达式中单纯的使用赋值运算，因为粗看下赋值运算的代码很容易让人误认为是等性比较。比如，不要使用下面示例的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x = y) &#123;</span><br><span class="line">   <span class="comment">/* do the right thing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果需要在条件表达式中使用赋值运算，用圆括号包裹赋值运算。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((x = y)) &#123;</span><br><span class="line">   <span class="comment">/* do the right thing */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><ol><li><p>描述：switch 语句评估一个表达式，将表达式的值与case子句匹配，并执行与该情况相关联的语句。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> value1:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 value1 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  <span class="keyword">case</span> value2:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 value2 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">case</span> valueN:</span><br><span class="line">    <span class="comment">// 当 expression 的结果与 valueN 匹配时，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]</span><br><span class="line">  [<span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果 expression 与上面的 value 值都不匹配，执行此处语句</span></span><br><span class="line">    [<span class="keyword">break</span>;]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>expression</code>：一个用来与 case 子语句匹配的表达式。</li><li><code>case valueN</code>：用于匹配 <code>expression</code> 的 <code>case</code> 子句。如果 <code>expression</code> 与给定的 <code>valueN</code> 相匹配，则执行该 case 子句中的语句，直到该 <code>switch</code> 语句结束或遇到一个 <code>break</code> 。</li><li><code>default</code>：一个 <code>default</code> 子句；如果给定，这条子句会在 <code>expression</code> 的值与任一 <code>case</code> 语句均不匹配时执行。</li></ul></li><li><p>说明：</p><ul><li>一个 switch 语句首先会计算其 expression 。然后，它将从第一个 case 子句开始直到寻找到一个其表达式值与所输入的 expression 的值所相等的子句（使用 <code>严格运算符 ===</code>）并将控制权转给该子句，执行相关语句。（如果多个 case 与提供的值匹配，则选择匹配的第一个 case，即使这些 case 彼此间并不相等。）</li><li>如果没有 <code>case</code> 子句相匹配，程序则会寻找那个可选的 <code>default</code> 子句，如果找到了，将控制权交给它，执行相关语句。若没有 <code>default</code> 子句，程序将继续执行直到 <code>switch</code> 结束。按照惯例，<code>default</code> 子句是最后一个子句，不过也不需要这样做。</li><li>可选的 break 语句确保程序立即从相关的 case 子句中跳出 switch 并接着执行 switch 之后的语句。若 break 被省略，程序会继续执行 switch 语句中的下一条语句。</li></ul></li><li><p>案例：</p><ul><li><p>使用 switch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>匹配到 1 之后，因为没有 break，就继续执行之后的语句，直到遇到第一个 break，如果之后一个 break 都没有，那么就全部都执行。</li><li>注意，匹配 case 中的语句，使用的是严格运算符 <code>===</code>，所以 <code>case true</code> 之后的语句并不会执行，因为 <code>1</code> 并不全等于 <code>true</code>。</li></ul></li><li><p>如果忘记 break 会怎么样？如果忘记添加 break，那么代码将会从值所匹配的 case 语句开始运行，然后持续执行下一个 case 语句而不论值是否匹配。例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// x 的值为 1 所以匹配这里所以这一块会运行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 注意：那个没写的 break 原本在这儿</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// &#x27;case 1:&#x27; 里没有 break 语句所以这个 case 也会运行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 遇到了 break，所以不会再继续进入 &#x27;case 3:&#x27; 了</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>能把 default 放到 case 之间吗？可以啊，比如，我们根据 case 能否匹配成功分开讨论一下：</p><ul><li><p>如果能在 case 中匹配成功，那就看 default 的位置 以及有没有 break 语句的情况，假设全部不设 break 语句，那么，如果 default 在匹配成功之前，就不执行，如果在匹配成功之后，就执行，对比以下几种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般习惯，我们会这样写，即 default 在最后面</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 无</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 无</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 后面能匹配成功，default 语句不在匹配成功的语句之后，就不执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 这里虽然有 break，但是这个 break 压根没有用</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>当然，如果有 break 出现，那就先看 break 的情况了。</li></ul></li><li><p>如果在 case 中匹配不成功，那么也会跳转到 default，对比以下几种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般习惯，我们会这样写，即 default 在最后面</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 匹配不成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 匹配不成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 之前匹配都不成功，这里就默认执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(x) &#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// 下面匹配都不成功，这里就默认执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;无&#x27;</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，所以会继续执行下面的语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，继续执行之后的语句</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: <span class="comment">// 执行</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 这里没有 break，但 switch 语句已经执行完了，所以跳出 switch</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 无</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li><p>使用多准则 case 的方法：（此技术来自于：<a href="http://stackoverflow.com/questions/13207927/switch-statement-multiple-cases-in-javascript">Stack Overflow | Switch statement multiple cases in JavaScript </a>）</p><ul><li><p>多 case —— 单一操作（这种方法是基于：如果 case 语句之下没有 break ，它将继续执行下一个 case 语句，而不管 case 是否符合条件）：下面是一个单操作顺序的 switch 语句，其中四个不同的值的执行结果完全一样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 匹配成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;匹配成功&#x27;</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;匹配失败&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匹配成功</span></span><br></pre></td></tr></table></figure></li><li><p>多 case —— 关联操作：下面是一个关联操作顺序的 switch 语句，其中，根据所输入的整数，你会得到不同的输出。这表示它将以你放置 case 语句的顺序遍历，并且不必是数字顺序的。在 JavaScript 中，你甚至可以将字符串定义到这些 case 语句里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> output = <span class="string">&#x27;Output: &#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    output += <span class="string">&#x27;So &#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 匹配成功</span></span><br><span class="line">    output += <span class="string">&#x27;What &#x27;</span>;</span><br><span class="line">    output += <span class="string">&#x27;Is &#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    output += <span class="string">&#x27;Your &#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    output += <span class="string">&#x27;Name &#x27;</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    output += <span class="string">&#x27;?&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(output);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    output += <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(output);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Over&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output: What Is Your Name ?</span></span><br></pre></td></tr></table></figure><ul><li><p>这个例子的输出是：</p><table><thead><tr><th align="center">num</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">foo is NaN or not 1, 2, 3, 4, 5 or 0</td><td align="center">Over</td></tr><tr><td align="center">0</td><td align="center">Output: So What Is Your Name ?</td></tr><tr><td align="center">1</td><td align="center">Output: What Is Your Name ?</td></tr><tr><td align="center">2</td><td align="center">Output: Your Name ?</td></tr><tr><td align="center">3</td><td align="center">Output: Name ?</td></tr><tr><td align="center">4</td><td align="center">Output:  ?</td></tr><tr><td align="center">5</td><td align="center">Output:  !</td></tr></tbody></table></li></ul></li></ul></li></ul></li></ul></li><li><p>switch 语句内的块级作用域：随着绝大多数现代浏览器已支持 ECMAScript 2015 (ES6)，在某些场景下您可能需要使用 let 和 const 语句，以在块级作用域内声明变量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;The value is 1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;The value is 1&#x27;</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;No answer&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错：SyntaxError: Identifier &#x27;message&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><ul><li><p>这是因为第一个 <code>let message</code> 与第二个 <code>let message</code> 语句产生了冲突，虽然他们处于各自分隔的 case 语句中，即 <code>case 0:</code> 和 <code>case 1:</code>。导致这一问题的根本原因在于两个 <code>let</code> 语句处于同一个块级作用域，所以它们被认为是同一个变量名的重复声明。</p></li><li><p>因为 let、const 都是有块作用域的，所以我们可以把 case 语句包装到括号里面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">switch</span>(num) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;The value is 1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">    <span class="keyword">let</span> message = <span class="string">&#x27;The value is 1&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">default</span>: &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;No answer&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// The value is 1</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h4 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h4><ol><li><p>描述：throw 语句用来抛出一个用户自定义的异常。当前函数的执行将被停止（throw之后的语句将不会执行），并且控制将被传递到调用堆栈中的第一个catch块。如果调用者函数中没有catch块，程序将会终止。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> expression;</span><br></pre></td></tr></table></figure><ul><li><p>使用 throw 语句来抛出一个异常。当你抛出异常时，<code>expression</code> 指定了异常的内容。下面的每行都抛出了一个异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">&quot;Error2&quot;</span>; <span class="comment">// 抛出了一个值为字符串的异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;       <span class="comment">// 抛出了一个值为整数42的异常</span></span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;     <span class="comment">// 抛出了一个值为true的异常</span></span><br></pre></td></tr></table></figure><ul><li><p>注意throw语句同样受到自动分号插入（ASI）机制的控制，在throw关键字和值之间不允许有行终止符。也就是说，不可以写成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span></span><br><span class="line"><span class="string">&quot;Error&quot;</span>;</span><br><span class="line"><span class="comment">// SyntaxError: Illegal newline after throw</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>案例：</p><blockquote><p>你可以在抛出异常时指定一个对象，然后可以在 <code>catch</code> 块中引用对象的属性。</p></blockquote><ul><li><p>下面创建了一个类型为<code>UserException</code>的对象，并在<code>throw</code>语句中使用它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserException</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.message = message;</span><br><span class="line"> <span class="built_in">this</span>.name = <span class="string">&#x27;UserException&#x27;</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getMonthName</span>(<span class="params">month</span>) </span>&#123;</span><br><span class="line">   month -= <span class="number">1</span>; <span class="comment">// 调整月份数字到数组索引 (1=Jan, 12=Dec)</span></span><br><span class="line">   <span class="keyword">let</span> months = [<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>];</span><br><span class="line">   <span class="keyword">if</span>(months[month] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> months[month];</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> UserException(<span class="string">&#x27;InvalidMonth&#x27;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">let</span> myMonth = <span class="number">15</span>; <span class="comment">// 15 超出边界并引发异常</span></span><br><span class="line">   <span class="keyword">let</span> monthName = getMonthName(month);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">   <span class="keyword">let</span> monthName = <span class="string">&#x27;unknown&#x27;</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(e.message, e.name);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>下面的示例中测试一个字符串是否是美国邮政编码。如果邮政编码是无效的，那么<code>throw</code>语句将会抛出一个类型为 <code>ZipCodeFormatException</code>的异常对象实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建 ZipCode 示例.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 可被接受的邮政编码格式:</span></span><br><span class="line"><span class="comment"> *    12345</span></span><br><span class="line"><span class="comment"> *    12345-6789</span></span><br><span class="line"><span class="comment"> *    123456789</span></span><br><span class="line"><span class="comment"> *    12345 6789</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果构造函数参数传入的格式不符合以上任何一个格式，将会抛出异常。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ZipCode</span>(<span class="params">zip</span>) </span>&#123;</span><br><span class="line">  zip = <span class="keyword">new</span> <span class="built_in">String</span>(zip);</span><br><span class="line">  pattern = <span class="regexp">/[0-9]&#123;5&#125;([- ]?[0-9]&#123;4&#125;)?/</span>;</span><br><span class="line">  <span class="keyword">if</span>(pattern.test(zip)) &#123;</span><br><span class="line">    <span class="comment">// zip 将会匹配 pattern 规则</span></span><br><span class="line">    <span class="built_in">this</span>.value = zip.match(pattern)[<span class="number">0</span>]; <span class="comment">// 返回匹配的结果</span></span><br><span class="line">    <span class="built_in">this</span>.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">String</span>(<span class="built_in">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 匹配不成功时，则抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZipCodeFormatException(zip);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ZipCodeFormatException</span>(<span class="params">zip</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.zip = zip;</span><br><span class="line">  <span class="built_in">this</span>.message = <span class="string">&#x27;不是正确的邮政编码&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.zip + <span class="built_in">this</span>.message;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ZIPCODE_INVALID = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> ZIPCODE_UNKNOWN_ERROR = -<span class="number">2</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">verifyZipCode</span>(<span class="params">zip</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    zip = <span class="keyword">new</span> ZipCode(zip);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">if</span>(error <span class="keyword">instanceof</span> ZipCodeFormatException) &#123;</span><br><span class="line">      <span class="keyword">return</span> ZIPCODE_INVALID;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> ZIPCODE_UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(verifyZipCode(<span class="number">9560</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(verifyZipCode(<span class="number">95060</span>)); <span class="comment">// ZipCode &#123; value: &#x27;95060&#x27;, valueOf: [Function], toString: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(verifyZipCode(<span class="string">&#x27;a&#x27;</span>)); <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">console</span>.log(verifyZipCode(<span class="string">&#x27;95060&#x27;</span>)); <span class="comment">// ZipCode &#123; value: &#x27;95060&#x27;, valueOf: [Function], toString: [Function] &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(verifyZipCode(<span class="string">&#x27;95060 1234&#x27;</span>)); <span class="comment">// ZipCode &#123; value: &#x27;95060 1234&#x27;, valueOf: [Function], toString: [Function] &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>下面的例子捕捉了一个异常值为数字的异常，并在其值大于50后重新抛出异常。重新抛出的异常传播到闭包函数或顶层，以便用户看到它：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> num; <span class="comment">// 抛出一个数值异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="keyword">if</span>(error &lt;= <span class="number">50</span>) &#123;</span><br><span class="line">    <span class="comment">// 异常在 1-50 之间时，直接处理</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 异常无法处理，重新抛出</span></span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="try…catch"><a href="#try…catch" class="headerlink" title="try…catch"></a>try…catch</h4><ol><li><p>描述：**<code>try...catch</code>** 语句标记要尝试的语句块，并指定一个出现异常时抛出的响应。</p></li><li><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   try_statements</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">catch</span> (exception_var_1 <span class="keyword">if</span> condition_1) &#123; <span class="comment">// non-standard</span></span><br><span class="line">   catch_statements_1</span><br><span class="line">&#125;]</span><br><span class="line">...</span><br><span class="line">[<span class="keyword">catch</span> (exception_var_2) &#123;</span><br><span class="line">   catch_statements_2</span><br><span class="line">&#125;]</span><br><span class="line">[<span class="keyword">finally</span> &#123;</span><br><span class="line">   finally_statements</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li><code>try_statements</code>：需要被执行的语句。</li><li><code>catch_statements_1, catch_statements_2</code>：如果在 <code>try</code> 块里有异常被抛出时执行的语句。</li><li><code>exception_var_1, exception_var_2</code>：用于保存关联<code>catch</code>子句的异常对象的标识符。</li><li><code>condition_1</code>：一个条件表达式。</li><li><code>finally_statements</code>：在<code>try</code>语句块之后执行的语句块。无论是否有异常抛出或捕获这些语句都将执行。</li></ul></li><li><p>说明：</p><ul><li>try语句包含了由一个或者多个语句组成的try块, 和至少一个catch块或者一个finally块的其中一个，或者两个兼有， 下面是三种形式的try声明：<ul><li><code>try...catch</code></li><li><code>try...finally</code></li><li><code>try...catch...finally</code></li></ul></li><li><code>catch</code>子句包含<code>try</code>块中抛出异常时要执行的语句。也就是，你想让<code>try</code>语句中的内容成功， 如果没成功，你想控制接下来发生的事情，这时你可以在<code>catch</code>语句中实现。 如果在<code>try</code>块中有任何一个语句（或者从<code>try</code>块中调用的函数）抛出异常，控制立即转向<code>catch</code>子句。如果在<code>try</code>块中没有异常抛出，会跳过<code>catch</code>子句。</li><li><code>finally</code>子句在<code>try</code>块和<code>catch</code>块之后执行但是在下一个<code>try</code>声明之前执行。无论是否有异常抛出或捕获它总是执行。</li><li>你可以嵌套一个或者更多的<code>try</code>语句。如果内部的<code>try</code>语句没有<code>catch</code>子句，那么将会进入包裹它的<code>try</code>语句的<code>catch</code>子句。</li></ul></li><li><p>无条件的 catch 块：当使用单个无条件catch子句时，抛出的任何异常时都会进入到catch块。例如，当在下面的代码中发生异常时，控制转移到catch子句。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="string">&#x27;myException&#x27;</span>; <span class="comment">// 生成一个异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 语句来处理任何异常</span></span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// 将异常对象传递给错误处理程序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// myException</span></span><br></pre></td></tr></table></figure><ul><li><code>catch</code>块指定一个标识符（在上面的示例中为 error），该标识符保存由<code>throw</code>语句指定的值。</li><li><code>catch</code>块是唯一的，因为当输入<code>catch</code>块时，JavaScript 会创建此标识符，并将其添加到当前作用域；标识符仅在<code>catch</code>块执行时存在；<code>catch</code>块执行完成后，标识符不再可用。</li></ul></li><li><p>条件 catch 块：</p><blockquote><p>此特性是非标准的，请尽量不要在生产环境中使用它。</p></blockquote><ul><li><p>你也可以用一个或者更多条件<code>catch</code>子句来处理特定的异常。在这种情况下，当异常抛出时将会进入合适的<code>catch</code>子句中。在下面的代码中，<code>try</code>块的代码可能会抛出三种异常：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RangeError"><code>RangeError</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/EvalError"><code>EvalError</code></a>。当一个异常抛出时，控制将会进入与其对应的<code>catch</code>语句。如果这个异常不是特定的，那么控制将转移到无条件<code>catch</code>子句。</p></li><li><p>当用一个无条件<code>catch</code>子句和一个或多个条件语句时，无条件<code>catch</code>子句必须放在最后。否则当到达条件语句之前所有的异常将会被非条件语句拦截。</p></li><li><p>提醒：这个功能不符合 ECMAscript 规范。</p></li><li><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  myroutine(); <span class="comment">// 下面这种 catch 写法，可能抛出三种类型的异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error <span class="keyword">if</span> error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理TypeError异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error <span class="keyword">if</span> error <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理RangeError异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error <span class="keyword">if</span> error <span class="keyword">instanceof</span> <span class="built_in">EvalError</span>) &#123;</span><br><span class="line">  <span class="comment">// 处理EvalError异常的语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="comment">// 用于处理任何未指定异常的语句</span></span><br><span class="line">  <span class="built_in">console</span>.log(error); <span class="comment">// 将异常对象传递给错误处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>下面用符合 ECMAscript 规范的简单的 JavaScript 来编写相同的“条件catch子句”（显然更加冗长的，但是可以在任何地方运行）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  myRoutine();</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">RangeError</span>) &#123;</span><br><span class="line">    <span class="comment">// 语句来处理这个非常常见的预期错误</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> error;  <span class="comment">// 不变地重新抛出错误</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>异常标识符：当<code>try</code>块中的抛出一个异常时， *<code>exception_var</code>*（如<code>catch (error)</code>中的<code>error</code>）用来保存被抛出声明指定的值。你可以用这个标识符来获取关于被抛出异常的信息。这个标识符是<code>catch</code>子语句内部的。换言之，当进入<code>catch</code>子语句时标识符创建，<code>catch</code>子语句执行完毕后，这个标识符将不再可用。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isValidJSON</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">JSON</span>.parse(text);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>finally 块：<code>finally</code>块包含的语句在<code>try</code>块和<code>catch</code>之后，<code>try..catch..finally</code>块后的语句之前执行。请注意，无论是否抛出异常<code>finally</code>子句都会执行。此外，如果抛出异常，即使没有<code>catch</code>子句处理异常，<code>finally</code>子句中的语句也会执行。</p><ul><li><p>一个简单的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;即使没有抛出异常，finally 中的语句也会被执行&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 即使没有抛出异常，finally 中的语句也会被执行</span></span><br></pre></td></tr></table></figure></li><li><p>以下示例打开一个文件，然后执行使用该文件的语句（服务器端 JavaScript 允许您访问文件）。如果文件打开时抛出异常，则<code>finally</code>子句会在脚本失败之前关闭该文件。finally中的代码最终也会在<code>try</code>或<code>catch block</code>显式返回时执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">openMyFile();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  writeMyFile(theData); <span class="comment">// 执行文件中的语句</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  closeMyFile(); <span class="comment">// 关闭文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（四）：String对象</title>
      <link href="025e8cf7d9f8/"/>
      <url>025e8cf7d9f8/</url>
      
        <content type="html"><![CDATA[<h2 id="初识js字符串"><a href="#初识js字符串" class="headerlink" title="初识js字符串"></a>初识js字符串</h2><blockquote><p>JavaScript 字符串用于存储和处理文本</p></blockquote><ol><li><p>字符串的创建：<br> 通常，JavaScript 字符串是原始值，通过字面方式创建，但是字符串也可通过关键词 <code>new</code> 定义为对象：</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过字面量创建</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;Bill&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x);  <span class="comment">// string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过关键字创建</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> y);  <span class="comment">// object</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请不要把字符串创建为对象，它会拖慢执行速度，new 关键字会使代码复杂化，也可能产生意外的结果</span></span><br><span class="line"><span class="built_in">console</span>.log(x == y);  <span class="comment">// true，因为值相等</span></span><br><span class="line"><span class="built_in">console</span>.log(x === y);  <span class="comment">// false，因为类型不相同</span></span><br><span class="line"><span class="keyword">var</span> z = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;Bill&quot;</span>);</span><br><span class="line">consolellog(y === z);  <span class="comment">// false，因为 y 与 z 是不用的对象</span></span><br><span class="line">consolellog(y == z);  <span class="comment">// false，因为 y 与 z 是不用的对象</span></span><br></pre></td></tr></table></figure></li><li><p>字符串是插入到单引号或双引号中的任何内容，其索引与数组相同</p><ul><li>引号间，嵌套引号时，单双引号要交替使用</li><li>字符串默认只能写在一行内，分成多行将会报错<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;a</span></span><br><span class="line"><span class="string">c&#x27;</span>  <span class="comment">// SyntaxError: Unexpected token ILLEGAL</span></span><br></pre></td></tr></table></figure></li><li>若要分行，可以采用以下几种方法：<ul><li>在每一行的尾部使用 <code>\</code>（但是 <code>\</code> 后面只能跟换行符，否则会报错）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;a\</span></span><br><span class="line"><span class="string">c&#x27;</span>;  <span class="comment">// str == &#x27;ac&#x27;</span></span><br></pre></td></tr></table></figure></li><li>连接运算符 <code>+</code> 可以连接多个运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;b&#x27;</span></span><br><span class="line"><span class="comment">// x = &#x27;ab&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>转义字符：<table><thead><tr><th align="center">代码</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">\‘</td><td align="center">‘（单引号）</td></tr><tr><td align="center">\‘’</td><td align="center">‘’（双引号）</td></tr><tr><td align="center">\\</td><td align="center">\（反斜杠）</td></tr><tr><td align="center">\b</td><td align="center">退格键</td></tr><tr><td align="center">\f</td><td align="center">换页</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\r</td><td align="center">回车</td></tr><tr><td align="center">\t</td><td align="center">水平制表符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr></tbody></table></li></ul></li><li><p>字符串与数组</p><ul><li>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符</li><li>若方括号中的数字超过字符串的长度，或者方括号中的根本不是数字，则返回 <code>undefined</code>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">// 则 s[3] 、s[-1] 、s[&#x27;x&#x27;] 均返回 undefined</span></span><br></pre></td></tr></table></figure></li><li>但是，数组可以改变元素，字符串不可以改变单个字符</li></ul></li></ol><hr><h2 id="字符串的属性与方法"><a href="#字符串的属性与方法" class="headerlink" title="字符串的属性与方法"></a>字符串的属性与方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li><code>length</code> 属性：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ol><li>字符串的方法较多，先总览一下：<br> <img src="https://s2.ax1x.com/2020/03/03/3fx6KS.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/03/03/3fx6KS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><ul><li>在此，我们只列举一些常用的方法</li></ul></li><li>输出下标位置的字符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(<span class="number">0</span>);  <span class="comment">// &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li><li>输出下标位置的字符的编码值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charCodeAt(<span class="number">0</span>);  <span class="comment">// 97</span></span><br></pre></td></tr></table></figure></li><li>把 <strong>Unicode</strong> 编码转换成对应的文字<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">10000</span>);  <span class="comment">// &quot;✐&quot;</span></span><br></pre></td></tr></table></figure></li><li>输出拼接后的字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.concat(<span class="string">&#x27;e&#x27;</span>);  <span class="comment">// &#x27;abcde&#x27;</span></span><br></pre></td></tr></table></figure></li><li>输出指定字符的下标位置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.indexOf(<span class="string">&#x27;c&#x27;</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li>从后向前搜索输出指定字符的下标位置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.lastIndexOf(<span class="string">&#x27;c&#x27;</span>);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li>输出字符串的长度<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.length;  <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li><li>按照字母表的顺序规则进行比较，输出比较结果，靠前为1，靠后为0，相等为0<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.localeCompare(<span class="string">&#x27;aacd&#x27;</span>);  <span class="comment">// 1</span></span><br><span class="line">str.localeCompare(<span class="string">&#x27;efg&#x27;</span>);  <span class="comment">// -1</span></span><br><span class="line">str.localeCompare(<span class="string">&#x27;abcd&#x27;</span>);  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li>输出指定字符从下标位置<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.search(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li>输出指定返回“切片”后的结果（左含右不含）<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.slice(<span class="number">1</span>,<span class="number">3</span>);  <span class="comment">// &#x27;bc&#x27;</span></span><br></pre></td></tr></table></figure></li><li>输出该字符串以指定字符分割为的数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.split();  <span class="comment">// [&#x27;abcd&#x27;]</span></span><br><span class="line">str.split(<span class="string">&#x27;&#x27;</span>);  <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]</span></span><br><span class="line">str.split(<span class="string">&#x27;b&#x27;</span>);  <span class="comment">// [&#x27;a&#x27;,&#x27;cd&#x27;]</span></span><br></pre></td></tr></table></figure></li><li>输出指定下标后面指定长度的字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str.substr(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">// &#x27;bc&#x27;</span></span><br><span class="line">str.substr(<span class="number">0</span>,<span class="number">2</span>);  <span class="comment">// &#x27;ab&#x27;</span></span><br><span class="line">str.substr(<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">// &#x27;cd&#x27;</span></span><br></pre></td></tr></table></figure></li><li>输出从指定左下标到右下标的所有字符串<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str.substring();  <span class="comment">// &#x27;abcd&#x27;</span></span><br><span class="line">str.substring(<span class="number">0</span>);  <span class="comment">// &#x27;abcd&#x27;</span></span><br><span class="line">str.substring(-<span class="number">1</span>);  <span class="comment">// &#x27;abcd&#x27;</span></span><br><span class="line">str.substring(<span class="number">2</span>);  <span class="comment">// &#x27;cd&#x27;</span></span><br><span class="line">str.substring(<span class="number">0</span>,<span class="number">2</span>);  <span class="comment">// &#x27;ab&#x27;</span></span><br></pre></td></tr></table></figure></li><li>将字符串所有的字符转换为小写再输出<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toLowerCase();  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;ABCD&#x27;</span>;</span><br><span class="line">s.toLowerCase();  <span class="comment">// &#x27;abcd&#x27;</span></span><br></pre></td></tr></table></figure></li><li>将字符串所有的字符转换为大写再输出<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.toUpperCase();  <span class="comment">// &#x27;ABCD&#x27;</span></span><br></pre></td></tr></table></figure></li><li>将其他类型的数据转换为字符串类型输出<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">x.toString();  <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（三）：Array对象</title>
      <link href="2d32849ebe03/"/>
      <url>2d32849ebe03/</url>
      
        <content type="html"><![CDATA[<h2 id="初识JS数组"><a href="#初识JS数组" class="headerlink" title="初识JS数组"></a>初识JS数组</h2><ol><li>数组的定义<ul><li>下标从0开始<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>]</span><br></pre></td></tr></table></figure></li><li>也可以先定义后赋值<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">arr[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li>任何类型的数据，都可以放入数组，因为数组是一种特殊的对象，所以数组元素可以是不同类型的，但是最好不要这么做<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,  <span class="comment">// arr[0] -&gt; 对象：Object &#123;a: 1&#125;</span></span><br><span class="line">  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],  <span class="comment">// arr[1] -&gt; 数组：array [1,2,3]</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> <span class="literal">true</span>;&#125;  <span class="comment">// arr[2] -&gt; 函数：function() &#123;return true;&#125;</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure>注意：请不要数组的最后一个元素之后写逗号，因为这可能存在跨浏览器兼容性问题</li><li>如果数组里面仍然嵌套着数组，那就形成了多维数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ [<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>] ];</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">arr[0][1] == 2</span></span><br><span class="line"><span class="comment">arr[1][1] == 4</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li>使用 JavaScript 关键词 <strong>New</strong><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>);  <span class="comment">// 一种定义数组的方法， 但最好不要使用这种</span></span><br><span class="line"><span class="comment">// 比较麻烦，一般也不用</span></span><br></pre></td></tr></table></figure></li></ul></li><li>数组的访问：<ul><li>我们通过引用索引号（下标号）来引用某个数组元素<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Saab&quot;</span>, <span class="string">&quot;Volvo&quot;</span>, <span class="string">&quot;BMW&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(cars);  <span class="comment">// [ &#x27;Saab&#x27;, &#x27;Volvo&#x27;, &#x27;BMW&#x27; ]</span></span><br></pre></td></tr></table></figure></li><li>这条语句修改 cars 中的首个元素：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cars[<span class="number">0</span>] = <span class="string">&quot;Opel&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(cars);  <span class="comment">// [ &#x27;Opel&#x27;, &#x27;Volvo&#x27;, &#x27;BMW&#x27; ]</span></span><br></pre></td></tr></table></figure></li><li>实例：访问整个数组<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>JavaScript 数组<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> cars = [<span class="string">&quot;Audi&quot;</span>, <span class="string">&quot;BMW&quot;</span>, <span class="string">&quot;porsche&quot;</span>];</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;demo&quot;</span>).innerHTML = cars;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>改变数组元素 <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;demo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span></span><br><span class="line"><span class="javascript">  arr[<span class="number">0</span>] = <span class="string">&#x27;A&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById.innerHTML(<span class="string">&#x27;demo&#x27;</span>) = arr[<span class="number">0</span>];</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>数组的本质<ul><li>本质上，数组属于一种现象。<code>typeof</code>运算符会返回任一数组的类型都是<code>object</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];  <span class="comment">//&quot;Object&quot;</span></span><br></pre></td></tr></table></figure></li><li>数组的特殊性在于，它的<strong>键名</strong>是<strong>按次序排列</strong>的一组整数<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">Object</span>.keys(arr);  <span class="comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span></span><br><span class="line"><span class="comment">//Object.keys方法返回数组的所有键名</span></span><br></pre></td></tr></table></figure></li><li>对比 — 数组与对象的键名：<ul><li>数组的键名是固定的(0、1、2…..)</li><li>对象的每个成员都必须指定键名</li><li>JS规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串</li><li>之所以可以用数值读取，是因为非字符串的键名会被转为字符串 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="comment">// arr[0] == arr[&#x27;0&#x27;] == &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure></li><li>注意，这点在赋值时也成立，一个值总是先转成字符串，再作为键名进行赋值<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line">arr[<span class="number">1.00</span>] = <span class="number">6</span>;</span><br><span class="line"><span class="comment">// arr[1] == 6 -&gt; 原因: 1.00转成字符串是1，所以数字键1可以读取值</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>关联数组<ul><li>很多编程元素支持命名索引的数组，具有命名索引的数组被称为关联数组（或散列），但是，JavaScript <strong>不支持</strong> 命名索引的数组，也就是说，在 JavaScript 中，数组只能使用 <strong>数字索引</strong>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = [];</span><br><span class="line">person[<span class="string">&quot;firstName&quot;</span>] = <span class="string">&quot;Bill&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;lastName&quot;</span>] = <span class="string">&quot;Gates&quot;</span>;</span><br><span class="line">person[<span class="string">&quot;age&quot;</span>] = <span class="number">62</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person.length);  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="number">0</span>]);  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li>当然，这也是数组与对象的一个区别：数组使用数字索引，对象使用命名索引</li></ul></li><li>识别数组<ul><li><code>Array.isArray()</code> 方法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Apple&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(fruits));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>这是 ES5 定义的方法，不支持版本较老的浏览器</li></ul></li><li>创建 <code>isArray()</code> 函数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Apple&quot;</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">myArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> myArray.constructor.toString().indexOf(<span class="string">&quot;Array&quot;</span>) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(isArray(fruits));  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>假如参数为数组，则上面的函数始终返回 true，更准确地说，如果对象原型包含 “Array” 这个单词，则说明它是数组，返回 true.</li></ul></li></ul></li></ol><hr><h2 id="数组的属性与方法"><a href="#数组的属性与方法" class="headerlink" title="数组的属性与方法"></a>数组的属性与方法</h2><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><ol><li><p>判断长度：<strong>length</strong> 属性：返回数组的长度</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[arr.length-<span class="number">1</span>]);  <span class="comment">// 访问最后一个元素:&#x27;c&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.cnblogs.com/yunshangwuyou/p/10539090.html">判断数组是否包含某个元素</a></p><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3></li><li><p>添加到最后面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;x&#x27;</span>);  <span class="comment">// arr = [1,2,3,&#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure></li><li><p>添加到最前面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;x&#x27;</span>);  <span class="comment">// arr = [&#x27;x&#x27;,1,2,3]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="删除与切分"><a href="#删除与切分" class="headerlink" title="删除与切分"></a>删除与切分</h3><ol><li>删除数组最后一项：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.pop();  <span class="comment">// arr = [1,2]</span></span><br></pre></td></tr></table></figure></li><li>删除数组第一项：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.shift();  <span class="comment">// arr = [2,3]</span></span><br></pre></td></tr></table></figure></li><li>截取数组的一部分：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标:左算右不算</span></span><br><span class="line"><span class="comment">// -1指最后一个元素，一次类推</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr.slice(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">// [2]</span></span><br><span class="line">arr.slice(-<span class="number">3</span>,<span class="number">1</span>)  <span class="comment">// [1,2]</span></span><br><span class="line">arr.slice()  <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="拷贝与衔接"><a href="#拷贝与衔接" class="headerlink" title="拷贝与衔接"></a>拷贝与衔接</h3><ol><li><a href="https://blog.csdn.net/weixin_37719279/article/details/81240658">数组的深拷贝和浅拷贝</a>：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>浅拷贝 : 浅拷贝是拷贝一层，深层次的对象级别的就拷贝引用<ul><li>用 <code>Arr.slice()</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr1 = arr.slice();</span><br></pre></td></tr></table></figure></li><li>用 <code>Arr.concat()</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr2 = arr.concat();</span><br></pre></td></tr></table></figure></li></ul></li><li>深拷贝：深拷贝是拷贝多层，每一级别的数据都会拷贝出来<ul><li>用 <code>Arr.copyWithin()</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr3 = arr.copyWithin();</span><br></pre></td></tr></table></figure></li><li>其余的方法参考博客……</li></ul></li></ul></li><li>数组的填充：<a href="https://blog.csdn.net/weixin_33857679/article/details/91425375">Arr.fill()方法</a></li><li>合并两个数组：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line"><span class="keyword">var</span> newArr = arr1.concat(arr2);  <span class="comment">// newArr = [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ol><li>数组排序：<ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">Arr.sort()</a></li><li><code>sort()</code> 以字母顺序对数组进行排序：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fruits.sort());  <span class="comment">// [ &#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Mango&#x27;, &#x27;Orange&#x27; ]</span></span><br></pre></td></tr></table></figure></li><li><code>reverse()</code> 反转数组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fruits = [<span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Mango&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(fruits.reverse());  <span class="comment">// [ &#x27;Mango&#x27;, &#x27;Apple&#x27;, &#x27;Orange&#x27;, &#x27;Banana&#x27; ]</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（二）：词法与变量</title>
      <link href="df656e604d75/"/>
      <url>df656e604d75/</url>
      
        <content type="html"><![CDATA[<h2 id="基础了解"><a href="#基础了解" class="headerlink" title="基础了解"></a>基础了解</h2><ol><li><p>JavaScript 是<strong>区分大小写</strong>的。</p></li><li><p>JavaScript 使用的是 unicode 字符集，例如，可以将单词 Früh （在德语中意思是“早”）用作变量名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Früh = <span class="string">&quot;Good Moring&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><p>关于字符集与字符编码，请查：</p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81">维基百科 | 字符编码</a></li><li><a href="https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86/946585?fr=aladdin">百度百科 | 字符集</a></li><li><a href="https://zhuanlan.zhihu.com/p/260192496">字符、字符集、字符编码的基础知识科普</a></li><li><a href="https://zhuanlan.zhihu.com/p/27171404">Unicode字符集的字符编码方式</a></li></ul></li><li><p>Unicode 转义序列：Unicode 转义序列要求在<code>\u</code>之后至少有四个字符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u00A9&#x27;</span> <span class="comment">// &#x27;©&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>Unicode 编码转义：ECMAScript 6新增特性。使用Unicode编码转义，任何字符都可以被转义为十六进制编码。最高可以用到<code>0x10FFFF</code>。使用单纯的Unicode转义通常需要写成分开的两半以达到相同的效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;\u&#123;2F804&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单纯 Unicode 转义</span></span><br><span class="line"><span class="string">&#x27;\uD87E\uDC04&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>与此类似的方式是 <code>String.fromCodePoint</code> 和 <code>String.prototype.codePointAt()</code></li></ul></li></ul></li><li><p>在 JavaScript 中，指令被称为语句 （Statement），并用分号（;）进行分隔，ECMAScript 规定了在语句的末尾自动插入分号。Javascript 源码从左往右被扫描并转换成一系列由 token 、控制字符、行终止符、注释和空白字符组成的输入元素。空白字符指的是空格、制表符和换行符等。</p></li><li><p>注释：Javascript 注释的语法和 C++ 或许多其他语言类似：</p><ul><li><p>单行注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  这是一个</span></span><br><span class="line"><span class="comment">  多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>不能嵌套注释，否则会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 然而, 你不能, /* 嵌套注释 */</span> 语法错误 */</span><br></pre></td></tr></table></figure></li><li><p>多行注释也可以用于行内注释，但这样会使代码可读性变差，所以要谨慎使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">comment</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + x <span class="comment">/*引入的值*/</span> + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">comment(<span class="string">&#x27;World&#x27;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>hashbang 注释：</p><ul><li><p>专门的第三个注释语法，hashbang 注释正在 ECMAScript 中标准化。</p></li><li><p>Hashbang 注释的行为与单行（<code>//</code>）注释完全相同，但它以 <code>#!</code> 开头且<strong>仅在脚本或模块的绝对开头有效</strong>。</p></li><li><p>注意，在 <code>#!</code> 之前不允许有任何类型的空格。</p></li><li><p>注释由 <code>#!</code> 之后的所有字符组成直到第一行的末尾；只允许有一条这样的注释。</p></li><li><p>hashbang 注释指定特定 JavaScript 解释器的路径要用于执行脚本，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Hello world&#x27;</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>注意</strong>：JavaScript 中的 hashbang 注释模仿 Unix 中的 shebangs，用于指定适当的解释器运行文件。</li></ul></li><li><p>在 hashbang 注释之前的 BOM 在浏览器中能工作，但是不建议在具有 hashbang 的脚本中使用 BOM，因为若在 Unix/Linux 中运行脚本，则有些 BOM 将不工作，因此，如果要直接从 shell 运行脚本，请使用没有 BOM 的 UTF-8。</p></li><li><p>注意，只能使用 <code>#!</code> 注释样式以指定 JavaScript 解释器。在所有其他情况下，只需使用 <code>//</code> 注释或 <code>/**/</code> 多行注释。</p></li></ul></li></ul></li></ol><hr><h2 id="词法文法"><a href="#词法文法" class="headerlink" title="词法文法"></a>词法文法</h2><p>ECMAScript 源码文本会被从左到右扫描，并被转换为一系列的输入元素，包括 token、控制符、行终止符、注释和空白符。</p><p>ECMAScript 定义了一些关键字、字面量以及行尾分号补全的规则。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><blockquote><p>代码中用来标识变量、函数、或属性的字符序列。</p></blockquote><p>在JavaScript中，标识符只能包含字母或数字或下划线（“_”）或美元符号（“$”），且不能以数字开头。</p><p>标识符与字符串不同之处在于字符串是数据，而标识符是代码的一部分。</p><p>在 JavaScript 中，无法将标识符转换为字符串，但有时可以将字符串解析为标识符。</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>以下是 ES6 中保留的关键字，共 33 个：</p><table><thead><tr><th align="center">break</th><th align="center">case</th><th align="center">catch</th><th align="center">class</th><th align="center">const</th><th align="center">continue</th><th align="center">debugger</th></tr></thead><tbody><tr><td align="center"><strong>default</strong></td><td align="center"><strong>delete</strong></td><td align="center"><strong>do</strong></td><td align="center"><strong>else</strong></td><td align="center"><strong>export</strong></td><td align="center"><strong>extends</strong></td><td align="center"><strong>finally</strong></td></tr><tr><td align="center"><strong>for</strong></td><td align="center"><strong>function</strong></td><td align="center"><strong>if</strong></td><td align="center"><strong>import</strong></td><td align="center"><strong>in</strong></td><td align="center"><strong>instanceof</strong></td><td align="center"><strong>new</strong></td></tr><tr><td align="center"><strong>return</strong></td><td align="center"><strong>super</strong></td><td align="center"><strong>switch</strong></td><td align="center"><strong>this</strong></td><td align="center"><strong>throw</strong></td><td align="center"><strong>try</strong></td><td align="center"><strong>typeof</strong></td></tr><tr><td align="center"><strong>var</strong></td><td align="center"><strong>void</strong></td><td align="center"><strong>while</strong></td><td align="center"><strong>with</strong></td><td align="center"><strong>yield</strong></td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="未来保留关键字"><a href="#未来保留关键字" class="headerlink" title="未来保留关键字"></a>未来保留关键字</h4><p>在 ECMAScript 规格中，以下这些关键字被当成关键字保留。目前它们没有特殊功能，但是在未来某个时间可能会加上。所以这些关键字不能当成标识符使用。</p><ul><li><p><strong>enum</strong> 关键字在严格模式和非严格模式中均不能使用。</p></li><li><p>以下关键字只在严格模式中被当成保留关键字：</p><table><thead><tr><th align="center">implements</th><th align="center">interface</th><th align="center">let</th><th align="center">package</th></tr></thead><tbody><tr><td align="center"><strong>private</strong></td><td align="center"><strong>protected</strong></td><td align="center"><strong>public</strong></td><td align="center"><strong>static</strong></td></tr></tbody></table></li><li><p><strong>await</strong> 关键字只在模块代码中被当成保留关键字。</p></li></ul><h4 id="之前标准中的保留关键字"><a href="#之前标准中的保留关键字" class="headerlink" title="之前标准中的保留关键字"></a>之前标准中的保留关键字</h4><p>以下是之前版本中的 ECMAScript（1到3）中的保留关键字：</p><table><thead><tr><th align="center">abstract</th><th align="center">boolean</th><th align="center">byte</th><th align="center">char</th><th align="center">double</th></tr></thead><tbody><tr><td align="center"><strong>final</strong></td><td align="center"><strong>float</strong></td><td align="center"><strong>goto</strong></td><td align="center"><strong>int</strong></td><td align="center"><strong>long</strong></td></tr><tr><td align="center"><strong>native</strong></td><td align="center"><strong>short</strong></td><td align="center"><strong>synchronized</strong></td><td align="center"><strong>transient</strong></td><td align="center"><strong>volatile</strong></td></tr></tbody></table><p>另外，直接量 <strong>null、true、false</strong> 同样不能被当成标识使用。</p><h4 id="保留字的使用"><a href="#保留字的使用" class="headerlink" title="保留字的使用"></a>保留字的使用</h4><p>保留字是仅针对标识符（Identifier）的文法定义而言的（而不是标识符名（IdentifierName）的文法定义）。如 <a href="http://es5.github.com/#A.1">es5.github.com/#A.1</a>中所描述的，这些都是不排斥保留字的标识符名。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a.import</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;import&#x27;</span>]</span><br><span class="line"></span><br><span class="line">a = &#123;</span><br><span class="line">  <span class="keyword">import</span>: <span class="string">&#x27;test&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如下用法是不允许的，因为它是一个标识符，而标识符的文法定义是除保留字以外的标识符名，标识符用于函数声明式和函数表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">import</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// Illegal</span></span><br></pre></td></tr></table></figure><h3 id="直接量"><a href="#直接量" class="headerlink" title="直接量"></a>直接量</h3><h4 id="空直接量"><a href="#空直接量" class="headerlink" title="空直接量"></a>空直接量</h4><blockquote><p><strong>null</strong> 是空直接量</p></blockquote><h4 id="布尔直接量"><a href="#布尔直接量" class="headerlink" title="布尔直接量"></a>布尔直接量</h4><blockquote><p><strong>true、false</strong> 是布尔直接量</p></blockquote><h4 id="数值直接量"><a href="#数值直接量" class="headerlink" title="数值直接量"></a>数值直接量</h4><blockquote><p>十进制、二进制、八进制、十六进制的数字是数值直接量</p></blockquote><h4 id="对象直接量"><a href="#对象直接量" class="headerlink" title="对象直接量"></a>对象直接量</h4><blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></blockquote><h4 id="数组直接量"><a href="#数组直接量" class="headerlink" title="数组直接量"></a>数组直接量</h4><blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></blockquote><h4 id="字符串直接量"><a href="#字符串直接量" class="headerlink" title="字符串直接量"></a>字符串直接量</h4><blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;Hello World&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><h4 id="正则表达式直接量"><a href="#正则表达式直接量" class="headerlink" title="正则表达式直接量"></a>正则表达式直接量</h4><blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/ab+c/g</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">一个空的正则表达式直接量</span></span><br><span class="line"><span class="comment">必须有一个空的非捕获分组</span></span><br><span class="line"><span class="comment">以避免被当成是行注释符号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">/(?:)/</span><br></pre></td></tr></table></figure></blockquote><h4 id="模板直接量"><a href="#模板直接量" class="headerlink" title="模板直接量"></a>模板直接量</h4><blockquote><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">`string text`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text line 1</span></span><br><span class="line"><span class="string">string text line 2`</span></span><br><span class="line"></span><br><span class="line"><span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br><span class="line"></span><br><span class="line">tag <span class="string">`string text <span class="subst">$&#123;expression&#125;</span> string text`</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="自动分号补全"><a href="#自动分号补全" class="headerlink" title="自动分号补全"></a>自动分号补全</h3><p>一些 JavaScript 语句必须用分号结束，所以会被自动分号补全（ASI）影响：</p><ul><li>空语句</li><li><code>let</code>、<code>const</code>、变量声明</li><li><code>import</code>、<code>export</code>、模块定义</li><li>表达式语句</li><li><code>debugger</code></li><li><code>continue</code>、<code>break</code>、<code>throw</code></li><li><code>return</code></li></ul><h4 id="三个规则"><a href="#三个规则" class="headerlink" title="三个规则"></a>三个规则</h4><p>ECMAScript 规格中有自动分号补全的三个规则：</p><ol><li><p>当出现一个不允许的行终止符或 <code>&#125;</code> 时，会在其之前插入一个分号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="number">1</span> <span class="number">2</span> &#125; <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会被 ASI 转换为</span></span><br><span class="line">&#123; <span class="number">1</span> <span class="number">2</span> ;&#125; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></li><li><p>当捕获到标识符输入流的结尾，并且无法将单个输入流转换为一个完整的程序时，将在结尾插入一个分号。例如在下面这段中，由于在 b 和 ++ 之间出现了一个行终止符，所以 ++ 未被当成变量 b 的后置运算符：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = b</span><br><span class="line">++c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将被 ASI 转换为</span></span><br><span class="line">a = b;</span><br><span class="line">++c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而不是</span></span><br><span class="line">a = b++;</span><br><span class="line">c;</span><br></pre></td></tr></table></figure></li><li><p>当语句中包含语法中的限制产品后跟一个行终止符的时候，将会在结尾插入一个分号，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span></span><br><span class="line">a + b</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将被 ASI 转换为</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">a + b;</span><br></pre></td></tr></table></figure><ul><li>而带有 “这里没有行终止符” 规则的语句有：<ul><li>后置运算符（<code>++</code> 和 <code>--</code>）</li><li><code>continue</code></li><li><code>break</code></li><li><code>return</code></li><li><code>yield</code>、<code>yield*</code></li><li><code>module</code></li></ul></li></ul></li></ol><hr><h2 id="声明与变量"><a href="#声明与变量" class="headerlink" title="声明与变量"></a>声明与变量</h2><h3 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h3><p>JavaScript有三种声明方式：</p><ol><li><p>var：声明一个变量，可选初始化一个值。</p></li><li><p>let：声明一个块作用域的局部变量，可选初始化一个值。</p></li><li><p>const：声明一个块作用域的只读常量。</p></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>在应用程序中，使用变量来作为值的符号名。变量的名字又叫做标识符，其需要遵守一定的规则。</p><p>一个 JavaScript 标识符必须以字母、下划线（_）或者美元符号（$）开头；后续的字符也可以是数字（0-9）。因为 JavaScript 语言是区分大小写的，所以字母可以是从 “A” 到 “Z” 的大写字母和从 “a” 到 “z” 的小写字母。</p><p>可以使用大部分 ISO 8859-1 或 Unicode 编码的字符作标识符，例如 å 和 ü，也可以使用 Unicode 转义字符 作标识符。</p><h3 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h3><p>可以用以下三种方式声明变量：（注意，const 声明的不是变量而是常量）</p><ol><li>使用关键词 <code>var</code>。例如 <code>var x = 42</code>。这个语法可以用来声明局部变量和全局变量。</li><li>使用关键词 let 。例如 let y = 13。这个语法可以用来声明块作用域的局部变量。</li><li>直接赋值。例如<code>x = 42</code>。在函数外使用这种形式赋值，会产生一个全局变量。在严格模式下会产生错误。因此最好不要使用这种方式来声明变量。</li></ol><h3 id="变量求值"><a href="#变量求值" class="headerlink" title="变量求值"></a>变量求值</h3><p>用 <code>var</code> 或 <code>let</code> 语句声明的变量，如果没有赋初始值，则其值为 <code>undefined</code> 。</p><p>如果访问一个未声明的变量会导致抛出一个引用错误（ReferenceError）异常：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b;</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>因此，可以使用 <code>undefined</code> 来判断一个变量是否已赋值。在以下的代码中，变量<code>input</code>未被赋值，因此 <code>if</code> 条件语句的求值结果是 <code>true</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> input;</span><br><span class="line"><span class="keyword">if</span>(input === <span class="literal">undefined</span>)&#123;</span><br><span class="line">  doThis();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  doThat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实，若之前就定义 <code>let input = undefined</code>，结果也等同于未赋值。</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>在函数之外声明的变量，能被当前文档中的任何其他代码所访问，叫做全局变量。</p><p>在函数内部声明的变量，只能在当前函数的内部访问，叫做局部变量。</p><p>ECMAScript 6 之前的 JavaScript 没有语句块作用域；相反，语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量。例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>如果使用 ECMAScript 6 中的 <code>let</code> 声明，上述行为将发生变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// ReferenceError: y 没有被声明</span></span><br></pre></td></tr></table></figure><h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，可以先使用变量稍后再声明变量而不会引发异常，这一概念称为变量提升。</p><p>JavaScript 变量感觉上是被 “提升” 或 “移到” 了函数或语句的最前面。</p><p>但是，提升后的变量将返回 undefined 值。</p><p>因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line"><span class="built_in">console</span>.log(x === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br><span class="line">x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例子2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> myvar = <span class="string">&#x27;my value&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> myvar;</span><br><span class="line">  <span class="built_in">console</span>.log(myvar); <span class="comment">// undefined</span></span><br><span class="line">  myvar = <span class="string">&#x27;local value&#x27;</span>;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>由于存在变量提升，一个函数中所有的<code>var</code>语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。</p><p>在 ECMAScript 6 中，let（const）同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><h3 id="函数提升"><a href="#函数提升" class="headerlink" title="函数提升"></a>函数提升</h3><p>对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数声明 */</span></span><br><span class="line">foo(); <span class="comment">// &quot;bar&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数表达式 */</span></span><br><span class="line">baz(); <span class="comment">// 类型错误：baz 不是一个函数</span></span><br><span class="line"><span class="keyword">var</span> baz = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;bar2&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>实际上，全局变量是全局对象的属性。在网页中，全局对象是 window ，所以你可以用形如 <code>window.variable</code> 的语法来设置和访问全局变量。</p><p>因此，可以通过指定 window 或 frame 的名字，在当前 window 或 frame 访问另一个 window 或 frame 中声明的变量。例如，在文档里声明一个叫 <code>phoneNumber</code> 的变量，那么你就可以在子框架里使用 <code>parent.phoneNumber</code> 的方式来引用它。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>可以用关键字 <code>const</code> 创建一个只读的常量。常量标识符的命名规则和变量相同：必须以字母、下划线（_）或美元符号（$）开头并可以包含有字母、数字或下划线，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><p>常量不可以通过重新赋值改变其值，也不可以在代码运行时重新声明，它必须被初始化为某个值。</p><p>在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> f = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也会报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> g = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">var</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  key: <span class="string">&#x27;value&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.key = <span class="string">&#x27;otherValue&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;key: &quot;otherValue&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（一）：了解 JavaScript</title>
      <link href="b378fba5d5f4/"/>
      <url>b378fba5d5f4/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-JavaScript"><a href="#什么是-JavaScript" class="headerlink" title="什么是 JavaScript"></a>什么是 JavaScript</h2><ol><li><p>JavaScript 是一门跨平台、面向对象的脚本语言。</p></li><li><p>它能使网页可交互（例如拥有复杂的动画，可点击的按钮，通俗的菜单等），还有高级的服务端Javascript版本，例如Node.js。</p></li><li><p>在宿主环境（例如 web 浏览器）中， JavaScript 能够通过其所连接的环境提供的编程接口进行控制。</p></li><li><p>JavaScript 内置了一些对象的标准库，比如数组（<code>Array</code>），日期（<code>Date</code>），数学（<code>Math</code>）和一套核心语句，包括运算符、流程控制符以及声明方式等。</p></li><li><p>JavaScript 的核心部分可以通过添加对象来扩展语言以适应不同用途；例如：</p><ul><li>客户端的 JavaScript 通过提供对象，控制浏览器及其文档对象模型（DOM），来扩展语言核心。<ul><li>例如：客户端的拓展代码允许应用程序将元素放在某个 HTML 表单中，并且支持响应用户事件，比如鼠标点击、表单提交和页面导航。</li></ul></li><li>服务端的 JavaScript 则通过提供有关在服务器上运行 JavaScript 的对象来可扩展语言核心。<ul><li>例如：服务端版本直接支持应用和数据库通信，提供应用不同调用间的信息连续性，或者在服务器上执行文件操作。</li></ul></li><li>因为能通过添加对象来扩展语言以适应不同的用途，所以，在浏览器中，JavaScript 可以改变网页（DOM）的外观与样式；在服务器上，Node.js 中的 JavaScript 可以对浏览器上编写的代码发出的客户端请求做出响应。</li></ul></li></ol><hr><h2 id="JavaScript-与-Java"><a href="#JavaScript-与-Java" class="headerlink" title="JavaScript 与 Java"></a>JavaScript 与 Java</h2><ol><li><p>JavaScript 和 Java 有一些共性但是在另一些方面有着根本性区别。</p></li><li><p>JavaScript语言类似 Java 但是并没有 Java 的静态类型和强类型检查特性。</p></li><li><p>JavaScript 遵循了 Java 的表达式语法，命名规范以及基础流程控制，这也是 JavaScript 从 LiveScript 更名的原因。</p></li><li><p>Java 是通过声明的方式构建类的编译时系统的，但是 JavaScript 采用基于少量的数据类型如数字、布尔、字符串值的运行时系统。</p></li><li><p>JavaScript 拥有基于原型的对象模型提供的动态继承；也就是说，独立对象的继承是可以改变的。</p></li><li><p>JavaScript 支持匿名函数，函数也可以作为对象的属性被当做宽松的类型方式执行。</p></li><li><p>Java 是基于类的编程语言，设计的初衷就是为了确保快速执行和类型安全。JavaScript 传承了 HyperTalk 和 dBASE 语句精简、动态类型等精髓，这些脚本语言为更多开发者提供了一种语法简单、内置功能强大以及用最小需求创建对象的编程工具。与 Java 相比，Javascript 是一门形式自由的语言。你不必声明所有的变量，类和方法。你不必关心方法是否是公有、私有或者受保护的，也不需要实现接口。无需显式指定变量、参数、方法返回值的数据类型。</p></li><li><p>JavaScript 和 Java 的简单对比：</p><table><thead><tr><th align="center">JavaScript</th><th align="center">Java</th></tr></thead><tbody><tr><td align="center">面向对象</td><td align="center">面向对象</td></tr><tr><td align="center">基于少量数据类型的运行时系统</td><td align="center">基于类的编译时系统</td></tr><tr><td align="center">不区分对象类型</td><td align="center">分为类和实例，通过类层级的定义实现继承</td></tr><tr><td align="center">通过原型机制继承，任何对象的属性和方法均可以被动态添加</td><td align="center">不能动态增加对象或类的属性或方法</td></tr><tr><td align="center">变量类型不需要提前声明（动态类型）</td><td align="center">变量类型必须提前声明（静态类型）</td></tr><tr><td align="center">不能直接自动写入硬盘</td><td align="center">可以直接自动写入硬盘</td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa2入门（三）：骨架知识</title>
      <link href="02458ea63da4/"/>
      <url>02458ea63da4/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="中间件的认识"><a href="#中间件的认识" class="headerlink" title="中间件的认识"></a>中间件的认识</h3><blockquote><p>中间件是 Koa 一个重要的概念，它是一个执行的链条，整个链条组成了一个运行的周期</p></blockquote><ol><li><p>理解上述说的 “链条”，案例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问权限中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;权限验证成功...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> next() <span class="comment">// 执行下一个中间件</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 日志记录</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;日志记录成功...&quot;</span>)</span><br><span class="line">        <span class="keyword">await</span> next() <span class="comment">// 执行下一个中间件</span></span><br><span class="line">    &#125;)</span><br><span class="line"><span class="comment">// 响应处理</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    ctx.response.status = <span class="number">200</span></span><br><span class="line">    ctx.response.body = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">    <span class="keyword">await</span> next() <span class="comment">// 执行下一个中间件</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>打开 <code>http://localhost:3000/</code>，控制台打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting at 3000...</span><br><span class="line">权限验证成功...</span><br><span class="line">日志记录成功...</span><br></pre></td></tr></table></figure></li><li><p>可以看到，每个中间件都只负责一小部分，互相配合而组合成一条完整的业务通道，而中间件的功能也为 koa 提供了很大的便利性，因为一个特定成熟的功能可以抽象成一个个模块共享出来，例如路由模块、模板引擎……我们可以直接在项目中导入这些成熟的模块</p></li></ul></li><li><p>koa 是一个中间件框架，有两种不同的方法来实现中间件：</p><ul><li>async function</li><li>common function</li></ul></li><li><p>下面是用两种不同方法实现一个日志中间件的示例：</p><ul><li><p>async function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">const</span> result_ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span> ms`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>common function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">return</span> next().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result_ms = <span class="built_in">Date</span>.now() - start</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;ctx.method&#125;</span> <span class="subst">$&#123;ctx.url&#125;</span> - <span class="subst">$&#123;ms&#125;</span> ms`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>中间件通常带有两个参数（ctx，next），ctx 是一个请求的上下文（context），而 next 是调用执行下游中间件的函数，在代码执行完成后通过 then 方法返回一个 promise</p></li></ul></li></ol><h3 id="中间件的开发与使用示例"><a href="#中间件的开发与使用示例" class="headerlink" title="中间件的开发与使用示例"></a>中间件的开发与使用示例</h3><ol><li><p>generator 中间件开发可以在 koa v1 和 v2 中使用，但是 async await 中间件只能在 koa v2 中使用，这里只说 koa v2 的使用：</p><ul><li><p>generator 中间件开发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回的应该是function * () 函数</span></span><br><span class="line"><span class="comment">// ./generator.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.method, ctx.header.host + ctx.url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>*(<span class="params">next</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 执行中间件的操作</span></span><br><span class="line">        log(<span class="built_in">this</span>)</span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            <span class="keyword">yield</span> next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>generator 中间件在 koa v2 中需要用 koa-convert 封装一下才能使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> koaConvert = <span class="built_in">require</span>(<span class="string">&quot;koa-convert&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> loggerGenerator = <span class="built_in">require</span>(<span class="string">&quot;./generator.js&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(koaConvert(loggerGenerator()))</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>启动项目，并打开 <code>http://localhost:3000/</code>，控制台报告信息如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting at <span class="number">3000.</span>..</span><br><span class="line">GET localhost:<span class="number">3000</span>/</span><br><span class="line">GET localhost:<span class="number">3000</span>/favicon.ico</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>async 中间件开发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./async.js</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">ctx</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ctx.method, ctx.header.host + ctx.url)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line">        log(ctx)</span><br><span class="line">        <span class="keyword">await</span> next()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>async 中间件只能在 koa v2 中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> loggerAsync = <span class="built_in">require</span>(<span class="string">&quot;./async.js&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line">app.use(loggerAsync())</span><br><span class="line">app.use(<span class="function">(<span class="params">ctx</span>) =&gt;</span> &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>启动项目，并打开 <code>http://localhost:3000/</code>，控制台报告信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Starting at 3000...</span><br><span class="line">GET localhost:3000&#x2F;</span><br><span class="line">GET localhost:3000&#x2F;favicon.ico</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ol><h3 id="中间件的应用"><a href="#中间件的应用" class="headerlink" title="中间件的应用"></a>中间件的应用</h3><blockquote><p>中间件配合路由可以完成一系列的操作，下面这些都是例子</p></blockquote><ol><li><p>添加应用：主要通过 <code>app.use</code> 添加或者启动一些应用，例如一些常见的第三方中间件的使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>)()</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应用级中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 匹配路由之前打印一下信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始匹配路由...&quot;</span>)</span><br><span class="line">    <span class="comment">// 匹配路由完成之后继续向下匹配</span></span><br><span class="line">    <span class="comment">// 若无next()，则匹配成功后会自动终止</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line">Router.get(<span class="string">&quot;/index&quot;</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动路由</span></span><br><span class="line">app.use(Router.routes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>打开 <code>http://localhost:3000/index</code>，控制台输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting at 3000...</span><br><span class="line">开始匹配路由...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>匹配路由：主要通过 <code>next()</code> 完成多级路由的匹配，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>)()</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由级中间件</span></span><br><span class="line">Router.get(<span class="string">&quot;/index&quot;</span>, <span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始匹配首页路由...&quot;</span>)</span><br><span class="line">    <span class="comment">// 匹配到路由之后继续向下匹配</span></span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">&#125;)</span><br><span class="line">Router.get(<span class="string">&quot;/index&quot;</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动路由</span></span><br><span class="line">app.use(Router.routes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>打开 <code>http://localhost:3000/index</code>，控制台输入如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Starting at 3000...</span><br><span class="line">开始匹配首页路由...</span><br></pre></td></tr></table></figure></li></ul></li><li><p>增加错误处理：若一直匹配不成功，则可以通过中间件给出错误响应</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> Router = <span class="built_in">require</span>(<span class="string">&quot;koa-router&quot;</span>)()</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理中间件</span></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx, next) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这是包含路由匹配错误处理的中间件&quot;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;开始匹配首页路由...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> next()</span><br><span class="line">    <span class="keyword">if</span> (ctx.status == <span class="number">404</span>) &#123;</span><br><span class="line">        ctx.body = <span class="string">&quot;这是一个404页面&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(ctx.url)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">Router.get(<span class="string">&quot;/index&quot;</span>, <span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;首页&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动路由</span></span><br><span class="line">app.use(Router.routes())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Starting at 3000...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>打开 <code>http://localhost:3000/index</code>：</p><ul><li><p>匹配成功，浏览器会显示 “首页”，控制台会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting at 3000...</span><br><span class="line">这是包含路由匹配错误处理的中间件</span><br><span class="line">开始匹配首页路由...</span><br><span class="line">&#x2F;index</span><br></pre></td></tr></table></figure></li><li><p>匹配不成功，浏览器会显示 “这是一个404页面”，控制台会打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是包含路由匹配错误处理的中间件</span><br><span class="line">开始匹配首页路由...</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="另附链接"><a href="#另附链接" class="headerlink" title="另附链接"></a>另附链接</h3><blockquote><p>关于中间件的学习就到这里，中间件的原理之后再详细探讨</p></blockquote><ol><li><a href="https://www.imooc.com/article/details/id/280772">50行代码学会koa2中间件原理</a></li><li><a href="https://zhuanlan.zhihu.com/p/34874785">koa中间件总结</a></li><li><a href="https://zhuanlan.zhihu.com/p/150700836">Koa2第二篇：中间件</a></li><li><a href="https://blog.csdn.net/sinat_17775997/article/details/82898312">Koa2 中间件原理解析</a></li><li><a href="https://www.bookstack.cn/read/koa-docs-Zh-CN-v2.7.0/Readme.md#%E4%B8%AD%E9%97%B4%E4%BB%B6">Koa v2.7.0 中文文档 — 中间件</a></li><li><a href="https://wizardforcel.gitbooks.io/koa-doc/content/3.html">koa 中文文档 — 应用</a></li></ol><hr><h2 id="Request-amp-Response"><a href="#Request-amp-Response" class="headerlink" title="Request &amp; Response"></a>Request &amp; Response</h2><blockquote><p>在 <a href="https://www.w3cways.com/doc/koa/">koa 官方文档</a> 中，许多都在介绍 HTTP 的请求和响应，这里举例一些</p></blockquote><h3 id="Koa-Request"><a href="#Koa-Request" class="headerlink" title="Koa Request"></a>Koa Request</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header</span></span><br><span class="line">ctx.request.headers  </span><br><span class="line">ctx.request. protocol</span><br><span class="line">ctx.request.type</span><br><span class="line">ctx.request.charset</span><br><span class="line"></span><br><span class="line"><span class="comment">// method</span></span><br><span class="line">ctx.request.method</span><br><span class="line">ctx.request.query  <span class="comment">// get</span></span><br><span class="line">ctx.request.body  <span class="comment">// post | 依赖 koa-bodyparse 第三方模块，后面章节有描述</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// path</span></span><br><span class="line">ctx.request.url  <span class="comment">// path/?get=</span></span><br><span class="line">ctx.request.path  <span class="comment">// path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// host</span></span><br><span class="line">ctx.request.host  <span class="comment">// hostname:port</span></span><br><span class="line">ctx.request.hostname  <span class="comment">// hostname</span></span><br><span class="line">ctx.request.ip</span><br><span class="line">crx.request.subdomains </span><br><span class="line"></span><br><span class="line"><span class="comment">// cookie</span></span><br><span class="line">ctx.cookies.get(<span class="string">&#x27;name&#x27;</span>)  <span class="comment">// 获取 cookie</span></span><br><span class="line">ctx.cookies.set(name, value, &#123;  <span class="comment">// 设置 cookie</span></span><br><span class="line">  <span class="string">&#x27;expires&#x27;</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()  <span class="comment">// 时间</span></span><br><span class="line">  <span class="string">&#x27;path&#x27;</span> : <span class="string">&#x27;/&#x27;</span>  <span class="comment">// 路径</span></span><br><span class="line">  <span class="string">&#x27;domain&#x27;</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>  <span class="comment">// 域</span></span><br><span class="line">  <span class="string">&#x27;httpOnly&#x27;</span>: <span class="literal">false</span>  <span class="comment">// 禁止js获取</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// error</span></span><br><span class="line">ctx.throw(<span class="number">404</span>, <span class="string">&#x27;Not found&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Koa-Response"><a href="#Koa-Response" class="headerlink" title="Koa Response"></a>Koa Response</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// header</span></span><br><span class="line">ctx.set(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// status</span></span><br><span class="line">ctx.response.status = <span class="number">200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type</span></span><br><span class="line">ctx.response.type = <span class="string">&#x27;text/html; charset=utf-8&#x27;</span>  <span class="comment">// defaule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// redirect</span></span><br><span class="line">ctx.response.redirect(url)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa2入门（二）：知识回顾—异步处理</title>
      <link href="c926936fceae/"/>
      <url>c926936fceae/</url>
      
        <content type="html"><![CDATA[<h2 id="Async-Await-和-Promise-的使用"><a href="#Async-Await-和-Promise-的使用" class="headerlink" title="Async/Await 和 Promise 的使用"></a>Async/Await 和 Promise 的使用</h2><ol><li><p>async 方法以及 Promise 都来自 koa 的底层，可以让你编写非阻塞序列代码。</p></li><li><p>async 是让方法变为异步，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">testAsync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello Async&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = testAsync()</span><br><span class="line"><span class="built_in">console</span>.log(result)  <span class="comment">// Promise &#123; &#x27;Hello Async&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>await 会等待 async 执行完毕，await 等待的是一个表达式，在官方文档中即 promise 对象，但是它也可以接受普通值。注意，await 必须在 async 方法中才能使用，因为 await 访问本身就会造成程序阻塞停止，所以必须在异步方法中才能使用。例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ordinaryGetData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ordinaryGetData()&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncGetData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;asyncGetData()&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//await 返回普通值</span></span><br><span class="line">    <span class="keyword">const</span> result_1 = <span class="keyword">await</span> ordinaryGetData()</span><br><span class="line">    <span class="built_in">console</span>.log(result_1)  <span class="comment">// ordinaryGetData</span></span><br><span class="line">    <span class="comment">//await 返回 promise 对象</span></span><br><span class="line">    <span class="keyword">const</span> result_2 = <span class="keyword">await</span> asyncGetData()</span><br><span class="line">    <span class="built_in">console</span>.log(result_2)  <span class="comment">// asyncGetData</span></span><br><span class="line">&#125;</span><br><span class="line">result()</span><br></pre></td></tr></table></figure></li><li><p>综上所述，async 用于申明一个 function 是异步的，它会将其后的函数返回值封装成一个 promise 对象，而 await 用于等待一个异步方法（即 promise）执行完成，并将其 resolve 的结果返回出来</p></li></ol><hr><h2 id="案例理解"><a href="#案例理解" class="headerlink" title="案例理解"></a>案例理解</h2><ol><li><p>执行下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSyncTime</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> endTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">                <span class="keyword">let</span> data = endTime - startTime</span><br><span class="line">                resolve(data)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125; <span class="keyword">catch</span> (srr) &#123;</span><br><span class="line">            reject(err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getSyncData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="keyword">await</span> getSyncTime()</span><br><span class="line">    <span class="keyword">let</span> data = <span class="string">`endTime - startTime = <span class="subst">$&#123;time&#125;</span>.`</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> data = <span class="keyword">await</span> getSyncData()</span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData()</span><br></pre></td></tr></table></figure></li><li><p>得出结论：</p><ul><li>可以用同步的写法实现异步逻辑</li><li>最底层的 await 返回需要 Promise 对象</li><li>可以用多层 async function 的写法代替传统的回调嵌套</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>koa2入门（一）：初识-koa2</title>
      <link href="b11a35911dc2/"/>
      <url>b11a35911dc2/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。</p><p>Koa 通过 node.js 实现了一个十分具有表现力的 HTTP 中间件框架，力求让 Web 应用开发和 API 使用更加地愉快。Koa 的中间件之间按照编码顺序在栈内依次执行，允许您执行操作并向下传递请求（downstream），之后过滤并逆序返回响应（upstream）。</p><p>几乎所有 HTTP 服务器通用的方法都被直接集成到 Koa 大约570行源码的代码库中。其中包括内容协商，节点不一致性的规范化，重定向等等操作。</p><p>另外，Koa 没有捆绑任何中间件。</p><hr><h2 id="koa2-特性"><a href="#koa2-特性" class="headerlink" title="koa2 特性"></a>koa2 特性</h2><ol><li>只提供已经封装好了的 http 上下文、请求、响应，以及基于 <code>async/await</code> 的中间件容器</li><li>利用 ES7 的 <code>async/await</code> 来处理传统的回调嵌套问题以及代替 koa v1 中的 <code>generator</code>，不过要注意，需要在 node7.x 的 <code>harmony</code>   模式下才能支持 <code>async/await</code></li><li>中间件只支持 <code>async/await</code> 封装，如果要使用基于 koa v1 中 <code>generator</code> 的中间件，需要用中间件 <code>koa-convert</code> 封装一下才行</li></ol><hr><h2 id="koa2-快速开始"><a href="#koa2-快速开始" class="headerlink" title="koa2 快速开始"></a>koa2 快速开始</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install koa</span><br></pre></td></tr></table></figure><ul><li>此时我的版本是：<code>&quot;koa&quot;: &quot;^2.13.0&quot;</code></li></ul><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">&quot;koa&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa()</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx) =&gt; &#123;</span><br><span class="line">    ctx.body = <span class="string">&quot;Hello Koa2&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;listening...&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>打开 <code>http://localhost:3000/</code>，查看结果</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> koa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express 入门</title>
      <link href="51ef113f0712/"/>
      <url>51ef113f0712/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>创建一个目录，并将此目录作为当前的工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir myapp</span><br><span class="line">$ cd myapp</span><br></pre></td></tr></table></figure></li><li><p>初始化项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>打开 <code>package.json</code>，注意 “main” 为 <code>index.js</code>，这是它默认的入口文件，将其修改为 <code>app.js</code></p></li></ol><ul><li>关于 package.json 的作用，请参考：<a href="https://docs.npmjs.com/files/package.json">Specifics of npm’s package.json handling</a></li></ul><ol start="4"><li><p>安装 express</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express --save</span><br></pre></td></tr></table></figure><ul><li><p>安装 Node 模块时，如果指定了 <code>--save</code> 参数，那么此模块将被添加到 <code>package.json</code> 文件中 <code>dependencies</code> 依赖列表中。 然后通过 <code>npm install</code> 命令即可自动安装依赖列表中所列出的所有模块</p></li><li><p>如果只是临时安装 Express，不想将它添加到依赖列表中，只需略去 <code>--save</code> 参数即可：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><ol><li><p>注意，这里创建的是一个最简单的应用，并且只有一个文件，这和 <code>Express 应用生成器</code> 创建的完全不一样，Express 应用生成器所创建的应用框架包含多个 JavaScript 文件、Jade 模板 和 针对不同用途的子目录</p></li><li><p>进入 myapp 目录，创建 <code>app.js</code>（这里的命名源于之前 package.json 修改的命名）</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Example app listening at http://%s:%s&#x27;</span>, host, port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>命令行启动</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure></li><li><p>打开 <a href="http://localhost:3000/">http://localhost:3000/</a> 就可以看到结果了</p></li><li><p>单独的文件</p><ul><li><p>当路由过多时，需要单独建立一个文件来存放路由，在根目录下新建一个 <code>routes</code> 目录，再在其目录中新建 <code>index.js</code></p></li><li><p>修改 <code>myapp/app.js</code> 与 <code>myapp/routes/index.js</code> 的内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myapp/app.js</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> routes = <span class="built_in">require</span>(<span class="string">&#x27;./routes&#x27;</span>)(app);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = app.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> host = server.address().address;</span><br><span class="line">    <span class="keyword">var</span> port = server.address().port;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Example app listening at http://%s:%s&#x27;</span>, host, port);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myapp/routes/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">    app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">        res.send(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="运行原理"><a href="#运行原理" class="headerlink" title="运行原理"></a>运行原理</h2><ol><li>底层：http 模块<ul><li>Express 框架建立在 Node 内置的 http 模块的基础上，http 模块生成服务器的的原始代码如下：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span>&#125;);</span><br><span class="line">    response.end(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="string">&quot;localhost&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>上述代码中的 <code>createServer</code> 方法便表示生成一个服务器，<br>  该方法接受一个回调函数，即 <code>function(request, response)&#123; ... &#125;</code>，这两个参数 <code>request</code> 与 <code>response</code> 分别代表 HTTP 的请求和回应</li><li>express 的核心是对 http 模块的再包装，上述代码用 express 可以简写为如下：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li>比较上面两段代码，之前是用 <code>http.createServer</code> 创建一个实例，之后用的是 <code>Express的构造方法</code> 生成一个实例。两者的回调函数是相同的，express 相当于在 http 模块上加了一个中间层</li></ul></li><li>什么是中间件<ul><li>简单说，<code>中间件（middleware）</code>就是处理 HTTP 请求的函数</li><li>它最大的特点，就是一个中间件处理完，再传递给下一个中间件，app 实例在运行过程中，会调用一系列的中间件</li><li>中间件作为处理 http 请求的函数，每一个中间件都可以从 app 实例中获得三个参数：<ul><li><strong>request 对象</strong>：代表 HTTP 请求</li><li><strong>response 对象</strong>：代表 HTTP 回应</li><li><strong>next 回调函数</strong>：代表下一个中间件</li></ul></li><li>每个中间件都能对 http 请求（即 resquest 对象）进行加工，并且决定是否调用 next 方法，并将 request 对象传给下一个中间件</li><li>一个不进行任何操作，只传递 request 对象的中间件，就如同以下：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码的 next 就是下一个中间件， 如果它带有参数，就代表着已经抛出错误，参数一般为错误文本  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uselessMiddleware</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    next(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止</li></ul></li></ul></li><li>use 方法<ul><li>use 是 express 注册中间件的方法，它返回一个函数，下面的代码中使用了两个 <code>app.use</code> 方法，注册了两个中间件，然后连续调用两个中间件  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;In comes a &quot;</span> + request.method + <span class="string">&quot; to &quot;</span> + request.url);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    response.end(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li>上述代码中，HTTP 收到请求之后，先调用第一个中间件，在控制台输出一行信息，然后通过 <code>next</code> 方法，将执行权传给第二个中间件，输出 HTTP 回应<br>  由于第二个中间件没有调用 next 方法，所以 request 对象就不再向后传递了</li><li><code>use</code> 方法内部可以对访问进行判断，即根据不同的请求网址返回不同的网页内容，这能实现简单的路由，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.url == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">        response.end(<span class="string">&quot;Welcome to the homepage!\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (request.url == <span class="string">&quot;/about&quot;</span>) &#123;</span><br><span class="line">        response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;  <span class="comment">//注意，判断 404 没有判断 url</span></span><br><span class="line">    response.writeHead(<span class="number">404</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    response.end(<span class="string">&quot;404 error!\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li><li>上述代码通过 <code>app.use</code> 方法注册了三个中间件，再通过 <code>request.url</code>，根据请求的网址判断执行的内容，只要路径匹配，就不会将执行权交给下一个中间件，因此，在代码中，最后的 <code>else</code> 部分即为无效匹配时的返回内容</li><li>除了在回调函数中判断请求网址，use 方法也可在第一个参数中判断匹配，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&#x27;/path&#x27;</span>, someMiddleware);</span><br></pre></td></tr></table></figure>  这表示仅仅在网址匹配成功的情况下才执行之后的中间件</li><li>因此，上个案例中的代码可以改写为：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    response.end(<span class="string">&quot;Welcome to the homepage!\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&quot;/about&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    response.end(<span class="string">&quot;Welcome to the about page!\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;  <span class="comment">//注意，判断 404 没有判断 url</span></span><br><span class="line">    response.writeHead(<span class="number">404</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    response.end(<span class="string">&quot;404 error!\n&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="Express-方法"><a href="#Express-方法" class="headerlink" title="Express 方法"></a>Express 方法</h2><ol><li>HTTP 动词方法<ul><li>之前使用了很多次 <code>get</code> 方法，除此之外，Express 还提供了 <code>post</code>、<code>put</code>、<code>delete</code> 等方法，即 HTTP 动词都是 express 方法</li><li>这些方法的第一个参数都是请求的路径，除了绝对匹配之外（如之前的 if 判断），express 允许匹配模式，例如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/hello/:who&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.end(<span class="string">&quot;Hello, &quot;</span> + req.params.who + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>上面的代码将匹配诸如 <code>/hello/xxx</code> 此类的网址，网址中的 <code>xxx</code> 将作为 <code>req.params.who</code> 属性的值</li><li>注意，捕获后需要对网址进行安全性检查，以过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值</li></ul></li><li>如果在参数模式后面加上问号，表示该参数可选，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/hello/who?&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.params.id) &#123;</span><br><span class="line">        res.end(<span class="string">&quot;Hello, &quot;</span> + req.params.id + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        res.end(<span class="string">&quot;Hello Guest.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>  更复杂的匹配规则如下  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&#x27;/forum/:fid/thread/:tid&#x27;</span>, middleware);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配 &quot;/commits/71dbb9c&quot;</span></span><br><span class="line"><span class="comment">// 或 &quot;/commits/71dbb9c..4c084f9&quot; 这样的 git 格式的网址</span></span><br><span class="line">app.get(<span class="regexp">/^\/commits\/(\w+)(?:\.\.(\w+))?$/</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">from</span> = req.params[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> to = req.params[<span class="number">1</span>] || <span class="string">&#x27;HEAD&#x27;</span>;</span><br><span class="line">    res.send(<span class="string">&#x27;commit range &#x27;</span> + <span class="keyword">from</span> + <span class="string">&#x27;..&#x27;</span> + to);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li>all 方法<ul><li>之前的 <code>app.get</code> 方法中，第一个参数可以指定匹配的网址，<code>app.all</code> 方法则表示所有的请求都要执行该中间件，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.all(<span class="string">&quot;*&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response, next</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123; <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/plain&quot;</span> &#125;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">&quot;Welcome to the homepage!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/about&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">&quot;Welcome to the about page!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;*&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.end(<span class="string">&quot;404!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">http.createServer(app).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><ul><li>上述代码的 all 方法表示，所有请求都必须通过该中间件，参数中的 <code>*</code> 表示对所有的路径都有效，同时你会注意到，我们在 app.get 方法中也同样用到了 *，但这与 app.all 不同的是，app.get 是针对 HTTP 请求的，表示所有 HTTP 请求都需通过该中间件，而 app.all 指的是所有请求</li></ul></li></ul></li><li>set 方法<ul><li><code>app.set</code> 方法用于指定变量的值，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.set(<span class="string">&quot;views&quot;</span>, __dirname + <span class="string">&quot;views&quot;</span>);</span><br><span class="line">app.set(<span class="string">&quot;view engine&quot;</span>, <span class="string">&quot;jade&quot;</span>);</span><br></pre></td></tr></table></figure>  上述代码使用 set 方法，分别为 “views” 和 “view engine” 指定值</li></ul></li><li>request 对象<ul><li>request 对象表示 HTTP 请求，包含了请求查询字符串、参数、内容、HTTP 头部等属性，常见属性如下：<br><img src="https://user-images.githubusercontent.com/49378661/78871207-efbd1800-7a79-11ea-85bb-e015cb6d455c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/78871207-efbd1800-7a79-11ea-85bb-e015cb6d455c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li></ul></li></ol><hr><h2 id="Express-生成器"><a href="#Express-生成器" class="headerlink" title="Express 生成器"></a>Express 生成器</h2><ol><li><p>通过应用生成器工具 <code>express-generator</code> 可以快速构建一个应用的框架</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install express-generator -g</span><br></pre></td></tr></table></figure><ul><li><p>在终端中使用 <code>-h</code> 参数可以列出所有可用的命令行参数</p><p><img src="https://user-images.githubusercontent.com/49378661/80309787-b4f10900-8809-11ea-9705-561ce5b30dbe.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/80309787-b4f10900-8809-11ea-9705-561ce5b30dbe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="QQ截图20200426220139"></p></li></ul></li><li><p>创建名为 <code>example</code> 的应用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ express example</span><br></pre></td></tr></table></figure><p> <img src="https://s2.ax1x.com/2020/01/26/1m3lod.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/01/26/1m3lod.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li><li><p>安装依赖文件</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd example</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure></li><li><p>启动项目</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm start</span><br></pre></td></tr></table></figure><ul><li>打开 <a href="http://localhost:3000/">http://localhost:3000/</a> 即可查看结果</li></ul></li><li><p>注：该生成器创建的应用一般有：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── app.js</span><br><span class="line">├── bin</span><br><span class="line">│   └── www</span><br><span class="line">├── package.json</span><br><span class="line">├── public</span><br><span class="line">│   ├── images</span><br><span class="line">│   ├── javascripts</span><br><span class="line">│   └── stylesheets</span><br><span class="line">│       └── style.css</span><br><span class="line">├── routes</span><br><span class="line">│   ├── index.js</span><br><span class="line">│   └── users.js</span><br><span class="line">└── views</span><br><span class="line">    ├── error.pug</span><br><span class="line">    ├── index.pug</span><br><span class="line">    └── layout.pug</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="简单路由案例"><a href="#简单路由案例" class="headerlink" title="简单路由案例"></a>简单路由案例</h2><blockquote><p>对 Express 路由做一个简单的介绍</p></blockquote><ol><li><strong>路由</strong>（Routing）是由一个 <strong>URL</strong>（或者叫路径） 和一个 <strong>特定的 HTTP</strong>（如 GET、POST） 方法，涉及到应用如何响应客户端对某个网站节点的访问</li><li>每一个路由都可以有一个或者多个处理器函数，当匹配到路由时，这些函数将被执行</li><li>路由的定义由如下结构组成：**<code>app.METHOD(PATH, HANDLER)</code>**<ul><li><code>app</code> 是一个 express 实例</li><li><code>METHOD</code> 是请求方式中的一个</li><li><code>PATH</code> 是服务器端的路径</li><li><code>HANDLER</code> 是当路径匹配成功时需要执行的函数</li></ul></li><li>下面展示几个简单的路由案例：<br> 打开 <code>routes</code> 之中的 <code>index.js</code>，并将下面的代码修改 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.render(<span class="string">&#x27;index&#x27;</span>, &#123; <span class="attr">title</span>: <span class="string">&#x27;Express&#x27;</span> &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure> 修改为： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对网站首页的访问返回 &quot;Hello World!&quot; 字样</span></span><br><span class="line">router.get(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 网站首页接受 POST 请求</span></span><br><span class="line">router.post(<span class="string">&#x27;/&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Got a POST request&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /user 节点接受 PUT 请求</span></span><br><span class="line">router.put(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Got a PUT request at /user&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// /user 节点接受 DELETE 请求</span></span><br><span class="line">router.delete(<span class="string">&#x27;/user&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="string">&#x27;Got a DELETE request at /user&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="托管静态文件"><a href="#托管静态文件" class="headerlink" title="托管静态文件"></a>托管静态文件</h2><ol><li>通过 express 内置的 <code>express.static</code> 可以托管静态文件，比如 JavaScript 文件、CSS 文件、图片等</li><li>将静态文件资源所在的目录作为参数传递给 <code>express.static</code> 中间件就可以提供静态资源文件的访问了</li><li>托管案例<ul><li>在 <code>example/public/images</code> 目录下存放一个如下的图片（命名为 <code>logo.png</code>）：<br>  <img src="https://s2.ax1x.com/2020/01/26/1m0BRg.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/01/26/1m0BRg.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>打开 <code>example/app.js</code>，添加上使用中间件的代码：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li>现在，public 目录下面的文件就可以访问了，打开 <code>http://localhost:3000/images/logo.png</code>，即可查看图片</li><li>注：所有文件的路径都是相对于存放目录的，因此，存放静态文件的目录名不会出现在 URL 中</li></ul></li><li>如果你的静态资源存放在多个目录下面，你可以多次调用 <code>express.static</code> 中间件，需添加上使用中间件的代码： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.use(express.static(<span class="string">&#x27;public&#x27;</span>));</span><br><span class="line">app.use(express.static(<span class="string">&#x27;files&#x27;</span>));</span><br></pre></td></tr></table></figure></li><li>若要想通过 <code>express.static</code> 访问的文件都存放在一个 <code>虚拟（virtual）目录</code> （即目录根本不存在）下面，可以通过静态资源目录指定一个挂在路径方式，如下所示： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.use(<span class="string">&#x27;/static&#x27;</span>, express.static(<span class="string">&#x27;public&#x27;</span>));</span><br></pre></td></tr></table></figure><ul><li>现在，你就可以通过带有 <code>/static</code> 前缀的地址来访问 public 目录下面的文件了</li><li>可将之前的 <code>http://localhost:3000/images/logo.png</code> 改为 <code>http://localhost:3000/static/images/logo.png</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> expres </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>规范</title>
      <link href="190a6fec0e4b/"/>
      <url>190a6fec0e4b/</url>
      
        <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><ol><li>模块的介绍：为了编写可维护的代码，我们会将代码模块化，在 node 中，我们将代码分别拆分到不同的 JS 文件中，一个文件就是一个模块（<code>module</code>）<ul><li>在前面一节中，我们创建了 <code>test.js</code>，其实这个 <code>test.js</code> 就是一个模块，模块名就是文件名，所以我们把这个 <code>test.js</code> 叫做 test 模块</li></ul></li><li>使用模块的好处：<ul><li>大大提高了代码的可维护性</li><li>避免函数名与变量名冲突，相同名字的函数和变量完全可以存在于不同的模块中，降低了命名冲突的风险</li></ul></li></ol><h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h3><ol><li>Node.js 提供了 <code>exports</code>和<code>require</code> 两个对象<ul><li>其中 <code>exports</code> 是模块公开的接口，<code>require</code> 用来外部获取一个模块的接口，即所获取模块的<code>exports</code>对象</li></ul></li><li>我们将创建两个文件，分别用于创建模块和使用模块，如下：<ul><li><p>创建一个文件 <code>module.js</code>，用于创建模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个叫做&quot;Hello1&quot;与&quot;Hello2&quot;两个模块，两个模块的功能是打印内容</span></span><br><span class="line"><span class="built_in">exports</span>.Hello1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello NodeJs 1&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.Hello2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello NodeJs 2&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在同级目录下再创建一个文件<code>getmodule.js</code>，来使用模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">require</span>(<span class="string">&#x27;./module&#x27;</span>);  <span class="comment">//获取文件，因为该模块在文件中</span></span><br><span class="line"><span class="comment">//现在x已经可以调用&quot;module.js&quot;中的模块</span></span><br><span class="line">x.Hello1();  <span class="comment">//x调用Hello1模块</span></span><br><span class="line">x.Hello2();  <span class="comment">//x调用Hello2模块</span></span><br></pre></td></tr></table></figure></li><li><p>运行<code>getmodule.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node getmodule.js</span><br></pre></td></tr></table></figure></li></ul></li><li>分析一下：<ul><li>上述程序中，<code>module.js</code> 通过 <code>exports</code> 对象把 <code>Hello1</code> 和 <code>Hello2</code> 作为模块的访问接口，</li><li>在<code>getmodule.js</code> 中通过 <code>require(&#39;./module&#39;)</code> 加载这个模块</li><li>然后就可以直接访问<code>module.js</code> 中 <code>exports</code>对象的成员函数了</li></ul></li></ol><h3 id="单次加载与覆盖"><a href="#单次加载与覆盖" class="headerlink" title="单次加载与覆盖"></a>单次加载与覆盖</h3><ol><li><p>上面这个例子有点类似于创建一个对象，但实际上和创建对象有本质的区别，因为 <code>require</code> 不会重复加载模块，<br> 也就是说无论调用多少次 <code>require</code>，获得的模块都是同一个，这就是单次加载</p></li><li><p>我们将两个文件修改如下：</p><ul><li><p><code>module.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.Name = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    Name = str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">exports</span>.NameOutput = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + Name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>getmodule.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="built_in">require</span>(<span class="string">&#x27;./module&#x27;</span>);</span><br><span class="line">x.Name(<span class="string">&#x27;My&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> y = <span class="built_in">require</span>(<span class="string">&#x27;./module&#x27;</span>);</span><br><span class="line">y.Name(<span class="string">&#x27;You&#x27;</span>);</span><br><span class="line">x.NameOutput();  <span class="comment">//Hello You</span></span><br></pre></td></tr></table></figure></li><li><p>用 node 运行 <code>getmodule.js</code></p></li></ul></li><li><p>结果呢？并不是打印的 <code>Hello You</code>，为什么呢？虽然我们通过模块调用，两次地改变<code>Name</code>，通过 <code>x</code> 改变 <code>Name</code> 为 <code>My</code>，通过 <code>y</code> 改变 <code>Name</code> 为 <code>You</code>，但是，我们在用 <code>x</code> 调用 <code>NameOutput</code> 方法时，为什么不是 <code>x</code> 之前修改的 <code>My</code> 呢？这是因为<code>x</code>与<code>y</code>是指向的是同一个实例，因此<code>My</code>会被<code>You</code>覆盖，最终输出结果是由后者决定的</p></li><li><p>有的时候我们想的只是把对象封装到一个模块中，比如我们重写 <code>module.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>)</span>&#123;</span><br><span class="line">        name = thyName;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>如果我们需要使用 <code>module.js</code> 中的 <code>Hello</code> 函数，那么，我们通过 <code>require(&#39;module.js&#39;).Hello</code> 来获取 <code>Hello</code> 对象，这显然很麻烦，我们可以简化如下：</p></li></ol><ul><li><p>我们新建一个<code>hello.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//定义一个函数对象，函数名为Hello</span></span><br><span class="line">    <span class="keyword">var</span> name;</span><br><span class="line">    <span class="built_in">this</span>.setName = <span class="function"><span class="keyword">function</span>(<span class="params">thyName</span>)</span>&#123;  <span class="comment">//定义一个改变name的方法</span></span><br><span class="line">        name = thyName;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">//定义一个打印name的方法</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = Hello;  <span class="comment">//暴露接口，导出模块</span></span><br></pre></td></tr></table></figure></li><li><p>这样，我们就可以直接获得这个<code>hello</code>对象了</p></li><li><p>我们新建一个 <code>getHello.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Hello = <span class="built_in">require</span>(<span class="string">&#x27;./module&#x27;</span>);  <span class="comment">//获取module.js文件，导入文件中的模块</span></span><br><span class="line">x = <span class="keyword">new</span> Hello();  <span class="comment">//实例化Hello对象</span></span><br><span class="line">x.setName(<span class="string">&#x27;Ozzie&#x27;</span>);  <span class="comment">//调用方法，改变name的值</span></span><br><span class="line">x.sayHello();  <span class="comment">//调用方法,打印name的值</span></span><br></pre></td></tr></table></figure></li><li><p>执行 <code>node getHello.js</code> 的结果是：<code>Hello Ozzie</code></p></li><li><p>上述程序中，模块接口的唯一变化就是用 <code>module.exports = Hello</code> 代替了之前的<code>exports.Hello = Hello</code></p><ul><li>其实，<code>exports</code> 本身仅仅只是一个普通的空对象，即 <code>&#123; &#125;</code>，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口<pre><code>本质上它没有任何的特殊性，所以我们也可以用其他东西来代替`exports`</code></pre></li><li>不可以通过对 <code>exports </code>直接赋值代替对 <code>module.exports</code> 赋值<pre><code>`exports`实际上只是一个和 `module.exports` 指向同一个对象的变量，它本身会在模块执行结束后释放，但`module`不会，因此只能通过指定 `module.exports` 来改变访问接口</code></pre></li></ul></li></ul><h3 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h3><ol><li><code>Node.js </code>中的包类似于 <code>C/C++</code> 的函数库，将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制，<code>Node.js</code>根据<code>CommonJS</code>规范实现了包机制，用 <code>npm</code> 来解决包的发布和获取需求</li><li><code>Node.js</code> 的包是一个目录，其中包含一个 <code>package.json</code> 文件，用与对此包的说明，虽然 <code>CommonJs</code> 对 <code>Node.js</code> 中的包有很多规范要求，但其实在平时可以不严格遵守该规范…</li><li>建立最简单的包<ul><li><p>前面也说过，模块与文件是一一对应的，当然，文件不仅可以是 <strong>JavaScript代码或二进制代码</strong>，还可以是一个文件夹，而最简单的包，就是一个以文件夹的形式建立的</p></li><li><p>我们创建一个名为<code>somepackage</code>的文件夹，在其中创建<code>index.js</code>，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.Hello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello Node.js&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>somepackage</code>之外创建一个<code>getSomepackage.js</code>，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> somPackage = <span class="built_in">require</span>(<span class="string">&#x27;./somepackage&#x27;</span>);  <span class="comment">//导入包中的模块</span></span><br><span class="line"><span class="keyword">var</span> x = somPackage.Hello();  <span class="comment">//调用方法打印结果</span></span><br></pre></td></tr></table></figure></li><li><p>执行 <code>node getSomepackage.js</code>，打印结果 为<code>Hello Node.js</code></p></li></ul></li><li>上述方法可以把文件夹封装为一个模块，即所谓的包</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node（一）：初识</title>
      <link href="8eddf70a83b2/"/>
      <url>8eddf70a83b2/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>使用 Node.js 时，我们不仅仅在实现一个应用，同时还实现了整个HTTP服务器。事实上，我们的Web应用以及对应的Web服务器基本上是一样的</li><li>在创建应用前，需要知道的是，创建 Node 应用需要：<ul><li>引入 <code>require</code> 模块：我们可以使用 require 命令来载入 node 模块</li><li>创建服务器：服务器可以监听客户端的请求，类似于 Apache、Nginx 等 HTTP 服务器</li><li>接收请求与响应请求：服务器很容易创建，客户端可以使用浏览器或者终端发送 HTTP 请求，服务器接收请求后返回响应数据</li></ul></li></ol><hr><h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><ol><li><p>引入 <code>require</code> 模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建服务器：一方面，我们使用 <code>http.createServer</code> 方法创建服务器，并使用 <code>listen</code> 方法监听 <code>3000</code> 端口；另一方面，我们通过 <code>request</code> 和 <code>response</code> 函数来接收和响应数据，创建名为 <code>test.js</code> 的实例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;)</span><br><span class="line">    response.end(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server running at http://127.0.0.1:3000/&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><code>response.writeHead</code> 表示向请求的客户端发送响应头</li><li>HTTP 状态码为 <code>200</code> 表示成功处理了请求，这也是最常见的返回状态码</li><li><code>Content-Type</code> 用于定义用户的浏览器或相关设备如何显示将要加载的数据，或者如何处理将要加载的数据，而 <code>text/plain</code> 的意思是将文件设置为纯文本的形式，浏览器在获取到这种文件时并不会对其进行处理，另外， <code>text/html</code> 的意思是浏览器在获取到这种文件时会自动调用 html 的解析器对文件进行相应的处理</li><li><code>response.end</code> 表示发送响应的数据</li></ul></li><li><p>打开终端，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><ul><li>再打开浏览器的 3000 端口，你就会看到 <code>Hello World!</code>，这就表明你创建应用成功啦！</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML+CSS+JS：写出动态滑动登录框</title>
      <link href="1a595785865c/"/>
      <url>1a595785865c/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>一段时间没有写一些静态网页样式了，今天在 B 站看了一个视频，准备每天都练练手</p></blockquote><p>B站视频：<a href="https://www.bilibili.com/video/BV1yb411E7i6?t=17">[HTML+CSS+Js]十分钟写出动态滑动登录框</a></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><code>index.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;ie=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;show-login-btn&quot;</span>&gt;</span></span><br><span class="line">        -&gt; Show Login Form</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;login-box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hide-login-btn&quot;</span>&gt;</span></span><br><span class="line">            +</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;index.html&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span> <span class="attr">class</span>=<span class="string">&quot;login-form&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;txtb&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;txtb&quot;</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;login-btn&quot;</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span> <span class="attr">disabled</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> loginBox = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;login-box&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> showBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;show-login-btn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> hideBtn = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;hide-login-btn&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">hasClass</span>(<span class="params">element, clssname</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> element.className.match(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(\\s|^)&#x27;</span> + clssname + <span class="string">&#x27;(\\s|$)&#x27;</span>))</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">addClass</span>(<span class="params">element, clssname</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (!<span class="built_in">this</span>.hasClass(element, clssname)) element.className += <span class="string">&#x27; &#x27;</span> + clssname</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">removeClass</span>(<span class="params">element, clssname</span>) </span>&#123;</span></span><br><span class="line">            if (hasClass(element, clssname)) &#123;</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;(\\s|^)&#x27;</span> + clssname + <span class="string">&#x27;(\\s|$)&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                element.className = element.className.replace(reg, <span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">toggleClass</span>(<span class="params">element, clssname</span>) </span>&#123;</span></span><br><span class="line">            if (hasClass(element, clssname)) &#123;</span><br><span class="line">                removeClass(element, clssname)</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">                addClass(element, clssname)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        showBtn[<span class="number">0</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            toggleClass(loginBox[<span class="number">0</span>], <span class="string">&#x27;showed&#x27;</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line"><span class="javascript">        hideBtn[<span class="number">0</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            toggleClass(loginBox[<span class="number">0</span>], <span class="string">&#x27;showed&#x27;</span>)</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>index.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;montserrat&#x27;</span>, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.login-box</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">    <span class="comment">/* vh 视口高度 viewport height 百分比单位*/</span></span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>( <span class="number">45deg</span>, <span class="number">#9fbaa8</span>, <span class="number">#31354c</span>);</span><br><span class="line">    <span class="comment">/*设置颜色渐变 方向(0deg垂直向上) 起点颜色 终点颜色*/</span></span><br><span class="line">    <span class="attribute">transition</span>: <span class="number">0.4s</span>;</span><br><span class="line">    <span class="comment">/*过度效果  property duration timing-function delay 默认属性:all 0 ease 0*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.login-form</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="comment">/*定义 2D 转换8 */</span></span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.login-form</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">400</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.txtb</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffffff</span>28;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">10px</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.login-btn</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#2c3e50</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">6px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hide-login-btn</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">0.7</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">    <span class="comment">/*定义 2D 转换8 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.show-login-btn</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.showed</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="https://user-images.githubusercontent.com/49378661/95670333-4e478800-0bbc-11eb-96c1-dbb9eabc590a.gif" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95670333-4e478800-0bbc-11eb-96c1-dbb9eabc590a.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1602387459981"></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS-Demo：精美的输入框</title>
      <link href="74c04119a77b/"/>
      <url>74c04119a77b/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS-盒模型</title>
      <link href="0c170b8a39ed/"/>
      <url>0c170b8a39ed/</url>
      
        <content type="html"><![CDATA[<ol><li><p>对一个文档进行布局的时候，浏览器的渲染引擎会根据CSS基础框盒模型将所有元素表示为一个个矩形盒，CSS决定这些盒子的大小、位置以及属性。</p></li><li><p>可以认为，HTML 的每个标签都是一个方块，这个方块又包着几个小方块，如同盒子一样，一层一层包裹着，这就是盒模型。</p></li><li><p>盒模型分为IE盒模型和W3C标准盒模型。两者区别如下：</p><ul><li><p>IE盒模型：属性 width与height 包含 content、border 和 padding：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">width &#x3D; content(内容的宽度) + border(边框) + padding(内边距)</span><br><span class="line">height &#x3D; content(内容的高度) + border(边框) + padding(内边距)</span><br><span class="line">注意，这里是只加 border 和 padding，不加 margin(外边距)</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/2/20/1690b790ce3a56a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/2/20/1690b790ce3a56a0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IE盒模型"></p></li><li><p>W3C标准盒模型：属性 width 与 height 只包含 content：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">width &#x3D; 内容的宽度</span><br><span class="line">height &#x3D; 内容的高度</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2019/2/20/1690b7a232e7e1fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" class="lazyload" data-srcset="https://user-gold-cdn.xitu.io/2019/2/20/1690b7a232e7e1fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="标准盒模型"></p></li><li><p>在 IE6、IE7 中，docutype 缺失则会触发 IE 模式。在 IE8 中，可以通过CSS新增的属性 box-sizing 来选择使用哪一个盒模型，默认为 content-box，即标准盒模型，若设置为 border-box，则为IE盒模型。</p></li><li><p>当前的 W3C 标准中，盒模型可以通过 box-sizing 自由切换。</p></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> css </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Axios-笔记</title>
      <link href="e5f790a29ad3/"/>
      <url>e5f790a29ad3/</url>
      
        <content type="html"><![CDATA[<h2 id="Axios-介绍"><a href="#Axios-介绍" class="headerlink" title="Axios 介绍"></a>Axios 介绍</h2><ol><li><p>基于 promise 的，用于浏览器和 NodeJs 的 HTTP 客户端</p></li><li><p>特点：</p><ul><li>支持浏览器和 Node.js</li><li>支持 promise</li><li>能拦截请求和响应</li><li>能转换请求和响应数据</li><li>能取消请求</li><li>自动转换 JSON 数据</li><li>浏览器端支持防止 CSRF（跨站请求伪造）</li></ul></li><li><p>官网：</p><ul><li><a href="http://www.axios-js.com/zh-cn/docs/">axios中文文档|axios中文网</a></li><li><a href="https://www.kancloud.cn/yunye/axios/234845">Axios 中文说明</a></li></ul></li><li><p>安装 axios：</p><ul><li><p>CSD 引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Npm 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></li><li><p>Bower 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bower install axios</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="Axios-使用"><a href="#Axios-使用" class="headerlink" title="Axios 使用"></a>Axios 使用</h2><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><ol><li><p>发送一个 get 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(response))</span><br><span class="line">  .then(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure><ul><li><p>以上请求也可以变式为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID:<span class="number">12345</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(response))</span><br><span class="line">.then(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>发送一个 post 请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user&#x27;</span>, &#123;</span><br><span class="line">  firstName: <span class="string">&#x27;Ozzie&#x27;</span>,</span><br><span class="line">  lastName: <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(response))</span><br><span class="line">.then(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure></li><li><p>同时发起多个请求：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getUserAccout = <span class="function">() =&gt;</span> &#123; axios.get(<span class="string">&#x27;/user?ID=12345&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">let</span> getUserPermissions = <span class="function">() =&gt;</span> &#123; axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>); &#125;</span><br><span class="line">axios.all([getUserAccout(), getUserPermissions()])</span><br><span class="line">.then(axios.spread(<span class="function"><span class="keyword">function</span> (<span class="params">acct, perms</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">// 两个请求完成时，触发此函数，acct 与 perms 分别代表两个请求返回的结果</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="Axios-API"><a href="#Axios-API" class="headerlink" title="Axios API"></a>Axios API</h3><blockquote><p>可以通过设置 axios 的配置来创建请求</p></blockquote><ol><li><p><code>axios(config)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 post 请求</span></span><br><span class="line">axios.post(&#123;</span><br><span class="line">  method: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">  url: <span class="string">&#x27;/user/12345&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Ozzie&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>axios(url[,config])</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 get 请求</span></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line"><span class="comment">// 如果不指明何种请求，则默认 get</span></span><br><span class="line">axios(<span class="string">&#x27;/user/12345&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br></pre></td></tr></table></figure></li><li><p>请求方法的别名：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(url[,config])</span><br><span class="line"></span><br><span class="line">axios.post(url[,data,[,config]])</span><br><span class="line"></span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.delete(url[,config])</span><br><span class="line"></span><br><span class="line">axios.head(url[,config])</span><br><span class="line"></span><br><span class="line">axios.patch(url,[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.request(config)</span><br></pre></td></tr></table></figure><ul><li>在使用方法名时，url、method、data 这些属性都可以不在配置（config）中指定，也不用在config 中重复声明。</li></ul></li><li><p>同时发生的请求（以下两个是用来处理同时发生多个请求的辅助函数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iterable 是一个可迭代的参数，比如数组</span></span><br><span class="line">axios.all(iterable);</span><br><span class="line"></span><br><span class="line"><span class="comment">// callback 要等到所有请求都完成才会执行</span></span><br><span class="line">axios.spread(callback);</span><br></pre></td></tr></table></figure></li><li><p>创建实例（可以用自定义配置来新建一个 axios 实例，自定义配置需要用到 <code>axios.create([config])</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">1000</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;X-Custom-Header&#x27;</span>: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>实例方法（以下是可用的实例方法，指定的配置将与实例的配置合并，即额外声明的配置会和<code>axios.create</code> 创建的实例的配置合并）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios#get(url[,config])</span><br><span class="line"></span><br><span class="line">axios#post(url[,data,[,config]])</span><br><span class="line"></span><br><span class="line">axios#put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios#delete(url[,config])</span><br><span class="line"></span><br><span class="line">axios#head(url[,config])</span><br><span class="line"></span><br><span class="line">axios#patch(url,[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios#request(config)</span><br></pre></td></tr></table></figure></li></ol><h3 id="请求的配置"><a href="#请求的配置" class="headerlink" title="请求的配置"></a>请求的配置</h3><blockquote><p>这些是创建请求时可以用的配置选项，其中只有 url 是必需的</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// url 是用于请求服务器的 url</span></span><br><span class="line">  url: <span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// method 是创建请求所使用的方法</span></span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>, <span class="comment">// 若没有指定 method，则默认请求为 get</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// baseURL 的值会自动加在 url 前面，除非 url 是一个绝对的 url</span></span><br><span class="line">  <span class="comment">// 通过设置一个 baseURL 便于为 axios 实例方法传递相对 url</span></span><br><span class="line">  baseURL: <span class="string">&#x27;https://some-domain.com/api/&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transformRequest 允许在向服务器发送请求前修改请求数据</span></span><br><span class="line">  <span class="comment">// 只能用在 put、post、patch 这几个请求方法上面</span></span><br><span class="line">  transformRequest: [<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 数组中的函数必须返回一个字符串，或者 ArrayBuffer，或者 Stream</span></span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// transformResponse 允许在传递 then/catch 之前修改响应数据</span></span><br><span class="line">  transformResponse: [<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data; <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// headers 是即将被发送的自定义请求头</span></span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">&#x27;X-Request-With&#x27;</span>: <span class="string">&#x27;XMLHttpRequest&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// params 是即将与请求一起发送的 url 参数</span></span><br><span class="line">  <span class="comment">// 必须是一个无格式对象（plain object）或者 URLSearchParams 对象</span></span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: <span class="number">12345</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// paramsSerializer 是一个负责 params 序列化的函数</span></span><br><span class="line">  paramsSerializer: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Qs.stringify(params, &#123; <span class="attr">arrayFormat</span>: <span class="string">&#x27;brackets&#x27;</span> &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// data 是作为请求主体被发送的数据</span></span><br><span class="line">  <span class="comment">// 适用的请求方法只有：put、post、patch</span></span><br><span class="line">  <span class="comment">/* 若没有设置 transformRequest，则必须是以下类型之一：</span></span><br><span class="line"><span class="comment">     string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span></span><br><span class="line"><span class="comment">     浏览器专属：FormData, File, Blob</span></span><br><span class="line"><span class="comment">     Node 专属：Stream</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: <span class="string">&#x27;Ozzie&#x27;</span>,</span><br><span class="line">    lastName: <span class="string">&#x27;Nicholas&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// timeout 指定了请求超时的毫秒数（0 表示无超时时间），请求超时则会中断</span></span><br><span class="line">  timeout: <span class="number">1000</span>,  <span class="comment">// 默认值为0，即默认永不超时</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// withCredentials 表示跨域请求时是否需要凭证</span></span><br><span class="line">  withCredentials: <span class="literal">false</span>, <span class="comment">// 不指定值则默认为 false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// adapter 允许自定义处理请求，以使测试更轻松</span></span><br><span class="line">  <span class="comment">// 返回一个 promise 并应用一个有效的响应</span></span><br><span class="line">  adapter: <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// auth 表示应该使用 HTTP 基础验证，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将设置一个 Authorization 头，覆写掉现有的任意使用 header 设置的自定义 Authorization 头</span></span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">    password: <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// responseType 表示服务器响应的数据类型</span></span><br><span class="line">  <span class="comment">// 数据类型可选值：&#x27;arrayBuffer&#x27;, &#x27;blob&#x27;, &#x27;document&#x27;, &#x27;json&#x27;, &#x27;text&#x27;, &#x27;stream&#x27;</span></span><br><span class="line">  responseType: <span class="string">&#x27;json&#x27;</span>, <span class="comment">// 默认值为 &#x27;json&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// xsrfCookieName 是用作 xsrf token 的值的 HTTP 头的名称</span></span><br><span class="line">  xsrfCookieName: <span class="string">&#x27;X-XSRF-TOKEN&#x27;</span>, <span class="comment">//默认值为 &#x27;X-XSRF-TOKEN&#x27;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// onUploadProgress 允许为上传处理进度事件</span></span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onDownloadProgress 允许为下载处理进度事件</span></span><br><span class="line">  onDownloadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">progressEvent</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对原生进度事件的处理</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// maxContentLength 的值会定义允许的响应内容的最大尺寸</span></span><br><span class="line">  maxContentLength: <span class="number">2000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// validateStatus 定义对于给定 HTTP 的响应状态码是 resolve 或 reject promise</span></span><br><span class="line">  <span class="comment">// 若 validateStatus 返回 true (或者设置为 null 或 undefined)，promise 将被 resolve; 否则，promise 将被 rejecte</span></span><br><span class="line">  validateStatus: <span class="function"><span class="keyword">function</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>; <span class="comment">// 默认为此</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// httpAgent 和 httpsAgent 分别在 node 中用于定义在执行 http 和 https 时使用的自定义代理</span></span><br><span class="line">  <span class="comment">// 允许像如下的配置选项（keepAlive 默认没有启用）：</span></span><br><span class="line">  httpAgent: <span class="keyword">new</span> http.Agent(&#123;</span><br><span class="line">    keepAlive: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  httpsAgent: <span class="keyword">new</span> http.Agent(&#123;</span><br><span class="line">    keepAlive: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// proxy 定义代理服务器的主机名称和端口</span></span><br><span class="line">  <span class="comment">// auth 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span></span><br><span class="line">  <span class="comment">// 这将会设置一个 Proxy-Authorization 头，覆写掉已有的通过使用 header 设置的自定义Proxy-Authorization 头</span></span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: <span class="string">&#x27;127.0.0.1&#x27;</span>,</span><br><span class="line">    port: <span class="number">8000</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      username: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">      password: <span class="string">&#x27;000000&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// cancelToken 指定用于取消请求的 cancel token</span></span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于配置参数 params 中提到的 “无格式对象或 URLSearchParams”：<a href="https://segmentfault.com/q/1010000021782635">axios的参数必须是：无格式对象(plain object)或 URLSearchParams 对象是什么意思？</a></li><li>关于序列化函数 paramsSerializer：<ul><li><a href="https://github.com/nuxt-community/axios-module/issues/4">Configure custom paramsSerializer</a></li><li><a href="https://www.cnblogs.com/lou-0820/p/13807466.html">axios get传递数组 paramsSerializer序列化</a></li><li><a href="https://api.jquery.com/jquery.param/">jQuery.param()</a></li><li><a href="https://www.npmjs.com/package/qs">qs - npm</a></li></ul></li></ul><h3 id="响应的结构"><a href="#响应的结构" class="headerlink" title="响应的结构"></a>响应的结构</h3><ol><li><p>请求的响应内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 服务端返回的数据</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 服务端返回的状态码</span></span><br><span class="line">  status: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 服务端返回的状态信息</span></span><br><span class="line">  statusText: OK,</span><br><span class="line">  <span class="comment">// 响应头（所有的响应头名称都是小写）</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  <span class="comment">// axios 配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用 then 方法接收响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 catch 方法或者传递 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then">rejection callback</a> 作为 then 的第二个参数时，响应可以通过 error 对象被使用。</p></li></ul></li></ol><h3 id="配置默认值"><a href="#配置默认值" class="headerlink" title="配置默认值"></a>配置默认值</h3><blockquote><p>在各个配置参数上，都可以指定各个请求的配置默认值</p></blockquote><ol><li><p>全局的 axios 配置默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.default.baseURL = <span class="string">&#x27;https://api.example.com&#x27;</span>;</span><br><span class="line">axios.default.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = AUTH_TOKEN;</span><br><span class="line">axios.default.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>自定义的实例默认值：</p><ul><li><p>创建实例时就设置配置的默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;https://api.example.com&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>实例创建之后修改默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instance.default.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置的先后顺序：配置会按照优先级的顺序进行合并，优先级为：<code>设置请求的 config 值</code> &gt; <code>实例的 default 属性</code> &gt; <code>lib/default.js 中的默认值（库的默认值）</code></p><ul><li><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用由库提供的配置的默认值来创建实例</span></span><br><span class="line"><span class="comment">// 此时超时配置的默认值是 `0`</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆写库的超时默认值</span></span><br><span class="line"><span class="comment">// 现在，在超时前，所有请求都会等待 2.5 秒</span></span><br><span class="line">instance.defaults.timeout = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为已知需要花费很长时间的请求覆写超时设置</span></span><br><span class="line">instance.get(<span class="string">&#x27;/longRequest&#x27;</span>, &#123;</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><ol><li><p>在请求或者响应被 then 或者 catch 方法处理之前，你可以拦截它们：</p><ul><li><p>添加一个请求拦截器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 发送请求之前需要做的事情</span></span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对请求发送错误做的事情</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>添加一个响应拦截器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">axios.interceptors.response.use(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 发送响应数据之前需要做的事情</span></span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 对响应错误做的事情</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>当然，也可以移除拦截器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myInterceptor = axios.interceptors.request.use(<span class="function">() =&gt;</span> &#123;<span class="comment">/*...*/</span>&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></li><li><p>也可以为自定义的 axios 实例添加对应的拦截器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(<span class="comment">/*...*/</span>);</span><br><span class="line">instance.interceptors.request.use(<span class="function">() =&gt;</span> &#123;<span class="comment">/*...*/</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><ol><li><p>之前我们用 catch 方法简单地处理过错误发生的情况，但若发生错误，那么我们仍然可以打印出更详细的错误信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>).catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(error.response) &#123;</span><br><span class="line">    请求已经发出，但是服务器响应的状态码不在 2xx 范围内</span><br><span class="line">    <span class="built_in">console</span>.log(error.response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(error.response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(error.response.headers);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(error.request) &#123;</span><br><span class="line">    <span class="comment">// 请求发生错误要做的事情</span></span><br><span class="line">    <span class="built_in">console</span>.log(error.request);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 其他错误</span></span><br><span class="line">    <span class="built_in">console</span>.log(error.message);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(error.config);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>可以配置 validateStatus 选项来定义一个 http 状态码的错误范围：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  validateStatus: <span class="function"><span class="params">status</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status&lt;<span class="number">500</span>;  <span class="comment">// 状态码（status）在大于或者等于500时，才会拒绝</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="取消请求"><a href="#取消请求" class="headerlink" title="取消请求"></a>取消请求</h3><p>可以通过 cancel token 来取消已发送的请求：</p><ul><li><p>通过 <code>CancelToken.source</code> 工厂函数来创建一个 cancel token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> Source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  CancelToken: Source.token</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">thrown</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(axios.isCancel(thrown)) &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">&#x27;Request canceled&#x27;</span>, thrown.message);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 处理错误</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">Source.cancel(<span class="string">&#x27;Chrome canceled by the user.&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>还可以给 CancelToken 的构造函数传递一个 executor 函数来创建 cancel token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> CancelToken = axios.CancelToken;</span><br><span class="line"><span class="keyword">let</span> cancel;</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;/user/12345&#x27;</span>, &#123;</span><br><span class="line">  cancelToken: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// executor 函数接收一个 cancel 函数作为参数</span></span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 取消请求</span></span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></li></ul><p>可以用同一个 cancel token 取消多个请求</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm开发技巧</title>
      <link href="6ec7fd968a3a/"/>
      <url>6ec7fd968a3a/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每天，数以百万计的开发人员使用 npm 或者 yarn 来构建项目。无论是为客户端或服务器端，还是桌面应用程序，运行 <code>npm init</code> 或者 <code>npx create-response-app</code> 等命令来构建项目几乎是首选方式。</p><p>但是，npm 不仅仅用来初始化项目或者安装包，这里将介绍 13 个技巧来最大限度地利用 npm 从简单的快捷方式到自定义脚本。</p><p>本次内容是：</p><ul><li>快捷方式</li><li>设置默认 <code>npm init</code> 属性</li><li>让脚本跨平台兼容</li><li>并行运行脚本</li><li>在不同的目录中运行脚本</li><li>延迟运行脚本直到端口准备就绪</li><li>列出并选择可用脚本</li><li>运行前后脚本</li><li>控制应用程序版本</li><li>从命令行编辑 <code>package.json</code></li><li>自动设置和打开你的 github 库</li><li>自定义 npm init 脚本</li><li>使用自定义 npm init 脚本将你的第一个 Commit 提交到 GitHub</li></ul><hr><h2 id="快捷方式"><a href="#快捷方式" class="headerlink" title="快捷方式"></a>快捷方式</h2><h3 id="基本快捷方式"><a href="#基本快捷方式" class="headerlink" title="基本快捷方式"></a>基本快捷方式</h3><ol><li>安装：<ul><li>常规：<code>npm install</code></li><li>简写：<code>npm i</code></li></ul></li><li>测试：<ul><li>常规：<code>npm test</code></li><li>简写：<code>npm t</code></li></ul></li><li>帮助：<ul><li>常规：<code>npm --help</code></li><li>简写：<code>npm -h</code></li></ul></li><li>全局标志：<ul><li>常规：<code>--global</code></li><li>简写：<code>-g</code></li></ul></li><li>保存为开发依赖：<ul><li>常规：<code>--save-dev</code></li><li>简写：<code>-D</code></li></ul></li><li>npm init 默认值：<ul><li>常规：<code>npm init --yes</code> 或者 <code>npm init --force</code></li><li>简写：<code>npm init -y</code> 或者 <code>npm init -f</code></li></ul></li><li>另外，用 <code>--save</code>（或者 <code>-S</code>）来保存包已经是默认值，若你需要安装一个包但是不保存它，可以使用 <code>no -save</code> 标志</li></ol><h3 id="不太常见的快捷键"><a href="#不太常见的快捷键" class="headerlink" title="不太常见的快捷键"></a>不太常见的快捷键</h3><ol><li>安装包信息将加入到 optionalDependencies（可选阶段的依赖）：<ul><li>常规：<code>--save-optional</code></li><li>简写：<code>-O</code></li></ul></li><li>如果需要在本地保存一个 npm 包，或者通过单个文件下载一组可用的包，可以使用 <code>--save-bundle</code>（简写为 <code>-B</code>）来将它们捆绑在一起，并使用 <code>npm pack</code> 或者捆绑包</li></ol><h3 id="根的快捷方式"><a href="#根的快捷方式" class="headerlink" title="根的快捷方式"></a>根的快捷方式</h3><p><code>.</code> 符号通常用于表示应用程序的根目录，npm 中的应用程序入口点，就是 <code>package.json</code> 中指定为 <code>&quot;main&quot;</code> 的值：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个快捷方式也可以用于像 <code>npx create-react-app</code> 这样的命令。因此，可以运行 <code>npx create-react-app</code>，而不是使用 <code>npx create-react-app my-app</code> 去创建一个新的 my-app 目录</p><hr><h2 id="设置默认-npm-init-属性"><a href="#设置默认-npm-init-属性" class="headerlink" title="设置默认 npm init 属性"></a>设置默认 npm init 属性</h2><ol><li><p>当开始一个新的项目时，你可能会一次又一次地输入配置细节，我们可以为这些字段设置默认值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm config set init.author.name &quot;ozzie&quot;</span><br><span class="line">npm config set init.author.email &quot;ozzie@gmail.com&quot;</span><br><span class="line">npm config set init.author.url &quot;ozzie.com&quot;</span><br><span class="line">npm config set init.license &quot;MIT&quot;</span><br></pre></td></tr></table></figure><ul><li>要检查是否正确添加了这些属性，在终端输入 <code>npm config edit</code> 查看配置文件信息。当然也j可以通过直接在打开的配置文件编辑信息。</li><li>如果要编辑全局 npm 设置，使用 <code>npm config edit -g</code></li></ul></li><li><p>若要重新初始化默认设置，可以使用以下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&quot; &gt; $(npm config get userconfig)</span><br><span class="line">npm config edit</span><br></pre></td></tr></table></figure><ul><li>第一行用空字符串替换配置文件</li><li>第二行用默认设置重新填充配置文件</li></ul></li><li><p>上面的脚本将重置用户默认值，下面的脚本将重置全局默认值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;&quot; &gt; $(npm config get globalconfig)</span><br><span class="line">npm config --global edit</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="让脚本跨平台兼容"><a href="#让脚本跨平台兼容" class="headerlink" title="让脚本跨平台兼容"></a>让脚本跨平台兼容</h2><ol><li><p>任何在命令上运行的代码都有兼容性问题的风险，特别是在 Windows 和基于 unix 的系统（包括 Mac 和 Linux）之间，如果你只处理特定的项目，那么这不是问题，但许多情况下，跨平台兼容性是很有必要的，即任何开源代码或者协作项目，以及示例和教程项目，都应该能够工作，而不管操作系统是什么。</p></li><li><p>解决方案很简单，有几个选项可供选择，但效果最好的是 <code>cross-env</code>，使用 <code>npm i -D cross-env</code> 将其作为开发依赖项来安装，然后在任何环境变量之前包括关键字 <code>cross-env</code>，例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>cross-env</code> 是实现跨平台兼容性的最无缝的方法，但还有其他两个流行的 <a href="http://www.fly63.com/tool">工具</a>，它们可以帮助实现跨平台兼容性：</p><ul><li><a href="https://www.npmjs.com/package/rimraf">rimraf</a>：可以安装在全球运行跨平台脚本</li><li><a href="https://www.npmjs.com/package/shelljs">ShellJS</a>：是Unix shell命令在 node 的 api 上的可移植实现</li></ul></li></ol><hr><h2 id="并行运行脚本"><a href="#并行运行脚本" class="headerlink" title="并行运行脚本"></a>并行运行脚本</h2><ol><li><p>我们知道，可以使用 <code>&amp;&amp;</code> 来依次运行两个或多个进程，但是并行运行脚本呢？</p></li><li><p>我们可以从各种 npm 包中进行选择，<a href="https://www.npmjs.com/package/concurrently">concurrent</a> 和 <a href="https://www.npmjs.com/package/concurrently">npm-run-all</a> 是最流行的解决方案。</p></li><li><p>首先通过 <code>npm i -D concurrently</code> 安装开发依赖，然后按照以下格式将其添加到脚本中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;concurrently \&quot;command1 arg\&quot; \&quot;command2 arg\&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="在不同的目录中运行脚本"><a href="#在不同的目录中运行脚本" class="headerlink" title="在不同的目录中运行脚本"></a>在不同的目录中运行脚本</h2><ol><li><p>有时，在不同的文件夹中拥有一个包含多个 package.json 文件的应用程序，从根目录访问这些脚本会很方便，而不是每次要运行脚本时导航到不同的文件夹，有两种方法可以执行此操作：</p><ul><li><p>手动 cd 并运行对应的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd folder &amp;&amp; npm start &amp;&amp; cd ..</span><br></pre></td></tr></table></figure></li><li><p>还有一个更好的解决方案，即使用 <code>--prefix</code> 标志指定路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start --prefix path&#x2F;to&#x2F;your&#x2F;folder</span><br></pre></td></tr></table></figure></li></ul></li><li><p>下面是一个工作应用程序中此解决方案的示例，我们希望在前端（在客户机目录中）和后端（在服务器目录中）运行 npm start：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;start&quot;: &quot;concurrently \&quot;(npm start --prefix client)\&quot; \&quot;(npm start --prefix server)\&quot;&quot;,</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="延迟运行脚本直到端口准备就绪"><a href="#延迟运行脚本直到端口准备就绪" class="headerlink" title="延迟运行脚本直到端口准备就绪"></a>延迟运行脚本直到端口准备就绪</h2><ol><li><p>通常，在开发全堆栈应用程序期间，咱们可能希望同时启动服务器和客户端。<code>wait-on</code> 节点模块提供了一种方便的方法来确保进程只在某些进程就绪时发生:在我们的例子中，我们有一个特定的端口。</p></li><li><p>例如，这是我在使用 react 前端的 Electron 项目中使用的 dev 脚本。同时使用，脚本并行加载表示层和 Electron 窗口。但是，使用 wait-on，只有在 <a href="http://localhost:3000/">http://localhost:3000</a> 启动好，才会打开Electron窗口。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;concurrently \&quot;cross-env BROWSER=none npm run start\&quot; \&quot;wait-on http://localhost:3000 &amp;&amp; electron .\&quot;&quot;,</span><br></pre></td></tr></table></figure></li><li><p>此外，react 默认情况下会打开一个浏览器窗口，但对于 Electron 开发来说，这是不必要的。咱们可以通过传递环境变量 BROWSER=none 来禁用此行为。</p></li></ol><hr><h2 id="列出并选择可用脚本"><a href="#列出并选择可用脚本" class="headerlink" title="列出并选择可用脚本"></a>列出并选择可用脚本</h2><ol><li><p>列出 package.json 文件中可用的脚本很简单：只需转到项目的根目录并在终端中输入 npm run。</p></li><li><p>但是有一种更方便的方法可以获得脚本列表，可以立即运行该列表，为此，全局安装 NTL（npm任务列表）模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g ntl</span><br></pre></td></tr></table></figure></li><li><p>然后在项目文件夹中运行 ntl 命令，可以获得一个可用脚本列表，并可以选择其中一个运行：<br><img src="https://mmbiz.qpic.cn/mmbiz_jpg/eXCSRjyNYcaF9wkY4M6VvWkvCm6UvSuO2OfHc6LGQBKABibM1KEVEmiblCTeFN8xUG4icDOen002NGzNR8GnSICsw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" class="lazyload" data-srcset="https://mmbiz.qpic.cn/mmbiz_jpg/eXCSRjyNYcaF9wkY4M6VvWkvCm6UvSuO2OfHc6LGQBKABibM1KEVEmiblCTeFN8xUG4icDOen002NGzNR8GnSICsw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p></li></ol><hr><h2 id="运行前后脚本"><a href="#运行前后脚本" class="headerlink" title="运行前后脚本"></a>运行前后脚本</h2><ol><li>你可能熟悉 prebuild 和 postbuild 这样的脚本，它们允许你定义在构建脚本之前或之后运行的代码。但事实上，pre 和 post可以在任何脚本之前添加，包括自定义脚本。</li><li>这不仅使你的代码更干净，而且还允许你单独运行 pre 和 post脚本。</li></ol><hr><h2 id="控制应用程序版本"><a href="#控制应用程序版本" class="headerlink" title="控制应用程序版本"></a>控制应用程序版本</h2><ol><li><p>与手动更改应用程序的版本相比，npm 提供了一些有用的快捷方式来完成这一点。要增加版本，请在运行 <code>npm version</code> 加上 <code>major</code>，<code>minor</code> 或 <code>patch</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1.0.0</span><br><span class="line">npm version patch</span><br><span class="line">&#x2F;&#x2F; 1.0.1</span><br><span class="line">npm version minor</span><br><span class="line">&#x2F;&#x2F; 1.1.0</span><br><span class="line">npm version major</span><br><span class="line">&#x2F;&#x2F; 2.0.0</span><br></pre></td></tr></table></figure></li><li><p>根据更新应用程序的频率，可以通过在每次部署时增加版本号来节省时间，使用以下脚本：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;predeploy&quot;</span>: <span class="string">&quot;npm version patch&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="从命令行编辑-package-json"><a href="#从命令行编辑-package-json" class="headerlink" title="从命令行编辑 package.json"></a>从命令行编辑 package.json</h2><ol><li><p>package.json 是一个常规的 json 文件，因此可以使用工具库 json 从命令行进行编辑。这在修改package.json 提供另外一种新的方式，允许w你q创建超出默认值的快捷方式。全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json</span><br></pre></td></tr></table></figure></li><li><p>然后，可以使用它来使用-I进行就地编辑。例如，要添加值为 “bar” 的新脚本 “foo”，这样写：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json -I -f package.json -e &#x27;this.scripts.foo=&quot;bar&quot;&#x27;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="自动设置和打开你的-github-库"><a href="#自动设置和打开你的-github-库" class="headerlink" title="自动设置和打开你的 github 库"></a>自动设置和打开你的 github 库</h2><ol><li><p>如果 package.json 文件中有 “repository”，则可以通过输入 npm repo 在默认浏览器中打开它。</p></li><li><p>如果你的项目已经连接到远程存储库，并且已经在命令行上安装了 git，那你可以使用这个命令找到你的连接存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --get remote.origin.url</span><br></pre></td></tr></table></figure></li><li><p>更好的是，如果你按照上面的提示并安装了 json 模块，可以使用下面的脚本自动将正确的存储库添加到 package.json：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json -I -f package.json -e &quot;this.repository=\&quot;$(git config --get remote.origin.url)\&quot;&quot;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="自定义-npm-init-脚本"><a href="#自定义-npm-init-脚本" class="headerlink" title="自定义 npm init 脚本"></a>自定义 npm init 脚本</h2><ol><li><p>让我们更进一步，使用我们自己的 npm init 脚本，它接受 GitHub 存储库 URL 并自动推送我们的第一个提交。在本技巧中，我们将讨论如何创建自定义 npm init 脚本。在下一个(也是最后一个)技巧中，我们将合并 git。</p></li><li><p>可以通过重定向到主目录中的 <code>.npm-init.js</code> 文件来编辑 npm init 脚本</p><ul><li>在Windows上，通常是 <code>c/Users/&lt;用户名&gt;</code>，在 Mac 上，它是 <code>/Users/&lt;用户名&gt;</code></li></ul></li><li><p>让我们首先在我们的主目录中创建一个 <code>.nmm-init.js</code> 文件。为了确保 npm init 被指向正确的文件，可以运行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set init-module ~\.npm-init.js</span><br></pre></td></tr></table></figure></li><li><p>在集成 git 之前，这里有一个简单的 .npm-init.js 文件，它模拟了默认 npm init 的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  name: prompt(<span class="string">&#x27;package name&#x27;</span>, basename || package.name),</span><br><span class="line">  version: prompt(<span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;0.0.0&#x27;</span>),</span><br><span class="line">  decription: prompt(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">  main: prompt(<span class="string">&#x27;entry point&#x27;</span>, <span class="string">&#x27;index.js&#x27;</span>),</span><br><span class="line">  repository: prompt(<span class="string">&#x27;git repository&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">  keywords: prompt(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123; <span class="keyword">return</span> s.split(<span class="regexp">/\s+/</span>) &#125;),</span><br><span class="line">  author: prompt(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#x27;</span>),</span><br><span class="line">  license: prompt(<span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;ISC&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个问题都遵循 <code>nameInPackage</code> 模式：<code>prompt(&#39;nameInPrompt&#39;,&#39;defaultValue&#39;)</code>。要在缺省情况下设置值而不带问题，只需删除 prompt 方法，如果要返回默认设置，只需删除.npm-init.js。</p></li></ol><hr><h2 id="自定义npm-init-脚本将你的第一个-Commit-提交到-GitHub"><a href="#自定义npm-init-脚本将你的第一个-Commit-提交到-GitHub" class="headerlink" title="自定义npm init 脚本将你的第一个 Commit 提交到 GitHub"></a>自定义npm init 脚本将你的第一个 Commit 提交到 GitHub</h2><ol><li><p>为了将 git 命令合并到 <code>.npm-init.js</code> 文件中，需要一种方法来控制命令行。为此，我们可以使用<code>child_process</code> 模块。在文件的顶部引入它，因为我们只需要 <code>execSync</code> 函数，所以可以使用析构赋值语法自己获取它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; execSync &#125; &#x3D; require(&#39;child_process&#39;);</span><br></pre></td></tr></table></figure></li><li><p>我还创建了一个 helper 函数，它将函数的结果打印到控制台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(execSync(func).toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们将提示输入 GitHub 存储库 URL，如果提供，我们将生 <code>README.md</code> 文件，并启动我们的第一次提交。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">repository: prompt(<span class="string">&#x27;github repository url&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (url) &#123;</span><br><span class="line">    run(<span class="string">&#x27;touch README.md&#x27;</span>);</span><br><span class="line">    run(<span class="string">&#x27;git init&#x27;</span>);</span><br><span class="line">    run(<span class="string">&#x27;git add README.md&#x27;</span>);</span><br><span class="line">    run(<span class="string">&#x27;git commit -m &quot;first commit&quot;&#x27;</span>);</span><br><span class="line">    run(<span class="string">`git remote add origin <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">    run(<span class="string">&#x27;git push -u origin master&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>总的来说，<code>.npm-init.js</code> 文件大概如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; execSync &#125; = <span class="built_in">require</span>(<span class="string">&#x27;child_process&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(execSync(func).toString())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  name: prompt(<span class="string">&#x27;package name&#x27;</span>, basename || package.name),</span><br><span class="line">  version: prompt(<span class="string">&#x27;version&#x27;</span>, <span class="string">&#x27;0.0.0&#x27;</span>),</span><br><span class="line">  decription: prompt(<span class="string">&#x27;description&#x27;</span>, <span class="string">&#x27;&#x27;</span>),</span><br><span class="line">  main: prompt(<span class="string">&#x27;entry point&#x27;</span>, <span class="string">&#x27;index.js&#x27;</span>),</span><br><span class="line">  keywords: prompt(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123; <span class="keyword">return</span> s.split(<span class="regexp">/\s+/</span>) &#125;),</span><br><span class="line">  author: prompt(<span class="string">&#x27;author&#x27;</span>, <span class="string">&#x27;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&#x27;</span>),</span><br><span class="line">  license: prompt(<span class="string">&#x27;license&#x27;</span>, <span class="string">&#x27;ISC&#x27;</span>),</span><br><span class="line">  repository: prompt(<span class="string">&#x27;github repository url&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url) &#123;</span><br><span class="line">      run(<span class="string">&#x27;touch README.md&#x27;</span>);</span><br><span class="line">      run(<span class="string">&#x27;git init&#x27;</span>);</span><br><span class="line">      run(<span class="string">&#x27;git add README.md&#x27;</span>);</span><br><span class="line">      run(<span class="string">&#x27;git commit -m &quot;first commit&quot;&#x27;</span>);</span><br><span class="line">      run(<span class="string">`git remote add origin <span class="subst">$&#123;url&#125;</span>`</span>);</span><br><span class="line">      run(<span class="string">&#x27;git push -u origin master&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url;</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>package.json</code> 文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Custom npm init&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;decription&quot;</span>: <span class="string">&quot;A test project, to demonstrate a custom npm init script.&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;Joe Bloggs &lt;joe.bloggs@gmail.com&gt; (joebloggs.com)&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;git+https://github.com/JoeBloggs/custom.git&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;bugs&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://github.com/JoeBloggs/custom/issues&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;https://github.com/JoeBloggs/custom#readme&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>你也可以通过合并 GitHub API 进一步实现这一点，这样就不需要创建一个新的存储库，这部分留给你们自己完成。</p></li></ol><hr><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>希望这篇文章能够让你了解 npm 可以实现的目标，并展示了一些提高工作效率的方法 - 无论是你知道常见的快捷方式，还是通过充分利用脚本 package.json，或编写自定义版本的 npm init</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nodemon 的认识与使用</title>
      <link href="91ea3a24f4bd/"/>
      <url>91ea3a24f4bd/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol><li>在开发环境下，通常都需要一个工具来自动重启项目，之前我们每次更改文件时都需要手动输入命令启动，nodemon 可以随时监听文件的变更，自动重启服务，以提升我们的开发效率</li><li>实现此功能的工具还有很多，比较热门的有：<code>forever</code>，<code>nodemon</code>，<code>node-dev</code>，这里只讲 nodemon，它们之间的对比请查阅：<a href="https://strongloop.com/strongblog/comparison-tools-to-automate-restarting-node-js-server-after-code-changes-forever-nodemon-nodesupervisor-nodedev/">Comparison: Tools to Automate Restarting Node.js Server After Code Changes</a></li></ol><hr><h2 id="使用与配置"><a href="#使用与配置" class="headerlink" title="使用与配置"></a>使用与配置</h2><blockquote><p>我们在目录下创建了一个 <code>app.js</code></p></blockquote><ol><li><p>安装 nodemon：</p><ul><li><p>全局安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure></li><li><p>开发环境安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev nodemon</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查看 nodemon 使用命令：<br><img src="https://user-images.githubusercontent.com/49378661/82663660-b07e0b80-9c62-11ea-80ad-5d2d6f89aac7.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82663660-b07e0b80-9c62-11ea-80ad-5d2d6f89aac7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1590143925252"></p></li><li><p>启动 node 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure></li><li><p>指定端口启动（如指定 8080 端口）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js localhost 8080</span><br></pre></td></tr></table></figure></li><li><p>延迟启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon -delay 10 app.js</span><br></pre></td></tr></table></figure><ul><li>当你修改该文件后，会延迟 10 秒才启动修改后的文件</li></ul></li><li><p>配置：nodemon 比较流行的原因之一就是它的可配置性比较高，官网给出的配置示例如：<a href="https://github.com/remy/nodemon/blob/master/doc/sample-nodemon.md">Sample nodemon.json</a>，开发环境建议可以把每个参数都写上备用，生产环境就把没有必要的参数去掉，有些字段是可以在命令行模式以参数形式给出的，可以通过 <code>-h</code> 查看，下面逐个解释：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;restartable&quot;</span>: <span class="string">&quot;rs&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;ignore&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;.git&quot;</span>,</span><br><span class="line">    <span class="string">&quot;node_modules/**/node_modules&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;verbose&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;execMap&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;js&quot;</span>: <span class="string">&quot;node --harmony&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;events&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;restart&quot;</span>: <span class="string">&quot;osascript -e &#x27;display notification \&quot;App restarted due to:\n&#x27;$FILENAME&#x27;\&quot; with title \&quot;nodemon\&quot;&#x27;&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;watch&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;test/fixtures/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;test/samples/&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;env&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;NODE_ENV&quot;</span>: <span class="string">&quot;development&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;PORT&quot;</span>: <span class="string">&quot;3000&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;ext&quot;</span>: <span class="string">&quot;js, json&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;legacy-watch&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&quot;restartable&quot;</code>：重启的命令，默认是 <code>rs</code>，当你用 nodemon 启动应用时，可以直接键入 rs 来重启服务，你也可以不使用 rs 而去自定义一个字符串，除去字符串外，还可以设置 false 值，意思是当 nodemon 影响了你自己的终端命令时，设置为 false 则不会在 nodemon 运行期间监听 rs 的重启命令</li><li><code>&quot;ignore&quot;</code>：设置要忽略的文件后缀名或者要忽略的文件夹，文件路径的书写用相对于 <code>nodemon.json</code> 所在位置的相对路径</li></ul></li></ol><hr><p>暂时写到这里，其他的配置项我暂且用不到，之后再更新吧(#^.^#)</p><p>参考文档：</p><ul><li><a href="https://www.cnblogs.com/chris-oil/p/6239097.html#top">nodemon 基本配置与使用</a> </li><li><a href="https://www.npmjs.com/package/nodemon">npm — nodemon 官方文档</a></li><li><a href="https://zhuanlan.zhihu.com/p/96720675">nodemon 入门介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm命令总结</title>
      <link href="6f79ae89aaf9/"/>
      <url>6f79ae89aaf9/</url>
      
        <content type="html"><![CDATA[<ol><li><strong><code>npm adduser</code></strong><ul><li>添加用户</li></ul></li><li><strong><code>npm access</code></strong><ul><li>设置包的权限</li></ul></li><li><strong><code>npm bugs</code></strong><ul><li>打开包的bugs 报告页面</li></ul></li><li><strong><code>npm bin [—-global]</code></strong><ul><li>查看npm 可执行文件的目录</li></ul></li><li><strong><code>npm config get registry</code></strong><ul><li>获取 npm 仓库地址</li></ul></li><li><strong><code>npm config list [—-json]</code></strong><ul><li>获取 npm 配置信息</li></ul></li><li><strong><code>npm config edit</code></strong><ul><li>编辑 npm 的配置信息</li></ul></li><li><strong><code>npm config delete</code></strong><ul><li>删除某个配置</li><li><strong><code>npm c</code></strong> 是 npm config 别名</li></ul></li><li><strong><code>npm cache add</code></strong><ul><li>通过 git 地址添加某个 tar 包到缓存</li></ul></li><li><strong><code>npm cache clean —force</code></strong><ul><li>清除缓存文件 npm@5 后必须使用强制符</li></ul></li><li><strong><code>npm cache verify</code></strong><ul><li>清理无用的缓存文件和校验缓存数据完整性</li></ul></li><li><strong><code>npm completion &gt;&gt; ~/.zsh</code></strong><ul><li>npm 开启自动补全命令，设置后，按住 tab 键能自动提示 npm 命令</li></ul></li><li><strong><code>npm deprecate [@]</code></strong><ul><li>添加对某个包的某个版本的反对信息。只有 owner 才可以，安装此包能看到这些反对信息</li></ul></li><li><strong><code>npm dist-tag add @ []</code></strong><ul><li>为某个版本添加 tag，如果添加的 tag 为 latest，这个 tag 版本将成为最新版本。用户下载最新的时候会直接下载到该版本</li></ul></li><li><strong><code>npm dist-tag rm</code></strong><ul><li>移除tag</li></ul></li><li><strong><code>npm dist-tag ls []</code></strong><ul><li>查看 tag 清单</li></ul></li><li><strong><code>npm doctor</code></strong><ul><li>npm 诊断命令，npm 会对 npm 运行的环境进行检测诊断，包括 npm 的版本，git 版本，npm 使用的文件权限，npm ping 等等</li></ul></li><li><strong><code>npm docs</code></strong><ul><li>打开包的文档地址</li></ul></li><li><strong><code>npm dedupe</code></strong><ul><li>通过一些算法 将多个依赖包中重复依赖的包移除，只保留一个</li><li>该命令别名为：**<code>npm ddp</code>**</li></ul></li><li><strong><code>npm explore [ – ]</code></strong><ul><li>进入指定的包里执行一些命令，比如执行更新源代码，执行重新编译等</li></ul></li><li><strong><code>npm edit</code></strong><ul><li>修改包内容</li></ul></li><li><strong><code>npm get key val</code></strong><ul><li>获取某个配置</li></ul></li><li><strong><code>npm init</code></strong><ul><li>初始化当前目录为一个包，会生成一个 <code>package.json</code> 的文件</li></ul></li><li><strong><code>npm install</code></strong><ul><li>不带任何参数，会按照根目录下的 <code>package.json</code> 里的依赖包</li><li>将安装包放在 <code>./node_modules 下</code>（运行 npm 命令时所在的目录），如果没有 <code>node_modules</code> 目录，会在当前执行 npm 命令的目录下自动生成该目录</li><li>会把该包安装到 <code>node_modules</code> 目录中，不会修改 <code>package.json</code>，之后运行 <code>npm install</code> 命令时，不会自动安装该包</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/]</code></strong><ul><li>局部安装某个包，默认安装最新版本</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/]@</code></strong><ul><li>局部安装指定版本的某个包（按照tag）</li><li>该命令的别名是：**<code>npm i</code>**</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/] --save</code></strong><ul><li>简写为：**<code>npm install [&lt;@scope&gt;/] -S</code>**</li><li>会在 <code>package.json</code> 的 <strong>dependencies</strong> 属性下添加该包的名称及版本号，之后运行 <code>npm install</code> 命令时，会自动安装模块依赖到 node_modules 目录中</li><li>运行 <code>npm install --production</code> 或者注明 <code>NODE_ENV</code> 变量值为 <code>production</code> 时，会自动下载模块到 <code>node_modules</code> 目录中</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/] --save-dev</code></strong><ul><li>简写为 <strong><code>npm install [&lt;@scope&gt;/] -D</code></strong></li><li>与 <code>npm install [&lt;@scope&gt;/] --save</code> 的区别是：<ul><li><code>--save-dev</code> 会将模块依赖写入 <strong>devDependencies</strong> 节点，而 <code>--save</code> 是将模块依赖写入 <strong>dependencies</strong> 节点</li><li>运行 <code>npm install --production</code> 或者注明 <code>NODE_ENV</code> 变量值为 <code>production</code> 时，<code>npm install [&lt;@scope&gt;/] --save-dev</code> 不会自动下载模块到 <code>node_modules</code> 目录中 </li></ul></li></ul></li><li>package.json 文件里面的 devDependencies 和 dependencies 对象的区别是什么呢；<ul><li>–save-dev 对应的 devDependencies 里面的插件只用于开发环境，不用于生产环境，而 –save 对应的 dependencies 是需要发布到生产环境的</li><li>devDependencies 节点下的模块是开发时候需要的，如构建工具 glup、webpack，预处理器less、sass这些只在开发环境有用，所以使用 <strong>–save-dev</strong> 安装</li><li>dependencies 节点下的模块是线上代码运行需要的，如 axios、vue-router、vuex，所以需要使用 <strong>–-save</strong> 安装</li></ul></li><li><strong><code>npm install-test</code></strong><ul><li>它和 <code>npm install</code> 的区别是执行完 npm install 后立马执行 npm test</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/] -g</code></strong><ul><li>全局安装某个包，默认安装最新版本</li></ul></li><li><strong><code>npm install [&lt;@scope&gt;/] --save</code></strong></li><li><strong><code>npm help</code></strong><ul><li>查看某个命令的帮助信息</li></ul></li><li><strong><code>npm help-search</code></strong><ul><li>在帮助文档中查找包含关键词的文档列表</li></ul></li><li><strong><code>npm link [&lt;@scope&gt;/][@]</code></strong><ul><li>将 npm 包创建快捷方式到全局 npm 的路径下</li></ul></li><li><strong><code>npm login</code></strong><ul><li>登陆用户</li></ul></li><li><strong><code>npm logout</code></strong><ul><li>退出当前登陆的 npm 账号</li></ul></li><li><strong><code>npm ls、npm list、npm la、npm ll</code></strong><ul><li>查看当前 npm 包的依赖包列表</li><li><code>npm ls</code> 是 <code>npm list</code> 的简写</li></ul></li><li><strong><code>npm outdated</code></strong><ul><li>查看当前安装的包里版本是否过期的信息</li></ul></li><li><strong><code>npm owner add [&lt;@scope&gt;/]</code></strong><ul><li>添加某个用户作为某个包的管理者</li></ul></li><li><strong><code>npm owner rm [&lt;@scope&gt;/]</code></strong><ul><li>移除某个用户作为某个包的管理者</li></ul></li><li><strong><code>npm owner ls [&lt;@scope&gt;/]</code></strong><ul><li>查看某个包的管理者</li></ul></li><li><strong><code>npm ping</code></strong><ul><li>验证 registry 的连通性和身份验证</li></ul></li><li><strong><code>npm pack</code></strong><ul><li>将当前 npm 包文件打成一个压缩包</li></ul></li><li><strong><code>npm prune</code></strong><ul><li>移除没有定义在package.json 依赖配置上的包</li></ul></li><li><strong><code>npm publish [|] [–tag ] [–access &lt;public|restricted&gt;]</code></strong><ul><li>发布一个包</li></ul></li><li><strong><code>用户个人信息管理</code></strong><ul><li><strong><code>npm profile get [–json|–parseable] []</code></strong><ul><li>获取个人信息</li></ul></li><li><strong><code>npm profile set [–json|–parseable]</code></strong><ul><li>设置个人信息</li></ul></li><li><strong><code>npm profile set password</code></strong><ul><li>设置密码</li></ul></li><li><strong><code>npm profile enable-2fa [auth-and-writes|auth-only]</code></strong><ul><li>设置开启双重验证</li></ul></li><li><strong><code>npm profile disable-2fa</code></strong><ul><li>关闭开启双重验证</li></ul></li></ul></li><li><strong><code>npm prefix [-g]</code></strong><ul><li>查看最靠近 package.json 的父级目录</li></ul></li><li><strong><code>npm root [-g]</code></strong><ul><li>查看本地或者全局 node-module 目录的位置</li></ul></li><li><strong><code>npm repo []</code></strong><ul><li>打开包的源文件管理地址 比如 github 地址</li></ul></li><li><strong><code>npm restart</code></strong><ul><li>运行当前目录下的 package.json 里的 scripts 里的 restart 命令，如果没有，则执行 <code>npm stop</code> 再执行 <code>npm start</code></li></ul></li><li><strong><code>npm run-script [-- …]</code></strong><ul><li>运行当前目录下的 package.json 里的 scripts 里的命令</li><li>该命令的别名是：**<code>npm run</code>**</li></ul></li><li><strong><code>npm rebuild [[&lt;@scope&gt;/]…]</code></strong><ul><li>执行编译某个包</li><li>该命令的别名是：**<code>npm rb</code>**</li></ul></li><li><strong><code>npm search [–long] [search terms …]</code></strong><ul><li>从远程仓库中搜索某个包的信息</li></ul></li><li><strong><code>npm set key val</code></strong><ul><li>设置某个配置</li></ul></li><li><strong><code>npm stop</code></strong><ul><li>运行当前目录下的 package.json 里的 scripts 里的 top 命令，如果有的话</li></ul></li><li><strong><code>npm start</code></strong><ul><li>运行当前目录下的 package.json 里的 scripts 里的 start 命令，如果有的话</li></ul></li><li><strong><code>npm star […]</code></strong><ul><li>将某个包加入当前用户的感兴趣的清单</li></ul></li><li><strong><code>npm stars []</code></strong><ul><li>列出该用户所有感兴趣的包</li></ul></li><li><strong><code>npm shrinkwrap</code></strong><ul><li>生成当前项目确定的依赖版本，类似 package-lock.json，但是还是有略微区别</li></ul></li><li><strong><code>npm test [-- ]</code></strong><ul><li>运行当前目录下的 package.json 里的 scripts 里的 test 命令，如果有的话</li></ul></li><li><strong><code>npm team</code></strong><ul><li>管理所属团队或者添加团队成员等</li></ul></li><li><strong><code>npm token</code></strong><ul><li>身份令牌管理</li></ul></li><li><strong><code>npm uninstall</code></strong><ul><li>卸载某个包</li><li>该命令的别名是：**<code>npm un</code>**</li></ul></li><li><strong><code>npm update [-g] […]</code></strong><ul><li>更新包</li><li>该命令的别名是：**<code>npm up [-g] […]</code>**</li></ul></li><li><strong><code>npm unpublish [&lt;@scope&gt;/][@]</code></strong><ul><li>取消发布包，将发布的包从远程仓库中删除</li></ul></li><li><strong><code>npm unstar […]</code></strong><ul><li>将某个包移除当前用户清单</li></ul></li><li><strong><code>npm version</code></strong><ul><li>查看各个依赖的版本</li></ul></li><li><strong><code>npm whoami</code></strong><ul><li>npm 当前登陆用户</li></ul></li><li><strong><code>npm -l</code></strong><ul><li>查看所有命令的用例信息</li></ul></li><li><strong><code>npm -h</code></strong><ul><li>查看某个命令的用法</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 Git 到 Github：上传、更新及常见命令集</title>
      <link href="80bb98e6730f/"/>
      <url>80bb98e6730f/</url>
      
        <content type="html"><![CDATA[<h2 id="将项目上传到-Github"><a href="#将项目上传到-Github" class="headerlink" title="将项目上传到 Github"></a>将项目上传到 Github</h2><blockquote><p>关于下载安装 git，注册 github 账号等操作，此处略过</p></blockquote><ol><li><p>进入 github 并创建一个仓库：<br><img src="https://user-images.githubusercontent.com/49378661/84569212-64347000-adb7-11ea-8df3-e48cd9519f0b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569212-64347000-adb7-11ea-8df3-e48cd9519f0b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613092257831"></p><p><img src="https://user-images.githubusercontent.com/49378661/84569216-71e9f580-adb7-11ea-9c7b-4e14e55e1225.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569216-71e9f580-adb7-11ea-9c7b-4e14e55e1225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613092739497"></p></li></ol><ol start="2"><li>这里我准备了一个待提交的 <code>peoject</code> 项目文件夹，如下：<br><img src="https://user-images.githubusercontent.com/49378661/84569219-77dfd680-adb7-11ea-8858-226c2c27f025.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569219-77dfd680-adb7-11ea-8858-226c2c27f025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613164252269"></li></ol><ol start="3"><li><p>在文件夹处右键，并用 <code>Git Bush</code> 打开</p></li><li><p>创建 git 仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569224-7f06e480-adb7-11ea-8187-49b4cefb8b93.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569224-7f06e480-adb7-11ea-8187-49b4cefb8b93.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170306963"></p></li></ol><ol start="5"><li><p>将所有文件添加到仓库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569242-9fcf3a00-adb7-11ea-986f-71babfe36776.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569242-9fcf3a00-adb7-11ea-986f-71babfe36776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170344073"></p></li><li><p>将项目提交到本地仓库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;注释内容&quot;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569238-9ba31c80-adb7-11ea-8107-5bd1452ba491.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569238-9ba31c80-adb7-11ea-8107-5bd1452ba491.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170414095"></p></li></ol><ul><li>虽然没有强制要写注释内容，可以不写，但为了防止莫名其妙的报错，最好写上</li></ul><ol start="7"><li><p>将本地仓库关联到 github 上的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:OzzieNicholas&#x2F;test.git</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569241-9f36a380-adb7-11ea-8a77-69a2b6c2c8f5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569241-9f36a380-adb7-11ea-8a77-69a2b6c2c8f5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170616719"></p></li></ol><ul><li>“origin” 后面跟着的就是创建的仓库的地址</li></ul><ol start="8"><li><p>关联好之后我们就把本地仓库的所有内容推送到 github 仓库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569247-a65db180-adb7-11ea-9c6c-af4e5a7fab49.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569247-a65db180-adb7-11ea-9c6c-af4e5a7fab49.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170926655"></p></li></ol><ul><li><p>由于新建的仓库是空的，所以需要加上 <code>-u</code> 参数，若 github 仓库中已经有了内容，再从本地上传到远程仓库中时就直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>我们的仓库如下：<br><img src="https://user-images.githubusercontent.com/49378661/84569250-ac539280-adb7-11ea-97de-bd39952fd114.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569250-ac539280-adb7-11ea-97de-bd39952fd114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613171657138"></li></ol><ul><li>最后增加上 <code>README.md</code> 即可</li></ul><hr><h2 id="将项目更新到-Github"><a href="#将项目更新到-Github" class="headerlink" title="将项目更新到 Github"></a>将项目更新到 Github</h2><blockquote><p>假设项目更新了，需要我们再次提交到同一个的仓库中</p></blockquote><ol><li><p>将 origin 上的 master 分支 merge 到当前的 branch 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin&#x2F;master</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569366-91cde900-adb8-11ea-870a-3d5c36d2b9a5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569366-91cde900-adb8-11ea-870a-3d5c36d2b9a5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182317075"></p></li></ol><ol start="2"><li><p>重新向仓库中添加文件（由于我们已经在第一次提交时就创建了仓库，所以这里直接把添加）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure></li><li><p>向本地仓库中提交文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;第二次提交&quot;</span><br></pre></td></tr></table></figure></li><li><p>将本地仓库中的所有文件推送到 github 仓库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><ul><li>由于远程仓库并不为空，所以不需要加 <code>-u</code> 参数</li></ul><p><img src="https://user-images.githubusercontent.com/49378661/84569258-bb3a4500-adb7-11ea-9d0a-88e32d50f124.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569258-bb3a4500-adb7-11ea-9d0a-88e32d50f124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182847899"></p></li></ol><ol start="5"><li><p>查看 github 仓库效果：我们已经完成了仓库更新</p><p><img src="https://user-images.githubusercontent.com/49378661/84569261-bffef900-adb7-11ea-8f43-53c46d61e150.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569261-bffef900-adb7-11ea-8f43-53c46d61e150.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182931055"></p></li></ol><ol start="6"><li>另附：<a href="https://segmentfault.com/q/1010000000455436/a-1020000000455462">git merge origin master 和 git merge origin/master的区别在哪里？</a></li></ol><hr><h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ol><li><p>查看、添加、提交、删除、找回，重置修改文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示command的help</span><br><span class="line"> </span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"> </span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"> </span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"> </span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改　　　　</span><br><span class="line"></span><br><span class="line">git ci -am &quot;some comments&quot;</span><br><span class="line"> </span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"> </span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"> </span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure></li><li><p>查看文件 diff：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示command的help</span><br><span class="line"> </span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"> </span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"> </span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"> </span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"> </span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"> </span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"> </span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure></li><li><p>查看提交记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"> </span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"> </span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"> </span><br><span class="line">git log --stat #查看提交统计信息</span><br></pre></td></tr></table></figure></li><li><p>本地分支管理：查看、切换、创建和删除分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git br -r # 查看远程分支</span><br><span class="line"> </span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"> </span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line"> </span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"> </span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"> </span><br><span class="line">git co &lt;branch&gt; # 切换到某个分支</span><br><span class="line"> </span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去</span><br><span class="line"> </span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"> </span><br><span class="line">git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"> </span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"> </span><br><span class="line">git br -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"> </span><br><span class="line">git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br></pre></td></tr></table></figure></li><li><p>分支合并 和 reba：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"> </span><br><span class="line">git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"> </span><br><span class="line">git rebase master &lt;branch&gt;</span><br><span class="line"># 将 master rebase 到 branch</span><br><span class="line"># 相当于 git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></li><li><p>存储管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash # 暂存</span><br><span class="line"> </span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"> </span><br><span class="line">git stash apply # 恢复暂存的内容</span><br><span class="line"> </span><br><span class="line">git stash drop # 删除暂存区</span><br></pre></td></tr></table></figure></li><li><p>远程分支管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin&#x2F;master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line">git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push 所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"> </span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"> </span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"> </span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"> </span><br><span class="line">git push origin :&lt;remote_branch&gt;</span><br><span class="line"># 先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span><br></pre></td></tr></table></figure></li><li><p>远程仓库管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"> </span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"> </span><br><span class="line">git remote add origin git@ github:robbin&#x2F;robbin_site.git # 添加远程仓库地址</span><br><span class="line"> </span><br><span class="line">git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git</span><br><span class="line"># 设置远程仓库地址(用于修改远程仓库地址)</span><br><span class="line"></span><br><span class="line">git remote rm &lt;repository&gt; # 删除远程仓库</span><br><span class="line"></span><br><span class="line">git remote remove origin # 断开已连接的远程仓库</span><br><span class="line"></span><br><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"> </span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"> </span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"> </span><br><span class="line">git remote add origin git@ github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址</span><br><span class="line"> </span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"> </span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"> </span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br></pre></td></tr></table></figure></li><li><p>命令设置跟踪远程库和本地库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream master origin&#x2F;master</span><br><span class="line"> </span><br><span class="line">git branch --set-upstream develop origin&#x2F;develop</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git：从安装到操作</title>
      <link href="36409b32e950/"/>
      <url>36409b32e950/</url>
      
        <content type="html"><![CDATA[<h2 id="将项目上传到-Github"><a href="#将项目上传到-Github" class="headerlink" title="将项目上传到 Github"></a>将项目上传到 Github</h2><blockquote><p>关于下载安装 git，注册 github 账号等操作，此处略过</p></blockquote><ol><li><p>进入 github 并创建一个仓库：<br><img src="https://user-images.githubusercontent.com/49378661/84569212-64347000-adb7-11ea-8df3-e48cd9519f0b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569212-64347000-adb7-11ea-8df3-e48cd9519f0b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613092257831"></p><p><img src="https://user-images.githubusercontent.com/49378661/84569216-71e9f580-adb7-11ea-9c7b-4e14e55e1225.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569216-71e9f580-adb7-11ea-9c7b-4e14e55e1225.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613092739497"></p></li></ol><ol start="2"><li>这里我准备了一个待提交的 <code>peoject</code> 项目文件夹，如下：<br><img src="https://user-images.githubusercontent.com/49378661/84569219-77dfd680-adb7-11ea-8858-226c2c27f025.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569219-77dfd680-adb7-11ea-8858-226c2c27f025.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613164252269"></li></ol><ol start="3"><li><p>在文件夹处右键，并用 <code>Git Bush</code> 打开</p></li><li><p>创建 git 仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569224-7f06e480-adb7-11ea-8187-49b4cefb8b93.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569224-7f06e480-adb7-11ea-8187-49b4cefb8b93.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170306963"></p></li></ol><ol start="5"><li><p>将所有文件添加到仓库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569242-9fcf3a00-adb7-11ea-986f-71babfe36776.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569242-9fcf3a00-adb7-11ea-986f-71babfe36776.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170344073"></p></li><li><p>将项目提交到本地仓库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;注释内容&quot;</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569238-9ba31c80-adb7-11ea-8107-5bd1452ba491.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569238-9ba31c80-adb7-11ea-8107-5bd1452ba491.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170414095"></p></li></ol><ul><li>虽然没有强制要写注释内容，可以不写，但为了防止莫名其妙的报错，最好写上</li></ul><ol start="7"><li><p>将本地仓库关联到 github 上的仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:OzzieNicholas&#x2F;test.git</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569241-9f36a380-adb7-11ea-8a77-69a2b6c2c8f5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569241-9f36a380-adb7-11ea-8a77-69a2b6c2c8f5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170616719"></p></li></ol><ul><li>“origin” 后面跟着的就是创建的仓库的地址</li></ul><ol start="8"><li><p>关联好之后我们就把本地仓库的所有内容推送到 github 仓库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569247-a65db180-adb7-11ea-9c6c-af4e5a7fab49.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569247-a65db180-adb7-11ea-9c6c-af4e5a7fab49.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613170926655"></p></li></ol><ul><li><p>由于新建的仓库是空的，所以需要加上 <code>-u</code> 参数，若 github 仓库中已经有了内容，再从本地上传到远程仓库中时就直接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>我们的仓库如下：<br><img src="https://user-images.githubusercontent.com/49378661/84569250-ac539280-adb7-11ea-97de-bd39952fd114.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569250-ac539280-adb7-11ea-97de-bd39952fd114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613171657138"></li></ol><ul><li>最后增加上 <code>README.md</code> 即可</li></ul><hr><h2 id="将项目更新到-Github"><a href="#将项目更新到-Github" class="headerlink" title="将项目更新到 Github"></a>将项目更新到 Github</h2><blockquote><p>假设项目更新了，需要我们再次提交到同一个的仓库中</p></blockquote><ol><li><p>将 origin 上的 master 分支 merge 到当前的 branch 上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git merge origin&#x2F;master</span><br></pre></td></tr></table></figure><p><img src="https://user-images.githubusercontent.com/49378661/84569366-91cde900-adb8-11ea-870a-3d5c36d2b9a5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569366-91cde900-adb8-11ea-870a-3d5c36d2b9a5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182317075"></p></li></ol><ol start="2"><li><p>重新向仓库中添加文件（由于我们已经在第一次提交时就创建了仓库，所以这里直接把添加）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure></li><li><p>向本地仓库中提交文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;第二次提交&quot;</span><br></pre></td></tr></table></figure></li><li><p>将本地仓库中的所有文件推送到 github 仓库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><ul><li>由于远程仓库并不为空，所以不需要加 <code>-u</code> 参数</li></ul><p><img src="https://user-images.githubusercontent.com/49378661/84569258-bb3a4500-adb7-11ea-9d0a-88e32d50f124.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569258-bb3a4500-adb7-11ea-9d0a-88e32d50f124.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182847899"></p></li></ol><ol start="5"><li><p>查看 github 仓库效果：我们已经完成了仓库更新</p><p><img src="https://user-images.githubusercontent.com/49378661/84569261-bffef900-adb7-11ea-8f43-53c46d61e150.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/84569261-bffef900-adb7-11ea-8f43-53c46d61e150.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200613182931055"></p></li></ol><ol start="6"><li>另附：<a href="https://segmentfault.com/q/1010000000455436/a-1020000000455462">git merge origin master 和 git merge origin/master的区别在哪里？</a></li></ol><hr><h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><ol><li><p>查看、添加、提交、删除、找回，重置修改文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示command的help</span><br><span class="line"> </span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"> </span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"> </span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"> </span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改　　　　</span><br><span class="line"></span><br><span class="line">git ci -am &quot;some comments&quot;</span><br><span class="line"> </span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"> </span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"> </span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure></li><li><p>查看文件 diff：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示command的help</span><br><span class="line"> </span><br><span class="line">git show # 显示某次提交的内容 git show $id</span><br><span class="line"> </span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line"> </span><br><span class="line">git add &lt;file&gt; # 将工作文件修改提交到本地暂存区</span><br><span class="line"> </span><br><span class="line">git add . # 将所有修改过的工作文件提交暂存区</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line"> </span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件</span><br><span class="line"> </span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset -- . # 从暂存区恢复到工作文件</span><br><span class="line"> </span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改</span><br><span class="line"> </span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line"> </span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象</span><br><span class="line"> </span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure></li><li><p>查看提交记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git log git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line"> </span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的diff</span><br><span class="line"> </span><br><span class="line">git log -p -2 # 查看最近两次详细修改内容的diff</span><br><span class="line"> </span><br><span class="line">git log --stat #查看提交统计信息</span><br></pre></td></tr></table></figure></li><li><p>本地分支管理：查看、切换、创建和删除分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">git br -r # 查看远程分支</span><br><span class="line"> </span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line"> </span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line"> </span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line"> </span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line"> </span><br><span class="line">git co &lt;branch&gt; # 切换到某个分支</span><br><span class="line"> </span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去</span><br><span class="line"> </span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branch</span><br><span class="line"> </span><br><span class="line">git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除</span><br><span class="line"> </span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支</span><br><span class="line"> </span><br><span class="line">git br -d &lt;branch&gt; # 删除某个分支</span><br><span class="line"> </span><br><span class="line">git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制)</span><br></pre></td></tr></table></figure></li><li><p>分支合并 和 reba：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt; # 将branch分支合并到当前分支</span><br><span class="line"> </span><br><span class="line">git merge origin&#x2F;master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交</span><br><span class="line"> </span><br><span class="line">git rebase master &lt;branch&gt;</span><br><span class="line"># 将 master rebase 到 branch</span><br><span class="line"># 相当于 git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure></li><li><p>存储管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git stash # 暂存</span><br><span class="line"> </span><br><span class="line">git stash list # 列所有stash</span><br><span class="line"> </span><br><span class="line">git stash apply # 恢复暂存的内容</span><br><span class="line"> </span><br><span class="line">git stash drop # 删除暂存区</span><br></pre></td></tr></table></figure></li><li><p>远程分支管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地</span><br><span class="line"></span><br><span class="line">git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并</span><br><span class="line"></span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line"></span><br><span class="line">git merge origin&#x2F;master # 将远程主分支合并到本地当前分支</span><br><span class="line"></span><br><span class="line">git co --track origin&#x2F;branch # 跟踪某个远程分支创建相应的本地分支</span><br><span class="line"></span><br><span class="line">git co -b &lt;local_branch&gt; origin&#x2F;&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上</span><br><span class="line"></span><br><span class="line">git push # push 所有分支</span><br><span class="line"></span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line"> </span><br><span class="line">git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span><br><span class="line"> </span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名</span><br><span class="line"> </span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line"> </span><br><span class="line">git push origin :&lt;remote_branch&gt;</span><br><span class="line"># 先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span><br></pre></td></tr></table></figure></li><li><p>远程仓库管理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">git remote -v # 查看远程服务器地址和仓库名称</span><br><span class="line"> </span><br><span class="line">git remote show origin # 查看远程服务器仓库状态</span><br><span class="line"> </span><br><span class="line">git remote add origin git@ github:robbin&#x2F;robbin_site.git # 添加远程仓库地址</span><br><span class="line"> </span><br><span class="line">git remote set-url origin git@github.com:robbin&#x2F;robbin_site.git</span><br><span class="line"># 设置远程仓库地址(用于修改远程仓库地址)</span><br><span class="line"></span><br><span class="line">git remote rm &lt;repository&gt; # 删除远程仓库</span><br><span class="line"></span><br><span class="line">git remote remove origin # 断开已连接的远程仓库</span><br><span class="line"></span><br><span class="line">git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库</span><br><span class="line"> </span><br><span class="line">scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上</span><br><span class="line"> </span><br><span class="line">mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库</span><br><span class="line"> </span><br><span class="line">git remote add origin git@ github.com:robbin&#x2F;robbin_site.git # 设置远程仓库地址</span><br><span class="line"> </span><br><span class="line">git push -u origin master # 客户端首次提交</span><br><span class="line"> </span><br><span class="line">git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track</span><br><span class="line"> </span><br><span class="line">git remote set-head origin master # 设置远程仓库的HEAD指向master分支</span><br></pre></td></tr></table></figure></li><li><p>命令设置跟踪远程库和本地库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch --set-upstream master origin&#x2F;master</span><br><span class="line"> </span><br><span class="line">git branch --set-upstream develop origin&#x2F;develop</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postman 使用教程</title>
      <link href="c853069b0fd0/"/>
      <url>c853069b0fd0/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍-Postman"><a href="#介绍-Postman" class="headerlink" title="介绍 Postman"></a>介绍 Postman</h2><ol><li>官网：<a href="https://www.postman.com/">https://www.postman.com/</a></li><li>背景介绍：postman 不仅可以调试简单的 html、css、以及一些脚本等简单的网页信息，它还能发送几乎所有的 Http 请求，而 postman 在发送网络请求方面可以说是 Chrome 插件类产品哒代表作之一</li><li>postman 的操作环境：Mac、Windows X32、Windows X64、Linux 系统，还支持 postman 浏览器扩展程序，postman chrome 应用程序等等</li><li>使用参考文档：<ul><li><a href="https://learning.postman.com/docs/postman/launching-postman/introduction/">英文官方文档</a></li><li><a href="https://chromecj.com/web-development/2017-12/870.html">Postman API 中文白皮书文档</a></li></ul></li></ol><hr><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>postman 安装地址：</p><ul><li><p><a href="https://app.getpostman.com/app/download/osx64?utm_source=site&utm_medium=apps&utm_campaign=macapp&_ga=2.21151352.2119858274.1527039878-1088353859.1527039878">For Mac</a></p></li><li><p><a href="https://app.getpostman.com/app/download/win64?_ga=2.201562513.1250696341.1530543681-1582181135.1530543681">For Win64</a></p></li></ul></li><li><p>浏览器插件安装：</p><ul><li>postman 是谷歌浏览器的插件，所以安装的前提是有谷歌浏览器</li><li>地址：<a href="http://extb.cqttech.com/search/postman">http://extb.cqttech.com/search/postman</a><br><img src="https://user-images.githubusercontent.com/49378661/79690733-8bc2fc80-828e-11ea-924d-832b5b8bda5f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79690733-8bc2fc80-828e-11ea-924d-832b5b8bda5f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587303722245"></li></ul></li></ol><hr><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><p><img src="https://user-images.githubusercontent.com/49378661/79705251-9eb5eb00-82e7-11ea-891d-f00179adf59f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705251-9eb5eb00-82e7-11ea-891d-f00179adf59f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="y"></p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><blockquote><p>除了以上的基础设置外，我们还有以下设置</p></blockquote><ol><li>有时候需要在不同的环境下测试，此时我们可以通过环境变量来动态选择<br><img src="https://user-images.githubusercontent.com/49378661/79705263-a6758f80-82e7-11ea-8566-53628323ec21.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705263-a6758f80-82e7-11ea-8566-53628323ec21.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="z"></li></ol><ul><li><p>此时，我们没有设置环境，点击最后边的 “设置” 按钮<br><img src="https://user-images.githubusercontent.com/49378661/79705290-c1480400-82e7-11ea-9072-a63b40d706a6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705290-c1480400-82e7-11ea-9072-a63b40d706a6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a"></p><ul><li><p>使用这些键值的时候需要加上两个花括号引用 key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;base_url&#125;&#125;&#x2F;username  #解析之后就是：https:&#x2F;&#x2F;www.test.com&#x2F;username</span><br></pre></td></tr></table></figure></li></ul></li><li><p>添加之后，我们就可以选择这个新增的环境</p><p><img src="https://user-images.githubusercontent.com/49378661/79705360-f6eced00-82e7-11ea-8ef2-0157fe42aa28.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705360-f6eced00-82e7-11ea-8ef2-0157fe42aa28.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587343645998"></p></li></ul><ol start="2"><li><p>Headers</p><ul><li>设置 <code>key:value</code> 值<br><img src="https://user-images.githubusercontent.com/49378661/79705377-1126cb00-82e8-11ea-80b8-ef32cd97ee23.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705377-1126cb00-82e8-11ea-80b8-ef32cd97ee23.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="b"></li></ul></li></ol><ul><li><p>有些 headers 和 cookies 是保密的，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>Accept-Charset</span><br><span class="line"><span class="number">2.</span>Accept-Encoding</span><br><span class="line"><span class="number">3.</span>Access-Control-Request-Headers</span><br><span class="line"><span class="number">4.</span>Access-Control-Request-Method</span><br><span class="line"><span class="number">5.</span>Connection</span><br><span class="line"><span class="number">6.</span>Content-Length</span><br><span class="line"><span class="number">7.</span>Cookie</span><br><span class="line"><span class="number">8.</span>Cookie <span class="number">2</span></span><br><span class="line"><span class="number">9.</span>Content-Transfer-Encoding</span><br><span class="line"><span class="number">10.</span><span class="built_in">Date</span></span><br><span class="line"><span class="number">11.</span>Expect</span><br><span class="line"><span class="number">12.</span>Host</span><br><span class="line"><span class="number">13.</span>Keep-Alive</span><br><span class="line"><span class="number">14.</span>Origin</span><br><span class="line"><span class="number">15.</span>Referer</span><br><span class="line"><span class="number">16.</span>TE</span><br><span class="line"><span class="number">17.</span>Trailer</span><br><span class="line"><span class="number">18.</span>Transfer-Encoding</span><br><span class="line"><span class="number">19.</span>Upgrade</span><br><span class="line"><span class="number">20.</span>User-Agent</span><br><span class="line"><span class="number">21.</span>Via</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>Body 中的参数格式：<br><img src="https://user-images.githubusercontent.com/49378661/79705384-17b54280-82e8-11ea-9de8-85e8c96c9f41.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705384-17b54280-82e8-11ea-9de8-85e8c96c9f41.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="c"></li></ol><ul><li><p><code>form-data</code>：<code>mutipart/form-data</code> 是网页表单用来传输数据的默认格式。可以模拟填写并提交表单。可以上传一个文件作为 key 的 value 提交（如上传文件）。但该文件不会作为历史保存，只能在每次需要发送请求的时候，重新添加文件</p></li><li><p><code>urlencoded</code>：同前面一样，注意,你不能上传文件通过这个编码模式，该模式和表单模式会容易混淆，<code>urlencoded</code> 中的 <code>key-value</code> 会写入URL，<code>form-data</code> 模式的 <code>key-value</code> 不明显写入URL，而是直接提交</p></li><li><p><code>raw</code>：<code>raw request</code> 可以包含任何东西，所有填写的 <code>text</code> 都会随着请求发送。</p></li><li><p><code>binary</code>：支持 image、audio 、video files 以及 text files，也不能保存历史，每次选择文件，提交。</p></li></ul><ol start="4"><li><p>身份验证（Authentication）</p><p><img src="https://user-images.githubusercontent.com/49378661/79705390-1e43ba00-82e8-11ea-9ea4-92d920e9f649.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79705390-1e43ba00-82e8-11ea-9ea4-92d920e9f649.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="d"></p></li></ol><ul><li>Basic Auth：基础的验证，比较简单，会直接把用户名、密码的信息放在请求的 Header 中</li><li>Digest Auth：比 Basic Auth 复杂很多。使用当前填写的值生成 authorization header。所以在生成 header 之前要确保设置的正确性。如果当前的 header 已经存在，postman 会移除之前的 header</li><li>OAuth 1.0：postman 的 OAuth helper 让你签署支持 OAuth。1.0 是基于身份验证的请求，OAuth  不用获取access token，你需要去API提供者获取的。OAuth 1.0 可以在 header 或者查询参数中设置 value。</li><li>OAuth 2.0：postman 支持获得 OAuth 2.0 token 并添加到 requests 中。</li></ul><hr><blockquote><p>暂时介绍到这里，还有更多的功能，，，以后用到再说啦 (#^.^#)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows神器：Cmder</title>
      <link href="3acab0f3d61b/"/>
      <url>3acab0f3d61b/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><ol><li>cmder是一个增强型命令行工具，不仅可以使用windows下的所有命令，更爽的是可以使用linux的命令,shell命令。</li><li>cmder不是一个独立的工具，应该说是一系列工具包的集合，包括Conemu、clink、git for windows 等，足够简单好用，且支持多栏显示，多个tab运行，功能十分强大</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>官网下载地址：<a href="https://cmder.net/">cmder</a></li><li>如下：<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/POIlZaAgvF.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/POIlZaAgvF.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><ul><li>官网上的有 <strong>min 版</strong> 和 <strong>full 版</strong>，我们下载后者</li></ul></li><li>最后可以打开 <code>Cmder.exe</code> 检验一下，会出现 Cmder 界面</li></ol><hr><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li>打开控制面板，再打开系统环境变量配置<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/73TG4CnnpO.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/73TG4CnnpO.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>新建环境变量，之后将 <code>Cmder.exe</code> 所在的文件夹添加进 Path 中，例如：<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/Xy9Mq94zJV.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/Xy9Mq94zJV.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><h3 id="配置右键快捷启动"><a href="#配置右键快捷启动" class="headerlink" title="配置右键快捷启动"></a>配置右键快捷启动</h3><ol><li>以管理员的身份打开 <code>Cmder.exe</code>，输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder.exe /REGISTER ALL</span><br></pre></td></tr></table></figure><ul><li>这会设置在任何地方都可以鼠标启动 Cmder</li></ul></li><li>现在你对任何一个文件夹右键，都会有一个 <code>Cmder Here</code> 选项，点开即为该路径下的命令行界面<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/vvYfPgS811.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/vvYfPgS811.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><h3 id="界面效果的设置"><a href="#界面效果的设置" class="headerlink" title="界面效果的设置"></a>界面效果的设置</h3><ol><li>神奇当然支持自定义，打开 <code>Cmder.exe</code>，右键右下角进入设置<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/BX4t6WX4gS.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/BX4t6WX4gS.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="><br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/nMQvUcpB3k.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/nMQvUcpB3k.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>语言与设置<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/4CHKPxA1py.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/4CHKPxA1py.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>上一次设置我将语言改为了中文，现在可以设置其他的了…<br> <img src="https://cdn.learnku.com/uploads/images/202002/12/53391/kf2pwzcev0.png!large" class="lazyload" data-srcset="https://cdn.learnku.com/uploads/images/202002/12/53391/kf2pwzcev0.png!large" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><hr><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><ol><li>这里介绍一下关于 Cmder 的一些常用快捷键 <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Tab              自动路径补全</span><br><span class="line">Ctrl+T           建立新页签</span><br><span class="line">Ctrl+W           关闭页签</span><br><span class="line">Ctrl+Tab         切换页签</span><br><span class="line">Alt+F4           关闭所有页签</span><br><span class="line">Alt+<span class="built_in">Shift</span>+<span class="number">1</span>      开启<span class="built_in">cmd</span>.exe</span><br><span class="line">Alt+<span class="built_in">Shift</span>+<span class="number">2</span>      开启powershell.exe</span><br><span class="line">Alt+<span class="built_in">Shift</span>+<span class="number">3</span>      开启powershell.exe (系统管理员权限)</span><br><span class="line">Ctrl+<span class="number">1</span>           快速切换到第<span class="number">1</span>个页签</span><br><span class="line">Ctrl+n           快速切换到第n个页签(n值无上限)</span><br><span class="line">Ctrl+r           历史命令搜索</span><br><span class="line">Alt+enter 切换到全屏状态</span><br><span class="line">Win+Alt+P        开启工具选项视窗</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="附链"><a href="#附链" class="headerlink" title="附链"></a>附链</h2><ol><li>GitHub地址：<a href="https://github.com/cmderdev/cmder">GitHub — cmder</a></li><li>推荐阅读：<a href="https://www.cnblogs.com/ziyoublog/p/10416684.html">cmder使用简介</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向Github提交代码报错：Updates were rejected because a pushed branch tip is behind its remote...</title>
      <link href="9e88e9aa8fda/"/>
      <url>9e88e9aa8fda/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在向 github 上传代码时，给我报错：<br><img src="https://user-images.githubusercontent.com/49378661/86753875-04a64900-c073-11ea-9c55-b10fb4b5ce22.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/86753875-04a64900-c073-11ea-9c55-b10fb4b5ce22.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200707164758065"></p><p>关键的就是黄色的第一行：<code>Updates were rejected because a pushed branch tip is behind its remote.</code></p><p>翻译过来就是：由于推送的分支提示位于其远程后面，因此更新被拒绝。</p><p>好吧，看看连接的远程仓库有哪些：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:OzzieNicholas&#x2F;Travel.git (fetch)</span><br><span class="line">origin  git@github.com:OzzieNicholas&#x2F;Travel.git (push)</span><br></pre></td></tr></table></figure><p>我想断开所有连接的远程仓库，打算重新连接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote remove origin</span><br></pre></td></tr></table></figure><p>可是……好像并没有什么用</p><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>百度了一波，我承认我还是没看懂什么操作，被 git 支配的恐惧确实有点……先记录下解决办法</p><p>连接远程仓库，并输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin git@github.com:OzzieNicholas&#x2F;Travel.git</span><br><span class="line">$ git push -u origin master -f</span><br></pre></td></tr></table></figure><p>令人迷惑操作，就这样 OK 了……</p><hr><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/shiren1118/article/details/7761203">github上的版本和本地版本冲突的解决方法</a></p><p><a href="https://www.cnblogs.com/xwdreamer/archive/2012/05/29/2523958.html">github中non-fast-forward错误的解决</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向Github提交代码报错：Permanently added the RSA host key for IP address...</title>
      <link href="24035baedd34/"/>
      <url>24035baedd34/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在准备向 github 提交代码时，给我报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Warning: Permanently added the RSA host key for IP address &#39;13.229.188.59&#39; t</span><br></pre></td></tr></table></figure><p>谷歌翻译了一下：”警告：永久添加了IP地址“ 13.229.188.59”的RSA主机密钥”</p><p>百度到的一种方法是说这是缺少 SSH 公钥导致的，我用 <code>ssh -T git@github.com</code> 测试了一下，发现我并非缺少公钥</p><p>百度到的第二种方法是说这是一个警告，无伤大雅，在 <code>C:\Windows\System32\drivers\etc\hosts</code> 文件中添加 github 的 IP 地址即可，可是我发现需要权限才能修改，就暂时跳过这个方法了</p><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>我觉得尝试一下更新 SSH，神奇地可行了，emm，至于之前提到的第二种方法，现在也先记录下来，或许之后会遇到</p><p>更新 SSH：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;GitHub账号&quot;</span><br></pre></td></tr></table></figure><p>然后一直 Enter 下去即可生成新的公钥</p><p>复制 <code>id_rsa.pub</code> 文件中的内容，用于在 github 上的 <code>Settings</code> 部分更新公钥，之后就OK了</p><p>参考：</p><ul><li><p><a href="https://www.jianshu.com/p/a234f6e40a40">关于Github遇到”Permanently added the RSA host key for IP address ‘192.30.255.113’ to the list of known hosts.”的问题</a></p></li><li><p><a href="https://blog.csdn.net/yushuangping/article/details/84240863">Permanently added the RSA host key for IP address ‘13.250.177.223’ to t he list of known hosts.</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向Github提交代码报错：failed to push some refs to....</title>
      <link href="6df9b860828c/"/>
      <url>6df9b860828c/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在向 github 上传代码时，给我报错：</p><p><img src="https://user-images.githubusercontent.com/49378661/82517816-8805ec80-9b50-11ea-8dc8-a3683bc6c266.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/82517816-8805ec80-9b50-11ea-8dc8-a3683bc6c266.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2020-05-21_104736"></p><p>即那一行：<code>error: failed to push some refs to....</code></p><p>翻译过来就是：无法将代码推送到该仓库</p><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这是本地库与远程库不一致导致的，解决办法就是将远程库同步到本地库，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull --rebase origin master</span><br></pre></td></tr></table></figure><p>之后就可以上传了</p><hr><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>该指令的意思是将远程库之中的更新合并到本地库中，<code>–rebase</code> 的作用是取消本地库中之前的 <code>commit</code>，并把他们接到更新后的版本库之中</p><p>请参考：<a href="https://blog.csdn.net/rocling/article/details/82956402">【github】git push错误failed to push some refs to的解决</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巨坑！node-sass 安装的痛</title>
      <link href="c37fbf8ee648/"/>
      <url>c37fbf8ee648/</url>
      
        <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>在安装项目依赖的时候，突然发现，总是报错：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node Sass could <span class="keyword">not</span> <span class="built_in">find</span> a binding <span class="keyword">for</span> your current environment: Windows <span class="number">64</span>-bit with Node.js <span class="number">12</span>.x</span><br></pre></td></tr></table></figure><p>最后 <code>npm run dev</code> 尝试启动时总是说：”Cannot find module ‘node-sass’”</p><p>这也就是说，我没有成功安装 <code>node-sass</code>，难受o(╥﹏╥)o</p><p>我百度了很多解决办法，例如：</p><ul><li>第1种：<code>npm cache clean --force</code> 清除缓存，再升级 node 版本，再重新安装</li><li>第2种：<code>npm rebuild node-sass</code> 重新添加依赖，再用 <code>npm update</code> 更新，再重启</li><li>第3种：删除之前的安装，使用 cnpm 在淘宝镜像上安装 node-sass</li></ul><p>好像，，，都没什么用</p><hr><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>接下来说一下我的最终解决办法：</p><p>报错原因：windows 平台缺少编译环境</p><p>解决步骤：</p><ol><li>执行：<code>npm install -g node-gyp</code></li><li>打开 cmd，<strong>以管理员的身份执行</strong> <code>npm install --global --production windows-build-tools</code><ul><li>这个的作用是可以自动安装跨平台的编译器</li></ul></li><li>执行 <code>npm uninstall node-sass</code> 来删除之前的安装包（未安装可忽略）</li><li>执行 <code>npm install node-sass</code> 重新安装</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unexpected end of JSON input while...</title>
      <link href="7f065221428f/"/>
      <url>7f065221428f/</url>
      
        <content type="html"><![CDATA[<h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p><img src="https://user-images.githubusercontent.com/49378661/78953639-293e6380-7b0c-11ea-822e-c33a013baeb8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/78953639-293e6380-7b0c-11ea-822e-c33a013baeb8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>这种情况一般是受到 npm 缓存的影响，清除缓存即可</li><li>使用命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-App：npm start 报错</title>
      <link href="6ffba565cd57/"/>
      <url>6ffba565cd57/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>在读《React学习之道》时，我按照步骤输入了如下代码： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br><span class="line"><span class="built_in">cd</span> my-app</span><br><span class="line">npm <span class="built_in">start</span></span><br></pre></td></tr></table></figure></li><li>结果，报错如下：<br> <img src="https://s2.ax1x.com/2020/01/31/11L34J.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/01/31/11L34J.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><hr><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li>原文链接：<a href="https://stackoverflow.com/questions/52606707/cannot-uninstall-webpack-from-react-script">Cannot uninstall webpack from react-script</a></li><li>步骤：<ul><li>在项目根目录下新建 <code>.env</code> 文件</li><li>输入：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SKIP_PREFLIGHT_CHECK&#x3D;true</span><br></pre></td></tr></table></figure></li></ul></li><li>重新启动项目<br> <img src="https://s2.ax1x.com/2020/01/31/11LD4H.png" class="lazyload" data-srcset="https://s2.ax1x.com/2020/01/31/11LD4H.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>附上：<a href="https://www.html.cn/create-react-app/docs/getting-started/">Create React App 中文文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm ERR! A complete log of this run can be found in</title>
      <link href="cda94e503d2e/"/>
      <url>cda94e503d2e/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在使用 <code>npm</code> 下载某些包的时候，总是出现如下所示的情况：<br><img src="https://s1.ax1x.com/2020/03/25/8XesHS.png" class="lazyload" data-srcset="https://s1.ax1x.com/2020/03/25/8XesHS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><blockquote><p>百度一波之后，发现这是 npm 版本的问题，更新 npm 就可解决，步骤如下.</p></blockquote><ol><li>删除项目目录中的 <code>node_modules</code></li><li>在项目目录下输入以下内容来清除缓存： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure></li><li>将 npm 升级到最新版本： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install npm@latest -g</span><br></pre></td></tr></table></figure></li><li>重新安装 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 踩坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（四）：回滚</title>
      <link href="29cd2b494840/"/>
      <url>29cd2b494840/</url>
      
        <content type="html"><![CDATA[<h2 id="初识-Webpack"><a href="#初识-Webpack" class="headerlink" title="初识 Webpack"></a>初识 Webpack</h2><h3 id="关于-webpack"><a href="#关于-webpack" class="headerlink" title="关于 webpack"></a>关于 webpack</h3><ol><li><p><a href="https://www.webpackjs.com/concepts/">官网</a> 对 webpack 的介绍 ： </p><blockquote><p> 本质上，<em>webpack</em>是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)<em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个</em>bundle</em>。 </p></blockquote><p><img src="https://user-images.githubusercontent.com/49378661/95358141-4d340380-08fb-11eb-959e-a16ea81e456f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95358141-4d340380-08fb-11eb-959e-a16ea81e456f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1602073608306"></p><ul><li>在官网的图片介绍中， modules 经过 webpack 打包处理成了各种静态资源。</li><li>简单来说，webpack 就是一个 JavaScript 的打包器，将各种模块（module）打包成资源文件；还可以通过代码拆分来把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件；webpack 可以使用 loader 来预处理文件，这允许你打包除了JavaScript 之外的任何静态资源。 </li></ul></li><li><p>核心概念：</p><ul><li>入口（entry）</li><li>出口（output）</li><li>loader</li><li>插件（plugins） </li></ul></li></ol><h3 id="入口（entry）"><a href="#入口（entry）" class="headerlink" title="入口（entry）"></a>入口（entry）</h3><ol><li><p> 入口指示着 webpack 应该使用哪个模块，来开始构建其内部依赖。进入入口后，webpack 会找出有哪些模块和库是与入口相依赖的。 </p></li><li><p>我们在 webpack 配置中配置 entry 属性，来设置一个或多个入口起点。以下是一个简单的entry配置： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure></li></ol><h3 id="出口（output）"><a href="#出口（output）" class="headerlink" title="出口（output）"></a>出口（output）</h3><ol><li><p> 设置output是为了告诉webpack要在哪里输出其创建的bundle，并且可以对bundle命名。 </p></li><li><p>我们通过 <code>output.filename</code> 来设置输出 bundle 的文件名，通过 <code>output.path</code> 来设置 bundle 的输出路径 ，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">modules.exports = config</span><br></pre></td></tr></table></figure><ul><li>path 也是 node 的核心模块，用来处理项目中的路径</li></ul></li></ol><h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><ol><li><p> 由于 webpack 只认识 JavaScript 代码，因此就需要借助其他方法来处理那些非 JavaScript 文件，如 css、image、font 等。而 loader 可以将所有类型的文件处理成 webpack 能够识别的有效模块，然后再对其进行处理。</p></li><li><p>loader 中有两个重要的属性：</p><ul><li>test 属性：用于标识出应该被对应的 loader 进行转换的某个或某些文件，通常是一个正则表达式</li><li> use属性：表示进行转换时，应该使用哪个 loader</li></ul></li><li><p>案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><ul><li> 以上示例中 loader 的配置告诉 webpack：在遇到 .css 的文件时，在打包之前先用 css-loader 转换一下。</li></ul></li><li><p>webpack 的 loader 集合地：<a href="https://www.webpackjs.com/loaders/">loaders</a></p></li></ol><h3 id="插件（plugins）"><a href="#插件（plugins）" class="headerlink" title="插件（plugins）"></a>插件（plugins）</h3><ol><li><p> loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。</p></li><li><p>要使用一个插件，只需要 require() 它，然后把它添加到 plugins 数组中。</p><ul><li>多数插件可以通过选项(option)自定义。 </li></ul></li><li><p>例如，插件 HtmlWebpackPlugin 将为你生成一个 HTML5 文件， 其中包括使用script标签的 body 中的所有 webpack 包， 案例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filenae: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;css-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  pligins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      title: <span class="string">&#x27;webpack demo&#x27;</span>,</span><br><span class="line">      template: path.join(__dirname, <span class="string">&#x27;./index.html&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure></li><li><p>webpack 提供提供了许多功能强大的插件，查阅 <a href="https://www.webpackjs.com/plugins">插件列表</a> 获取更多插件的使用方法。</p></li></ol><hr><h2 id="开始上手-Webpack"><a href="#开始上手-Webpack" class="headerlink" title="开始上手 Webpack"></a>开始上手 Webpack</h2><h3 id="打包第一个-JS-文件"><a href="#打包第一个-JS-文件" class="headerlink" title="打包第一个 JS 文件"></a>打包第一个 JS 文件</h3><ol><li><p>创建 <code>test</code> 目录，安装依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure></li><li><p>创建相关目录以及文件，最终结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|-index.html</span><br><span class="line">|-src</span><br><span class="line">  |-index.js</span><br><span class="line">|-webpack.config.js</span><br><span class="line">|-package.json</span><br></pre></td></tr></table></figure></li><li><p>文件内容分别如下：</p><ul><li><p>index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&#x27;dist/main.bundle.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>index.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>webpack.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: path.join(__dirname, <span class="string">&#x27;./src/index.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><ul><li>各项解析：<ul><li>webpack4中，我们需要设置 mode 属性，用来决定当前是development还是production 环境，webpack 会根据此值来进行一些默认操作，两种环境的不同配置后面的博文会详解，这里我们设置为 ‘none’ ，来避免默认操作。 </li><li>path 是 nodeJs 中用来操作路径的核心模块，__dirname 表示文件的当前路径（此时为根路径） </li><li>output 中 的 filename 属性，[name] 表示入口的名称，此处就是 main</li></ul></li></ul></li><li><p>打开 <code>package.json</code>，编写一条命令来执行 webpack 打包，在 scripts 中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;webpack --config webpack.config.js --progress --colors&quot;</span><br></pre></td></tr></table></figure><ul><li> webpack –config path/to/your/file/file.js 表示执行某个配置文件</li><li>–progress 可以让我们看到打包的进度</li><li>–colors 开启命令行颜色显示</li><li>（更多的 webpack 命令参数大家可以另行查阅）</li></ul></li></ul></li><li><p>控制台执行 <code>npm run build</code>， 我们可以看到，在根目录下多了一个 dist 文件夹 并有一个 main.bundle.js 文件，这就是 webpack 为我们打包出来的静态资源，而文件路径就是我们在 output 中设置的值。 </p></li><li><p>打开 index.html，即可查看结果，此 demo 也就成功了。</p></li></ol><h3 id="自动生成项目中的-HTML-文件"><a href="#自动生成项目中的-HTML-文件" class="headerlink" title="自动生成项目中的 HTML 文件"></a>自动生成项目中的 HTML 文件</h3><ol><li><p>webpack 中的 CommonJS 和 ES Mudule 规范：</p><ul><li>CommonJs 规范：<ul><li>制定规定的出发点：JS 没有模块系统、标准库较少、缺乏包管理工具；为了让 JS 可以在任何地方运行，以达到 Java、PHP 这些后台语言具备开发大型应用的能力，制定了 CommonJs 规范。</li><li>在规范中：<ul><li>一个文件就是一个模块，拥有单独的作用域；</li><li>普通方式定义的变量、函数、对象都属于该模块内；</li><li>通过 require 来加载模块；</li><li>通过 exports 和 modul.exports 来暴露模块中的内容；</li></ul></li></ul></li><li>ES Mudule 规范：<ul><li>ES6 在语言标准的层面上，实现了模块功能，基本特点如下： <ul><li>每一个模块只加载一次， 每一个 JS 文件内容只执行一次， 如果下次再去加载同目录下同文件，直接从内存中读取；</li><li>每一个模块内声明的变量都是局部变量， 不会污染全局作用域；</li><li>模块内部的变量或者函数可以通过 export 导出；</li><li>一个模块可以导入别的模块；</li></ul></li><li>模块功能主要由两个命令构成：export 和 import<ul><li>export 命令用于规定模块的对外接口</li><li>import 命令用于输入其他模块提供的功能</li></ul></li></ul></li></ul></li><li><p>在上一个打包 js 文件的 demo 中， 我们为了演示打包好的 main.bundle.js ，在根目录下创建了一个 index.html ，并引入main.bundle.js。而在实际项目中，我们可以通过 webpack 的一个插件：<a href="https://www.webpackjs.com/plugins/html-webpack-plugin/">HtmlWebpackPlugin</a> 来自动生成HTML文件并引入我们打包好的JS和CSS文件。 </p></li><li><p>加载插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure></li><li><p>在根目录稍作修改，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">|-index.html</span><br><span class="line">|-src</span><br><span class="line">  |-index.js</span><br><span class="line">|-dist</span><br><span class="line">  |-main.bundle.js</span><br><span class="line">|-config</span><br><span class="line">  |-webpack.config.js</span><br><span class="line">|-package.json</span><br></pre></td></tr></table></figure></li><li><p>修改 webpack.config.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: path.join(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">&#x27;../index.html&#x27;</span>),</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeComments: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><ul><li>各项解析如下：<ul><li>template：模版文件的路径，这里使用根目录下的 index.html 文件；</li><li>inject：设为 true 表示把 JS 文件注入到 body 结尾，CSS 文件注入到 head 中；</li><li>minify：removeComments: true 表示删除模版文件中的注释<ul><li>minify 还有很多配置可选请查阅：<a href="https://github.com/jantimon/html-webpack-plugin#minification">html-webpack-plugin#minification</a></li></ul></li></ul></li></ul></li><li><p>然后，更改 index.html 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;renderer&quot;</span> <span class="attr">content</span>=<span class="string">&quot;webkit&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;script src=&quot;dist/main.bundle.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>由于我们改动了 webpack.config.js 文件的位置，所以要修改 package.json 文件：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;build&quot;: &quot;webpack --config config/webpack.config.js --progress --colors&quot;</span><br></pre></td></tr></table></figure><ul><li>不改动的话，之后 <code>npm run build</code> 会报错</li></ul></li><li><p><code>npm run build</code> 启动项目， 可以看到，dist 目录下多了一个 index.html，这就是通过 <a href="https://www.webpackjs.com/plugins/html-webpack-plugin/">HtmlWebpackPlugin </a> 生成的文件，打开 dist/index.html，已经自动引入了 main.bundle.js并且注释已被删除。</p></li><li><p>清理 /dist 文件夹：每次执行 npm run build 打包时，都会有上次的代码遗留下来，导致我们的 <code>/dist</code> 文件夹相当杂乱。最好在每次构建前清理 <code>/dist</code> 文件夹。 </p><ul><li><p><a href="https://www.npmjs.com/package/clean-webpack-plugin">clean-webpack-plugin</a> 是一个比较普及的管理插件，让我们安装和配置下： </p><ul><li><p>在 webpack.config.js 中使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;clean-webpack-plugin&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在 plugins 中加入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><h3 id="处理项目中的资源文件（一）"><a href="#处理项目中的资源文件（一）" class="headerlink" title="处理项目中的资源文件（一）"></a>处理项目中的资源文件（一）</h3><h4 id="loader-的使用：尝试处理-ejs"><a href="#loader-的使用：尝试处理-ejs" class="headerlink" title="loader 的使用：尝试处理 ejs"></a>loader 的使用：尝试处理 ejs</h4><ol><li><p>之前已经介绍了 Loader 的概念以及用法，webpack 可以使用 loader 来预处理文件，这允许你打包除 JavaScript 之外的任何静态资源， 甚至允许你直接在 JavaScript 模块中通过 import 来导入 CSS 文件。 </p></li><li><p>在 src 目录下新建 components 文件夹……最后整个目录具体内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-index.html</span><br><span class="line">|-src</span><br><span class="line">  |-index.js</span><br><span class="line">  |-components</span><br><span class="line">    |-modal</span><br><span class="line">      |-modal.ejs</span><br><span class="line">      |-modal.css</span><br><span class="line">      |-modal.js</span><br><span class="line">|-dist</span><br><span class="line">  |-main.bundle.js</span><br><span class="line">|-config</span><br><span class="line">  |-webpack.config.js</span><br><span class="line">|-package.json</span><br></pre></td></tr></table></figure></li><li><p>modal.ejs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;modal-parent&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;modal-header&quot;&gt;</span><br><span class="line">        &lt;h3 class&#x3D;&quot;modal-title&quot;&gt;&lt;%&#x3D; title %&gt;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;modal-body&quot;&gt;</span><br><span class="line">        &lt;%&#x3D; content %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;modal-footer&quot;&gt;</span><br><span class="line">        &lt;%&#x3D; footer %&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li><li><p>modal.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> template <span class="keyword">from</span> <span class="string">&#x27;./modal.ejs&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">modal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name: <span class="string">&#x27;modal&#x27;</span>,</span><br><span class="line">    template: template</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 index.js 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Modal <span class="keyword">from</span> <span class="string">&#x27;./components/modal/modal&#x27;</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">  div.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">  <span class="keyword">let</span> dom = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> modal = <span class="keyword">new</span> Modal()</span><br><span class="line">  dom.innerHTML = modal.template(&#123;</span><br><span class="line">    title: <span class="string">&#x27;标题&#x27;</span>,</span><br><span class="line">    content: <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">    footer: <span class="string">&#x27;底部&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> App()</span><br></pre></td></tr></table></figure></li><li><p>如果此时打包，那么会报错，因为 webpack 还无法解析 ejs 文件，所以我们需要对应的 loader 来打包：</p></li><li><p>安装 loader：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev ejs-loader</span><br></pre></td></tr></table></figure></li><li><p>修改 webpack.config.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HTMLWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: path.join(__dirname, <span class="string">&#x27;../src/index.js&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">&#x27;[name].bundle.js&#x27;</span>,</span><br><span class="line">    path: path.join(__dirname, <span class="string">&#x27;../dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.ejs$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;ejs-loader&#x27;</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HTMLWebpackPlugin(&#123;</span><br><span class="line">      template: path.join(__dirname, <span class="string">&#x27;../index.html&#x27;</span>),</span><br><span class="line">      inject: <span class="literal">true</span>,</span><br><span class="line">      minify: &#123;</span><br><span class="line">        removeComments: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure></li><li><p> 再次执行 npm run build 就不会报错了，打开 dist/index.html 即可查看结果。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（三）：loader案例.md</title>
      <link href="3553fa75c021/"/>
      <url>3553fa75c021/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack"></a>什么是webpack</h2><ol><li>文档：<ul><li><a href="https://webpack.js.org/">webpack</a></li><li><a href="https://www.webpackjs.com/">webpack中文文档</a></li></ul></li><li>可以将 webpack 看做是一个 <strong>模块打包机</strong>，它做的事情是：分析你的项目结构，找到 JavaScript模块 以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用</li><li>Webpack 的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（比如<code>index.js</code>），webpack 将从这个主文件开始找到你的项目的所有依赖文件<br> 使用 loaders 处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件</li></ol><hr><h2 id="安装webpack"><a href="#安装webpack" class="headerlink" title="安装webpack"></a>安装webpack</h2><ol><li>首先你得先安装好 <strong>Node.js</strong>（最好版本够新），因为 webpack 是基于 Node.js 的一个开发工具，webpack 的很多新功能更是基于新的 Node.js 版本的<ul><li>Node.js 官网如下：<a href="https://nodejs.org/en/">Node.js</a></li><li>可以在终端输入 <code>node -v</code> 以及 <code>npm -v</code> 来确定是否已经安装正确</li></ul></li><li>建立一个新的文件夹，我假设为<code>webpack-demo</code></li><li>初始化：<ul><li>打开终端，输入：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li>注：你将会创建一个 <code>package.json</code> 文件，这是一个标准的 npm 说明文件，如果需要自定义一些内容，你也可以使用 <code>npm init</code> 来指定</li></ul></li><li>安装 webpack：<ul><li>在终端输入：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli -D</span><br></pre></td></tr></table></figure></li><li>注：<code>-D</code> 即代表 <code>--save-dev</code>，此处为局部安装，当然也可以通过 <code>npm install webpack webpack-cli-g</code> 来全局安装，但是强烈推荐局部安装<br>  另外，此处是直接连同 webpack-cil 一起安装的，网上也有安装其他的方式，此处仅供参考</li><li>验证 webpack 版本：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack -v</span><br></pre></td></tr></table></figure></li></ul></li><li>安装步骤已经结束啦，现在你的文件夹目录应该如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|- node_modules</span><br><span class="line">|- package.json</span><br><span class="line">|- package-lock.json</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="loader及其使用"><a href="#loader及其使用" class="headerlink" title="loader及其使用"></a>loader及其使用</h2><ol><li>现在我们的目标是：将一个图片打包，并且在网页上显示出来</li><li>新建一个 <code>src</code> 文件夹，来存放我们的资源文件<ul><li>在 <code>src</code> 文件夹中新建文件 <code>index.js</code>，此文件将会作为我们之前提到过的 <strong>主文件</strong>，webpack 页将从这个主文件开始找到这个项目的所有依赖文件</li><li>在 <code>src</code> 文件夹中保存 <code>avatar.jpg</code> 图片，图片如下：<br><img src="https://s2.ax1x.com/2019/11/24/MLx2M6.jpg" class="lazyload" data-srcset="https://s2.ax1x.com/2019/11/24/MLx2M6.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ul></li><li>新建一个 <code>dist</code> 文件夹，来作为即将容纳我们的 html 文件以及打包后的文件：<ul><li><p>在文件夹中新建 <code>index.html</code>，作为要访问的网页，并在文件中输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bundle.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注：这个 `bundle.js` 即为我们打包好的文件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li><li>指定主文件：<ul><li>我们在 <code>src</code> 中新建了 <code>index.js</code>，但是 webpack 默认是在根目录下找 index.js，所以我们需要单独设定</li><li>打开 <code>package.json</code>，将其中的 <code>&quot;main&quot;</code> 改为：<code>&quot;main&quot;: &quot;./src/index.js&quot;</code></li></ul></li><li>配置文件 <code>webpack.config.js</code><ul><li>在根目录下新建 <code>webpack.config.js</code></li><li>在其中输入：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">      filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">      path: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [&#123;</span><br><span class="line">          test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">          use: &#123; <span class="attr">loader</span>: <span class="string">&#x27;file-loader&#x27;</span> &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注：这里只强调 <code>module</code>，对其它的配置项不清楚请查阅官方文档的概念部分</li></ul></li><li>我们已经安装的 webpack 其实并不会知道如何打包图片文件，所以我们在这里引入另一个工具：<code>file-loader</code> 来专门解决图片文件<br>  关于该 loader 的链接如下：<ul><li><a href="https://www.webpackjs.com/loaders/file-loader/">webpack file-loader</a></li></ul></li><li>安装 <code>file-loader</code>：<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure></li><li>入口与出口：<ul><li>在 <code>webpack.config.js</code> 中，我们可以通过 <code>entry</code> 来指定打包的入口文件</li><li>同样，也可以通过 <code>output</code> 来指定我们的出口文件</li></ul></li></ul></li></ol><hr><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ol><li>文件已经配置好啦，现在我们现在终端输入： <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure></li><li>结果如下：<br> <img src="https://s2.ax1x.com/2019/11/24/MOCnHK.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/11/24/MOCnHK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>打开 <code>index.html</code>，就会看到图片。</li></ol><hr><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>我们之前是用 <code>npx webpack</code> 来打包文件，当然我们也可以自定义命令：<ul><li>在 <code>package.json</code> 文件中，指定 <code>&quot;scripts&quot;</code> 如下：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;bundle&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这样我们就可以输入 <code>npm run bundle</code>，结果当时也相同</li></ul></li><li>此处我们打包的是 <code>.jpg</code> 文件，其实我们安装了 <code>file-loader</code> 之后，我们也可以打包 <code>.png</code>、<code>.gif</code>等等，详情请查文档</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（二）：Loader与Plugin</title>
      <link href="e00b596958a5/"/>
      <url>e00b596958a5/</url>
      
        <content type="html"><![CDATA[<h2 id="预处理器（loader）"><a href="#预处理器（loader）" class="headerlink" title="预处理器（loader）"></a>预处理器（loader）</h2><h3 id="loader-概述"><a href="#loader-概述" class="headerlink" title="loader 概述"></a>loader 概述</h3><ol><li>每一个 loader 本质上都是一个函数，在 webpack4 之前，loader 函数的输入输出都必须为字符串，但在 webpack4 之后，loader 也同时支持 <strong>抽象语法树（AST）</strong> 的传递，以此来减少代码的重复解析<br> 用公式可以表示为：<code>output = loader(input)</code></li><li>在此，我们来看一下 loader 的源码结构，以此阐释 loader 是如何工作的： <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">loader</span> (<span class="params">content, map, meta</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callback = <span class="built_in">this</span>.async();</span><br><span class="line">  <span class="keyword">var</span> result = handler(content, map, meta);</span><br><span class="line">  callback&#123;</span><br><span class="line">    <span class="literal">null</span>,  <span class="comment">// error</span></span><br><span class="line">    result.content,  <span class="comment">// 转换后的内容</span></span><br><span class="line">    result.map,  <span class="comment">// 转换后的 source-map</span></span><br><span class="line">    result.meta,  <span class="comment">// 转换后的 AST</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 从代码中可以看出，loader 本身就是一个函数，将函数中接收到的内容进行转换，然后返回转换后的结果<br> （可能包含 <strong>sourcr map 和 AST 对象</strong>）</li></ol><h3 id="loader-的配置"><a href="#loader-的配置" class="headerlink" title="loader 的配置"></a>loader 的配置</h3><ol><li>webpack 只认识 JavaScript，对于其他类型的资源，比如 CSS、图片等等，必须预先定义一个或多个 loader 来进行转译，经过 loader 输出为 webpack 能够接受的形式再继续进行<br> 因此，loader 做的实际上是一个预处理的工作</li><li>loader 的引入：<ul><li><p>假设在我们的目录中，有以下两种文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|-app.js</span><br><span class="line">|-style.css</span><br></pre></td></tr></table></figure></li><li><p>我们要做的是将 css 文件引入到 js 文件中使用，那么跟着我开始吧！</p></li><li><p>安装第三方模块</p><ul><li>webpack 本身并不含有任何的 loader，而所有的 loader 都是第三方 npm 模块，所以我们必须先安装它<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure></li></ul></li><li><p>引入到工程中</p><ul><li><p>在 <code>webpack.config.js</code> 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置项的说明：</p><ul><li><strong>module.rules</strong> 代表着模块的处理规则，每条规则都包含着许多配置项，这里我们只用最重要的两项：<strong>test 和 use</strong></li><li>test 接受一个正则表达式或者元素为正则表达式的数组，如果匹配这条正则表达式，那么就会使用与之对应的规则，比如这里的 <code>/\.css$/</code> 用来匹配所有的 <code>.css</code> 结尾的文件</li><li>use 接受一个数组，数组中包含着对应 test 会使用到的所有 loader，比如这里的 css 文件会使用到 <code>css-loader</code> ，如果只有一个 loader，那么也可以省略数组，只写成字符串</li></ul></li></ul></li><li>链式 loader：<ul><li><p>上述的案例是不成功的，因为我们还差一样东西：style-loader</p></li><li><p>每一个 loader 的功能都是独特而局限的，也就是说，一种类型的模块可以需要多种 loader 共同完成，在处理 css 文件时同样如此，需要 <code>style-loader</code> 和 <code>css-loader</code> 共同完成</p></li><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure></li><li><p>添加配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">    &#125;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 打包时，是按照数组从后往前的顺序将资源交给 loader 处理的，因此要把最后生效的 style-loader 放在最前面</p></li></ul></li><li>exclude 与 include<ul><li><p>在项目中我们经常会用到 <code>babel-loader</code> 来处理 ES6+ 语言特性，将其编译为 ES5 来适应浏览器，但是对于 node_modules 中的 js 文件来说，很多都是已经编译为 ES5 的，因此没必要再使用 babel-loader 来进行额外的处理</p></li><li><p><strong>exclude 与 include</strong> 就是用来排除规则的，他们可接收正则表达式或者字符串（字符串即文件的绝对路径），以及由他们组成的数组，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure><ul><li>这里的含义是：对于匹配到正则表达式的模块，若在 exclude 指定的目录中（此处为 node_modules 目录），则不会执行该 use 规则</li></ul></li><li><p>除了 exclude 之外，使用 include 配置也能达到相同的效果，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  include: <span class="regexp">/src/</span>,</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure></li><li><p>值得注意的是，include 的逻辑似乎与 exclude 是相反的，对于匹配到正则表达式的模块，若在 include 指定的目录中（此处为 src 目录），才执行该 use 规则</p></li><li><p>exclude 与 include 同时存在时，exclude 的优先级更高，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  include: <span class="regexp">/node_modules\/awesome/</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li><li><p>此时，exclude 使得 node_modules 目录已经被排除了，虽然 include 之后想要让该 use 规则对 node_modules 中的某一个模块生效，也是无济于事的，因为 include 是无法覆盖 exclude 的</p></li><li><p>要实现原本的需求，我们可以改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test； /\.css/,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  <span class="comment">// 用 exclude 排除 node_modules 中除了 foo 和 bar 以外的所有模块</span></span><br><span class="line">  exclude: <span class="regexp">/node_modules\/(?!(foo|bar)\/).*/</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>另外，由于 exclude 的优先级跟高，所以我们可以对 include 的子目录进行排除，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test； /\.css/,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  exclude: <span class="regexp">/src\/lib/</span>,</span><br><span class="line">  include: <span class="regexp">/src/</span>,</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><ul><li>此处的结果就是：该 use 规则只对 src 目录生效，同时排除 src 目录中的 lib 目录</li></ul></li></ul><ul><li>注：exclude 与 include 的配置项往往是必须考虑的，也是常加的，否则可能会拖慢整体的打包速度</li></ul></li><li>resource 与 issuer<ul><li><p><strong>resource 与 issuer</strong> 可以用于更加精确地确定模块规则的作用范围，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./style.css&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>在 webpack 中，被加载模块是 resource，而加载者是 issuer，在上面的例子中，resource 是 <code>style.css</code>，加载者是 <code>index.js</code>。</li></ul></li><li><p>前面介绍的 test、exclude、include 在本质上就是对 resource 的配置，如果想要对 issuer 增加条件的话，需要额外地写配置，比如，我们只想让 <code>/src/pages</code> 目录下的 js 文件可以引用 css，本质想就是改变加载者的范围，配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  issuer: &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    include: <span class="regexp">/src/</span>pages/,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;],</span><br><span class="line"><span class="comment">// 只有 /src/pages/ 下面的 js 文件引用 css 文件才能使此 use 规则生效</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>事实上，上述代码的可读性较差，我们可以改为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">  resource: &#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  issuer: &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;],</span><br></pre></td></tr></table></figure></li></ul><ul><li>注：此风格和上面的代码风格无法并存的，只能选择一种风格配置</li></ul></li><li>enforce<ul><li><p>webpack 中的 loader 按照<strong>执行顺序</strong>可分为：pre、inline、normal、post四种，之前我们直接定义的 loader 都属于 normal 类型，官方已不推荐 inline 形式，而 pre 和 post 形式则需我们使用 enforce 指定，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rules: [&#123;</span><br><span class="line">  test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">  enforce: <span class="string">&#x27;pre&#x27;</span>,</span><br><span class="line">  use: <span class="string">&#x27;eslint-loader&#x27;</span>,</span><br><span class="line">  <span class="comment">// eslint-loader 的功能是对源代码进行质量检测，这种检测工作往往在其他 loader 之前执行</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure></li><li><p>这段代码的解释为：对于所有匹配正则表达式的模块，首先使用的 loader 规则就是 eslint-loader</p></li><li><p>概述起来就是，enforce 可以强制指定 loader 的执行顺序</p><ul><li>pre 能强制 loader 首先执行</li><li>post 能强制 loader 最后执行</li></ul></li></ul></li><li>常用 loader 介绍<ul><li>loader 官方文档<ul><li><a href="https://www.webpackjs.com/loaders/">中文：loaders</a></li><li><a href="https://webpack.js.org/loaders/">原文：Loaders</a></li></ul></li><li>下载源<ul><li><a href="https://github.com/webpack-contrib/awesome-webpack#loaders">awesome-webpack:loader</a></li></ul></li><li>模板 loader：<ul><li><strong>html-loader</strong> : 将HTML文件导出编译为字符串，可供js识别的其中一个模块</li><li><strong>pug-loader</strong> : 加载pug模板</li><li><strong>jade-loader</strong> : 加载jade模板(是pug的前身，由于商标问题改名为pug)</li><li><strong>ejs-loader</strong> : 加载ejs模板</li><li><strong>handlebars-loader</strong> : 将Handlebars模板转移为HTML</li></ul></li><li>样式 loader：<ul><li><strong>css-loader</strong> : 解析css文件中代码</li><li><strong>style-loader</strong> : 将css模块作为样式导出到DOM中</li><li><strong>less-loader</strong> : 加载和转义less文件</li><li><strong>sass-loader</strong> : 加载和转义sass/scss文件</li><li><strong>postcss-loader</strong> : 使用postcss加载和转义css/sss文件</li></ul></li><li>脚本转换编译 loader：<ul><li><strong>script-loader</strong> : 在全局上下文中执行一次javascript文件，不需要解析</li><li><strong>babel-loader</strong> : 加载ES6+ 代码后使用Babel转义为ES5后浏览器才能解析</li><li><strong>typescript-loader</strong> : 加载Typescript脚本文件</li><li><strong>coffee-loader</strong> : 加载Coffeescript脚本文件</li></ul></li><li>JSON加载 loader：<ul><li><strong>json-loader</strong> : 加载json文件（默认包含）</li><li><strong>json5-loader</strong> : 加载和转义JSON5文件</li></ul></li><li>Files文件 loader：<ul><li><strong>raw-loader</strong> : 加载文件原始内容(utf-8格式)</li><li><strong>url-loader</strong> : 多数用于加载图片资源,超过文件大小显示则返回data URL</li><li><strong>file-loader</strong> : 将文件发送到输出的文件夹并返回URL(相对路径)</li><li><strong>jshint-loader</strong> : 检查代码格式错误</li></ul></li><li>加载框架 loader：<ul><li><strong>vue-loader</strong> : 加载和转义vue组件</li><li><strong>angualr2-template–loader</strong> : 加载和转义angular组件</li><li><strong>react-hot-loader</strong> : 动态刷新和转义react组件中修改的部分,基于webpack-dev-server插件需先安装,然后在webpack.config.js中引用react-hot-loader</li></ul></li></ul></li></ol><hr><h2 id="插件篇（Plugins）"><a href="#插件篇（Plugins）" class="headerlink" title="插件篇（Plugins）"></a>插件篇（Plugins）</h2><h3 id="初识-Plugin"><a href="#初识-Plugin" class="headerlink" title="初识 Plugin"></a>初识 Plugin</h3><ol><li>我们从最简单的情况说起：处理纯 CSS，之前接触 loader 的时候提及到 <code>style-loader</code> 与 <code>css-loader</code>，确实，通过 js 引用 css 的方式来打包样式很清晰地可以描述模块间的打包关系</li><li>然鹅，我们之前如果是通过 <code>&lt;style&gt;...&lt;/style&gt;</code> 来引入的 css 的，那么如何输出单独的 css 文件呢，在生产环境下，关于样式的代码我们更希望存在于 css 文件中，因为这样更有利于客户端进行缓存</li><li>当然，这个问题在 webpack 中已经有了答案，webpack 有专门的 <strong>插件</strong> ：<code>extract-text-webpack-plugin</code>（适用于 webpack4 之前的版本）以及 <code>mini-css-extract-plugin</code>（适用于 webpack4 及以上的版本），这些就是专门用于提取样式到 css 文件中的</li></ol><h3 id="使用-Plugin"><a href="#使用-Plugin" class="headerlink" title="使用 Plugin"></a>使用 Plugin</h3><ol><li><p>我们先通过一个简单的例子来认识插件是怎么工作的吧，这里使用的是 <code>mini-css-extract-plugin</code>（毕竟要跟上版本嘛）</p><ul><li>当然最直接的方式就是查看文档：<a href="https://github.com/webpack-contrib/mini-css-extract-plugin">mini-css-extract-plugin</a></li><li>不过不熟悉的话还是跟着下面流程走吧</li></ul></li><li><p>安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev mini-css-extract-plugin</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack（一）：初识 Webpack</title>
      <link href="fb2d6a527e7c/"/>
      <url>fb2d6a527e7c/</url>
      
        <content type="html"><![CDATA[<h2 id="初识Webpack"><a href="#初识Webpack" class="headerlink" title="初识Webpack"></a>初识Webpack</h2><h3 id="模块打包工具"><a href="#模块打包工具" class="headerlink" title="模块打包工具"></a>模块打包工具</h3><ol><li>模块打包工具的任务：解决模块之间的依赖，使其打包后能运行在浏览器上</li><li>模块打包工具的工作方式（主要分为以下两种）<ul><li>将存在依赖关系的模块按照特定的规则合并为单个的 JS 文件，一次全部加载进入页面中</li><li>在页面初始时加载一个入口模块，其他模块异步地进行加载</li></ul></li><li>有哪些模块打包工具？<ul><li>Webpack</li><li>Parcel</li><li>Rollup</li></ul></li><li>为什么选择 Webpack ？<ul><li>支持多种模块标准，如 <strong>AMD 规范</strong> 、<strong>Commonjs 规范</strong>、 <strong>ES6 模块规范</strong> 等等</li><li>完备的代码分割方案，通俗地说，就是首屏只加载必要的部分，不太重要的部分放到后面动态地加载</li><li>处理各种类型的资源，除了能处理 JavaScript 文件，还能处理样式、模板、甚至图片</li><li>庞大的社区支持</li></ul></li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>注意：确保已经安装了 <strong>Node.js</strong>，并且该 Node 的版本要尽量新</li><li>初始化项目<ul><li><p>新建 <code>MyWebpack</code> 文件夹，并输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li></ul></li><li>安装 <strong>webpack</strong>：<ul><li><p>我们采用局部安装的方式，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli --save-dev </span><br></pre></td></tr></table></figure><p>注：<code>webpack</code> 是核心模块，<code>webpack-cli</code> 是命令行工具，在这里是需要的</p></li></ul></li><li>检验安装<ul><li>由于我们将 webpack 安装在了本地，所以这里无法使用 “webpack” 指令，<br>  工程内部只能使用 <code>npx webpack &lt;command&gt;</code> 的方式，所以我们输入以下命令检验版本：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npx webpack -v</span><br><span class="line">npx webpack-cli -v</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="打包第一个应用"><a href="#打包第一个应用" class="headerlink" title="打包第一个应用"></a>打包第一个应用</h3><ol><li>在根目录下添加以下几个文件：<ul><li><p>新建 <code>index.js</code> 并输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> addContent <span class="keyword">from</span> <span class="string">&#x27;./addContent&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;My first Webpack app &lt;br/&gt;&#x27;</span>)</span><br><span class="line">addContent()</span><br></pre></td></tr></table></figure></li><li><p>新建 <code>addContent.js</code> 并输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建 <code>index.html</code> 并输入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>在命令行中输入： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack --entry&#x3D;.&#x2F;index.js --output-filename&#x3D;bundle.js --mode&#x3D;development</span><br></pre></td></tr></table></figure></li><li>浏览器打开 <code>index.html</code> 即可看到内容</li><li>回顾刚才的命令：<ul><li><code>entry</code><ul><li>资源打包的入口，Webpack 将从这里开始进行模块依赖的查找，webpack 便知道了项目中包含 <code>index.js</code> 和 <code>addContent.js</code> 两个模块，通过他们来生成产物</li></ul></li><li><code>output-filename</code><ul><li>打包后的文件名</li></ul></li><li><code>mode=development</code><ul><li>打包模式，Webpack 提供了 <strong>development、production、none</strong> 三种模式</li><li>当选择 <strong>development</strong> 和 <strong>production</strong> 模式时，它会自动添加适用于当前模式下的一系列配置，一般在开发环境下，我们选择 <strong>development</strong> 就行了</li></ul></li></ul></li><li>使用 <strong>npm scripts</strong>：<ul><li><p>在 <code>package.json</code> 中添加一下命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;webpack --entry=./index.js --output-filename=bundle.js --mode=development&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在不需要像刚才那样输入冗长的命令，直接输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li></ul></li><li>使用默认目录配置<ul><li><p>通常情况下，我们会设置两个目录，分别为源代码目录和资源输出目录<br>  工程源代码放在  <code>/src</code> 中，输出资源放在 <code>/dist</code> 中</p></li><li><p>Webpack 默认的源代码入口就是 <code>src/index.js</code> ，所以现在我们可以省略掉 <strong>entry</strong> 的配置，编辑 <code>package.json</code> 如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack --output-filename=bundle.js --mode=development&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>使用配置文件<ul><li><p>webpack 有非常多的配置项以及相应的命令行参数，我们可以通过以下命令查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack -h</span><br></pre></td></tr></table></figure></li><li><p>新建 <code>webpack.config.js</code>，输入如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在我们可以去掉 <code>package.json</code> 中配置的打包参数了：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;build&quot;: &quot;webpack&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入 <code>npm run build</code> 即可重新打包</p></li></ul></li><li><strong>webpack-dev-server</strong><ul><li><p>由于我们现在每次更新内容都需要重新打包一次，比较麻烦，我们可以使用 Webpack 社区提供的一个开发工具 —— <code>webpack-dev-server</code></p></li><li><p>安装工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure></li><li><p>在 <code>package.json</code> 中添加一项：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;dev&quot;: &quot;webpack-dev-server&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后，我们需要对 <code>webpack.config.js</code> 进行配置，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">&#x27;./bundle.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        publicPath: <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>webpack.config.js</code> 的 <strong>devServer对象</strong> 是专门配置 webpack-dev-server 的，webpack-dev-server 主要工作就是接受浏览器的请求，然后将资源返回<br>  当服务启动时，会先让 webpack 进行模块打包，当 webpack-dev-server 接收到 浏览器的资源请求时，它会首先进行 URL 地址校验，如果地址是资源服务地址（即配置中的 publicPath），那么就从 webpack 将打包结果返回给浏览器，否则直接从硬盘读取源文件并返回</p></li><li><p>总结 webpack-dev-server 的职能：</p><ul><li>令 webpack 进行模块打包，并处理打包结果的资源请求</li><li>作为 web server，处理静态资源文件请求</li></ul></li><li><p>输入命令，并打开 <code>http://localhost:8080/</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><ul><li>直接用 webpack 开发和使用 webpack-dev-server 有一个很大的区别：前者每次都会生成 bundle.js，而后者只是将打包结果放在内存中，并没有实际写入 bundle.js 中，每次都是将内存中的打包结果返回给浏览器，可以通过删除 dist 目录来检验此区别</li></ul></li><li><p>当然，还需说明的一点是，webpack-dev-server 中的很便捷的的特点就是 <code>live-reloading</code>，来保持本地服务启动以及浏览器打开的状态</p></li></ul></li></ol><hr><h2 id="再谈模块打包"><a href="#再谈模块打包" class="headerlink" title="再谈模块打包"></a>再谈模块打包</h2><h3 id="各种模块规范"><a href="#各种模块规范" class="headerlink" title="各种模块规范"></a>各种模块规范</h3><ul><li>此处不再叙述 CommonJs，ES6 Module 等规范标准以及它们之间的区别，详情清查：<ul><li><a href="http://www.ruanyifeng.com/blog/2012/10/javascript_module.html">Javascript模块化编程</a></li><li><a href="https://www.cnblogs.com/lishuxue/p/6000205.html">CommonJS, AMD, CMD是什么及区别–简单易懂有实例</a></li><li><a href="http://javascript.ruanyifeng.com/nodejs/module.html#toc10">CommonJS规范</a></li></ul></li></ul><h3 id="模块打包原理"><a href="#模块打包原理" class="headerlink" title="模块打包原理"></a>模块打包原理</h3><ol><li>新建两个文件，内容分别如下：<ul><li><p><code>index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./mod.js&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> sum = mod.add(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;sum&#x27;</span>,sum)</span><br></pre></td></tr></table></figure></li><li><p><code>mod.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>打包之后的 JS 文件如下： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">            <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">module</span> = installedModules[moduleId] = &#123;</span><br><span class="line">            i: moduleId,</span><br><span class="line">            l: <span class="literal">false</span>,</span><br><span class="line">            <span class="built_in">exports</span>: &#123;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line">        <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">    &#125;</span><br><span class="line">    __webpack_require__.m = modules;</span><br><span class="line">    __webpack_require__.c = installedModules;</span><br><span class="line">    __webpack_require__.d = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!__webpack_require__.o(<span class="built_in">exports</span>, name)) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123;</span><br><span class="line">                enumerable: <span class="literal">true</span>,</span><br><span class="line">                get: getter</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    __webpack_require__.r = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123;</span><br><span class="line">                value: <span class="string">&#x27;Module&#x27;</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123;</span><br><span class="line">            value: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">    __webpack_require__.t = <span class="function"><span class="keyword">function</span>(<span class="params">value, mode</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mode &amp; <span class="number">1</span>) value = __webpack_require__(value);</span><br><span class="line">        <span class="keyword">if</span> (mode &amp; <span class="number">8</span>) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">if</span> ((mode &amp; <span class="number">4</span>) &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class="keyword">return</span> value;</span><br><span class="line">        <span class="keyword">var</span> ns = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">        __webpack_require__.r(ns);</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(ns, <span class="string">&#x27;default&#x27;</span>, &#123;</span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            value: value</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (mode &amp; <span class="number">2</span> &amp;&amp; <span class="keyword">typeof</span> value != <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> value) __webpack_require__.d(ns, key, <span class="function"><span class="keyword">function</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value[key];</span><br><span class="line">            &#125;.bind(<span class="literal">null</span>, key));</span><br><span class="line">        <span class="keyword">return</span> ns;</span><br><span class="line">    &#125;;</span><br><span class="line">    __webpack_require__.n = <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> getter = <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule ?</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">            &#125; :</span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        __webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line">        <span class="keyword">return</span> getter;</span><br><span class="line">    &#125;;</span><br><span class="line">    __webpack_require__.o = <span class="function"><span class="keyword">function</span>(<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class="line">    &#125;;</span><br><span class="line">    __webpack_require__.p = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./index.js&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">(&#123;</span><br><span class="line">    <span class="string">&quot;./index.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span>, __webpack_require__</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(</span><br><span class="line">            <span class="string">&quot;const mod = __webpack_require__(/*! ./mod.js */ \&quot;./mod.js\&quot;)\r\nconst sum = mod.add(2,3)\r\nconsole.log(&#x27;sum&#x27;,sum)\r\n\n\n//# sourceURL=webpack:///./index.js?&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="string">&quot;./mod.js&quot;</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, <span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">eval</span>(</span><br><span class="line">            <span class="string">&quot;module.exports = &#123;\r\n\tadd: function(a, b)&#123;\r\n\t\treturn a + b;\r\n\t&#125;\r\n&#125;\n\n//# sourceURL=webpack:///./mod.js?&quot;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>上述这个结果可以很清晰地展示它是如何将具有依赖关系的模块串联在一起的，此文件可以分为以下几个部分：<ul><li>最外层立即执行匿名函数，用来包裹整个文件，并形成自己的作用域</li><li><strong>installedModules对象</strong>：每个模块只在第一次被加载的时候执行，然后导出的值就存在这个对象里面，当再次被加载的时候直接从里面取值，而不会重新执行</li><li><strong>__webpack_require__函数</strong>：对于模块加载的实现，在浏览器中可以通过 <code>__webpack_require__(module.id)</code> 来完成模块的导入</li><li><strong>module对象</strong>：工程中所有产生了依赖关系的文件都会以 <strong>key-value</strong> 的形式存放在这里<ul><li><strong>key</strong> 可以理解为一个模块的 id，由数字或者很短的 hash 字符串组成</li><li><strong>value</strong> 是一个匿名函数包裹的模块实体，匿名函数的每个参数赋予了模块的导入和导出的功能</li></ul></li></ul></li><li>打包后的文件在浏览器中的执行过程：<ul><li>最外层的匿名函数初始化浏览器的执行环境，为模块的加载和执行做准备工作，比如定义 <strong>installedModules 对象</strong>、__webpack_require__ 函数等等</li><li>加载入口模块，每个打包后的文件都有一个入口模块，上述实例中，<code>index.js</code> 是入口模块，浏览器即从入口模块开始执行</li><li>执行模块代码：<ul><li>如果执行到了 <code>module.exports</code>，则记录下模块的导出值</li><li>如果执行时遇到了 <code>__webpack_require__</code>，则会暂时交出执行权，进入 __webpack_require__ 函数体内加载其他模块的内容</li></ul></li><li>在 __webpack_require__ 中判断即将加载的模块是否存在于 installedModules 中，如果存在则直接取值，否则返回上一步 —— 执行模块代码获取导出值</li><li>当所有依赖的模块均已执行完毕，则最后的执行权显然又会回到入口模块，当入口模块的代码执行结束，也就标致着整个模块打包过程结束</li></ul></li></ol><hr><h2 id="资源输入与输出"><a href="#资源输入与输出" class="headerlink" title="资源输入与输出"></a>资源输入与输出</h2><h3 id="资源处理流程"><a href="#资源处理流程" class="headerlink" title="资源处理流程"></a>资源处理流程</h3><ol><li>在一切工作开始之前，我们需要指定一个或者多个 <strong>入口（entry）</strong> 来让 webpack 知晓应该从哪里开始打包，如果把各个模块的依赖关系比喻成一颗树，那么入口文件显然就是树根，如图：<br> <img src="https://s2.ax1x.com/2019/12/11/QsvlJH.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/12/11/QsvlJH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>这些存在依赖关系的模块，在打包时会被封装成一个 <strong>chunk</strong>，chunk 的字面意思是代码块，在 webpack 中，可以理解为被封装和抽象过后的一些模块，根据配置不同，webpack可能会形成一个或多个 chunk</li><li>由这个 chunk 得到的打包产物我们称为 <strong>bundle</strong>。<code>entry</code>、<code>chunk</code>、<code>bundle</code>的关系如下：<br> <img src="https://s2.ax1x.com/2019/12/11/Qsxo4g.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/12/11/Qsxo4g.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li><li>在工程中可以定义多个入口，每个入口都会产生一个结果，比如我们有两个入口文件 <code>index.js</code> 和 <code>lib.js</code>，那么打包的结果就会生成 <code>dist/bundle.js</code> 和 <code>dist/lib.js</code>，如图：<br> <img src="https://s2.ax1x.com/2019/12/11/QsxxET.png" class="lazyload" data-srcset="https://s2.ax1x.com/2019/12/11/QsxxET.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII="></li></ol><h3 id="配置资源入口"><a href="#配置资源入口" class="headerlink" title="配置资源入口"></a>配置资源入口</h3><ul><li>webpack 通过 <strong>context</strong> 和 <strong>entry</strong> 两个配置项来共同决定入口文件的路径，在配置时，实际上做了两件事：<ul><li>确定入口模块的位置，告诉 webpack 从哪里开始打包</li><li>定义 <strong>chunk name</strong> ，如果该工程只有唯一入口，那么默认为 main，若有多个入口，那么分别定义对应的 chunk name。</li></ul></li></ul><h4 id="context与entry"><a href="#context与entry" class="headerlink" title="context与entry"></a>context与entry</h4><ol><li>context<ul><li>context 可以理解为资源入口的路径前缀，在配置时要求使用绝对路径的形式，比如下面两个例子：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定路径为：&lt;工程根路径&gt;/src/home/index.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">&#x27;./src&#x27;</span>),</span><br><span class="line">    entry: <span class="string">&#x27;./home/index.js&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 等同于下面这种方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">&#x27;./src/home&#x27;</span>),</span><br><span class="line">    entry: <span class="string">&#x27;./index.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>配置 context 的目的主要是让 entry 的编写更加简洁，这种作用在多入口的情况下尤其突出，此外，context 是可以省略的，则默认值为当前工程的根目录</li><li>context 的配置形式只能为字符串</li></ul></li><li>entry<ul><li>首先，entry 的配置形式可以有多种：字符串、数组、对象、函数，可以根据不同的需求场景来选择</li><li>字符串类型入口<ul><li>直接传入路径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>数组类型入口：<ul><li>传入一个数组的作用是将多个资源先合并，在打包时 webpack 会将数组中的最后一个元素作为实际的入口路径，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>以上配置等同于：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;babel-polyfill&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>对象类型入口：<ul><li>如果想要定义多个入口，则必须要使用对象地形式，对象的属性名（key）是 chunk name，属性值（value）是入口路径，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        <span class="comment">// chunk name 为 index，入口路径为 ./src/index.js</span></span><br><span class="line">        index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// chunk name 为 lib，入口路径为 ./src/lib.js</span></span><br><span class="line">        lib: <span class="string">&#x27;./src/lib.js&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>当然，对象的属性值也可以为字符串或者数组，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    index: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">    lib: <span class="string">&#x27;./src/lib.js&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>函数类型入口：<ul><li>用函数定义入口时，只需要返回字符串、数组或者对象中的任何一种配置形式即可，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串型的入口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function">() =&gt;</span> <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回对象型的入口</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">        index: [<span class="string">&#x27;babel-polyfill&#x27;</span>, <span class="string">&#x27;./src/index.js&#x27;</span>],</span><br><span class="line">        lib: <span class="string">&#x27;./src/lib.js&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用函数的优势是我们可以在函数体内添加一些动态的逻辑来获取入口，而且，函数也支持返回一个 <strong>Promise 对象</strong> 来进行异步操作，如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="string">&#x27;./src/index.js&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li>注：使用字符串或数组定义单入口时，没有办法更改 chunk name，只能为默认的 “main”<br>  使用对象来定义多入口时，则必须为每一个入口定义 chunk name</li></ul></li></ol><h4 id="实例-——-单页与多页"><a href="#实例-——-单页与多页" class="headerlink" title="实例 —— 单页与多页"></a>实例 —— 单页与多页</h4><ol><li>单页应用<ul><li>对于 <strong>单页应用（SPA）</strong> 来说，一般定义单一入口即可：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>这样做的好处是只会产生一个 JS 文件，依赖关系清晰，而弊端就是所有的模块都打包到一个文件中，可能会导致该输出文件体积过大，降低页面的渲染速度<br>  在 webpack 的默认配置中，一个输出文件大于 250KB 时，会认为这个文件已经过大了，在打包时会发出警告</li></ul></li><li>提取 vendor<ul><li>假如工程产生的 JS 文件体积很大，那么一旦代码更新，输出文件也要响相应地更新，这对页面的性能影响是比较大的，我们可以通过 vendor 来解决这个问题</li><li>在 webpack 中，vendor 一般指的是工程所使用的库、框架等第三方模块集中打包产生的输出文件，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    context: path.join(__dirname, <span class="string">&#x27;./src&#x27;</span>),</span><br><span class="line">    entry: &#123;</span><br><span class="line">        index: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">        vendor: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>, <span class="string">&#x27;react-router&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  在上述的例子中，我们添加了一个新的 chunk name 作为 vendor 的入口，通过数组的形式将工程所需的第三方模块放了进去</li></ul></li><li>多页应用<ul><li>我们希望每个页面都只加载各自必要的逻辑，而不是把所有的内容都打包到一个输出文件中，因此每个页面都需要有一个独立的输出文件，如：  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        pageA: <span class="string">&#x27;./src/pageA.js&#x27;</span>,</span><br><span class="line">        pageB: <span class="string">&#x27;./src/pageB.js&#x27;</span>,</span><br><span class="line">        <span class="comment">// 提取 vendor 来对公共模块打包</span></span><br><span class="line">        vendor: [<span class="string">&#x27;react&#x27;</span>, <span class="string">&#x27;react-dom&#x27;</span>],</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="配置资源出口"><a href="#配置资源出口" class="headerlink" title="配置资源出口"></a>配置资源出口</h3><ul><li>所有与出口相关的配置都集中在 <strong>output 对象</strong> 中，此部分最好的学习当然是去查文档啦，给出链接：<ul><li>原文档：<a href="https://webpack.js.org/configuration/output/">Output</a></li><li>中文文档：<a href="https://www.webpackjs.com/configuration/output/">输出(output)</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转字符串</title>
      <link href="58b54336770f/"/>
      <url>58b54336770f/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>链接：<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/</a></li><li>题面：<br><img src="https://user-images.githubusercontent.com/49378661/79094781-2c935280-7d8b-11ea-82e8-8cddac580725.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79094781-2c935280-7d8b-11ea-82e8-8cddac580725.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1586741469839"></li></ol><hr><h2 id="个人方法"><a href="#个人方法" class="headerlink" title="个人方法"></a>个人方法</h2><ol><li><p>分析：由于每个单词反转后的顺序不变，所以我们将该字符串，按照空格分割成独立单词，再反转单词，再拼接</p></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串按空格分成单词，并存入数组中</span></span><br><span class="line">    <span class="keyword">let</span> arr = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="comment">// 遍历数组，将每个单词拆成字母存入数组，再反转，再拼接成单词</span></span><br><span class="line">    <span class="keyword">let</span> result = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将所有单词用空格连成字符串</span></span><br><span class="line">    <span class="keyword">return</span> result.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27; &#x27;</span>).map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> item.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;).join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这样就没有了 arr 和 result，节省了时间和空间</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="大佬启示"><a href="#大佬启示" class="headerlink" title="大佬启示"></a>大佬启示</h2><ol><li><p>之前是先分割成独立单词，再反转单词，再拼接，可是我们用到的 <code>map</code> 方法是比较耗时的，所以优化如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>).reverse().join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>进一步优化为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split 的参数也可以是正则表达式，所以用 /\s+/ 来代替原先的空格字符</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>).split(<span class="regexp">/\s+/</span>).reverse().join(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组中重复的数字</title>
      <link href="5e668cf71402/"/>
      <url>5e668cf71402/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><img src="https://user-images.githubusercontent.com/49378661/102364966-05fc7a00-3ff2-11eb-9429-4b8acd772d99.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102364966-05fc7a00-3ff2-11eb-9429-4b8acd772d99.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201216162437543"></p><hr><h2 id="思路（一）"><a href="#思路（一）" class="headerlink" title="思路（一）"></a>思路（一）</h2><ol><li>转化为集合时，会自动去除重复的元素；</li><li>如果集合的长度小于原数组的长度，那么原数组就有重复的元素；</li><li>题目只要求返回任一重复的元素，那么就边转化边比较长度；</li><li>如果将原数组的元素增加到集合中时，集合的长度没有增加，就返回该元素，结束过程。</li></ol><h2 id="题解（一）"><a href="#题解（一）" class="headerlink" title="题解（一）"></a>题解（一）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> nums) &#123;</span><br><span class="line">        s.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(s.size-i &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结果（一）"><a href="#结果（一）" class="headerlink" title="结果（一）"></a>结果（一）</h2><p>执行用时：100 ms</p><p>内存消耗：45.9 MB</p><hr><h2 id="思路（二）"><a href="#思路（二）" class="headerlink" title="思路（二）"></a>思路（二）</h2><ol><li>先把数组排序，再遍历数组；</li><li>若相邻元素相同，那就返回该元素。</li></ol><h2 id="题解（二）"><a href="#题解（二）" class="headerlink" title="题解（二）"></a>题解（二）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findRepeatNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort();</span><br><span class="line">    <span class="keyword">let</span> cnt = nums.length - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;=cnt; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结果（二）"><a href="#结果（二）" class="headerlink" title="结果（二）"></a>结果（二）</h2><p>执行用时：92 ms</p><p>内存消耗：44.2 MB</p><hr>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>只出现一次的数字</title>
      <link href="c326c1ec9705/"/>
      <url>c326c1ec9705/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>链接：<a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></li><li>题面：<br><img src="https://user-images.githubusercontent.com/49378661/79754377-08ff7780-834a-11ea-825c-02345288f0d3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79754377-08ff7780-834a-11ea-825c-02345288f0d3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a"></li></ol><hr><h2 id="个人方法"><a href="#个人方法" class="headerlink" title="个人方法"></a>个人方法</h2><ol><li><p>分析：</p><ul><li>出现两次的元素的第一次下标和最后一次下标肯定不同</li><li>那么，对于元素 x，若 <code>nums.indexOf(x) == nums.lastIndexOf(x)</code>，则肯定是只出现一次的元素</li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.indexOf(nums[i]) == nums.lastIndexOf(nums[i]))</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="大佬启示"><a href="#大佬启示" class="headerlink" title="大佬启示"></a>大佬启示</h2><h3 id="法一：哈希"><a href="#法一：哈希" class="headerlink" title="法一：哈希"></a>法一：哈希</h3><ol><li><p>分析：</p><ul><li>建立哈希表，空间复杂度为 O(n)</li><li>遍历一次并用数组存储所有数的出现次数</li><li>遍历第二次找到次数为 1 的元素</li><li>最后返回该元素</li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret[nums[i]])</span><br><span class="line">            <span class="keyword">delete</span> ret[nums[i]];</span><br><span class="line">        <span class="keyword">else</span> ret[nums[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(ret)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="法二：先排序后暴力"><a href="#法二：先排序后暴力" class="headerlink" title="法二：先排序后暴力"></a>法二：先排序后暴力</h3><ol><li><p>分析：</p><ul><li>将整数数组排序，若相邻项有相同的，则肯定是出现两次的</li><li>这比直接暴力的时间复杂度要低很多</li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums = nums.sort();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=nums[i+<span class="number">1</span>] &amp;&amp; nums[i]!=nums[i-<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="法三：位运算-——-异或"><a href="#法三：位运算-——-异或" class="headerlink" title="法三：位运算 —— 异或"></a>法三：位运算 —— 异或</h3><ol><li><p>分析：</p><ul><li>异或运算的性质：<ul><li>一个数和 0 异或运算等于本身：<strong>a ⊕ 0 = a</strong></li><li>一个数和其本身异或运算等于 0：<strong>a ⊕ a = 0</strong></li><li>异或运算满足交换律和结合律：<strong>a ⊕ b ⊕ a = ( a ⊕ a ) ⊕ b = 0 ⊕ b = b</strong></li></ul></li><li>所以，将所有的数字按照顺序做异或运算，最后剩下的结果即为唯一的数字</li><li>算法如下：<ul><li>定义 <code>ret=0</code>，用于对每一个数组元素做异或运算</li><li>遍历数组，与 <code>ret</code> 异或运算，且结果赋值给 <code>ret</code></li></ul></li><li>例如，若 <code>nums = [2, 3, 2, 4, 4]</code>，则按照算法执行结果即为 <code>2^3^2^4^4</code>，运用交换律和结合律得知，结果即为唯一的奇数项： 3</li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++)</span><br><span class="line">        ret ^= nums[i];</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>旋转数组</title>
      <link href="9e617b7862e8/"/>
      <url>9e617b7862e8/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>链接：<a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></li><li>题面<br><img src="https://user-images.githubusercontent.com/49378661/79736203-0726bb80-832c-11ea-929b-d8138c488273.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79736203-0726bb80-832c-11ea-929b-d8138c488273.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a"></li></ol><hr><h2 id="个人方法"><a href="#个人方法" class="headerlink" title="个人方法"></a>个人方法</h2><ol><li><p>分析：旋转 k 次，也就是每次都把最后一个元素放到最前面，执行 k 次</p></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">k</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;void&#125;</span> </span>Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        nums.unshift(nums.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>优化：若 <code>k&gt;nums.length</code>，则应该将 k 对 nums.length 求余</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= nums.length)</span><br><span class="line">        k = k%nums.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; k; i ++) &#123;</span><br><span class="line">        nums.unshift(nums.pop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="大佬启示"><a href="#大佬启示" class="headerlink" title="大佬启示"></a>大佬启示</h2><ol><li><p>分析：旋转 k 次，也就是将最后 k 个元素提到最前面</p></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rotate = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &gt;= nums.length)</span><br><span class="line">        k = k%nums.length</span><br><span class="line">    nums.splice(<span class="number">0</span>, <span class="number">0</span>, ...nums.splice(nums.length - k));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除排序数组中的重复项</title>
      <link href="637def054a12/"/>
      <url>637def054a12/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ol><li>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></li><li>题面：<br><img src="https://user-images.githubusercontent.com/49378661/79420290-3c10d680-7feb-11ea-9c23-72ff2c0824d5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/79420290-3c10d680-7feb-11ea-9c23-72ff2c0824d5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1587014876789"></li></ol><hr><h2 id="个人方法"><a href="#个人方法" class="headerlink" title="个人方法"></a>个人方法</h2><ol><li><p>分析：</p><ul><li>给出的是已经排好序的数组，那么重复的元素肯定相邻</li><li>题目中要求的是要在给出的数组上操作，而我们如果不使用深拷贝，就需要一些能操作原始数组的方法， <code>Array.splice()</code> 也就是此次用到的核心方法</li><li>算法：遍历数组，如果第 <code>i</code> 项与第 <code>i+1</code> 项重复，那么就删除第 <code>i</code> 项，再用 <code>i--</code> 更新下标</li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 遍历数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;nums.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123;  <span class="comment">// 若重复</span></span><br><span class="line">      nums.splice(i,<span class="number">1</span>);  <span class="comment">// 删除第i项</span></span><br><span class="line">      i--;  <span class="comment">// 更新下标</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="大佬启示"><a href="#大佬启示" class="headerlink" title="大佬启示"></a>大佬启示</h2><h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><ol><li><p>对于返回的长度，很明显，等于 <strong>原数组的长度 － 重复元素的个数</strong></p></li><li><p>对于返回的数组，由题干以及两个示例可以得出：只是重复的部分被不重复的部分所替代</p><ul><li>如，对于 <code>[1, 2, 3, 3, 4, 5, 6, 6, 7]</code>，经过操作后应该是 <code>[1, 2, 3, 4, 5, 6, 7, 6, 7]</code>，而返回的数组是前7个不重复的元素，即 <code>[1, 2, 3, 4, 5, 6, 7]</code>，返回的长度为7</li></ul></li><li><p>所以，算法如下：</p><ul><li>定义 <code>count</code> 来记录重复的元素</li><li>用 <code>i(1 ≤ i ≤ n)</code> 循环下标来遍历原数组<ul><li>若 <code>nums[i]</code> 与 <code>nums[i-1]</code> 相同，则 <code>count + 1</code>，表示这是第几个重复的元素，</li><li>若 <code>nums[i]</code> 与 <code>nums[i-1]</code> 不同，则 <code>nums[i]</code> 应该向前移动 <code>count</code> 个下标来替换 <code>num[i-count]</code></li></ul></li><li>例如：对于 <code>[1, 2, 3, 3, 4, 5, 6, 6, 7]</code>，<code>1 ≤ i ≤ 2</code> 时 <code>count=0</code>，这段区间的 <code>num[i]</code> 不需要移动，而 <code>i=3</code> 时，<code>num[i]等于num[i-1]</code>，此时 <code>count应该+1</code>，<code>i=4</code> 时，<code>num[i]</code> 就应该替换 <code>num[i-count]</code>，也就是 <code>num[4]</code> 要替换 <code>num[3]</code></li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>,len=nums.length; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[i-<span class="number">1</span>])</span><br><span class="line">            count ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            nums[i-count] = nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len-count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="法二（双指针法）"><a href="#法二（双指针法）" class="headerlink" title="法二（双指针法）"></a>法二（双指针法）</h3><ol><li><p>顾名思义，我们将会用到两个指针，分别是遍历数组的 <code>i</code>，和记录重复元素第一次出现位置的 <code>r</code></p></li><li><p>算法如下：</p><ul><li>用 <code>i(1 ≤ i ≤ n)</code> 遍历数组，并初始化 <code>r=0</code></li><li>若 <code>nums[i]不等于nums[i-1]</code>，则 <code>r++且i++</code> ，且执行 <code>nums[r] = num[i]</code>（这是为了之后遇到不重复元素做铺垫），两个指针将同步循环</li><li>若 <code>nums[i]等于nums[i-1]</code>，则 <code>r</code> 不变，而只是 <code>i++</code>，此时的 <code>r</code> 将记录下重复元素的首次下标</li><li>因为 <code>r</code> 是索引值，所以最后返回的长度是 <code>r+1</code></li></ul></li><li><p>代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>,len=n.length; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != nums[i-<span class="number">1</span>]) &#123;</span><br><span class="line">            r ++;</span><br><span class="line">            nums[r] = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选课</title>
      <link href="8a2e1e17351c/"/>
      <url>8a2e1e17351c/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://user-images.githubusercontent.com/49378661/102797830-2f9b1400-43eb-11eb-8d03-841b5541fb68.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102797830-2f9b1400-43eb-11eb-8d03-841b5541fb68.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="QQ图片20201222001715"></p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cl(x,y) memset(x,y,sizeof(x))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> loop(x,y,z) for(x=y;x&lt;=z;x++)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reve(x,y,z)for(x=y;x&gt;=z;x--)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ct cerr&lt;&lt;<span class="meta-string">&quot;Time elapsed:&quot;</span>&lt;&lt;1.0*clock()/CLOCKS_PER_SEC&lt;&lt;<span class="meta-string">&quot;s.\n&quot;</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> all(x) x.begin(),x.end()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lson x&lt;&lt;1,l,mid</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rson x&lt;&lt;1|1,mid+1,r</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e18</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps=<span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> w[N],len=<span class="number">0</span>,in[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; e[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">  <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> n, m, k, i;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">  <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; ma;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;w[i];</span><br><span class="line">    ma[s]=i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">int</span> k1=ma[s], k2=ma[t];</span><br><span class="line">    in[k2]++;</span><br><span class="line">    e[k1].pb(k2);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">priority_queue</span>&lt;pii,<span class="built_in">vector</span>&lt;pii&gt;,greater&lt;pii&gt;&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(in[i]==<span class="number">0</span>) &#123;</span><br><span class="line">      q.push(mp(w[i],i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">    pii pre = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    ans += pre.fi;</span><br><span class="line">    k--;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;e[pre.se].size(); i++) &#123;</span><br><span class="line">      <span class="keyword">int</span> v = e[pre.se][i];</span><br><span class="line">      in[v]--;</span><br><span class="line">      <span class="keyword">if</span>(in[v]==<span class="number">0</span>) &#123;</span><br><span class="line">        q.push(mp(w[v],v));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>选拔继承人</title>
      <link href="a1f5becdb664/"/>
      <url>a1f5becdb664/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://user-images.githubusercontent.com/49378661/102796247-f2ce1d80-43e8-11eb-8f66-e62d2ac13e93.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102796247-f2ce1d80-43e8-11eb-8f66-e62d2ac13e93.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="QQ图片20201222000050"></p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);</span></span><br><span class="line"><span class="comment">//#define int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> endl <span class="meta-string">&#x27;\n&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s, fa[N][<span class="number">30</span>], deep[N], lg[N];</span><br><span class="line"><span class="keyword">int</span> head[N&lt;&lt;<span class="number">1</span>], nex[N&lt;&lt;<span class="number">1</span>], to[N&lt;&lt;<span class="number">1</span>], tot=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  to[++tot] = b;</span><br><span class="line">  nex[tot] = head[a];</span><br><span class="line">  head[a] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  deep[x] = deep[y]+<span class="number">1</span>;</span><br><span class="line">  fa[x][<span class="number">0</span>] = y;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; (<span class="number">1</span>&lt;&lt;i)&lt;=deep[x]; i++) &#123;</span><br><span class="line">    fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; i; i=nex[i]) &#123;</span><br><span class="line">    <span class="keyword">if</span>(to[i]!=y) &#123;</span><br><span class="line">      dfs(to[i],x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(deep[x]&lt;deep[y]) &#123;</span><br><span class="line">    swap(x,y);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(deep[x]&gt;deep[y]) &#123;</span><br><span class="line">    x=fa[x][lg[deep[x]-deep[y]]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x==y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=lg[deep[x]]; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x][i]!=fa[y][i]) &#123;</span><br><span class="line">      x = fa[x][i];</span><br><span class="line">      y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> in[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  IOS;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">  <span class="keyword">int</span> a, b;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b &amp;&amp; (a+b)) &#123;</span><br><span class="line">    add(a,b);</span><br><span class="line">    add(b,a);</span><br><span class="line">    in[a]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(in[i]==<span class="number">0</span>) &#123;</span><br><span class="line">      s=i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  dfs(s,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++) &#123;</span><br><span class="line">    lg[i]=lg[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> m,ans=<span class="number">0</span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;m;</span><br><span class="line">  <span class="keyword">while</span>(m--) &#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="keyword">int</span> k=LCA(a,b);</span><br><span class="line">    <span class="keyword">if</span>(k==a || k==b) &#123;</span><br><span class="line">      ans++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混合排序</title>
      <link href="6ba5c394a3c6/"/>
      <url>6ba5c394a3c6/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p><img src="https://user-images.githubusercontent.com/49378661/102704784-adabcd80-42ba-11eb-933c-cd86e36965c1.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102704784-adabcd80-42ba-11eb-933c-cd86e36965c1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2020-12-20_115815"></p><hr><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">float</span> eps = <span class="number">0.000001</span>; <span class="comment">// 定义0的精度</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">float</span> brr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 按月薪输出成绩</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt;n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">std</span>::swap(brr[j], brr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=n<span class="number">-1</span>; k&gt;n<span class="number">-1</span>-m; k--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;brr[k]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">B</span><span class="params">(<span class="keyword">float</span> arr[], <span class="built_in">string</span> brr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 按成绩输出学号</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]-arr[j+<span class="number">1</span>]&gt;eps) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">std</span>::swap(brr[j], brr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=n<span class="number">-1</span>; k&gt;n<span class="number">-1</span>-m; k--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;brr[k]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C</span><span class="params">(<span class="keyword">int</span> arr[], <span class="built_in">string</span> brr[], <span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// 按年薪输出名称</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j &lt;n-i<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">std</span>::swap(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">                <span class="built_in">std</span>::swap(brr[j], brr[j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=n<span class="number">-1</span>; k&gt;n<span class="number">-1</span>-m; k--) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;brr[k]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输入N，M，分别表示N行输入，M行判断</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="comment">// N行输入6条数据，分别存入对应数组，外加年薪计算</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="comment">// 数据数组，以及数组复制</span></span><br><span class="line">    <span class="built_in">string</span> xm[<span class="number">1002</span>], xh[<span class="number">1002</span>], mc[<span class="number">1002</span>], xh_2[<span class="number">1002</span>], mc_2[<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">float</span> cj[<span class="number">1002</span>], cj_2[<span class="number">1002</span>];</span><br><span class="line">    <span class="keyword">int</span> ys[<span class="number">1002</span>], yx[<span class="number">1002</span>], nx[<span class="number">1002</span>];</span><br><span class="line">        <span class="comment">// 输入数据</span></span><br><span class="line">    <span class="built_in">string</span> xingming, xuehao, mingcheng;</span><br><span class="line">    <span class="keyword">float</span> chengji;</span><br><span class="line">    <span class="keyword">int</span> yueshu, yuexin;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;xingming&gt;&gt;xuehao&gt;&gt;chengji&gt;&gt;mingcheng&gt;&gt;yuexin&gt;&gt;yueshu;</span><br><span class="line">        xm[i] = xingming;</span><br><span class="line">        xh[i] = xuehao;     xh_2[i] = xuehao;</span><br><span class="line">        cj[i] = chengji;    cj_2[i] = chengji;</span><br><span class="line">        mc[i] = mingcheng;  mc_2[i] = mingcheng;</span><br><span class="line">        yx[i] = yuexin;</span><br><span class="line">        ys[i] = yueshu;</span><br><span class="line">        nx[i] = yuexin*yueshu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对月薪、成绩、年薪分别排序，输出前M个判断数据</span></span><br><span class="line">    A(yx, cj_2, n);</span><br><span class="line">    B(cj, xh_2, n);</span><br><span class="line">    C(nx, mc_2, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>偶数求和</title>
      <link href="6c7433ceebd6/"/>
      <url>6c7433ceebd6/</url>
      
        <content type="html"><![CDATA[<h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>有一个长度为n(0&lt;n&lt;=100)的数列，该数列定义为从2开始的递增有序偶数（公差为2的等差数列），现在要求你按照顺序每m个数求出一个平均值，如果最后不足m个，则以实际数量求平均值。编程输出该平均值序列。</p><p>输入：输入数据有多组，每组占一行，包含两个正整数n和m，n和m的含义如上所述。</p><p>输出：对于每组输入数据，输出一个平均值序列，每组输出占一行。</p><p>样例输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br><span class="line">4 2</span><br></pre></td></tr></table></figure><p>样例输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 6</span><br><span class="line">3 7</span><br></pre></td></tr></table></figure><h3 id="思路（一）"><a href="#思路（一）" class="headerlink" title="思路（一）"></a>思路（一）</h3><ol><li>先分析样例输入：输入3、2：<ul><li>说明 n=3，m=2；</li><li>也就是：在数列 <code>2, 4, 6</code> 中，以2位单位分组求平均值，剩余的分开求平均值</li><li><code>2, 4</code> 为1组，平均值为3，<code>6</code> 单独一组，平均值为6</li><li>则输出就为：3 6</li></ul></li><li>也就是，我们分成两部分：“能分组的” 和 “剩余的”</li><li>能分组的部分：这部分是有规律的，规律就是：在等差数列中，等间距地分组求和所构成的新数列也是等差数列，其平均值也同样是等差数列。</li><li>剩余的部分：求出剩余多少元素，再求出这些元素的和的平均值即可。</li><li>还需注意：<ul><li>n&lt;m 时：没有“能分组的”，只有“剩余的”。</li><li>n%m==0 时：只有“能分组的”，没有“剩余的”。</li><li>所以，在求平均值时，还要再加一些判断。</li></ul></li></ol><h3 id="解题（一）"><a href="#解题（一）" class="headerlink" title="解题（一）"></a>解题（一）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="comment">// 输入n,m</span></span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">100</span>]; <span class="comment">// 输出数组</span></span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m)) &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// 数组下标</span></span><br><span class="line">        <span class="comment">// n个数，每m个一组</span></span><br><span class="line">        <span class="keyword">int</span> a = n/m; <span class="comment">// 分为多少组</span></span><br><span class="line">        <span class="keyword">int</span> b = n%m; <span class="comment">// 分组后还剩余多少</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">// 平均值初始为0</span></span><br><span class="line">        <span class="comment">// 若n&gt;m，则有第一个数</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=<span class="number">2</span>*m; i+=<span class="number">2</span>) &#123;</span><br><span class="line">                ret += i;</span><br><span class="line">            &#125;</span><br><span class="line">            ret /= m;</span><br><span class="line">            <span class="comment">// 保存元素</span></span><br><span class="line">            arr[cnt] = ret;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分组数大于2，则循环存入已分组的数</span></span><br><span class="line">        <span class="keyword">if</span>(a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=(a<span class="number">-1</span>); i++) &#123;</span><br><span class="line">                ret += <span class="number">2</span>*m;</span><br><span class="line">                arr[cnt] = ret;</span><br><span class="line">                cnt ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若有剩余，则再加未分组的平均值</span></span><br><span class="line">        <span class="keyword">if</span>(b != <span class="number">0</span>) &#123;</span><br><span class="line">            ret = <span class="number">0</span>; <span class="comment">// 清零</span></span><br><span class="line">            <span class="keyword">int</span> k = a*m*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=b; i++) &#123;</span><br><span class="line">                ret += (k + i*<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            arr[cnt] = ret/b;</span><br><span class="line">            cnt ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cnt; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="思路（二）"><a href="#思路（二）" class="headerlink" title="思路（二）"></a>思路（二）</h3><ol><li>这次借助数组，把需要的数列元素先存入数组；</li><li>先按照m的值，分开遍历每个组，如果已经遍历完数组或者遍历了一个分组，就计算平均值。</li></ol><h3 id="解题（二）"><a href="#解题（二）" class="headerlink" title="解题（二）"></a>解题（二）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)!=EOF) &#123;</span><br><span class="line">        <span class="keyword">int</span> i, j; <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 数列初始化</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">// 求和</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123; <span class="comment">// 将数列存入数组</span></span><br><span class="line">            a[i] = <span class="number">2</span>+i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; ;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i=m*j; i&lt;m*(j+<span class="number">1</span>); i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[i] == <span class="number">0</span>) <span class="comment">// 遍历完数组，则退出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                sum += a[i]; <span class="comment">// 求和</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, sum/(i-m*j));</span><br><span class="line">            <span class="keyword">if</span>(a[i] == <span class="number">0</span>) <span class="comment">// 遍历完数组，则退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高次方数的尾数</title>
      <link href="5e7a7d126d68/"/>
      <url>5e7a7d126d68/</url>
      
        <content type="html"><![CDATA[<p>继续水题。。。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>求13的13次方的最后三位数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最直接的方法是：将13累乘13次方截取最后三位即可。 但是由于计算机所能表示的整数范围有限，用这种“正确”的算法不可能得到正确的结果。事 实上，题目仅要求最后三位的值，完全没有必要求13的13次方的完整结果。</p><p>研究乘法的规律发现：乘积的最后三位的值只与乘数和被乘数的后三位有关，与乘数和被乘 数的高位无关。</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x, y; <span class="comment">// 输入x、y来表示x的y次方</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">int</span> mul = <span class="number">1</span>; <span class="comment">// 表示乘积 </span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=y; i++) &#123; </span><br><span class="line"><span class="comment">// 每增加一个次方，都只需要后三位</span></span><br><span class="line">mul = (mul*x)%<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d的%d次方的后三位为：%d\n&quot;</span>, x, y, mul);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码</title>
      <link href="7f6d9db2fdc1/"/>
      <url>7f6d9db2fdc1/</url>
      
        <content type="html"><![CDATA[<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">网上流传一句话：&quot;常在网上飘啊，哪能不挨刀啊～&quot;。其实要想能安心地上网其实也不难，学点安全知识就可以。</span><br><span class="line">首先，我们要设置一个安全的密码。那什么样的密码才叫安全的呢？一般来说，比较安全的密码至少应该满足下面两个条件：</span><br><span class="line">(1)密码长度大于等于8，且不要超过16。</span><br><span class="line">(2)密码中的字符应该来自下面“字符类别”中四组中的至少三组。</span><br><span class="line">这四个字符类别分别为：</span><br><span class="line">1.大写字母：A,B,C...Z;</span><br><span class="line">2.小写字母：a,b,c...z;</span><br><span class="line">3.数字：0,1,2...9;</span><br><span class="line">4.特殊符号：~,!,@,#,$,%,^;</span><br><span class="line">给你一个密码，你的任务就是判断它是不是一个安全的密码。</span><br></pre></td></tr></table></figure><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入数据第一行包含一个数M，接下有M行，每行一个密码（长度最大可能为50），密码仅包括上面的四类字符。</span><br></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于每个测试实例，判断这个密码是不是一个安全的密码，是的话输出YES，否则输出NO。</span><br></pre></td></tr></table></figure><h3 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">a1b2c3d4</span><br><span class="line">Linle@ACM</span><br><span class="line">^~^@^@!%</span><br></pre></td></tr></table></figure><h3 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>输入，判断每个元素符合的条件即可</p><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123; <span class="comment">// 输入测试组数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> s[<span class="number">50</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">// 输入字符串</span></span><br><span class="line">            <span class="keyword">int</span> len = <span class="built_in">strlen</span>(s); <span class="comment">// 求出长度</span></span><br><span class="line">            <span class="keyword">if</span>(len&gt;=<span class="number">8</span> &amp;&amp; len&lt;<span class="number">16</span>) &#123; <span class="comment">// 满足长度要求</span></span><br><span class="line">                <span class="keyword">int</span> A=<span class="number">0</span>, B=<span class="number">0</span>, C=<span class="number">0</span>, D=<span class="number">0</span>; <span class="comment">// A,B,C,D分别代表4个条件判断</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">                    <span class="keyword">char</span> c = s[j];</span><br><span class="line">                    <span class="keyword">if</span>(c&gt;=<span class="number">65</span> &amp;&amp; c&lt;=<span class="number">90</span>)</span><br><span class="line">                        A = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c&gt;=<span class="number">97</span> &amp;&amp; c&lt;=<span class="number">122</span>)</span><br><span class="line">                        B = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c&gt;=<span class="number">48</span> &amp;&amp; c&lt;=<span class="number">57</span>)</span><br><span class="line">                        C = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(c==<span class="string">&#x27;~&#x27;</span> || c==<span class="string">&#x27;!&#x27;</span> || c==<span class="string">&#x27;@&#x27;</span> || c==<span class="string">&#x27;#&#x27;</span> || c==<span class="string">&#x27;$&#x27;</span> || c==<span class="string">&#x27;%&#x27;</span> || c==<span class="string">&#x27;^&#x27;</span>)</span><br><span class="line">                        D = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(A+B+C+D &gt;= <span class="number">3</span>) <span class="comment">// A,B,C,D总和不小于3则满足</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不满足长度要求</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阶乘尾数零的个数</title>
      <link href="514d0a0e69a7/"/>
      <url>514d0a0e69a7/</url>
      
        <content type="html"><![CDATA[<p>心情不好，水了好几个题了。。。</p><h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>给定一个正整数 n，请计算 n 的阶乘 <code>n!</code>末尾所含有 “0” 的个数。例如：</p><ul><li>5! = 120，其末尾所含有的 “0” 的个数为 1；</li><li>10! = 3628800，其末尾所含有的 “0” 的个数为 2；</li><li>20! = 2432902008176640000，其末尾所含有的 “0” 的个数为 4。</li></ul><h2 id="思路（一）"><a href="#思路（一）" class="headerlink" title="思路（一）"></a>思路（一）</h2><ol><li><p>两个大数字相乘，都可以拆分成多个质数相乘，而质数相乘结果尾数为0的，只可能是 2*5。</p></li><li><p>所以，两个数相乘尾数0的个数其实就是依赖于2和5因子的个数。</p></li><li><p>例如，对于 <code>10!</code>，有 <code>10! = 1*2*3*4*5*6*7*8*9*10</code>，遍历 <code>1-10</code> 这10个数分别求其质因数，那么 <code>10! = (2)*(3)*(2*2)*(5)*(2*3)*(7)*(2*2*2)*(3*3)*(2*5)</code> </p></li><li><p>找到质因数为2和5的分别有多少个，对 <code>10!</code> 质因数分解后，质因数为2的有8个，质因数为5的有2个，那么所有的2和所有的5一共能组合为2个10，也就是尾数中0的个数为2</p></li></ol><h2 id="解题（一）"><a href="#解题（一）" class="headerlink" title="解题（一）"></a>解题（一）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt; <span class="comment">// 输入阶乘数cnt </span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;cnt);</span><br><span class="line">    <span class="comment">// 存在多少个&#123;2,5&#125;，就有多少个0</span></span><br><span class="line">    <span class="comment">// 将num分解质因数，2的个数为cnt_2，5的个数为cnt_5</span></span><br><span class="line">    <span class="keyword">int</span> cnt_2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt_5 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 用ret遍历cnt，对每个ret都求其质因数</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">for</span>(ret=<span class="number">1</span>; ret&lt;=cnt; ret++) &#123;</span><br><span class="line">        <span class="comment">// 由于求质因数时要改变原数，所以要单独赋值 </span></span><br><span class="line">        <span class="keyword">int</span> num = ret;</span><br><span class="line">        <span class="comment">// 求质因数，并计数</span></span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=num; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i != num) &#123;</span><br><span class="line">                <span class="keyword">if</span>(num%i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">                        cnt_2 += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">                        cnt_5 += <span class="number">1</span>;</span><br><span class="line">                    num = num/i;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">2</span>)</span><br><span class="line">            cnt_2 += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">5</span>)</span><br><span class="line">            cnt_5 += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取较小的作为10的个数</span></span><br><span class="line">    <span class="keyword">if</span>(cnt_2 &lt; cnt_5)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;阶乘尾数中0的个数为：%d\n&quot;</span>, cnt_2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;阶乘尾数中0的个数为：%d\n&quot;</span>, cnt_5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思路（二）"><a href="#思路（二）" class="headerlink" title="思路（二）"></a>思路（二）</h2><ol><li>因为每两个连续数字就会有一个因子2，个数非常充足，所以此时只需要关心5因子的个数就行了。</li><li>我们只需要循环每个阶乘数，并判断该数含有多少个因子5即可。</li></ol><h2 id="解题（二）"><a href="#解题（二）" class="headerlink" title="解题（二）"></a>解题（二）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">// 输入阶乘数num</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>; <span class="comment">// 最后的结果初始化为0 </span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">5</span>; i&lt;=num; i+=<span class="number">5</span>) &#123; <span class="comment">// 以5为单位循环num，计算每个i中含有因子5的个数</span></span><br><span class="line">        <span class="keyword">int</span> j = i; <span class="comment">// i要变化，所以赋值给j</span></span><br><span class="line">        <span class="keyword">while</span>(j%<span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            ret += <span class="number">1</span>; <span class="comment">// 每含有一个5，结果都+1</span></span><br><span class="line">            j /= <span class="number">5</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;阶乘尾数中0的个数为：%d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟原生态的前端请求</title>
      <link href="75a17178196e/"/>
      <url>75a17178196e/</url>
      
        <content type="html"><![CDATA[<ol><li><p>如果想模拟原生态的前端请求，还有跨域问题，那就最好不用一些工具，因为那不是客户端请求了，就用浏览器。</p></li><li><p>在浏览器的 Console 里面的上下文都是跟浏览器共享的，比如百度有使用 jquery 来进行网络请求，可以尝试一下以下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.get(<span class="string">&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;</span>, <span class="function"><span class="params">resp</span> =&gt;</span> <span class="built_in">console</span>.log(resp));</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://user-images.githubusercontent.com/49378661/95295248-4b415480-08a9-11eb-97d2-0c9eca1153ab.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95295248-4b415480-08a9-11eb-97d2-0c9eca1153ab.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007140209443"></p></li></ol><ol start="3"><li>打开浏览器控制台，打开 Sources -&gt; Snippets -&gt; New snippet，新建一个用来测试的脚本：<br><img src="https://user-images.githubusercontent.com/49378661/95295259-4f6d7200-08a9-11eb-8aac-98fc42c0d219.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95295259-4f6d7200-08a9-11eb-8aac-98fc42c0d219.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007140426266"></li></ol><ol start="4"><li><p>我新建了一个 <code>test</code> 的测试脚本，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReq</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    $.get(url, <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">      resolve(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postReq</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    $.post(url, <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">      resolve(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在这里封装你的接口测试方法</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> resp = <span class="keyword">await</span> getReq(<span class="string">&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resp&#x27;</span>, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行测试</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><ul><li>按下 Ctrl+Enter，接口返回的情况结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/95295270-56948000-08a9-11eb-823d-d7e5ff9c876c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95295270-56948000-08a9-11eb-823d-d7e5ff9c876c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007140920470"></li></ul></li></ol><ol start="5"><li><p>如果接口有跨域限制，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getReq</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    $.get(url, <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">      resolve(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">postReq</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    $.post(url, <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">      resolve(resp);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，在这里封装你的接口测试方法</span></span><br><span class="line"><span class="keyword">var</span> main = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> resp = <span class="keyword">await</span> getReq(<span class="string">&#x27;https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=pc_web&amp;sugsid=7524&amp;wd=ss&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=jQuery1102046164195643269457_1601721870208&amp;_=1601721870210&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resp&#x27;</span>, resp);</span><br><span class="line">    <span class="comment">// 请求有跨域限制的接口</span></span><br><span class="line">    resp = <span class="keyword">await</span> getReq(<span class="string">&#x27;https://www.bilibili.com/&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;resp&#x27;</span>, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行测试</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><ul><li>接口返回情况结果如下：<br><img src="https://user-images.githubusercontent.com/49378661/95295283-5dbb8e00-08a9-11eb-89f2-ff77534c45d3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95295283-5dbb8e00-08a9-11eb-89f2-ff77534c45d3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201007141919416"></li></ul></li></ol><ol start="6"><li><p>最后，再封装一些方法，用 github 把测试脚本管理起来，这就是你的专属前端测试框架了。</p></li><li><p>其他了解：</p><ul><li>在浏览器的调试器控制台手写 fetch：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch">使用 Fetch</a></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 随笔漫谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细解浏览器缓存</title>
      <link href="1d7ac5a99202/"/>
      <url>1d7ac5a99202/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li><p>在开发中，我们总会提到 “合理设置缓存”，缓存机制非常普遍，有客户端缓存、服务器缓存、代理服务器缓存等等，在 HTTP 中，具有缓存功能的是浏览器缓存。 HTTP 缓存是作为web 性能优化的重要手段。</p></li><li><p>HTML5 引入了应用程序缓存，在没有网络的情况下也能进行访问，同时，还引入了 storage 本地存储，这些都属于应用缓存，本文主要是和浏览器缓存相关的，也可以说是 HTTP 缓存。</p></li><li><p>什么是浏览器缓存？</p><ul><li><p>MDN 的解释是：</p><blockquote><p>A browser cache holds all documents downloaded via HTTP by the user … without requiring an additional trip to the server.</p></blockquote><p>意思就是，浏览器缓存保存着用户通过 <code>HTTP</code> 获取的所有资源，再下一次请求时可以避免重复向服务器发出多余的请求，简单说，就是在你访问过某网站之后，这个站点的文字、图片等所有资源都被下载到本地了，下次再党文该网站时，会判断是否满足缓存条件，如果满足，则不用再花时间去等待资源的获取了。</p></li><li><p>浏览器的缓存机制也就是我们说的 HTTP 缓存机制，其机制是根据 HTTP 报文的缓存标识进行的所以在分析浏览器缓存机制之前，我们待会儿得先简单介绍一下 HTTP 报文。</p></li></ul></li></ol><hr><h2 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h2><ol><li><p>HTTP 报文分两种：</p><ul><li><p>HTTP 请求（Resquest）报文，报文格式为：请求行 — HTTP 头（通用信息头、请求头、实体头）— 请求报文主体（只有 POST 才有报文主体），如图：<br><img src="https://user-images.githubusercontent.com/49378661/111856114-95a02480-8963-11eb-872c-53e13bb14896.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856114-95a02480-8963-11eb-872c-53e13bb14896.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>HTTP 响应（Response）报文，报文格式为：状态行 — HTTP头（通用信息头、请求头、实体头）— 响应报文主体，如图：<br><img src="https://user-images.githubusercontent.com/49378661/111856125-a5b80400-8963-11eb-98e6-f4bb8aec8ce8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856125-a5b80400-8963-11eb-98e6-f4bb8aec8ce8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p><p><img src="https://user-images.githubusercontent.com/49378661/111856132-aea8d580-8963-11eb-9d5b-8aa37cc1437e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856132-aea8d580-8963-11eb-9d5b-8aa37cc1437e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li></ul></li><li><p>注意：</p><ul><li>通用信息头指的是请求和响应报文都支持的头域，分别为：<code>Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via</code></li><li>实体头则是实体信息的实体头域，分别为：<code>Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header</code></li><li>之前是为了方别理解，而将通用信息头、响应头/请求头、实体头都归为了 HTTP 头</li></ul></li></ol><hr><h2 id="缓存的优点"><a href="#缓存的优点" class="headerlink" title="缓存的优点"></a>缓存的优点</h2><ol><li>减少了冗余的数据传递，节省宽带流量</li><li>减少了服务器的负担，大大提高了网站性能</li><li>加快了客户端加载网页的速度 这也正是HTTP缓存属于客户端缓存的原因</li></ol><hr><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><ol><li>浏览器与服务器通信的方式是应答模式，即为：浏览器发起 HTTP 请求 — 服务器响应该请求，那么，浏览器第一次向服务器发起该请求后拿到结果，会根据响应报文中的 HTTP 头的缓存标识，决定是否缓存结果，若是，则将请求结果和缓存标识存入浏览器缓存中，如图：<br><img src="https://user-images.githubusercontent.com/49378661/111856141-ba949780-8963-11eb-8012-c6dab20b0b04.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856141-ba949780-8963-11eb-8012-c6dab20b0b04.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li>由上图可知：<ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul></li><li>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，下面开始理解浏览器缓存的使用规则</li></ol><hr><h2 id="缓存的规则"><a href="#缓存的规则" class="headerlink" title="缓存的规则"></a>缓存的规则</h2><h3 id="缓存的分类"><a href="#缓存的分类" class="headerlink" title="缓存的分类"></a>缓存的分类</h3><ol><li>一般来说，浏览器缓存可以分为：<ul><li>强缓存</li><li>协商缓存（对比缓存）</li></ul></li><li>浏览器在加载资源时，会先判断是否命中强缓存，再验证是否命中协商缓存</li></ol><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><ol><li><p>浏览器在加载资源时，会先根据本地缓存资源的 <code>header</code> 中的信息判断是否命中强缓存，如果命中，则直接使用缓存中的资源，而不会再向服务器发送请求，如图：<br><img src="https://user-images.githubusercontent.com/49378661/111856146-c3856900-8963-11eb-8617-16d541885c59.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856146-c3856900-8963-11eb-8617-16d541885c59.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>从图中可以看出，强缓存的一般流程是：</p><ul><li>查看 <code>header</code> 头中的 <code>Expire</code> 和 <code>Cache-control</code> 来判断是否满足规则</li><li>如果满足规则，就返回缓存的数据</li><li>如果不满足规则，就向服务器发送请求</li><li>服务器返回数据</li><li>将新数据存入缓存</li></ul></li><li><p>接下来我们主要就关注 <code>Expire</code> 和 <code>Cache-control</code> 这两个字段</p></li><li><p>Expire：</p><ul><li><p>Expires 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，当客户端的时间小于 Expires 的值时，直接使用缓存结果。</p></li><li><p>再看看 MDN 中如何解释这个字段：</p><blockquote><p>The Expires header contains the date/time after which the response is considered stale.</p></blockquote></li><li><p>这个字段包含了一个时间，过了这个时间，响应将会失效。也就是说，<code>Expire</code> 这个字段表示缓存到期时间，我们来打开一个网站并查看 <code>Response Header</code> 看看这个字段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Fri, 27 Oct 2017 07:55:30 GMT</span><br></pre></td></tr></table></figure></li><li><p>可能在你查看这的时候发现时间都已经是过去了 ~，<code>GMT</code> 表示的是格林威治时间，和北京时间相差8小时，上面的这个时间表示的是 <code>2017年10月27日15:55:30</code>。</p></li><li><p>通过设置 <code>Expire</code> 来设置缓存有一个缺点：这个是个绝对时间，也就是说，如果我修改了客户端的本地时间，是不是就会导致判断缓存失效了呢。</p></li><li><p>Expires 是 HTTP/1.0的字段，但是现在浏览器默认使用的是 HTTP/1.1，那么在HTTP/1.1 中网页缓存还是否由 Expires 控制？</p><ul><li>到了 HTTP/1.1，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义。接下来我们开始认识 Cache-Control。</li></ul></li></ul></li><li><p>Cache-Control：</p><ul><li><p>在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。</p></li><li><p>承接上面的例子，既然不能设置绝对时间，那就设置相对时间吧</p></li><li><p>在 <code>HTTP/1.1</code> 中，增加了一个字段 <code>Cache-Control</code> ，它包含一个 <code>max-age</code> 属性，该字段表示资源缓存的最大有效时间，这就是一个相对时间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age&#x3D;600</span><br></pre></td></tr></table></figure></li><li><p>这个表示的就是最大有效时间是 <code>600s</code> ，对的，它的单位是秒。</p></li><li><p><code>Cache-Control</code> 除了 <code>max-age</code> 属性之外还有一些属性：</p><ul><li><code>no-cache</code>：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li><li><code>no-store</code>：禁止使用缓存，每一次都要重新请求数据。</li><li><code>public</code>：默认设置。</li><li><code>private</code>：不能被多用户共享。</li></ul></li><li><p>接下来，我们直接看一个例子，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856151-caac7700-8963-11eb-9ea0-e04a79c4e5d2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856151-caac7700-8963-11eb-9ea0-e04a79c4e5d2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>由上面的例子我们可以知道：</p><ul><li>HTTP 响应报文中 Expires 的时间值，是一个绝对值</li><li>HTTP响应报文中 Cache-Control 为 max-age=600，是相对值</li></ul></li><li><p>由于 Cache-Control 的优先级比 Expires，那么直接根据 Cache-Control 的值进行缓存，意思就是说在600秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。注：在无法确定客户端的时间是否与服务端的时间同步的情况下，Cache-Control 相比于Expires 是更好的选择，所以同时存在时，只有 Cache-Control生效。了解强制缓存的过程后，我们拓展性的思考一下：<strong>浏览器的缓存存放在哪里，如何在浏览器中判断强制缓存是否生效？</strong></p></li><li><p>我们以博客的请求为例，状态码为灰色的请求则代表使用了强制缓存，请求对应的 Size值则代表该缓存存放的位置，分别为 from memory cache 和 from disk cache：<br><img src="https://user-images.githubusercontent.com/49378661/111856156-d13aee80-8963-11eb-930b-1459a91d7aac.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856156-d13aee80-8963-11eb-930b-1459a91d7aac.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>那么 from memory cache 和 from disk cache又分别代表的是什么呢？什么时候会使用from disk cache，什么时候会使用from memory cache呢？</p></li><li><p>from memory cache 代表使用内存中的缓存，from disk cache 则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为 <code>memory –&gt; disk</code></p></li><li><p>对于上个结论，我们需要了解内存缓存（from memory cache）和硬盘缓存（from disk cache），如下:</p><ul><li>内存缓存（from memory cache）：内存缓存具有两个特点，分别是快速读取和时效性。</li><li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li><li>硬盘缓存（from disk cache）：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li></ul></li><li><p>在浏览器中，浏览器会在 js 和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache）</p></li></ul></li><li><p>现在基本上都会同时设置 <code>Expire</code> 和 <code>Cache-Control</code> ，<code>Cache-Control</code> 的优先级别更高。</p></li></ol><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><ol><li><p>当强缓存没有命中的时，浏览器会发送一个请求到服务器，服务器根据请求头中的部分信息来判断是否命中缓存。如果命中，则返回 <code>304</code> ，告诉浏览器资源未更新，可使用本地的缓存。</p></li><li><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li>协商缓存生效，返回304，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856162-db5ced00-8963-11eb-8bb1-d063058ddeb2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856162-db5ced00-8963-11eb-8bb1-d063058ddeb2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li>协商缓存失效，返回200和请求结果结果，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856169-e57eeb80-8963-11eb-9217-34f59e7dfa32.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856169-e57eeb80-8963-11eb-9217-34f59e7dfa32.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li></ul></li><li><p>协商缓存整体流程图：<br><img src="https://user-images.githubusercontent.com/49378661/111856173-f0398080-8963-11eb-8705-5ea1c1441fdc.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856173-f0398080-8963-11eb-8705-5ea1c1441fdc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li></ol><ul><li>从图中可以看出，协商缓存一般是这样一个流程：<ul><li>把资源标识，比如 <code>If-Modify-Since</code> 或 <code>Etag</code> 发送到服务器，确认资源是否更新</li><li>如果资源未更新，请求响应返回的http状态为 <code>304</code> 并且会显示一个 <code>Not Modified</code> 的字符串，告诉浏览器使用本地缓存</li><li>如果资源已经更新，返回新的数据</li><li>将新数据存入缓存</li></ul></li></ul><ol start="4"><li><p>Last-Modified / If-Modified-Since：</p><ul><li><p><code>Last-Modified</code> 是浏览器第一次请求资源的时候，服务器返回的 <code>header</code> 上会带有一个 <code>Last-Modified</code> 字段，服务器响应请求时，返回该资源文件在服务器最后被修改的时间，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856179-f62f6180-8963-11eb-927a-71211b53af19.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856179-f62f6180-8963-11eb-927a-71211b53af19.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>同样的，这是一个 <code>GMT</code> 的绝对时间。</p></li><li><p><code>If-Modified-Since</code> 则是客户端再次发起该请求时，携带上次请求返回的 <code>Last-Modified</code> 值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有 <code>If-Modified-Since</code> 字段，则会根据 <code>If-Modified-Since</code> 的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于 <code>If-Modified-Since</code> 的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856189-ffb8c980-8963-11eb-9da7-ba6a83eb57ac.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856189-ffb8c980-8963-11eb-9da7-ba6a83eb57ac.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></p></li><li><p>当然，这个方法也是有缺点的：</p><ul><li>最小单位是秒。也就是说如果我短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化；</li><li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为。</li></ul></li><li><p>所以，后来又引入一个 <code>Etag</code></p></li></ul></li><li><p>Etag：</p><ul><li><code>Etag</code> 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856192-047d7d80-8964-11eb-8804-8376ebf43b3c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856192-047d7d80-8964-11eb-8804-8376ebf43b3c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li><code>If-None-Match</code>c是客户端再次发起该请求时，携带上次请求返回的唯一标识 <code>Etag</code> 值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有 <code>If-None-Match</code>，则会根据 <code>If-None-Match</code> 的字段值与该资源在服务器的 <code>Etag</code> 值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856195-0a735e80-8964-11eb-93f4-6daf4e828519.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856195-0a735e80-8964-11eb-93f4-6daf4e828519.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li>它一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code>发生改变。</li><li>同样地，在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</li><li><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>，如果 <code>Etag</code> 相等就会继续比对 <code>Last-Modified</code>，最后才会决定是否返回 <code>304</code>。</li><li><code>Etag / If-None-Match</code> 优先级高于 <code>Last-Modified / If-Modified-Since</code>，同时存在则只有 <code>Etag / If-None-Match</code> 生效。</li></ul></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>强制缓存优先于协商缓存进行，若强制缓存（Expires和Cache-Control）生效则直接使用缓存，若不生效则进行协商缓存（Last-Modified / If-Modified-Since和Etag / If-None-Match），</li><li>协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存</li><li>总结的主要过程如下：<br><img src="https://user-images.githubusercontent.com/49378661/111856198-12cb9980-8964-11eb-940c-38c11564f6f2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/111856198-12cb9980-8964-11eb-940c-38c11564f6f2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image"></li><li>即，当浏览器再次访问一个已经访问过的资源时，它会这样做：<ul><li>看看是否命中强缓存，如果命中，就直接使用缓存了；</li><li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；</li><li>如果命中协商缓存，服务器会返回 <code>304</code> 告诉浏览器使用本地缓存；</li><li>否则，返回最新的资源。</li></ul></li></ol><hr><h2 id="用户对缓存的影响"><a href="#用户对缓存的影响" class="headerlink" title="用户对缓存的影响"></a>用户对缓存的影响</h2><p>若是问到用户进行一些操作的时候，对缓存是有什么影响的，答案如下：</p><table><thead><tr><th align="center"><strong>用户操作</strong></th><th align="center"><strong>Expires/Cache-Control</strong></th><th align="center"><strong>Last-Modified/Etag</strong></th></tr></thead><tbody><tr><td align="center">地址栏回车</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">页面链接跳转</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">新开窗口</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">前进回退</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">F5 刷新</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Ctrl+F5 强制刷新</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><hr><h2 id="不同刷新的请求执行过程"><a href="#不同刷新的请求执行过程" class="headerlink" title="不同刷新的请求执行过程"></a>不同刷新的请求执行过程</h2><ol><li>URL（最快）：浏览器地址栏中写入URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。</li><li>F5：告诉浏览器去服务器看看这个文件是否有过期了。于是浏览器就发送一个请求带上 <code>If-Modify-since</code>。</li><li>Ctrl+F5：让浏览器先把缓存中的文件删了，然后再去服务器请求个完整的资源文件下来，于是客户端就完成了强行更新的操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 随笔漫谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（二）：数据库的设计与操作</title>
      <link href="7635befe4d5a/"/>
      <url>7635befe4d5a/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h2><ol><li>在实际项目开发中，如果系统的数据存储量较大，设计的表较多，表与表之间的关系比较复杂，就必须先规范的设计数据库，然后再创建数据库、表等工作。</li><li>糟糕的数据库设计表现在以下几个方面：<ul><li>访问数据效率低下</li><li>存在大量的数据冗余，浪费存储空间</li><li>更新和检索数据时会出现许多问题</li></ul></li><li>良好的数据库设计表现在以下几方面：<ul><li>访问效率高</li><li>减少数据冗余，节省存储空间，便于进一步扩展</li><li>可以使应用程序的开发变得更容易</li></ul></li></ol><hr><h2 id="数据库设计的基本步骤"><a href="#数据库设计的基本步骤" class="headerlink" title="数据库设计的基本步骤"></a>数据库设计的基本步骤</h2><p>在了解数据库设计步骤之前，我们先来了解一下软件项目的开发周期，如下：</p><ul><li>需求分析：<ul><li>需求分析是数据库设计的第一步，是最困难、最耗费时间的一步，也是整个设计过程的基础。</li><li>本阶段的主要任务是对现实世界中要处理的对象（公司、部门及企业，也可以理解成客户）进行详细调查，然后通过分析，逐步明确客户/用户对系统的需求，包括数据需求和业务处理需求。</li><li>需求分析是否做的充分和准确，直接决定了在其上构建数据库大厦的速度与质量。需求分析做的不好，会导致整个数据库设计返工重做。</li></ul></li><li>概要设计：<ul><li>概要设计是数据库设计的关键，通过综合、归纳与抽象用户需求，形成一个具体 DBMS 的概念模型，也就是绘制数据库的 E-R 图。</li><li>E-R 图主要用于在项目团队内部，设计人员和客户之间进行沟通，确认需求信息的正确性和完整性。</li></ul></li><li>逻辑设计/详细设计：<ul><li>将 E-R 图转换为多张表，进行逻辑设计，确认各表的主外键，并应用数据库设计的三大范式进行审核，对其优化。</li><li>在这阶段，E-R 图非常重要。所以要学会根据各个实体定义的属性来画出总体的 E-R 图。</li><li>确定 E-R 图后，根据项目的技术实现，团队开发能力及项目的成本预算，选择具体的数据库（如 MySQL 或 Oracle 等）进行物理实现。</li></ul></li><li>数据库实施：运用 DBMS 提供的数据语言（例如 SQL）、工具及宿主语言（例如 Java），根据逻辑设计和物理设计的结果建立数据库，编制与调试应用程序，组织数据入库，并进行试运行。</li><li>数据库运行和维护阶段：数据库应用系统经过试运行后即可投入正式运行。在运行过程中必须不断地对其进行评价、调整与修改。</li></ul><hr><h2 id="SQL-语句的基本书写规则"><a href="#SQL-语句的基本书写规则" class="headerlink" title="SQL 语句的基本书写规则"></a>SQL 语句的基本书写规则</h2><ol><li>SQL 语句要以分号 <code>;</code> 结尾</li><li>在 RDBMS （关系型数据库）当中，SQL 语句是逐条执行的，一条 SQL 语句代表着数据库的一个操作。</li><li>大小写问题：（不区分大小写的意思是，全部大写或者全部小写或者大小写混合都是一样的）<ul><li>SQL 不区分关键字的大小写（例如，SELECT 等价于 select 等价于 SeLecT）；</li><li>SQL 不区分表名和列名的大小写；</li><li>SQL 区分插入到表中的数据的大小写。</li></ul></li><li>常数的书写方式是固定的：（在 SQL 语句中直接书写的字符串、日期或者数字等称为常数）<ul><li>SQL 语句中含有字符串的时候，需要像 ‘abc’ 这样，使用英文单引号<code>&#39;</code>将字符串括起来，用来标识这是一个字符串。</li><li>SQL 语句中含有日期的时候，同样需要使用英文单引号将其括起来。日期的格式有很多种（’26 Jan 2010’ 或者’10/01/26’ 等）。</li><li>在 SQL 语句中书写数字的时候，不需要使用任何符号标识，直接写成 1000 这样的数字即可。</li><li>列名不是字符串，不能使用单引号，在 MySQL 中可以用倒引号`把表名和列名括起来。</li></ul></li></ol><hr><h2 id="MySql-的注释"><a href="#MySql-的注释" class="headerlink" title="MySql 的注释"></a>MySql 的注释</h2><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><ol><li><p>方式一：<code>#</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 这是单行注释内容</span><br></pre></td></tr></table></figure></li><li><p>方式二：<code>--</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-- 这是单行注释内容</span><br></pre></td></tr></table></figure></li></ol><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>唯一方式：<code>/**/</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line">  第一行注释内容</span><br><span class="line">  第二行注释内容</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure><hr><h2 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h2><h3 id="查看数据库（show-database-…）"><a href="#查看数据库（show-database-…）" class="headerlink" title="查看数据库（show database …）"></a>查看数据库（show database …）</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases [like &#39;数据库名&#39;];</span><br></pre></td></tr></table></figure><p>案例：</p><ol><li><p>查看全部的数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><ul><li>可以发现，在上面的列表中有 6 个数据库，它们都是安装 MySQL 时系统自动创建的，其各自功能如下：<ul><li>information_schema：主要存储了系统中的一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息和分区信息等。</li><li>mysql：MySQL 的核心数据库，类似于 SQL Server 中的 master 表，主要负责存储数据库用户、用户访问权限等 MySQL 自己需要使用的控制和管理信息。常用的比如在 mysql 数据库的 user 表中修改 root 用户密码。</li><li>performance_schema：主要用于收集数据库服务器性能参数。</li><li>sys：MySQL 5.7 安装完成后会多一个 sys 数据库。sys 数据库主要提供了一些视图，数据都来自于 performation_schema，主要是让开发者和使用者更方便地查看性能问题。</li></ul></li></ul></li><li><p>使用 like 从句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 创建 test_db、db_test、db_test_db 三个数据库</span><br><span class="line">mysql&gt; create database test_db;                                           </span><br><span class="line">mysql&gt; create database db_test;                                           </span><br><span class="line">mysql&gt; create database db_test_db;   </span><br><span class="line">                                     </span><br><span class="line"># 使用 like 从句，查看与 test_db 完全匹配的数据库</span><br><span class="line">mysql&gt; show databases like &#39;test_db&#39;;</span><br><span class="line">+--------------------+               </span><br><span class="line">| Database (test_db) |               </span><br><span class="line">+--------------------+               </span><br><span class="line">| test_db            |               </span><br><span class="line">+--------------------+                          </span><br><span class="line">                                     </span><br><span class="line"># 用 like 从句，查看名字中包含 test 的数据库</span><br><span class="line">mysql&gt; show databases like &#39;%test%&#39;; </span><br><span class="line">+-------------------+                </span><br><span class="line">| Database (%test%) |                </span><br><span class="line">+-------------------+                </span><br><span class="line">| db_test           |                </span><br><span class="line">| db_test_db        |                </span><br><span class="line">| test_db           |                </span><br><span class="line">+-------------------+                          </span><br><span class="line">                                     </span><br><span class="line"># 用 like 从句，查看名字以 test 开头的数据库</span><br><span class="line">mysql&gt; show databases like &#39;test%&#39;;  </span><br><span class="line">+------------------+                 </span><br><span class="line">| Database (test%) |                 </span><br><span class="line">+------------------+                 </span><br><span class="line">| test_db          |                 </span><br><span class="line">+------------------+                              </span><br><span class="line">                                     </span><br><span class="line"># 用 like 从句，查看名字以 test 结尾的数据库</span><br><span class="line">mysql&gt; show databases like &#39;%test&#39;;  </span><br><span class="line">+------------------+                 </span><br><span class="line">| Database (%test) |                 </span><br><span class="line">+------------------+                 </span><br><span class="line">| db_test          |                 </span><br><span class="line">+------------------+                             </span><br></pre></td></tr></table></figure></li></ol><h3 id="创建数据库（create-database-…）"><a href="#创建数据库（create-database-…）" class="headerlink" title="创建数据库（create database …）"></a>创建数据库（create database …）</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create database [if not exists] &lt;数据库名&gt;</span><br><span class="line">[[default] character set &lt;字符集名&gt;]</span><br><span class="line">[[default] collate &lt;校对规则名&gt;];</span><br></pre></td></tr></table></figure><ul><li><code>[if not exists]</code>：在创建数据库之前进行判断，只有该数据库目前尚不存在时才能执行操作。此选项可以用来避免数据库已经存在而重复创建的错误。</li><li><code>[default] character set</code>：指定数据库的字符集。指定字符集的目的是为了避免在数据库中存储的数据出现乱码的情况。如果在创建数据库时不指定字符集，那么就使用系统的默认字符集。</li><li><code>[default] collate</code>：指定字符集的默认校对规则。</li></ul><p>案例：</p><ol><li><p>使用 <code>if not exists</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test;</span><br><span class="line">Query OK, 1 row affected (0.20 sec)</span><br><span class="line"></span><br><span class="line"># 直接创建会报错</span><br><span class="line">mysql&gt; create database test;</span><br><span class="line">ERROR 1007 (HY000): Can&#39;t create database &#39;test&#39;; database exists</span><br><span class="line"></span><br><span class="line">mysql&gt; create database if not exists test;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.11 sec)</span><br></pre></td></tr></table></figure></li><li><p>指定字符集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test_db</span><br><span class="line">    -&gt; default character set utf8;</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.13 sec)</span><br></pre></td></tr></table></figure><ul><li><p>用 <code>show create database &#39;数据库名&#39;</code> 来查看该数据库的定义声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看该数据库的定义声明</span><br><span class="line">mysql&gt; show create database test_db;                                           </span><br><span class="line">+----------+------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                  |</span><br><span class="line">+----------+------------------------------------------------------------------+</span><br><span class="line">| test_db  | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |</span><br><span class="line">+----------+------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>注意：</p><ol><li>MySQL 的字符集（character）和校对规则（collate）是两个不同的概念。字符集是用来定义 MySQL 存储字符串的方式，校对规则定义了比较字符串的方式。</li><li>MySQL 不允许在同一系统下创建两个相同名称的数据库。</li></ol><h3 id="修改数据库（alter-database-…）"><a href="#修改数据库（alter-database-…）" class="headerlink" title="修改数据库（alter database …）"></a>修改数据库（alter database …）</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter database [数据库名] &#123;</span><br><span class="line">[default] character set &lt;字符集名&gt; |</span><br><span class="line">[default] collate &lt;校对规则名&gt;&#125;</span><br></pre></td></tr></table></figure><ul><li>alter database 用于更改数据库的全局特性。</li><li>使用 alter database 需要获得数据库 alter 权限。</li><li>数据库名称可以忽略，此时语句对应于默认数据库。</li><li>character set 子句用于更改默认的数据库字符集。</li></ul><p>案例：</p><ol><li><p>查看 test_db 的定义声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create database test_db;</span><br><span class="line">+----------+------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                  |</span><br><span class="line">+----------+------------------------------------------------------------------+</span><br><span class="line">| test_db  | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |</span><br><span class="line">+----------+------------------------------------------------------------------+</span><br></pre></td></tr></table></figure></li><li><p>将数据库 test_db 的指定字符集修改为 gb2312：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter database test_db</span><br><span class="line">    -&gt; default character set gb2312;</span><br><span class="line">Query OK, 1 row affected (0.23 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show create database test_db;</span><br><span class="line">+----------+--------------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                    |</span><br><span class="line">+----------+--------------------------------------------------------------------+</span><br><span class="line">| test_db  | CREATE DATABASE &#96;test_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gb2312 *&#x2F; |</span><br></pre></td></tr></table></figure></li></ol><h3 id="删除数据库（drop-database-…-）"><a href="#删除数据库（drop-database-…-）" class="headerlink" title="删除数据库（drop database ….）"></a>删除数据库（drop database ….）</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><ul><li>&lt;数据库名&gt;：指定要删除的数据库名。</li><li>if exists：用于防止当数据库不存在时发生错误。</li><li>drop database：删除数据库中的所有表格并同时删除数据库。使用此语句时要非常小心，以免错误删除。如果要使用 drop database，需要获得数据库 drop 权限。</li></ul><p>案例：</p><ol><li><p>删除数据库 test：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database test;</span><br><span class="line">Query OK, 0 rows affected (0.06 sec)</span><br></pre></td></tr></table></figure></li><li><p>再次删除时，会报错，之后使用 if exists 从句，可以防止系统报此类错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database test;</span><br><span class="line">ERROR 1008 (HY000): Can&#39;t drop database &#39;test&#39;; database doesn&#39;t exist</span><br><span class="line"></span><br><span class="line">mysql&gt; drop database if exists test;</span><br><span class="line">Query OK, 0 rows affected, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure></li></ol><p>注意：</p><ol><li>MySQL 安装后，系统会自动创建名为 information_schema 和 mysql 的两个系统数据库，系统数据库存放一些和数据库相关的信息，如果删除了这两个数据库，MySQL 将不能正常工作。</li><li>使用 drop database 命令时要非常谨慎，在执行该命令后，MySQL 不会给出任何提示确认信息。drop database 删除数据库后，数据库中存储的所有数据表和数据也将一同被删除，而且不能恢复。因此最好在删除数据库之前先将数据库进行备份</li></ol><h3 id="选择数据库（ues-database-…）"><a href="#选择数据库（ues-database-…）" class="headerlink" title="选择数据库（ues database …）"></a>选择数据库（ues database …）</h3><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>在操作数据库之前就必须要确定是哪一个数据库。</li><li>在 MySQL 中，USE 语句用来完成一个数据库到另一个数据库的跳转。</li><li>当用 create database 语句创建数据库之后，该数据库不会自动成为当前数据库，需要用 USE 来指定当前数据库。</li><li>该语句可以通知 MySQL 把<code>&lt;数据库名&gt;</code>所指示的数据库作为当前数据库。该数据库保持为默认数据库，直到语段的结尾，或者直到遇见一个不同的 USE 语句。 只有使用 USE 语句来指定某个数据库作为当前数据库之后，才能对该数据库及其存储的数据对象执行操作。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（三）：mysql命令行基本操作</title>
      <link href="6ec4d66625a2/"/>
      <url>6ec4d66625a2/</url>
      
        <content type="html"><![CDATA[<h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><h3 id="窗口启动-mysql-服务"><a href="#窗口启动-mysql-服务" class="headerlink" title="窗口启动 mysql 服务"></a>窗口启动 mysql 服务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><h3 id="导出数据库"><a href="#导出数据库" class="headerlink" title="导出数据库"></a>导出数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p –default-character-set&#x3D;latin1 数据库名 &gt; 导出的文件名(数据库默认编码是latin1)</span><br></pre></td></tr></table></figure><h3 id="导出一个表"><a href="#导出一个表" class="headerlink" title="导出一个表"></a>导出一个表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u wcnc -p smgp_apps_wcnc users&gt; wcnc_users.sql</span><br></pre></td></tr></table></figure><h3 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h3><ul><li><p>常用 source 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">mysql&gt;use 数据库</span><br><span class="line">mysql&gt;source x.sql # 后面参数为脚本文件(如这里用到的.sql)</span><br></pre></td></tr></table></figure></li><li><p>使用 mysqldump 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u 用户名 -p 密码 &lt; x.sql</span><br></pre></td></tr></table></figure></li><li><p>使用 mysql 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p -D 密码 &lt; x.sql</span><br></pre></td></tr></table></figure></li><li><p>建议使用 Navicat 工具操作 mysql</p></li></ul><h3 id="SQL-语句的分类"><a href="#SQL-语句的分类" class="headerlink" title="SQL 语句的分类"></a>SQL 语句的分类</h3><ol><li>数据定义语言（DDL）：create、drop、alter</li><li>数据操作语言（DML）：insert、delete、update、truncate</li><li>数据查询语言（DQL）：select、show</li><li>数据控制语言：grant、revoke</li></ol><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h3 id="查看所有数据库："><a href="#查看所有数据库：" class="headerlink" title="查看所有数据库："></a>查看所有数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><h3 id="创建活跃连接："><a href="#创建活跃连接：" class="headerlink" title="创建活跃连接："></a>创建活跃连接：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROCESSLIST;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show processlist;</span><br><span class="line">+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+</span><br><span class="line">| Id | User            | Host            | db   | Command | Time  | State                  | Info</span><br><span class="line">   |</span><br><span class="line">+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+</span><br><span class="line">|  4 | event_scheduler | localhost       | NULL | Daemon  | 25324 | Waiting on empty queue | NULL</span><br><span class="line">   |</span><br><span class="line">| 14 | root            | localhost:52760 | NULL | Query   |     0 | starting               | show processlist |</span><br><span class="line">+----+-----------------+-----------------+------+---------+-------+------------------------+------------------+</span><br></pre></td></tr></table></figure><h3 id="创建数据库："><a href="#创建数据库：" class="headerlink" title="创建数据库："></a>创建数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个名为 ozzie 的数据库</span><br><span class="line">mysql&gt; create database ozzie;</span><br><span class="line">Query OK, 1 row affected (0.44 sec)</span><br><span class="line"></span><br><span class="line"># 查看所有的数据库（此时应该多出了 ozzie）</span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| ozzie              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><h3 id="查看数据库的默认字符集："><a href="#查看数据库的默认字符集：" class="headerlink" title="查看数据库的默认字符集："></a>查看数据库的默认字符集：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show create database ozzie;</span><br><span class="line">+----------+----------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                                |</span><br><span class="line">+----------+----------------------------------------------------------------+</span><br><span class="line">| ozzie    | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F; |</span><br><span class="line">+----------+----------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="选择数据库："><a href="#选择数据库：" class="headerlink" title="选择数据库："></a>选择数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE 数据库名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use ozzie;</span><br><span class="line">Database changed</span><br></pre></td></tr></table></figure><h3 id="查看当前使用的数据库："><a href="#查看当前使用的数据库：" class="headerlink" title="查看当前使用的数据库："></a>查看当前使用的数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASES();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select database();</span><br><span class="line">+------------+</span><br><span class="line">| database() |</span><br><span class="line">+------------+</span><br><span class="line">| ozzie      |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><h3 id="修改数据库："><a href="#修改数据库：" class="headerlink" title="修改数据库："></a>修改数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER DATABASE &lt;数据库名&gt; DEFAULT CHARACTER SET GBK;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter database ozzie default character set gbk;                      </span><br><span class="line">Query OK, 1 row affected (0.47 sec)                                         </span><br><span class="line"></span><br><span class="line"># 此时字符集由 utf8 变成了 gbk</span><br><span class="line">mysql&gt; show create database ozzie;                                          </span><br><span class="line">+----------+---------------------------------------------------------------+</span><br><span class="line">| Database | Create Database                                               |</span><br><span class="line">+----------+---------------------------------------------------------------+</span><br><span class="line">| ozzie    | CREATE DATABASE &#96;ozzie&#96; &#x2F;*!40100 DEFAULT CHARACTER SET gbk *&#x2F; |</span><br><span class="line">+----------+---------------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="删除数据库："><a href="#删除数据库：" class="headerlink" title="删除数据库："></a>删除数据库：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE 数据库名;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop database ozzie;</span><br><span class="line">Query OK, 0 rows affected (0.19 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 数据表名(&lt;字段名&gt; &lt;类型&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;]);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有数据库</span><br><span class="line">mysql&gt; SHOW DATABASES;  </span><br><span class="line">+--------------------+  </span><br><span class="line">| Database           |  </span><br><span class="line">+--------------------+  </span><br><span class="line">| information_schema |  </span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |  </span><br><span class="line">| sys                |  </span><br><span class="line">+--------------------+  </span><br><span class="line"></span><br><span class="line"># 创建一个名为 ozzie 的数据库</span><br><span class="line">mysql&gt; CREATE DATABASE ozzie;</span><br><span class="line">Query OK, 1 row affected (0.23 sec) </span><br><span class="line"></span><br><span class="line"># 查看数据库（此时会多出一个 ozzie）</span><br><span class="line">mysql&gt; SHOW DATABASES;              </span><br><span class="line">+--------------------+              </span><br><span class="line">| Database           |              </span><br><span class="line">+--------------------+              </span><br><span class="line">| information_schema |              </span><br><span class="line">| mysql              |              </span><br><span class="line">| ozzie              |              </span><br><span class="line">| performance_schema |              </span><br><span class="line">| sys                |              </span><br><span class="line">+--------------------+              </span><br><span class="line">         </span><br><span class="line"># 使用 ozzie</span><br><span class="line">mysql&gt; USE ozzie;</span><br><span class="line">Database changed</span><br><span class="line"></span><br><span class="line"># 创建一个名为 student 的表</span><br><span class="line">mysql&gt; CREATE TABLE student</span><br><span class="line">    -&gt; (</span><br><span class="line">    -&gt; id int(4) not null primary key auto_increment,</span><br><span class="line">    -&gt; name char(20) not null,</span><br><span class="line">    -&gt; sex char(4) not null default &#39;男&#39;,</span><br><span class="line">    -&gt; degree double(16, 2)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (1.77 sec)</span><br></pre></td></tr></table></figure><h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><ul><li><p>方式一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC &lt;表名&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; DESC student;                                             </span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(4)       | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | char(20)     | NO   |     | NULL    |                |</span><br><span class="line">| sex    | char(4)      | NO   |     | 男      |                | </span><br><span class="line">| degree | double(16,2) | YES  |     | NULL    |                |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure></li><li><p>方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW COLUMNS from &lt;表名&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW COLUMNS FROM student;                                </span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(4)       | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | char(20)     | NO   |     | NULL    |                |</span><br><span class="line">| sex    | char(4)      | NO   |     | 男      |                | </span><br><span class="line">| degree | double(16,2) | YES  |     | NULL    |                |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br></pre></td></tr></table></figure></li></ul><h3 id="查看所有表："><a href="#查看所有表：" class="headerlink" title="查看所有表："></a>查看所有表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW TABLES;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_ozzie |</span><br><span class="line">+-----------------+</span><br><span class="line">| student         |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><h3 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO &lt;表名&gt; [(&lt;字段名&gt;[,..&lt;字段名n&gt;])] values (值)[,(值n)]</span><br></pre></td></tr></table></figure><ul><li><p>现在向表中插入两条记录，这两条记录分别表示：</p><ul><li>id 为 1，name 为 ‘Tom’，sex 为 ‘男’，degree 为 99.45</li><li>id 为 2，name 为 ‘Alice’，sex 为 ‘女’，degree 为 82.64</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; insert into student values</span><br><span class="line">     &gt; (1, &#39;Tom&#39;, &#39;男&#39;, 99.45),</span><br><span class="line">     &gt; (2, &#39;Alice&#39;, &#39;女&#39;, 82.64);</span><br><span class="line">Query OK, 2 rows affected (0.91 sec)</span><br><span class="line">Records: 2  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure></li></ul><h3 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &lt;字段, 字段, ...&gt; FROM &lt;表名&gt; WHERE &lt;表达式&gt;;</span><br></pre></td></tr></table></figure><ul><li><p>查看前两行的所有数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from student order by id limit 0,2;</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">| id | name  | sex | degree |</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">|  1 | Tom   | 男  |  99.45 |</span><br><span class="line">|  2 | Alice | 女  |  82.64 |</span><br><span class="line">+----+-------+-----+--------+</span><br></pre></td></tr></table></figure></li><li><p>查看所有的 name：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select name from student;</span><br><span class="line">+-------+</span><br><span class="line">| name  |</span><br><span class="line">+-------+</span><br><span class="line">| Tom   |</span><br><span class="line">| Alice |</span><br><span class="line">+-------+</span><br></pre></td></tr></table></figure></li><li><p>查看前两行的 degree：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select degree from student order by id limit 0,2;</span><br><span class="line">+--------+                                              </span><br><span class="line">| degree |                                              </span><br><span class="line">+--------+                                              </span><br><span class="line">|  99.45 |                                              </span><br><span class="line">|  82.64 |                                              </span><br><span class="line">+--------+</span><br></pre></td></tr></table></figure></li><li><p>查看 id 为 1 的 sex：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select sex from student where id&#x3D;1;</span><br><span class="line">+-----+</span><br><span class="line">| sex |</span><br><span class="line">+-----+</span><br><span class="line">| 男  |</span><br><span class="line">+-----+</span><br></pre></td></tr></table></figure></li></ul><h3 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &lt;字段, 字段, ...&gt; FROM &lt;表达式&gt;;</span><br></pre></td></tr></table></figure><p>删除 id 为 1 的记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 先查看所有数据</span><br><span class="line">mysql&gt; select * from student</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">| id | name  | sex | degree |</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">|  1 | Tom   | 男  |  99.45 |</span><br><span class="line">|  2 | Alice] | 女  |  82.64 |</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line"></span><br><span class="line"># 删除 id 为 1 的记录</span><br><span class="line">mysql&gt; delete from student where id&#x3D;1;</span><br><span class="line">Query OK, 1 row affected (0.79 sec)</span><br><span class="line"></span><br><span class="line"># 再次查看所有数据（此时应该只剩下 id&#x3D;2 的记录）</span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">| id | name  | sex | degree |</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line">|  2 | Alice | 女  |  82.64 |</span><br><span class="line">+----+-------+-----+--------+</span><br><span class="line"></span><br><span class="line"># 删除 name 为 Alice 的记录</span><br><span class="line">mysql&gt; delete from student where name&#x3D;&#39;Alice&#39;;</span><br><span class="line">Query OK, 1 row affected (0.47 sec)</span><br><span class="line"></span><br><span class="line"># 再次查看所有数据（此时应该没有记录）</span><br><span class="line">mysql&gt; select * from student;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="在表中增加字段："><a href="#在表中增加字段：" class="headerlink" title="在表中增加字段："></a>在表中增加字段：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; add &lt;字段&gt; &lt;类型&gt; &lt;其他&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 查看表中原先字段</span><br><span class="line">mysql&gt; desc student;                                             </span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| Field  | Type         | Null | Key | Default | Extra          |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line">| id     | int(4)       | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| name   | char(20)     | NO   |     | NULL    |                |</span><br><span class="line">| sex    | char(4)      | NO   |     | 男      |                | </span><br><span class="line">| degree | double(16,2) | YES  |     | NULL    |                |</span><br><span class="line">+--------+--------------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line"># 增加一条叫做 birthday 的字段，类型为 date，默认值为 &#39;2000-01-01&#39;</span><br><span class="line">mysql&gt; alter table student add birthday date default &#39;2000-01-01&#39;;</span><br><span class="line">Query OK, 0 rows affected (1.20 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># 现在多了一条 dirthday 字段</span><br><span class="line">mysql&gt; desc student;</span><br><span class="line">+----------+--------------+------+-----+------------+----------------+</span><br><span class="line">| Field    | Type         | Null | Key | Default    | Extra          |</span><br><span class="line">+----------+--------------+------+-----+------------+----------------+</span><br><span class="line">| id       | int(4)       | NO   | PRI | NULL       | auto_increment |</span><br><span class="line">| name     | char(20)     | NO   |     | NULL       |                |</span><br><span class="line">| sex      | char(4)      | NO   |     | 男         |                |</span><br><span class="line">| degree   | double(16,2) | YES  |     | NULL       |                |</span><br><span class="line">| birthday | date         | YES  |     | 2000-01-01 |                |</span><br><span class="line">+----------+--------------+------+-----+------------+----------------+</span><br></pre></td></tr></table></figure><h3 id="删除表："><a href="#删除表：" class="headerlink" title="删除表："></a>删除表：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; drop table student;</span><br><span class="line">Query OK, 0 rows affected (1.15 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">Empty set (0.00 sec)</span><br></pre></td></tr></table></figure><h3 id="更改表名："><a href="#更改表名：" class="headerlink" title="更改表名："></a>更改表名：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RENAME TABLE &lt;原表名&gt; to &lt;新表名&gt;；</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; rename table student to new_student;</span><br><span class="line">Query OK, 0 rows affected (0.70 sec)</span><br><span class="line"></span><br><span class="line"># 由 student 变为了 new_student</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------+</span><br><span class="line">| Tables_in_ozzie |</span><br><span class="line">+-----------------+</span><br><span class="line">| new_student     |</span><br><span class="line">+-----------------+</span><br></pre></td></tr></table></figure><h3 id="更改字段名字："><a href="#更改字段名字：" class="headerlink" title="更改字段名字："></a>更改字段名字：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE &lt;表名&gt; CHANGE &lt;字段名&gt; &lt;字段新名&gt; &lt;字段类型&gt;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 把名为 id 的字段改名称为 studentId</span><br><span class="line">mysql&gt; alter table new_student change id studentId int(4);</span><br><span class="line">Query OK, 0 rows affected (0.79 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"># 此时 id 应改为了 studentId</span><br><span class="line">mysql&gt; desc new_student;</span><br><span class="line">+-----------+--------------+------+-----+------------+-------+</span><br><span class="line">| Field     | Type         | Null | Key | Default    | Extra |</span><br><span class="line">+-----------+--------------+------+-----+------------+-------+</span><br><span class="line">| studentId | int(4)       | NO   | PRI | NULL       |       |</span><br><span class="line">| name      | char(20)     | NO   |     | NULL       |       |</span><br><span class="line">| sex       | char(4)      | NO   |     | 男         |       |</span><br><span class="line">| degree    | double(16,2) | YES  |     | NULL       |       |</span><br><span class="line">| birthday  | date         | YES  |     | 2000-01-01 |       |</span><br><span class="line">+-----------+--------------+------+-----+------------+-------+</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库（一）：数据库入门了解</title>
      <link href="0c221b96c236/"/>
      <url>0c221b96c236/</url>
      
        <content type="html"><![CDATA[<h2 id="了解数据库："><a href="#了解数据库：" class="headerlink" title="了解数据库："></a>了解数据库：</h2><ol><li>数据库（DataBase）：数据库是一个以某种有组织的方式存储的数据集合，并不能用数据库来代表数据库软件，数据库软件应称为 DBMS（数据库管理系统），数据库 是通过DBMS创建和操纵的容器，简单来说，你使用的是DBMS，它替你访问数据库。</li><li>表（Table）：某种特定类型数据的结构化清单。每个表的名字（表名）在同一数据库中是唯一的，但在不同的数据库中可以使用相同的表名。</li><li>模式（Schema）：关于数据库和表的布局及特性的信息。有时，模式用作数据库的同义词，但模式的含义通常在上下文中并不是很清晰。</li><li>列（Column）：表由列组成，一列就是表中的一个字段。数据库中的每个列都有相应的数据类型，列可以存储的数据种类是有规定的。</li><li>行（Row）：表中的数据是按行存储的，一行就是表中的一个记录。所保存的每个记录存储在自己的行内。 如果将表想象为网格，网格中垂直的列为表列，水平行为表行。 <ul><li>可以将 “行” 称为 数据库记录（record）。在很大程度上，这两个术语是可以互相替代的，但从技术上说，“行” 才是正确的术语。 </li></ul></li><li>主键（Primary Key）：一列（或一组列），其值能够唯一区分表中每个行，唯一标识表中每行的这个列（或这组列）称为主键。例如用每个人的身份证号来标识每个人。<ul><li>表中的任何列都可以作为主键，只要它满足以下条件：<ul><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值（主键列不允许 NULL 值）。</li></ul></li><li>主键通常定义在表的一列上，但也可以使用多个列（组列）作为主键。</li><li>一些关于主键的约定：<ul><li>不更新主键列中的值； </li><li>不重用主键列的值；</li><li>不在主键列中使用可能会更改的值（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并和更改其名字时，必须更改这个主键）。</li></ul></li></ul></li><li>DBMS（Data Base Management System，数据库管理系统）：是位于用户与操作系统之间的一层数据管理软件，是数据库系统的核心。数据的所有存储、检索、管理和处理实际上都是由数据库软件 —— DBMS 完成的。<ul><li>DBMS 可分为两类：<ul><li>基于共享文件系统的DBMS：例如 Microsoft Access 和 FileMaker，用于桌面用途，通常不用于高端或更关键的应用。</li><li>基于客户机—服务器的DBMS：例如 MySQL、Oracle 以及 Microsoft SQL Server 等数据库。客户机—服务器 应用分为两个不同的部分：<ul><li>客户机是与用户打交道的软件，客户机软件通过网络把用户的请求提交给服务器软件。</li><li>服务器部分是负责所有数据访问和处理的一个软件，这个软件运行在 “数据库服务器” 上面，与数据文件打交道的只有服务器软件，关于数据、数据添加、删除和数据更新的所有请求都由服务器软件完成。</li><li>客户机和服务器软件可能安装在两台计算 机或一台计算机上。不管它们在不在相同的计算机上，为进行 所有数据库交互，客户机软件都要与服务器软件进行通信。 </li></ul></li></ul></li></ul></li><li>DBA（Data Base Administrator，数据库用户）：是从事管理和维护数据库管理系统的相关工作人员。</li><li>DBS（Data Base System，数据库系统）：采用了数据库技术的计算机系统。</li></ol><h2 id="数据库的大致分类"><a href="#数据库的大致分类" class="headerlink" title="数据库的大致分类"></a>数据库的大致分类</h2><blockquote><p>数据库有两种类型，分别是关系型数据库和非关系型数据库。</p></blockquote><ol><li>关系型数据库：关系型数据库是建立在关系模型基础上的数据库，是由多张能互相连接的表组成的数据库。<ul><li>优点：<ul><li>都使用表结构，格式一致，易于维护。</li><li>使用通用的 SQL 语言操作，使用方便，可用于复杂查询。</li><li>数据存储在磁盘中，比较安全。</li></ul></li><li>缺点：<ul><li>读写性能比较差，不能满足海量数据的高效率读写。</li><li>不节省空间。因为建立在关系模型上，就要遵循某些规则，比如数据中某字段值即使为空仍要分配空间。</li><li>固定的表结构，灵活度较低。</li></ul></li><li>常见的关系型数据库：Oracle、DB2、PostgreSQL、Microsoft SQL Server、Microsoft Access 和 MySQL。</li></ul></li><li>非关系型数据库：非关系型数据库又被称为 <a href="http://c.biancheng.net/nosql/">NoSQL</a>（Not Only SQL )，意为不仅仅是 SQL。通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定。<ul><li>优点：</li><li>缺点：</li><li>常见的非关系型数据库：Neo4j、<a href="http://c.biancheng.net/mongodb/">MongoDB</a>、<a href="http://c.biancheng.net/redis/">Redis</a>、Memcached、MemcacheDB 和 <a href="http://c.biancheng.net/hbase/">HBase</a> 等。</li></ul></li></ol><h2 id="了解-SQL"><a href="#了解-SQL" class="headerlink" title="了解 SQL"></a>了解 SQL</h2><ol><li><p>SQL（Structured Query Language）：是结构化查询语言，是一种专门用来与数据库通信的语言，用于存取数据以及查询、更新和管理关系数据库系统。</p></li><li><p>SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的 DBMS（数据管理系统）都支持 SQL，所以，学习此语言使你几乎能与所有数据库打交道。</p></li><li><p>SQL不是一种专利语言，而且存在一个标准委员会，但是，任意两个 DBMS 实现的 SQL 都不完全相同，也就是，不同的 DBMS 对应的 SQL 语法不是完全可移植的。</p></li><li><p>与其他程序设计语言（如 C语言、Java 等）不同的是，SQL 由很少的关键字组成，每个 SQL 语句通过一个或多个关键字构成。</p></li><li><p>SQL 的优点：</p><ul><li>一体化：SQL 集数据定义、数据操作和数据控制于一体，可以完成数据库中的全部工作。</li><li>使用方式灵活：SQL 具有两种使用方式，可以直接以命令方式交互使用；也可以嵌入使用，嵌入C、C++、Fortran、COBOL、Java 等语言中使用。</li><li>非过程化：只提操作要求，不必描述操作步骤，也不需要导航。使用时只需要告诉计算机“做什么”，而不需要告诉它“怎么做”，存储路径的选择和操作的执行由数据库管理系统自动完成。</li><li>语言简洁、语法简单：该语言的语句都是由描述性很强的英语单词组成，而且这些单词的数目不多。</li></ul></li><li><p>SQL 包含以下 4 部分：</p><ul><li>数据定义语言（Data Definition Language，DDL）：用来创建或删除数据库以及表等对象，主要包含以下几种命令：<ul><li>DROP：删除数据库和表等对象</li><li>CREATE：创建数据库和表等对象</li><li>ALTER：修改数据库和表等对象的结构</li></ul></li><li>数据操作语言（Data Manipulation Language，DML）：用来变更表中的记录，主要包含以下几种命令：<ul><li>SELECT：查询表中的数据</li><li>INSERT：向表中插入新数据</li><li>UPDATE：更新表中的数据</li><li>DELETE：删除表中的数据</li></ul></li><li>数据查询语言（Data Query Language，DQL）：用来查询表中的记录，主要包含 SELECT 命令，来查询表中的数据。</li><li>数据控制语言（Data Control Language，DCL）：用来确认或者取消对数据库中的数据进行的变更。除此之外，还可以对数据库中的用户设定权限。主要包含以下几种命令：<ul><li>GRANT：赋予用户操作权限</li><li>REVOKE：取消用户的操作权限</li><li>COMMIT：确认对数据库中的数据进行的变更</li><li>ROLLBACK：取消对数据库中的数据进行的变更</li></ul></li></ul></li><li><p>实例如下：<br><img src="https://user-images.githubusercontent.com/49378661/94098804-07d3f880-fe5c-11ea-9aa6-d1991898721a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/94098804-07d3f880-fe5c-11ea-9aa6-d1991898721a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200924114709627"></p></li></ol><ol start="8"><li><p>上述实例的吓你详细过程如下：</p><ul><li><p>下面的 SQL 语句声明创建一个名叫 students 的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE students (</span><br><span class="line">    student_id INT UNSIGNED,</span><br><span class="line">    name VARCHAR(30),</span><br><span class="line">    sex CHAR(1),</span><br><span class="line">    birth DATE,</span><br><span class="line">    PRIMARY KEY(student_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>该表包含 4 个字段，分别为 student_id、name、sex、birth，其中 student_id 定义为表的主键。</p></li><li><p>现在只是定义了一张表格，但并没有任何数据，接下来这条 SQL 声明语句，将在 students 表中插入一条数据记录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO students (student_id, name, sex, birth)</span><br><span class="line">VALUES (201803666, &#39;洛伊&#39;, &#39;1&#39;, &#39;2018-09-03&#39;)</span><br></pre></td></tr></table></figure></li><li><p>上述 SQL 语句执行之后，students 表中就会增加一行新记录，在该记录中：</p><ul><li>student_id 字段的值为：201803666</li><li>name 字段的值为：”洛伊”</li><li>sex 字段的值为：”1”</li><li>birth 字段值为：”2018-09-03”</li></ul></li><li><p>再使用 SELECT 查询语句获取刚才插入的数据，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT name FROM students WHERE student_id&#x3D;201803666;</span><br><span class="line">+------+</span><br><span class="line">| name |</span><br><span class="line">+------+</span><br><span class="line">| 洛伊 |</span><br><span class="line">+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>标准 SQL 是指符合国际标准的 SQL，而非某个数据库厂商的 SQL 语法（如：Microsoft SQL Server 的 T-SQL，Oracle 的 PL/SQL，MySQL）。标准 SQL 可以在任何数据库中使用，而数据库厂商的 SQL 只适合它们对应的数据库，如 T-SQL 只适合 Microsoft SQL Server。</p></li></ol><h2 id="了解-MySQL"><a href="#了解-MySQL" class="headerlink" title="了解 MySQL"></a>了解 MySQL</h2><ol><li>MySQL 是一种 DBMS，它是一种数据库软件。</li><li>对于 MySQL：</li></ol><ul><li>客户机可以是 MySQL 提供的工具、脚本语言（如 Perl）、Web应用开发语言（如 ASP、ColdFusion、JSP 和 PHP）、程序设计语言（如 C、C++、Java）等</li><li>服务器软件为 MySQL DBMS，你可以在本地安装的副本上运行， 也可以连接到运行在你具有访问权的远程服务器上的一个副本。</li></ul><ol start="3"><li>MySQL 是一个免费开源的关系型数据库管理系统（但也不意味着该数据库是完全免费的），适合中小型软件。</li><li>MySQL 是开放源代码的数据库。</li><li>MySQL 的跨平台性：不仅可以在 Windows 系列的操作系统上运行，还可以在 UNIX、Linux 和 Mac OS 等操作系统上运行。在这一方面，SQL Server 数据库虽然也是一款很优秀的商业数据库，但它只能在 Windows 系列的操作系统上运行。因此，MySQL 数据库的跨平台性是一个很大的优势。</li><li>MySQL 是一个真正的多用户、 多线程 SQL 数据库服务器。它能够快速、有效和安全的处理大量的数据。相对于 Oracle 等数据库来说，MySQL 的使用是非常简单的。MySQL 主要目标是快速、健壮和易用。</li><li>MySQL 与常用的主流数据库 Oracle、SQL Server 相比，主要特点就是免费，并且在任何平台上都能使用，占用的空间相对较小。但是，MySQL 也有一些不足，比如对于大型项目来说，MySQL 的容量和安全性就略逊于 Oracle 数据库。</li><li>MySQL 的适用场景：<ul><li>Web 网站系统：<ul><li>因为 MySQL 数据库的安装配置都非常简单，使用过程中的维护也不像很多大型商业数据库管理系统那么复杂，而且性能出色。还有一个非常重要的原因就是 MySQL 是开放源代码的，完全可以免费使用。</li><li>Web 网站开发者也是 MySQL 最大的客户群。</li></ul></li><li>日志记录系统：<ul><li>MySQL 数据库的插入和查询性能都非常的高效，如果设计的好，在使用 MyISAM 存储引擎的时候，两者可以做到互不锁定，达到很高的并发性能。所以，对需要大量的插入和查询日志记录的系统来说，MySQL 是非常不错的选择，比如处理用户的登录日志，操作日志等。</li></ul></li><li>数据仓库系统：<ul><li>通过 MySQL 的简单复制功能，可以很好的将数据从一台主机复制到另外一台 ，不仅仅在局域网内可以复制，在广域网同样可以。</li></ul></li><li>嵌入式系统：<ul><li>MySQL 在资源的使用方面的伸缩性非常大，可以在资源非常充裕的环境下运行，也可以在资源非常少的环境下正常运行。它对于嵌入式环境来说，是一种非常合适的数据库系统，而且 MySQL 有专门针对于嵌入式环境的版本。</li></ul></li></ul></li><li>学习 MySQL 必须掌握的知识点如下，也是我准备学习的知识：<ul><li>MySQL 的下载安装。熟悉 MySQL 的配置文件，目录结构。</li><li>MySQL 服务器的启动，登录与退出。</li><li>MySQL 常用命令及语法规范。</li><li>MySQL 常用命令及语法规范。</li><li>MySQL 数据类型与数据表的操作。例如，数据表的增删改查、单表查询、多表查询等。</li><li>MySQL 运算符和函数，例如，日期函数，时间函数，信息函数，聚合函数，加密函数，自定义函数等。</li><li>MySQL 存储过程，存储过程的调用。</li><li>MySQL 各个存储引擎的特点，如何选择合适的存储引擎等。</li><li>MySQL 事务的概念和使用等。</li><li>MySQL 权限管理和用户管理等。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统学习计算机网络（五）：TCP详解</title>
      <link href="94895040cb03/"/>
      <url>94895040cb03/</url>
      
        <content type="html"><![CDATA[<h2 id="传输控制协议-TCP-概述"><a href="#传输控制协议-TCP-概述" class="headerlink" title="传输控制协议 TCP 概述"></a>传输控制协议 TCP 概述</h2><h3 id="TCP-最主要的特点"><a href="#TCP-最主要的特点" class="headerlink" title="TCP 最主要的特点"></a>TCP 最主要的特点</h3><ol><li>TCP 是面向连接的运输层协议，在无连接的、不可靠的 IP 网络服务基础之上提供可靠交付的服务。为此，在 IP 的数据报服务基础之上，增加了保证可靠性的一系列措施。<br><img src="https://user-images.githubusercontent.com/49378661/102600541-ee400580-4159-11eb-82a2-fa0bacef85f2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600541-ee400580-4159-11eb-82a2-fa0bacef85f2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218092848812"></li><li>TCP 是面向连接的运输层协议。</li><li>每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。</li><li>TCP 提供可靠交付的服务。</li><li>TCP 提供全双工通信。</li><li>TCP 是面向字节流的：虽然应用程序和 TCP 的交互是一次一个数据块，但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流。<br><img src="https://user-images.githubusercontent.com/49378661/102600567-f4ce7d00-4159-11eb-9ad5-8ac30535b238.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600567-f4ce7d00-4159-11eb-9ad5-8ac30535b238.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218093226897"><br><img src="https://user-images.githubusercontent.com/49378661/102600584-f9933100-4159-11eb-9fa1-5c64059abdf5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600584-f9933100-4159-11eb-9fa1-5c64059abdf5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218093247372"></li></ol><h3 id="TCP-的连接"><a href="#TCP-的连接" class="headerlink" title="TCP 的连接"></a>TCP 的连接</h3><p><img src="https://user-images.githubusercontent.com/49378661/102600611-031c9900-415a-11eb-8e5c-7cde2e4c637c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600611-031c9900-415a-11eb-8e5c-7cde2e4c637c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218093601107"></p><ol><li><p>TCP 把连接作为最基本的抽象。</p></li><li><p>每一条 TCP 连接有两个端点。</p></li><li><p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做套接字 (socket) 或插口。</p></li><li><p>端口号拼接到 IP 地址即构成了套接字。</p><ul><li><p>套接字：<br><img src="https://user-images.githubusercontent.com/49378661/102600632-09ab1080-415a-11eb-9a88-ec917e2e1f8b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600632-09ab1080-415a-11eb-9a88-ec917e2e1f8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218093624414"></p><p><img src="https://user-images.githubusercontent.com/49378661/102600650-0e6fc480-415a-11eb-8c05-e2726bc826eb.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600650-0e6fc480-415a-11eb-8c05-e2726bc826eb.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218093747423"></p></li><li><p>TCP 连接的端点是个很抽象的套接字，即（IP 地址：端口号）。</p></li></ul></li><li><p>同一个 IP 地址可以有多个不同的 TCP 连接，同一个端口号也可以出现在多个不同的 TCP 连接中。</p></li><li><p>Socket 有多种不同的意思：</p><ul><li>应用编程接口  API  称为 socket API, 简称为 socket。</li><li>socket API 中使用的一个函数名也叫作 socket。</li><li>调用 socket 函数的端点称为 socket。</li><li>调用 socket 函数时其返回值称为 socket 描述符，可简称为 socket。</li><li>在操作系统内核中连网协议的 Berkeley 实现，称为 socket 实现。 </li></ul></li></ol><hr><h2 id="可靠传输的工作原理"><a href="#可靠传输的工作原理" class="headerlink" title="可靠传输的工作原理"></a>可靠传输的工作原理</h2><h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ol><li><p>IP 网络所提供的是不可靠的传输：<br><img src="https://user-images.githubusercontent.com/49378661/102600673-14fe3c00-415a-11eb-95ed-2946c46f3a3a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600673-14fe3c00-415a-11eb-95ed-2946c46f3a3a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218094257283"></p></li><li><p>“停止等待”就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。</p></li><li><p>全双工通信的双方既是发送方也是接收方。</p></li><li><p>无差错情况：<br><img src="https://user-images.githubusercontent.com/49378661/102600688-1a5b8680-415a-11eb-9ded-0e47a7d47323.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600688-1a5b8680-415a-11eb-9ded-0e47a7d47323.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218094509526"></p></li><li><p>出现差错：</p><ul><li>在接收方 B 会出现两种情况：<ul><li>B 接收 M1 时检测出了差错，就丢弃 M1，其他什么也不做（不通知 A 收到有差错的分组）。</li><li>M1 在传输过程中丢失了，这时 B 当然什么都不知道，也什么都不做。</li></ul></li><li>在这两种情况下，B 都不会发送任何信息。</li><li>但A都必须重发分组，直到B正确接收为止，这样才能实现可靠通信。</li></ul></li><li><p>出现差错的解决办法：<br><img src="https://user-images.githubusercontent.com/49378661/102600732-2e06ed00-415a-11eb-955d-18692373da78.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600732-2e06ed00-415a-11eb-955d-18692373da78.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218095007189"></p><ul><li>A如何知道 B 是否正确收到了 M1 呢？<ul><li>解决方法：超时重传</li><li>A 为每一个已发送的分组都设置了一个超时计时器。</li><li>A 只要在超时计时器到期之前收到了相应的确认，就撤销该超时计时器，继续发送下一个分组 M2 。</li><li>若A在超时计时器规定时间内没有收到B的确认，就认为分组错误或丢失，就重发该分组</li></ul></li><li>若分组正确到达B，但B回送的确认丢失或延迟了，A未收到B的确认，会超时重发。B 可能会收到重复的 M1 。B如何知道收到了重复的分组，需要丢弃呢？<ul><li>解决方法：编号</li><li>A为每一个发送的分组都进行编号。若B收到了编号相同的分组，则认为收到了重复分组，丢弃重复的分组，并回送确认。</li><li>B为发送的确认也进行编号，指示该确认是对哪一个分组的确认。<br>A根据确认及其编号，可以确定它是对哪一个分组的确认，避免重发发送。若为重复的确认，则将其丢弃。</li></ul></li></ul></li><li><p>确认丢失和确认迟到：<br><img src="https://user-images.githubusercontent.com/49378661/102600747-34956480-415a-11eb-9b1c-01d12dfa86d5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600747-34956480-415a-11eb-9b1c-01d12dfa86d5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218095213298"></p><ul><li><p>确认丢失：</p><ul><li>若 B 所发送的对 M1 的确认丢失了，那么 A 在设定的超时重传时间内不能收到确认，但 A 并无法知道：是自己发送的分组出错、丢失了，或者 是 B 发送的确认丢失了。因此 A 在超时计时器到期后就要重传 M1。</li><li>假定 B 又收到了重传的分组 M1。这时 B 应采取两个行动：<ul><li>第一，丢弃这个重复的分组 M1，不向上层交付。</li><li>第二，向 A 发送确认。不能认为已经发送过确认就不再发送，因为 A 之所以重传 M1 就表示 A 没有收到对 M1 的确认。</li></ul></li></ul></li><li><p>确认迟到：</p><ul><li>传输过程中没有出现差错，但 B 对分组 M1 的确认迟到了。</li><li>A 会收到重复的确认。对重复的确认的处理很简单：收下后就丢弃。</li><li>B 仍然会收到重复的 M1，并且同样要丢弃重复的 M1，并重传确认分组。</li></ul></li><li><p>注意：</p><ul><li>在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。</li><li>分组和确认分组都必须进行编号。</li><li>超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。</li></ul></li></ul></li><li><p>自动重传请求 ARQ：通常 A 最终总是可以收到对所有发出的分组的确认。</p><ul><li>如果 A 不断重传分组但总是收不到确认，就说明通信线路太差，不能进行通信。</li><li>使用上述的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信。</li></ul></li><li><p>停止等待协议的优点是简单，缺点是信道利用率太低：<br><img src="https://user-images.githubusercontent.com/49378661/102600784-3fe89000-415a-11eb-9d3d-cb4b657d98c9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600784-3fe89000-415a-11eb-9d3d-cb4b657d98c9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218143057821"></p><ul><li>可以看出，当往返时间 RTT 远大于分组发送时间 TD 时，信道的利用率就会非常低。</li></ul></li><li><p>流水线传输：发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送。<br><img src="https://user-images.githubusercontent.com/49378661/102600802-470f9e00-415a-11eb-8e6c-8d2bfe47c528.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600802-470f9e00-415a-11eb-8e6c-8d2bfe47c528.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218143242295"></p><ul><li>由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 </li></ul></li><li><p>停止等待协议要点：</p><ul><li>停止等待：发送方每次只发送一个分组，在收到确认后再发送下一个分组。</li><li>编号：对发送的每个分组和确认都进行编号。</li><li>自动重传请求：发送方为每个发送的分组设置一个超时计时器。若超时计时器超时，发送方会自动重传分组。</li><li>简单：但信道利用率太低。</li></ul></li></ol><h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h3><ol><li>基本思想：<br><img src="https://user-images.githubusercontent.com/49378661/102600830-4f67d900-415a-11eb-970d-3e90e05cf6d4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600830-4f67d900-415a-11eb-970d-3e90e05cf6d4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218143444520"><ul><li>发送方一次可以发出多个分组。</li><li>使用滑动窗口协议控制发送方和接收方所能发送和接收的分组的数量和编号。<ul><li>滑动窗口协议比较复杂，是 TCP 协议的精髓所在。</li></ul></li><li>每收到一个确认，发送方就把发送窗口向前滑动。<ul><li>位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了。</li><li>连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。</li></ul></li><li>接收方一般采用累积确认的方式。</li><li>采用回退N（Go-Back-N）方法进行重传。<ul><li>回退N：表示需要再退回来重传已发送过的 N 个分组。例如，如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。</li></ul></li></ul></li><li>累积确认：<br><img src="https://user-images.githubusercontent.com/49378661/102600850-568ee700-415a-11eb-924e-395c126537b2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600850-568ee700-415a-11eb-924e-395c126537b2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218144026649"><ul><li>接收方一般采用累积确认的方式。即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，这样就表示：到这个分组为止的所有分组都已正确收到了。</li></ul></li><li>优缺点：<ul><li>优点：容易实现，即使确认丢失也不必重传。</li><li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。<ul><li>当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。</li></ul></li></ul></li><li>TCP 可靠通信的具体实现：<ul><li>TCP 连接的每一端都必须设有两个窗口：<ul><li>一个发送窗口。</li><li>一个接收窗口。</li></ul></li><li>TCP 的可靠传输机制用字节的序号进行控制。TCP 所有的确认都是基于序号而不是基于报文段。</li><li>TCP 两端的四个窗口经常处于动态变化之中。</li><li>TCP连接的往返时间 RTT 也不是固定不变的。需要使用特定的算法估算较为合理的重传时间。</li></ul></li><li>连续 ARQ 协议与停止等待协议：<br><img src="https://user-images.githubusercontent.com/49378661/102600869-5bec3180-415a-11eb-93d1-d8c4403a9047.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600869-5bec3180-415a-11eb-93d1-d8c4403a9047.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218144350540"></li></ol><hr><h2 id="TCP-报文段的首部格式"><a href="#TCP-报文段的首部格式" class="headerlink" title="TCP 报文段的首部格式"></a>TCP 报文段的首部格式</h2><p><img src="https://user-images.githubusercontent.com/49378661/102600891-60b0e580-415a-11eb-8d59-ae97d1a0e13a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600891-60b0e580-415a-11eb-8d59-ae97d1a0e13a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218144618732"></p><ol><li>TCP 虽然是面向字节流的，但 TCP 传送的数据单元却是报文段。</li><li>一个 TCP 报文段分为首部和数据两部分，而 TCP 的全部功能都体现在它首部中各字段的作用。</li><li>TCP 报文段首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。</li></ol><hr><h2 id="TCP-可靠传输的实现"><a href="#TCP-可靠传输的实现" class="headerlink" title="TCP 可靠传输的实现"></a>TCP 可靠传输的实现</h2><h3 id="以字节为单位的滑动窗口"><a href="#以字节为单位的滑动窗口" class="headerlink" title="以字节为单位的滑动窗口"></a>以字节为单位的滑动窗口</h3><ol><li>TCP 使用流水线传输和滑动窗口协议实现高效、可靠的传输。</li><li>TCP 的滑动窗口是以字节为单位的。</li><li>发送方 A 和接收方 B 分别维持一个发送窗口和一个接收窗口。</li><li>发送窗口表示：在没有收到确认的情况下，可以连续把窗口内的数据全部发送出去。</li><li>接收窗口表示：只允许接收落入窗口内的数据。</li><li>发送缓存：<br><img src="https://user-images.githubusercontent.com/49378661/102600926-69a1b700-415a-11eb-95a6-c726c4bfb902.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600926-69a1b700-415a-11eb-95a6-c726c4bfb902.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218145600152"></li><li>接收缓存：<br><img src="https://user-images.githubusercontent.com/49378661/102600940-6f979800-415a-11eb-89bd-f16d33ccbc7a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600940-6f979800-415a-11eb-89bd-f16d33ccbc7a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218145643563"></li><li>发送缓存与接收缓存的作用：<ul><li>发送缓存用来暂时存放：<ul><li>发送应用程序传送给发送方 TCP 准备发送的数据；</li><li>TCP 已发送出但尚未收到确认的数据。</li></ul></li><li>接收缓存用来暂时存放：<ul><li>按序到达的、但尚未被接收应用程序读取的数据；</li><li>不按序到达的数据。</li></ul></li></ul></li><li>接收方发送确认：接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上。</li><li>注意：<ul><li>A 的发送窗口并不总是和 B 的接收窗口一样大（因为有一定的时间滞后）。</li><li>TCP 标准没有规定对不按序到达的数据应如何处理。通常是先临时存放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程。</li><li>TCP 要求接收方必须有累积确认的功能，这样可以减小传输开销。 </li></ul></li></ol><h3 id="超时重传时间的选择"><a href="#超时重传时间的选择" class="headerlink" title="超时重传时间的选择"></a>超时重传时间的选择</h3><ol><li>重传机制是 TCP 中最重要和最复杂的问题之一。</li><li>TCP 每发送一个报文段，就对这个报文段设置一次计时器。</li><li>只要计时器设置的重传时间到但还没有收到确认，就要重传这一报文段。</li><li>重传时间的选择是 TCP 最复杂的问题之一。</li><li>TCP 超时重传时间设置：<ul><li>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大。</li><li>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率。</li><li>TCP 采用了一种自适应算法，它记录一个报文段发出的时间，以及收到相应的确认的时间。这两个时间之差就是报文段的往返时间 RTT。</li></ul></li></ol><h3 id="选择确认-SACK"><a href="#选择确认-SACK" class="headerlink" title="选择确认 SACK"></a>选择确认 SACK</h3><ol><li>若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么能否设法只传送缺少的数据而不重传已经正确到达接收方的数据？<ul><li>答案是可以的。选择确认 SACK  (Selective ACK) 就是一种可行的处理方法。</li></ul></li><li>接收到的字节流序号不连续：<br><img src="https://user-images.githubusercontent.com/49378661/102600967-78886980-415a-11eb-913a-ae406312f619.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600967-78886980-415a-11eb-913a-ae406312f619.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218150733530"></li></ol><hr><h2 id="TCP-的流量控制"><a href="#TCP-的流量控制" class="headerlink" title="TCP 的流量控制"></a>TCP 的流量控制</h2><h3 id="利用滑动窗口实现流量控制"><a href="#利用滑动窗口实现流量控制" class="headerlink" title="利用滑动窗口实现流量控制"></a>利用滑动窗口实现流量控制</h3><ol><li>流量控制：就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li><li>利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。</li><li>可能发生死锁：<ul><li>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd = 400 的报文段。</li><li>但这个报文段在传送过程中丢失了。A 一直等待收到 B 发送的非零窗口的通知，而 B 也一直等待 A 发送的数据。</li><li>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。为了解决这个问题，TCP 为每一个连接设有一个持续计时器。</li></ul></li><li>持续计时器：<ul><li>只要 TCP 连接的一方收到对方的零窗口通知，就启动该持续计时器。</li><li>若持续计时器设置的时间到期，就发送一个零窗口探测报文段（仅携带 1 字节的数据），而对方就在确认这个探测报文段时给出了现在的窗口值。</li><li>若窗口仍然是零，则收到这个报文段的一方就重新设置持续计时器。</li><li>若窗口不是零，则死锁的僵局就可以打破了。 </li></ul></li></ol><h3 id="TCP-的传输效率"><a href="#TCP-的传输效率" class="headerlink" title="TCP 的传输效率"></a>TCP 的传输效率</h3><ol><li><p>可以用不同的机制来控制 TCP 报文段的发送时机：</p><ul><li>第一种机制是 TCP 维持一个变量，它等于最大报文段长度 MSS。只要缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去。</li><li>第二种机制是由发送方的应用进程指明要求发送报文段，即 TCP 支持的推送 (push) 操作。</li><li>第三种机制是发送方的一个计时器期限到了，这时就把当前已有的缓存数据装入报文段（但长度不能超过 MSS）发送出去。</li></ul></li><li><p>发送方糊涂窗口综合症：每次仅发送一个字节或很少几个字节的数据时，有效数据传输效率变得很低的现象。</p><p><img src="https://user-images.githubusercontent.com/49378661/102600988-7e7e4a80-415a-11eb-9140-4d3cd40cbe4f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600988-7e7e4a80-415a-11eb-9140-4d3cd40cbe4f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218151904166"></p><ul><li>发送方 TCP 每次接收到一字节的数据后就发送。这样，发送一个字节需要形成 41 字节长的 IP 数据报。效率很低。</li><li>解决方法：使用 Nagle 算法。</li></ul></li><li><p>Nagle算法原理：<br><img src="https://user-images.githubusercontent.com/49378661/102601001-83db9500-415a-11eb-82d8-2719beaf6b69.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601001-83db9500-415a-11eb-82d8-2719beaf6b69.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218152038911"></p></li><li><p>接收方糊涂窗口综合症：</p><ul><li>当接收方的 TCP 缓冲区已满，接收方会向发送方发送窗口大小为 0 的报文。</li><li>若此时接收方的应用进程以交互方式每次只读取一个字节，于是接收方又发送窗口大小为一个字节的更新报文，发送方应邀发送一个字节的数据（发送的 IP 数据报是 41 字节长），于是接收窗口又满了，如此循环往复。</li><li>解决方法：让接收方等待一段时间，使得或者接收缓存已有足够空间容纳一个最长的报文段，或者等到接收缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发出确认报文，并向发送方通知当前的窗口大小。</li></ul></li></ol><hr><h2 id="TCP-的拥塞控制"><a href="#TCP-的拥塞控制" class="headerlink" title="TCP 的拥塞控制"></a>TCP 的拥塞控制</h2><h3 id="拥塞控制的一般原理"><a href="#拥塞控制的一般原理" class="headerlink" title="拥塞控制的一般原理"></a>拥塞控制的一般原理</h3><ol><li>在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞。<br><img src="https://user-images.githubusercontent.com/49378661/102601017-8938df80-415a-11eb-8b5f-1ccf025af33e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601017-8938df80-415a-11eb-8b5f-1ccf025af33e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218152542903"><ul><li>最坏结果：系统崩溃。</li></ul></li><li>拥塞产生的原因：网络拥塞往往是由许多因素引起的，例如：<ul><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞。</li></ul></li><li>增加资源能解决拥塞吗？<ul><li>不能。这是因为网络拥塞是一个非常复杂的问题。简单地采用上述做法，在许多情况下，不但不能解决拥塞问题，而且还可能使网络的性能更坏。</li><li>网络拥塞往往是由许多因素引起的。例如：<ul><li>增大缓存，但未提高输出链路的容量和处理机的速度，排队等待时间将会大大增加，引起大量超时重传，解决不了网络拥塞；</li><li>提高处理机处理的速率会会将瓶颈转移到其他地方；</li></ul></li></ul></li><li>拥塞控制与流量控制的区别：<br><img src="https://user-images.githubusercontent.com/49378661/102601032-90f88400-415a-11eb-847f-a541ba9d5fd5.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601032-90f88400-415a-11eb-847f-a541ba9d5fd5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218152950642"></li><li>拥塞控制所起的作用：<br><img src="https://user-images.githubusercontent.com/49378661/102601041-9524a180-415a-11eb-910e-c57722537027.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601041-9524a180-415a-11eb-910e-c57722537027.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218153157140"></li><li>拥塞控制的一般原理：<ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个动态问题。</li><li>分组的丢失是网络发生拥塞的征兆而不是原因。</li><li>在许多情况下，甚至正是拥塞控制本身成为引起网络性能恶化、甚至发生死锁的原因。</li></ul></li><li>开环控制和闭环控制：<br><img src="https://user-images.githubusercontent.com/49378661/102601059-9e157300-415a-11eb-8389-4f413ca30d27.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601059-9e157300-415a-11eb-8389-4f413ca30d27.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218153308050"><ul><li>属于闭环控制的有以下几种措施：<ul><li>监测网络系统，以便检测到拥塞在何时、何处发生。</li><li>将拥塞发生的信息传送到可采取行动的地方。</li><li>调整网络系统的运行以解决出现的问题。</li></ul></li></ul></li><li>监测网络的拥塞的主要指标：（下面这些指标的上升都标志着拥塞的增长）<ul><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ul></li><li>传递拥塞通知：<ul><li>发送通知拥塞发生的分组；</li><li>在分组中保留表示拥塞状态的字段；</li><li>周期性地发出探测分组等。</li></ul></li><li>采取行动的时机：<ul><li>过于频繁，会使系统产生不稳定的振荡；</li><li>过于迟缓地采取行动又不具有任何实用价值。</li></ul></li><li>解决拥塞的两条思路：<ul><li>增加网络可用资源；</li><li>减少用户对资源的需求。</li></ul></li></ol><h3 id="TCP-的拥塞控制方法"><a href="#TCP-的拥塞控制方法" class="headerlink" title="TCP 的拥塞控制方法"></a>TCP 的拥塞控制方法</h3><ol><li><p>TCP 采用基于窗口的方法进行拥塞控制。该方法属于闭环控制方法。</p></li><li><p>TCP发送方维持一个拥塞窗口 cwnd。</p></li><li><p>发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量。</p></li><li><p>发送窗口大小不仅取决于接收方窗口，还取决于网络的拥塞状况，所以真正的发送窗口值为：</p><ul><li>真正的发送窗口值 = Min (接收方窗口值，拥塞窗口值)</li></ul></li><li><p>控制拥塞窗口的原则：</p><ul><li>只要网络没有出现拥塞，拥塞窗口就可以再增大一些，以便把更多的分组发送出去，这样就可以提高网络的利用率。</li><li>但只要网络出现拥塞或有可能出现拥塞，就必须把拥塞窗口减小一些，以减少注入到网络中的分组数，以便缓解网络出现的拥塞。</li></ul></li><li><p>拥塞的判断：<br><img src="https://user-images.githubusercontent.com/49378661/102601099-ab326200-415a-11eb-9c2f-7f6f48d0fb02.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601099-ab326200-415a-11eb-9c2f-7f6f48d0fb02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218153956272"></p></li><li><p>四种拥塞控制算法：</p><ul><li><p>慢开始</p><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<br><img src="https://user-images.githubusercontent.com/49378661/102601111-b08fac80-415a-11eb-8a3a-224ea75e8c6f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601111-b08fac80-415a-11eb-8a3a-224ea75e8c6f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218154122283"></li><li>流程：<br><img src="https://user-images.githubusercontent.com/49378661/102601126-b5546080-415a-11eb-9661-f918525b8d95.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601126-b5546080-415a-11eb-9661-f918525b8d95.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218154356227"></li><li>设置慢开始门限状态变量 ssthresh，慢开始门限 ssthresh 的用法如下：<ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></li></ul></li><li><p>拥塞避免<br><img src="https://user-images.githubusercontent.com/49378661/102601155-bd140500-415a-11eb-96c5-5a19c697c1f8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601155-bd140500-415a-11eb-96c5-5a19c697c1f8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218154635793"></p><ul><li>思路：让拥塞窗口 cwnd 缓慢地增大，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 cwnd = cwnd + 1。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “加法增大” 的特点。</li><li>“拥塞避免” 并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。</li><li>“拥塞避免” 是说在拥塞避免阶段把拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。 </li></ul></li><li><p>快重传</p><ul><li>发送方只要一连收到三个重复确认，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</li><li>使用快重传可以使整个网络的吞吐量提高约20%。 </li><li>不难看出，快重传并非取消重传计时器，而是在某些情况下可以更早地（更快地）重传丢失的报文段。 </li><li>采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。</li><li>快重传算法首先要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/102601177-c604d680-415a-11eb-9543-88e88af572e6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601177-c604d680-415a-11eb-9543-88e88af572e6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218155204407"></li></ul></li><li><p>快恢复</p><ul><li>当发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不执行慢开始算法，而是执行快恢复算法：<ul><li>慢开始门限 ssthresh = 当前拥塞窗口 cwnd / 2 ；</li><li>新拥塞窗口 cwnd = 慢开始门限 ssthresh ；</li><li>开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。 </li></ul></li></ul></li></ul></li></ol><h3 id="主动队列管理-AQM"><a href="#主动队列管理-AQM" class="headerlink" title="主动队列管理 AQM"></a>主动队列管理 AQM</h3><ol><li>TCP 拥塞控制和网络层采取的策略有密切联系。</li><li>若路由器对某些分组的处理时间特别长，那么这就可能使这些分组中的TCP报文段经过很长时间才能到达终点，结果引起发送方超时，对这些报文段进行重传。</li><li>重传会使 TCP 连接的发送端认为在网络中发生了拥塞，但实际上网络并没有发生拥塞。<br>对 TCP 拥塞控制影响最大的就是路由器的分组丢弃策略。</li><li>先进先出(FIFO) 处理规则 与 尾部丢弃策略：<ul><li>路由器的队列通常都是按照“先进先出”FIFO (First In First Out) 的规则处理到来的分组。</li><li>当队列已满时，以后再到达的所有分组（如果能够继续排队，这些分组都将排在队列的尾部）将都被丢弃。这就叫做尾部丢弃策略 (tail-drop policy)。</li><li>路由器的尾部丢弃往往会导致一连串分组的丢失，这就使发送方出现超时重传，使 TCP 进入拥塞控制的慢开始状态，结果使 TCP 连接的发送方突然把数据的发送速率降低到很小的数值。</li></ul></li></ol><hr><h2 id="TCP-的运输连接管理"><a href="#TCP-的运输连接管理" class="headerlink" title="TCP 的运输连接管理"></a>TCP 的运输连接管理</h2><h3 id="TCP-的连接建立"><a href="#TCP-的连接建立" class="headerlink" title="TCP 的连接建立"></a>TCP 的连接建立</h3><ol><li>TCP 是面向连接的协议。</li><li>TCP 连接有三个阶段：<ul><li>连接建立</li><li>数据传送</li><li>连接释放</li></ul></li><li>TCP 连接的管理就是使 TCP 连接的建立和释放都能正常地进行。</li><li>TCP 连接建立过程中要解决的三个问题：<ul><li>要使每一方能够确知对方的存在。</li><li>要允许双方协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）。</li><li>能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。</li></ul></li><li>客户—服务器方式：<ul><li>TCP 连接的建立采用客户服务器方式。</li><li>主动发起连接建立的应用进程叫做客户 (client)。</li><li>被动等待连接建立的应用进程叫做服务器 (server)。</li></ul></li><li>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。称之为三报文握手，采用三报文握手主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ol><h3 id="TCP-的连接释放"><a href="#TCP-的连接释放" class="headerlink" title="TCP 的连接释放"></a>TCP 的连接释放</h3><ol><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是四报文握手：<br><img src="https://user-images.githubusercontent.com/49378661/102601196-cdc47b00-415a-11eb-8170-6caf59b648ff.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601196-cdc47b00-415a-11eb-8170-6caf59b648ff.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218162216573"></li></ol><h3 id="TCP-的有限状态机"><a href="#TCP-的有限状态机" class="headerlink" title="TCP 的有限状态机"></a>TCP 的有限状态机</h3><p><img src="https://user-images.githubusercontent.com/49378661/102601212-d2892f00-415a-11eb-95a1-351b33c0f281.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102601212-d2892f00-415a-11eb-95a1-351b33c0f281.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218162347063"></p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统学习计算机网络（四）：运输层概述与UDP详解</title>
      <link href="a2ed71807ea0/"/>
      <url>a2ed71807ea0/</url>
      
        <content type="html"><![CDATA[<h2 id="运输层协议概述"><a href="#运输层协议概述" class="headerlink" title="运输层协议概述"></a>运输层协议概述</h2><h3 id="进程之间的通信"><a href="#进程之间的通信" class="headerlink" title="进程之间的通信"></a>进程之间的通信</h3><ol><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。 </li><li>只有位于网络边缘部分的主机的协议栈才有运输层：<br><img src="https://user-images.githubusercontent.com/49378661/102599823-fea3b080-4158-11eb-9d09-8b1310df2cc8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599823-fea3b080-4158-11eb-9d09-8b1310df2cc8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218082316888"></li><li>主机 A 与 主机 B 之间的通信的两层含义：<br><img src="https://user-images.githubusercontent.com/49378661/102599835-04999180-4159-11eb-9d15-1483520242ba.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599835-04999180-4159-11eb-9d15-1483520242ba.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218082900532"></li><li>严格地讲，两台主机进行通信就是两台主机中的应用进程互相通信。<ul><li>从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信。</li></ul></li><li>网络层和运输层有明显的区别：<br><img src="https://user-images.githubusercontent.com/49378661/102599856-0bc09f80-4159-11eb-84bd-74f71b84bd13.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599856-0bc09f80-4159-11eb-84bd-74f71b84bd13.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218083103940"><ul><li>网络层是为主机之间提供逻辑通信；</li><li>运输层为应用进程之间提供端到端的逻辑通信。</li></ul></li><li>基于端口的复用和分用功能：<br><img src="https://user-images.githubusercontent.com/49378661/102599882-11b68080-4159-11eb-83dd-e01886869cc9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599882-11b68080-4159-11eb-83dd-e01886869cc9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218083221270"></li><li>逻辑通信信道对上层的表现却因运输层使用的不同协议而有很大的差别：<ul><li>当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。</li><li>当运输层采用无连接的 UDP 协议时，这种逻辑通信信道是一条不可靠信道。</li></ul></li><li>可靠信道与不可靠信道：<br><img src="https://user-images.githubusercontent.com/49378661/102599892-167b3480-4159-11eb-9775-7b94d0f5c8fd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599892-167b3480-4159-11eb-9775-7b94d0f5c8fd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218084542408"></li></ol><h3 id="运输层的两个主要协议"><a href="#运输层的两个主要协议" class="headerlink" title="运输层的两个主要协议"></a>运输层的两个主要协议</h3><ol><li>TCP/IP 的运输层有两个主要协议：<br><img src="https://user-images.githubusercontent.com/49378661/102599907-1aa75200-4159-11eb-8f6f-4892e3eb5dbe.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599907-1aa75200-4159-11eb-8f6f-4892e3eb5dbe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218084645420"><ul><li>用户数据报协议 UDP (User Datagram Protocol)</li><li>传输控制协议 TCP (Transmission Control Protocol)</li></ul></li><li>两个对等运输实体在通信时传送的数据单位叫作运输协议数据单元 TPDU：<ul><li>TCP 传送的数据单位协议是 TCP 报文段<br><img src="https://user-images.githubusercontent.com/49378661/102599928-23982380-4159-11eb-8879-1442ef916603.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599928-23982380-4159-11eb-8879-1442ef916603.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218085037420"></li><li>UDP 传送的数据单位协议是 UDP 报文或用户数据报<br><img src="https://user-images.githubusercontent.com/49378661/102599948-27c44100-4159-11eb-9eee-32197c696d40.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599948-27c44100-4159-11eb-9eee-32197c696d40.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218085005554"></li></ul></li><li>使用 UDP 和 TCP 的典型应用和应用层协议：<br><img src="https://user-images.githubusercontent.com/49378661/102599999-36aaf380-4159-11eb-8ccb-c4db133a054a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102599999-36aaf380-4159-11eb-8ccb-c4db133a054a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218085122061"></li><li>主机上可能有多个进程同时技能型通信，进程是动态创建和撤销的：<br><img src="https://user-images.githubusercontent.com/49378661/102600034-3ca0d480-4159-11eb-8d71-fc711b8b4eb4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600034-3ca0d480-4159-11eb-8d71-fc711b8b4eb4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218085229623"></li><li>运输层的 UDP 用户数据报与网际层的IP数据报有很大区别：<ul><li>IP 数据报要经过互连网中许多路由器的存储转发</li><li>UDP 用户数据报是在运输层的端到端抽象的逻辑信道中传送的</li></ul></li><li>TCP 报文段是在运输层抽象的端到端逻辑信道中传送，这种信道是可靠的全双工信道。但这样的信道却不知道究竟经过了哪些路由器，而这些路由器也根本不知道上面的运输层是否建立了 TCP 连接。</li></ol><h3 id="运输层的端口"><a href="#运输层的端口" class="headerlink" title="运输层的端口"></a>运输层的端口</h3><ol><li>运行在计算机中的进程是用进程标识符来标志的，但运行在应用层的各种应用进程却不应当让计算机操作系统指派它的进程标识符。这是因为在互联网上使用的计算机的操作系统种类很多，而不同的操作系统又使用不同格式的进程标识符。为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须用统一的方法对 TCP/IP 体系的应用进程进行标志。<br><img src="https://user-images.githubusercontent.com/49378661/102600056-44607900-4159-11eb-8e42-b69e40f1921c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600056-44607900-4159-11eb-8e42-b69e40f1921c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218085840164"></li><li>需要解决的问题：<ul><li>由于进程的创建和撤销都是动态的，发送方几乎无法识别其他机器上的进程。</li><li>有时我们会改换接收报文的进程，但并不需要通知所有发送方。</li><li>我们往往需要利用目的主机提供的功能来识别终点，而不需要知道实现这个功能的进程。</li></ul></li><li>解决这个问题的方法就是在运输层使用协议端口号，或通常简称为端口。</li><li>TCP/IP 运输层端口：<br><img src="https://user-images.githubusercontent.com/49378661/102600086-5215fe80-4159-11eb-9336-3e41d1f6a786.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600086-5215fe80-4159-11eb-9336-3e41d1f6a786.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218090414953"><ul><li>端口用一个 16 位端口号进行标志，允许有65535个不同的端口号。</li><li>端口号只具有本地意义，即端口号只是为了标志本计算机应用层中的各进程。</li><li>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的端口号（为了找到对方计算机中的应用进程） ，而且还要知道对方的 IP 地址（为了找到对方的计算机）</li></ul></li><li>两大类端口：<br><img src="https://user-images.githubusercontent.com/49378661/102600095-56421c00-4159-11eb-85cf-45fd124240b6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600095-56421c00-4159-11eb-85cf-45fd124240b6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218090712499"><ul><li>服务器端使用的端口号：<ul><li>熟知端口，数值一般为 0 ~ 1023。</li><li>登记端口号，数值为 1024 ~ 49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。</li></ul></li><li>客户端使用的端口号：<ul><li>又称为短暂端口号，数值为 49152 ~ 65535，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></li><li>常用的熟知端口：<br><img src="https://user-images.githubusercontent.com/49378661/102600111-5c37fd00-4159-11eb-8d43-11fff1454677.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600111-5c37fd00-4159-11eb-8d43-11fff1454677.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218090825016"></li></ul></li></ol><hr><h2 id="用户数据报协议-UDP"><a href="#用户数据报协议-UDP" class="headerlink" title="用户数据报协议 UDP"></a>用户数据报协议 UDP</h2><h3 id="UDP-概述"><a href="#UDP-概述" class="headerlink" title="UDP 概述"></a>UDP 概述</h3><ol><li>UDP 只在 IP 的数据报服务之上增加了很少一点的功能：<ul><li>复用和分用的功能</li><li>差错检测的功能</li></ul></li><li>UDP 的主要特点：<ul><li>UDP 是无连接的</li><li>UDP 使用尽最大努力交付</li><li>UDP 是面向报文的</li><li>UDP 没有拥塞控制</li><li>UDP 支持一对一、一对多、多对一和多对多的交互通信</li><li>UDP 的首部开销小</li></ul></li><li>UDP 是面向报文的：<br><img src="https://user-images.githubusercontent.com/49378661/102600127-62c67480-4159-11eb-9f72-f6ef262005e4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600127-62c67480-4159-11eb-9f72-f6ef262005e4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218091407461"><br><img src="https://user-images.githubusercontent.com/49378661/102600140-678b2880-4159-11eb-99af-f6e080a89c67.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600140-678b2880-4159-11eb-99af-f6e080a89c67.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218091611602"></li></ol><h3 id="UDP-的首部格式"><a href="#UDP-的首部格式" class="headerlink" title="UDP 的首部格式"></a>UDP 的首部格式</h3><ol><li><p>用户数据报 UDP 有两个字段：数据字段和首部字段，首部字段有 8 个字节，由 4 个字段组成，每个字段都是 2 个字节。</p></li><li><p>UDP 用户数据报格式：<br><img src="https://user-images.githubusercontent.com/49378661/102600172-71ad2700-4159-11eb-854c-8c889a5fd360.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600172-71ad2700-4159-11eb-854c-8c889a5fd360.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218092056833"></p></li><li><p>UDP 基于端口的分用：当运输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给最后的终点——应用进程。<br> <img src="https://user-images.githubusercontent.com/49378661/102600194-78d43500-4159-11eb-9262-403811c0047a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/102600194-78d43500-4159-11eb-9262-403811c0047a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201218092245377"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统学习计算机网络（三）：数据链路层</title>
      <link href="310577faf33f/"/>
      <url>310577faf33f/</url>
      
        <content type="html"><![CDATA[<h2 id="前序"><a href="#前序" class="headerlink" title="前序"></a>前序</h2><ol><li>计算机网络体系结构：<br><img src="https://user-images.githubusercontent.com/49378661/99773962-27c82580-2b48-11eb-96b7-103516dc3d95.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99773962-27c82580-2b48-11eb-96b7-103516dc3d95.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120083238126"></li><li>数据链路层是实现设备之间通信的非常重要的一层：<br><img src="https://user-images.githubusercontent.com/49378661/99773982-2f87ca00-2b48-11eb-8a38-e25832480704.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99773982-2f87ca00-2b48-11eb-8a38-e25832480704.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120083654010"></li></ol><hr><h2 id="使用点对点信道的数据链路层"><a href="#使用点对点信道的数据链路层" class="headerlink" title="使用点对点信道的数据链路层"></a>使用点对点信道的数据链路层</h2><h3 id="数据链路和帧"><a href="#数据链路和帧" class="headerlink" title="数据链路和帧"></a>数据链路和帧</h3><ol><li>链路 (link) 是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。</li><li>一条链路只是一条通路的一个组成部分。</li><li>数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。<ul><li>现在最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。</li><li>一般的适配器都包括了数据链路层和物理层这两层的功能。</li></ul></li><li>数据链路层传送的是帧：<br><img src="https://user-images.githubusercontent.com/49378661/99774016-3ca4b900-2b48-11eb-9801-e288cd6ca02b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774016-3ca4b900-2b48-11eb-9801-e288cd6ca02b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120144132021"></li></ol><h3 id="三个基本问题"><a href="#三个基本问题" class="headerlink" title="三个基本问题"></a>三个基本问题</h3><ol><li><p>封装成帧：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。<br><img src="https://user-images.githubusercontent.com/49378661/99774042-44645d80-2b48-11eb-940d-89d5a554cdab.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774042-44645d80-2b48-11eb-940d-89d5a554cdab.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120145051713"></p></li><li><p>透明传输：如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界”。</p><p><img src="https://user-images.githubusercontent.com/49378661/99774065-4b8b6b80-2b48-11eb-8170-d04bc921ed9b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774065-4b8b6b80-2b48-11eb-8170-d04bc921ed9b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120145116165"></p></li><li><p>差错检测：在传输过程中可能会产生比特差错：1 可能会变成 0， 而 0 也可能变成 1，为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错检测措施。</p><ul><li>在数据链路层传送的帧中，广泛使用了循环冗余检验 CRC 的检错技术。</li><li>在数据后面添加上的冗余码称为帧检验序列 FCS。</li><li>循环冗余检验 CRC 和帧检验序列 FCS 并不等同：<ul><li>CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。</li><li>FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 </li></ul></li></ul></li></ol><hr><h2 id="点对点协议-PPP"><a href="#点对点协议-PPP" class="headerlink" title="点对点协议 PPP"></a>点对点协议 PPP</h2><h3 id="PPP-协议的特点"><a href="#PPP-协议的特点" class="headerlink" title="PPP 协议的特点"></a>PPP 协议的特点</h3><ol><li>**对于点对点的链路，目前使用得最广泛的数据链路层协议是点对点协议 **PPP</li><li>用户到 ISP 的链路使用 PPP 协议：<br><img src="https://user-images.githubusercontent.com/49378661/99774092-57772d80-2b48-11eb-9a2d-17dd9dceec38.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774092-57772d80-2b48-11eb-9a2d-17dd9dceec38.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120150021428"></li></ol><h3 id="PPP-协议的帧格式"><a href="#PPP-协议的帧格式" class="headerlink" title="PPP 协议的帧格式"></a>PPP 协议的帧格式</h3><p>PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p><h3 id="PPP-协议的工作状态"><a href="#PPP-协议的工作状态" class="headerlink" title="PPP 协议的工作状态"></a>PPP 协议的工作状态</h3><p><img src="https://user-images.githubusercontent.com/49378661/99774137-6067ff00-2b48-11eb-8e07-a42a307f9853.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774137-6067ff00-2b48-11eb-8e07-a42a307f9853.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120150321099"></p><hr><h2 id="使用广播信道的数据链路层"><a href="#使用广播信道的数据链路层" class="headerlink" title="使用广播信道的数据链路层"></a>使用广播信道的数据链路层</h2><h3 id="局域网的数据链路层"><a href="#局域网的数据链路层" class="headerlink" title="局域网的数据链路层"></a>局域网的数据链路层</h3><ol><li><p>局域网最主要的特点是：</p><ul><li>网络为一个单位所拥有</li><li>地理范围和站点数目均有限</li></ul></li><li><p>局域网拓扑结构：</p><p><img src="https://user-images.githubusercontent.com/49378661/99774158-65c54980-2b48-11eb-85c9-029cffb40910.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774158-65c54980-2b48-11eb-85c9-029cffb40910.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120152112371"></p></li><li><p>局域网对 LLC 子层是透明的：</p></li></ol><p><img src="https://user-images.githubusercontent.com/49378661/99774189-6cec5780-2b48-11eb-8dc7-c93113fbf986.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774189-6cec5780-2b48-11eb-8dc7-c93113fbf986.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120152207118"></p><ol start="4"><li><p>适配器的作用：网络接口板又称为通信适配器 (adapter) 或网络接口卡 NIC (Network Interface Card)，或 “网卡”，重要功能如下：</p><ul><li>进行串行/并行转换。</li><li>对数据进行缓存。</li><li>在计算机的操作系统安装设备驱动程序。</li><li>实现以太网协议。</li></ul></li><li><p>计算机通过适配器和局域网进行通信：<br><img src="https://user-images.githubusercontent.com/49378661/99774222-7aa1dd00-2b48-11eb-96ae-ca9a8a8ed12f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774222-7aa1dd00-2b48-11eb-96ae-ca9a8a8ed12f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120152342873"></p></li></ol><h3 id="CSMA-CD-协议"><a href="#CSMA-CD-协议" class="headerlink" title="CSMA/CD 协议"></a>CSMA/CD 协议</h3><p><img src="https://user-images.githubusercontent.com/49378661/99774251-85f50880-2b48-11eb-963a-239ef596ed51.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774251-85f50880-2b48-11eb-963a-239ef596ed51.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120152714842"></p><h3 id="使用集线器的星形拓扑"><a href="#使用集线器的星形拓扑" class="headerlink" title="使用集线器的星形拓扑"></a>使用集线器的星形拓扑</h3><ol><li>使用集线器的以太网在逻辑上仍是一个总线网，各工作站使用的还是CSMA/CD 协议，并共享逻辑上的总线。 </li><li>集线器很像一个多接口的转发器，工作在物理层。</li></ol><h3 id="以太网的-MAC-层"><a href="#以太网的-MAC-层" class="headerlink" title="以太网的 MAC 层"></a>以太网的 MAC 层</h3><ol><li>在局域网中，硬件地址又称为物理地址，或 MAC 地址。</li><li>最常用的 MAC 帧是以太网 V2 的格式：<br><img src="https://user-images.githubusercontent.com/49378661/99774268-8b525300-2b48-11eb-9eca-053a31abd34c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774268-8b525300-2b48-11eb-9eca-053a31abd34c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120153226494"></li></ol><hr><h2 id="扩展的以太网"><a href="#扩展的以太网" class="headerlink" title="扩展的以太网"></a>扩展的以太网</h2><h3 id="在物理层扩展以太网"><a href="#在物理层扩展以太网" class="headerlink" title="在物理层扩展以太网"></a>在物理层扩展以太网</h3><ol><li>使用光纤扩展：主机使用光纤（通常是一对光纤）和一对光纤调制解调器连接到集线器。</li><li>使用集线器扩展：将多个以太网段连成更大的、多级星形结构的以太网。</li></ol><h3 id="在数据链路层扩展以太网"><a href="#在数据链路层扩展以太网" class="headerlink" title="在数据链路层扩展以太网"></a>在数据链路层扩展以太网</h3><ol><li><p>扩展以太网更常用的方法是在数据链路层进行。早期使用网桥，现在使用以太网交换机。</p></li><li><p>交换式集线器常称为以太网交换机 (switch) 或第二层交换机 (L2 switch)，强调这种交换机工作在数据链路层。</p></li><li><p>以太网交换机的特点：</p><ul><li>以太网交换机实质上就是一个多接口的网桥，通常都有十几个或更多的接口。</li><li>每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。</li><li>以太网交换机具有并行性。能同时连通多对接口，使多对主机能同时通信。</li><li>相互通信的主机都是独占传输媒体，无碰撞地传输数据（以太网交换机的每个接口是一个碰撞域）：<br><img src="https://user-images.githubusercontent.com/49378661/99774294-95745180-2b48-11eb-986a-353788f112b7.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774294-95745180-2b48-11eb-986a-353788f112b7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120153800750"></li></ul></li><li><p>交换机使用了生成树协议：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。<br><img src="https://user-images.githubusercontent.com/49378661/99774355-a2914080-2b48-11eb-9160-0058ecc1f3b8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774355-a2914080-2b48-11eb-9160-0058ecc1f3b8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154026944"></p></li></ol><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ol><li><p>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</p><blockquote><p>虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，而这些网段具有某些共同的需求。</p><p>每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</p></blockquote></li><li><p>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</p></li><li><p>划分虚拟局域网的方法：</p><ul><li>基于交换机端口：<br><img src="https://user-images.githubusercontent.com/49378661/99774372-a8872180-2b48-11eb-949c-951d9e8e582b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774372-a8872180-2b48-11eb-949c-951d9e8e582b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154444095"><ul><li>最简单、也是最常用的方法。</li><li>属于在第一层划分虚拟局域网的方法。</li></ul></li><li>基于计算机网卡的MAC地址：<br><img src="https://user-images.githubusercontent.com/49378661/99774402-b046c600-2b48-11eb-8470-3a6478ebb39f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774402-b046c600-2b48-11eb-8470-3a6478ebb39f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154516876"><ul><li>根据用户计算机的MAC地址划分虚拟局域网。</li><li>属于在第二层划分虚拟局域网的方法。</li></ul></li><li>基于协议类型：<br><img src="https://user-images.githubusercontent.com/49378661/99774421-b50b7a00-2b48-11eb-8e42-d70c8ab938e8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774421-b50b7a00-2b48-11eb-8e42-d70c8ab938e8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154546611"><ul><li>根据以太网帧的第三个字段“类型”字段确定该类型的协议属于哪一个虚拟局域网。</li><li>属于在第二层划分虚拟局域网的方法。</li></ul></li><li>基于IP子网地址：<br><img src="https://user-images.githubusercontent.com/49378661/99774436-ba68c480-2b48-11eb-8874-62405259ce0d.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774436-ba68c480-2b48-11eb-8874-62405259ce0d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154618630"><ul><li>根据以太网帧的第三个字段“类型”字段和IP分组首部中的源 IP 地址字段确定该 IP 分组属于哪一个虚拟局域网。</li><li>属于在第三层划分虚拟局域网的方法。</li></ul></li><li>基于高层应用或服务：<br><img src="https://user-images.githubusercontent.com/49378661/99774450-bfc60f00-2b48-11eb-8326-f481fd6137cd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99774450-bfc60f00-2b48-11eb-8326-f481fd6137cd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201120154657437"><ul><li>根据高层应用或服务、或者它们的组合划分虚拟局域网。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统学习计算机网络（二）：物理层</title>
      <link href="f567b7b406b2/"/>
      <url>f567b7b406b2/</url>
      
        <content type="html"><![CDATA[<h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p>物理层的主要任务描述为确定与传输媒体的接口的一些特性：</p><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一电平的电压表示何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。 </li></ul><hr><h2 id="数据通信的基础知识"><a href="#数据通信的基础知识" class="headerlink" title="数据通信的基础知识"></a>数据通信的基础知识</h2><h3 id="数据通信系统的模型"><a href="#数据通信系统的模型" class="headerlink" title="数据通信系统的模型"></a>数据通信系统的模型</h3><p><img src="https://user-images.githubusercontent.com/49378661/99030503-29c23f80-25b0-11eb-8834-2f8a0f9cc16c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030503-29c23f80-25b0-11eb-8834-2f8a0f9cc16c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113090612785"></p><h3 id="有关信道的几个基本概念"><a href="#有关信道的几个基本概念" class="headerlink" title="有关信道的几个基本概念"></a>有关信道的几个基本概念</h3><ol><li>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li>双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。 </li><li>基带（baseband）信号：即基本频带信号，来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。<ul><li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制。</li></ul></li><li>带通（bandpass）信号：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。</li><li>几种最基本的调制方法：（最基本的二元制调制方法有以下几种）<br><img src="https://user-images.githubusercontent.com/49378661/99030489-1d3de700-25b0-11eb-9fe5-b3bc8873746b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030489-1d3de700-25b0-11eb-9fe5-b3bc8873746b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113092842779"><ul><li>调幅(AM)：载波的振幅随基带数字信号而变化</li><li>调频(FM)：载波的频率随基带数字信号而变化</li><li>调相(PM) ：载波的初始相位随基带数字信号而变化</li></ul></li></ol><h3 id="信道的极限容量与极限信息传输速率"><a href="#信道的极限容量与极限信息传输速率" class="headerlink" title="信道的极限容量与极限信息传输速率"></a>信道的极限容量与极限信息传输速率</h3><blockquote><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p><p>码元传输的速率越高，或信号传输的距离越远，在信道的输出端的波形的失真就越严重。</p></blockquote><ol><li><p>有失真，但可识别：<br><img src="https://user-images.githubusercontent.com/49378661/99030476-16af6f80-25b0-11eb-958e-4cfb0dc7eb30.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030476-16af6f80-25b0-11eb-958e-4cfb0dc7eb30.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113094512540"></p></li><li><p>失真大，无法识别：<br><img src="https://user-images.githubusercontent.com/49378661/99030465-10b98e80-25b0-11eb-8ee0-8c8b49823203.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030465-10b98e80-25b0-11eb-8ee0-8c8b49823203.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113094540036"></p></li><li><p>奈氏准则：给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。</p><ul><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li></ul></li><li><p>香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率，信道的极限信息传输速率 <em>C</em> 可表达为：<br>$$<br>C = W \times \log_2^{1+S/N} (b/s)<br>$$</p><ul><li><em>W</em> 为信道的带宽（以 Hz 为单位）</li><li><em>S</em> 为信道内所传信号的平均功率</li><li><em>N</em> 为信道内部的高斯噪声功率</li><li>香农公式表明：<ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li><li>若信道带宽 <em>W</em> 或信噪比 <em>S</em>/<em>N</em> 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 <em>C</em> 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li></ul></li></ul></li></ol><hr><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p>电信领域使用的电磁波的频谱</p><p><img src="https://user-images.githubusercontent.com/49378661/99030454-09928080-25b0-11eb-8797-4341e7bc2057.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030454-09928080-25b0-11eb-8797-4341e7bc2057.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113110413137"></p><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><ol><li><p>双绞线</p><ul><li>屏蔽双绞线 STP (Shielded Twisted Pair)</li><li>无屏蔽双绞线 UTP (Unshielded Twisted Pair)</li></ul></li><li><p>同轴电缆</p><ul><li>50 Ω 同轴电缆</li><li>75 Ω 同轴电缆</li></ul></li><li><p>光缆 </p></li><li><p>光线在光纤中的折射<br><img src="https://user-images.githubusercontent.com/49378661/99030446-039c9f80-25b0-11eb-859f-a538a1a96348.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030446-039c9f80-25b0-11eb-859f-a538a1a96348.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113111845592"></p></li></ol><ol start="5"><li>光纤的工作原理<br><img src="https://user-images.githubusercontent.com/49378661/99030437-f8e20a80-25af-11eb-8176-5550786eac20.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030437-f8e20a80-25af-11eb-8176-5550786eac20.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113111904753"></li></ol><ol start="6"><li><p>多模光纤与单模光纤：</p><p><img src="https://user-images.githubusercontent.com/49378661/99030420-ed8edf00-25af-11eb-9ccf-b20ca0ef6017.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030420-ed8edf00-25af-11eb-9ccf-b20ca0ef6017.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113112654481"></p></li></ol><ol start="7"><li><p>光纤优点：</p><ul><li>通信容量非常大。</li><li>传输损耗小，中继距离长。</li><li>抗雷电和电磁干扰性能好。</li><li>无串音干扰，保密性好。</li><li>体积小，重量轻。</li></ul></li></ol><h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><ol><li>将自由空间称为“非导引型传输媒体”</li><li>传统微波通信有两种方式：<ul><li>地面微波接力通信</li><li>卫星通信</li></ul></li></ol><hr><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><blockquote><p>复用 (multiplexing) 是通信技术中的基本概念。<br>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p></blockquote><p>复用的示意图：<br><img src="https://user-images.githubusercontent.com/49378661/99030410-e5cf3a80-25af-11eb-977b-a57444efbce2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030410-e5cf3a80-25af-11eb-977b-a57444efbce2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113113148298"></p><h3 id="频分、时分、统计时分复用"><a href="#频分、时分、统计时分复用" class="headerlink" title="频分、时分、统计时分复用"></a>频分、时分、统计时分复用</h3><ol><li><p><strong>频分复用</strong> FDM ：<br><img src="https://user-images.githubusercontent.com/49378661/99030400-e071f000-25af-11eb-8e5a-495d0904b03f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030400-e071f000-25af-11eb-8e5a-495d0904b03f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113113443016"></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li>频分复用的所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul></li><li><p>时分复用 TDM：<br><img src="https://user-images.githubusercontent.com/49378661/99030388-d94ae200-25af-11eb-9210-01feafefe078.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030388-d94ae200-25af-11eb-9210-01feafefe078.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113113634433"></p><ul><li>时分复用则是将时间划分为一段段等长的时分复用帧（TDM帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是周期性地出现（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为等时 (isochronous) 信号。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li><li>时分复用可能会造成线路资源的浪费：使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。<br><img src="https://user-images.githubusercontent.com/49378661/99030378-d3550100-25af-11eb-9744-3baf89bb5010.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030378-d3550100-25af-11eb-9744-3baf89bb5010.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113113940297"></li></ul></li><li><p>统计时分复用 STDM：STDM 帧不是固定分配时隙，而是按需动态地分配时隙。因此统计时分复用可以提高线路的利用率。<br><img src="https://user-images.githubusercontent.com/49378661/99030364-c6d0a880-25af-11eb-85ae-afe2520bc03e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030364-c6d0a880-25af-11eb-85ae-afe2520bc03e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113114121386"></p></li></ol><h3 id="波分复用-WDM"><a href="#波分复用-WDM" class="headerlink" title="波分复用 WDM"></a>波分复用 WDM</h3><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号。</p></blockquote><p><img src="https://user-images.githubusercontent.com/49378661/99030360-c0423100-25af-11eb-9fc6-ffbbe882207f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030360-c0423100-25af-11eb-9fc6-ffbbe882207f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113114240793"></p><h3 id="码分复用-CDM"><a href="#码分复用-CDM" class="headerlink" title="码分复用 CDM"></a>码分复用 CDM</h3><blockquote><p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。<br>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 </p></blockquote><ol><li>每一个比特时间划分为 m 个短的间隔，称为码片 (chip)。</li><li>每个站被指派一个唯一的 m bit 码片序列。<ul><li>如发送比特 1，则发送自己的 m bit 码片序列。</li><li>如发送比特 0，则发送该码片序列的二进制反码。 </li><li>例如，S 站的 8 bit 码片序列是 00011011：<ul><li>发送比特 1 时，就发送序列 00011011</li><li>发送比特 0 时，就发送序列 11100100</li><li>S 站的码片序列：(–1 –1 –1 +1 +1 –1 +1 +1) </li></ul></li></ul></li><li>码片序列实现了扩频：<ul><li>假定S站要发送信息的数据率为 b bit/s。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。</li><li>这种通信方式是扩频(spread spectrum)通信中的一种。</li><li>扩频通信通常有两大类：<ul><li>一种是直接序列扩频DSSS (Direct Sequence Spread Spectrum)，如上面讲的使用码片序列就是这一类。</li><li>另一种是跳频扩频FHSS (Frequency Hopping Spread Spectrum)。</li></ul></li></ul></li><li>CDMA 的重要特点：<ul><li><p>每个站分配的码片序列不仅必须各不相同，并且还必须互相正交。</p><ul><li><p>码片序列的正交关系：</p><ul><li><p>令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量</p></li><li><p>两个不同站的码片序列正交，就是向量 S 和T 的规格化内积等于 0：<br>$$<br>S \times T \equiv \frac{1}{m} \sum_{i=1}^{m}S_iT_i = 0<br>$$</p></li></ul></li></ul></li><li><p>在实用的系统中是使用伪随机码序列。</p></li></ul></li><li>CDMA 的工作原理：<br><img src="https://user-images.githubusercontent.com/49378661/99030337-b3bdd880-25af-11eb-9e4b-556b8aa68adc.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030337-b3bdd880-25af-11eb-9e4b-556b8aa68adc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113120457802"></li></ol><hr><h2 id="宽带接入技术"><a href="#宽带接入技术" class="headerlink" title="宽带接入技术"></a>宽带接入技术</h2><ol><li>用户要连接到互联网，必须先连接到某个ISP。</li><li>从宽带接入的媒体来看，可以将宽带接入技术划分为两大类：<ul><li>有线宽带接入</li><li>无线宽带接入</li></ul></li></ol><h3 id="ADSL技术"><a href="#ADSL技术" class="headerlink" title="ADSL技术"></a>ADSL技术</h3><ol><li>ADSL 技术就把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。<ul><li>DSL 就是数字用户线 (Digital Subscriber Line) 的缩写。</li></ul></li><li>ADSL 的传输距离：<ul><li>ADSL 的传输距离取决于数据率和用户线的线径（用户线越细，信号传输时的衰减就越大）。</li><li>ADSL 所能得到的最高数据传输速率与实际的用户线上的信噪比密切相关。</li></ul></li><li>ADSL 的特点：<ul><li>上行和下行带宽做成不对称的：上行指从用户到 ISP，而下行指从 ISP 到用户。</li><li>ADSL 在用户线（铜线）的两端各安装一个 ADSL 调制解调器。</li></ul></li></ol><h3 id="光纤同轴混合网（HFC-网）"><a href="#光纤同轴混合网（HFC-网）" class="headerlink" title="光纤同轴混合网（HFC 网）"></a>光纤同轴混合网（HFC 网）</h3><ol><li><p>HFC (Hybrid Fiber Coax) 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。</p></li><li><p>HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。</p></li><li><p>现有的 CATV 网是树形拓扑结构的同轴电缆网络，它采用模拟技术的频分复用对电视节目进行单向传输。</p></li><li><p>HFC 网对 CATV 网进行了改造：HFC 网将原 CATV 网中的同轴电缆主干部分改换为光纤，并使用模拟光纤技术。</p></li><li><p>HFC 网采用结点体系结构：</p><p><img src="https://user-images.githubusercontent.com/49378661/99030295-a0ab0880-25af-11eb-98b4-0ffb91972c8b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030295-a0ab0880-25af-11eb-98b4-0ffb91972c8b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113124941997"></p></li></ol><h3 id="FTTx-技术"><a href="#FTTx-技术" class="headerlink" title="FTTx 技术"></a>FTTx 技术</h3><ol><li>FTTx 是一种实现宽带居民接入网的方案，代表多种宽带光纤接入方式。</li><li>FTTx 表示 Fiber To The…（光纤到…），例如：<ul><li>光纤到户(FTTH，Fiber To The Home)：光纤一直铺设到用户家庭，可能是居民接入网最后的解决方法。</li><li>光纤到大楼(FTTB，Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li><li>光纤到路边(FTTC，Fiber To The Curb)：光纤铺到路边，从路边到各用户可使用星形结构双绞线作为传输媒体。</li></ul></li><li>无源光网络 PON (Passive Optical Network) 的组成：<br><img src="https://user-images.githubusercontent.com/49378661/99030284-9983fa80-25af-11eb-94c6-473a3acdd1b4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99030284-9983fa80-25af-11eb-94c6-473a3acdd1b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201113125410004"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统学习计算机网络（一）：概述</title>
      <link href="36379c8f0263/"/>
      <url>36379c8f0263/</url>
      
        <content type="html"><![CDATA[<h2 id="互联网概述"><a href="#互联网概述" class="headerlink" title="互联网概述"></a>互联网概述</h2><ol><li>计算机网络是由若干个结点以及连接这些结点的链路组成。</li><li>网络把计算机连接在一起，而互联网则通过路由器把网络连接在一起，与网络相连的计算机常称为主机。</li></ol><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><ol><li>虽然互联网的拓扑结构很复杂，但从工作方式上看，可以大致分为：<ul><li>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li><li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）。</li></ul></li><li>互联网的边缘部分：<ul><li>连接在互联网上的这些主机，又被称为端系统。<ul><li>注意，这里的端系统并不只是指的电脑，当然也可以是一个很小的网络摄像头等其他具有上网功能的设备。</li></ul></li><li>“主机A 和 主机B 进行通信”，实际上指的是：“主机A 的某个进程和主机B 上的另一个进程进行通信”，这种阐述也被简称为 “计算机之间通信”</li><li>在网络边缘的端系统之间的通信方式可以分为两类：C/S方式 和 P2P方式。<ul><li>C/S 方式（客户—服务器方式）：<ul><li>这是最常用的方式，比如发送邮件。</li><li>“客户” 和 “服务器” 都是指通信中所涉及的两个应用进程，C/S 方式描述的是进程之间，客户是服务请求方，服务器是服务提供方，当然，服务请求方和服务提供方都要使用网络核心部分所提供的服务。</li><li>客户程序的主要特点：<ul><li>被用户调用后，在通信时主动向远地服务器发起通信（请求服务），因此，客户程序必须知道服务器程序的地址。</li><li>客户程序是不需要特殊的硬件和很复杂的操作系统的。</li></ul></li><li>服务器程序：<ul><li>是一种专门用来提供某种服务的程序，可以同时处理多个远地和本地客户的请求。</li><li>系统启动之后，即会自动调用并且一直不停地运行，被动地等待并接受来自各地的客户的通信请求，因此，服务器程序不需要知道客户程序的地址。</li><li>与客户程序不同的是，服务器程序一般需要有强大的硬件和高级的操作系统支持。</li></ul></li><li>客户和服务器的通信关系建立之后，通信可以是双向的，客户和服务器本来都指的是计算机进程（软件）。<ul><li>顺带一提，使用计算机的人是计算机的 “用户” 而非 “客户”。</li></ul></li></ul></li><li>P2P 方式（对等连接方式）：<ul><li>指两台主机在通信时，并不区分哪台是服务请求方与服务提供方。只要两台主机都运行了对等的连接软件（P2P 软件），它们就可以进行平等的、对等的连接通信，这时，双方都可以下载对方存储在硬盘中的共享文档。这时，双方都可以下载对方已经存储在硬盘中的共享文档，因此这几台主机也可以进行对等通信，从本质上，对等连接方式仍然使用的是客户—服务器方式，只是，对等连接中的每一台主机既是客户同时又是服务器。如下图：</li></ul></li></ul></li></ul></li><li>互联网的核心部分：<ul><li>网络核心部分是互联网中最复杂的部分。</li><li>路由器：在网络核心部分起着特殊的作用，它是一种专用的计算机（但不叫主机），它是实现分组交换的关键构件，其任务是转发收到的分组。<ul><li>若要弄清楚什么是分组交换，建议先理解一下电路交换的基本概念，此处不做解释。</li></ul></li></ul></li></ol><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><ol><li>按照网络的作用范围进行分类：<ul><li>广域网（WAN，Wide Area Network）：也称 “远程网”，是互联网的核心部分，其任务是长距离运送主机发送的数据。</li><li>城域网（MAN，Metropolitan Area Network）：作用范围一般是一个城市，用来将多个局域网进行互连，目前很多城域网采用的是以太网技术，因此也常并入局域网的范围来讨论。</li><li>局域网（LAN，Local Area Network）：常见的局域网如校园网或企业网。</li><li>个人局域网（PAN，Personal Area Network）：也通常称为 “无线个人局域网（WPAN，Wireless PAN）”。</li><li>顺便指出，如果中央处理机之间的距离非常近（如距离仅1米），那么一般就称之为多处理机系统，而不是计算机网络。</li></ul></li><li>按照网络的使用者进行分类：<ul><li>公用网（Public Network）：通常是电信公司（国有或私有）出资建造的大型网络，所有人按规定缴费就可以使用的网络，因此公用网也可以成为 “公众网”。</li><li>专用网（Private Network）：一般是为了本单位的特殊业务工作而建造的。</li></ul></li></ol><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><blockquote><p>计算机网络的性能一般指它的几个重要的性能指标，但除了这些重要的性能指标，还有一些非性能特征也对网络的性能有很大的影响。</p></blockquote><ol><li><p>计算机网络的性能指标：</p><ul><li><p>速率：</p><ul><li>这是最重要的性能指标，指的是数据的传送速率，也称为 “数据率” 或 “比特率”。</li><li>速率的单位是 bit/s（或 b/s，有时也写为 bps），当速率较高时，常常在 bit/s 的前面加上一个字母，例如：k（kilo）= 10^3 = 千，M（Mega）= 10^6 = 兆，以此类推，还有 G（Giga，吉）、T（Tera，太）、P（Peta，拍）、E（Exa，艾）、Z（Zetta，泽）、Y（Yotta，尧），例如 4*10^10 bit/s 的数据率就记为 40Gbit/s。</li><li>需要注意，提到网络的速率时，往往指的是稳定速率或标称速率，而非网络实际上运行的速率。</li></ul></li><li><p>带宽：</p><ul><li>带宽本来是指某个信号具有的 “频带宽度”，信号的带宽是指该信号所包含的各种不同频率成分所占据的频率范围。这种意义的带宽的单位是赫（或千赫、兆赫、吉赫）。在过去很长一段时间，通信的主干线路传送的是模拟信号（即连续变化的信号），因此，表示某信道允许通过的信号频带范围就称为该信道的带宽（或通频带）。</li><li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力，因此网络带宽表示在单位时间内网络中的某信道所能通过的 “最高数据率”，这种意义的带宽的单位就是数据率的单位，即 bit/s。</li><li>在上述两种表述中，前者是 “频域” 称谓，后者是 “时域” 称谓，其本质是相同的，也就是说，一条通信链路的 “带宽” 越宽，其所能传输的 “最高数据率” 也越高。</li></ul></li><li><p>吞吐量：</p><ul><li>吞吐量表示在单位时间内通过某个网络（或信道、接口）的实际的数据量。</li><li>吞吐量长用于对实际网络的测量，以便知道实际上到底有多少个数据量能够通过网络。吞吐量收到网络的带宽或网络的额定速率的限制，例如，对于一个 1 Gbit/s 的以太网，其额定速率是 1 Gbit/s，这个数值也是该以太网的吞吐量的绝对上限值，其实际的吞吐量可能也只有 100 Mbit/s 甚至更低。</li><li>有时吞吐量还可用每秒传送的字节数或帧数来表示。</li></ul></li><li><p>时延：</p><ul><li><p>时延是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间，有时也称为 “延迟” 或 “迟延”。时延是无法立即准确计算的，大多数时候是根据以前的已发生的时延经历而推测下一次的时延。</p></li><li><p>网络的时延是由以下几个不同的部分组成：</p><ul><li><p>发送时延：发送时延是主机或路由器发送数据帧所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，因此发送时延也叫做 “传输时延”，发送时延的计算公式是：发送时延 = 数据帧长度(bit) / 发送速率(bit/s)。</p></li><li><p>传播时延：传播时延是电子波在信道中传播需要一定的距离需要花费的时间。传播时延的计算公式是：传播时延 = 信道长度(n) / 电子波在信道上的传播速率(m/s)。</p><blockquote><p>以上两种时延有本质上的不同：发送时延是发生在机器内部的发送器中，与传输信道的长度无关；传播时延是发生在及其外部的传输信道媒体上，信号传送的距离越远，传播时延就越大，这与信号的发送速率无关。</p></blockquote></li><li><p>处理时延：主机或路由器在收到分组时要花费一定的时间进行处理。</p></li><li><p>排队时延：分组在经过网络传输时，要经过许多路由器，但分组在进入路由器后要先在输入队列中排队等待处理。</p></li></ul></li><li><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></li></ul></li><li><p>时延带宽积：时延带宽积等于传播时延和带宽相乘。</p></li><li><p>往返时间 RPT</p></li><li><p>利用率</p></li></ul></li><li><p>计算机网络的非性能特征：</p><ul><li>费用</li><li>质量</li><li>标准化</li><li>可靠性</li><li>可扩展性和可升级性</li><li>易于管理和维护</li></ul></li></ol><h2 id="TCP-IP-体系结构"><a href="#TCP-IP-体系结构" class="headerlink" title="TCP/IP 体系结构"></a>TCP/IP 体系结构</h2><ol><li><p>TCP/IP 的体系结构比较简单，它只有四层。下图给出了用这种四层协议表示方法的例子。请注意，图中的路由器在转发分组时最高只用到网络层而没有使用运输层和应用层：<br><img src="https://user-images.githubusercontent.com/49378661/95531175-7abfa080-0a12-11eb-9d53-6d2647a3fcd2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95531175-7abfa080-0a12-11eb-9d53-6d2647a3fcd2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201009092506015"></p></li><li><p>我们分层次画出具体的协议来表示TCP/IP协议族（如图）：<br><img src="https://user-images.githubusercontent.com/49378661/95531280-c07c6900-0a12-11eb-98e1-0ec3c9bdb067.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/95531280-c07c6900-0a12-11eb-98e1-0ec3c9bdb067.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201009092623509"></p><ul><li>它的特点是：上下两头大而中间小 — 应用层和网络接口层都有多种协议，而中间的IP 层很小，上层的各种协议都向下汇聚到-一个IP 协议中。</li></ul></li></ol><h2 id="概念回顾"><a href="#概念回顾" class="headerlink" title="概念回顾"></a>概念回顾</h2><ol><li>计算机网络（可简称为网络）把许多计算机连接在一起，而互连网则把许多网络连接在一起，互联网是网络的网络。</li><li>以小写字母 i 开始的 internet（互连网）是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。以大写字母 I 开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用TCP/IP 协议族作为通信规则。</li><li>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。互联网按工作方式可划分为边缘部分与核心部分。主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</li><li>计算机通信是计算机中的进程之间的通信。计算机网络采用的通信方式是客户—服务器方式和对等连接方式（P2P方式）。</li><li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务<br>提供方。</li><li>按作用范围的不同，计算机网络分为广域网WAN、城域网MAN、局域网LAN和个人区域网PAN。</li><li>计算机网络最常用的性能指标是：速率、带宽、吞吐量、时延(发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道（或网络）利用率。</li><li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</li><li>五层协议的体系结构由应用层、运输层、网络层(或网际层)、数据链路层和物理层组成。运输层最重要的协议是TCP和UDP协议，而网络层最重要的协议是IP协议。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（八）：页面置换算法</title>
      <link href="61c42f2ee851/"/>
      <url>61c42f2ee851/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存的基本思想：每个程序都有自己的地址空间，这个空间被分割成多个块，每一个块被称作一页或页面。每一页有连续的地址范围。</p><p>这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。</p><p>当程序引用到一部分在物理内存中的地址空间时，由硬件立刻执行必要的映射。</p><p>当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><h3 id="Linux-进程内存布局"><a href="#Linux-进程内存布局" class="headerlink" title="Linux 进程内存布局"></a>Linux 进程内存布局</h3><ol><li>进程内存空间通过分段存储来管理</li></ol><p><img src="https://user-images.githubusercontent.com/49378661/99282736-0aa50580-286f-11eb-8938-780eb7c05ad3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99282736-0aa50580-286f-11eb-8938-780eb7c05ad3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201116222635496"></p><ol start="2"><li>内核空间（kernel space）(1G)：内核总是驻留在内存中，是操作系统的一部分。内核空间为内核保留，不允许应用程序读写该区域的内容或直接调用内核代码定义的函数。</li><li>用户空间（3G）：<ul><li>环境变量（environment variables）</li><li>命令行参数（command-line arguments）</li><li>栈（stack）：栈又称堆栈，由编译器自动分配释放，用来存储临时数据和栈帧。</li><li>内存映射段（memory mapping segment）：将硬盘文件的内容直接映射到内存，内存映射是一种方便高效的文件I/O方式， 因而被用于装载动态共享库。</li><li>堆（heap）：堆用于存放进程运行时动态分配的内存段。</li><li>BSS段（bss segment）：静态内存分配，保存未初始化的全局及静态变量（皆为0），可读可写。</li><li>数据段（data segment）：静态内存分配，保存已初始化的全局及静态变量，可读可写。</li><li>代码段（text segment）：保存可执行机器码和常量，可读不可写可执行。</li><li>保留区（reserved）(32位cpu下占128M)：位于虚拟地址空间的最低部分，未赋予物理地址。任何对它的引用都是非法的，用于捕捉使用空指针和小整型值指针引用内存的异常情况。<ul><li>它并不是一个单一的内存区域，而是对地址空间中受到操作系统保护而禁止用户进程访问的地址区域的总称。</li><li>在32位X86架构的Linux系统中，用户进程可执行程序一般从虚拟地址空间0x08048000开始加载。该加载地址由ELF文件头决定</li><li>交换分区：在物理内存满时， 如果还需要内存资源，内核则把物理内存中非活动的页面放到交换分区中。</li></ul></li></ul></li></ol><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>大部分虚拟内存系统中都使用一种称为分页的技术。</p><p>由程序产生的地址称为虚拟地址，它们构成了一个虚拟地址空间。在没有虚拟内存的计算机上，系统直接把虚拟地址送到内存总线上，读写操作使用具有相同地址的物理内存字；而在使用虚拟内存的情况下，虚拟地址不是被直接送到内存总线上，而是被送到<strong>内存管理单元</strong>（Memory Management Unit，MMU），MMU把虚拟地址映射为物理内存地址。</p><p>虚拟地址空间按照固定大小划分成被称为页面（page）的若干单元。在物理内存中对应的单元称为<strong>页框</strong>。页面和页框的大小通常是一样的。实际系统中的页面大小从512字节到1GB。</p><p>栗子：一页4KB，64KB的虚拟地址空间和32KB的物理内存可得到16个虚拟页面和8个页框。从虚拟地址到物理地址的流程：<br><img src="https://img-blog.csdnimg.cn/20190810144722509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjA5NzQx,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810144722509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjA5NzQx,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><ul><li>在上图中，虚拟地址8196（二进制是0010 0000 0000 0100），输入的16位虚拟地址被分为4位的页号和12位的偏移量。4位的页号可以表示16个页面，12位的偏移量可以为一页内的全部4096个字节编址。</li><li>可用页号作为页表的索引，以得出对应于该虚拟页面的页框号。如果“在/不在”位是0，则引起缺页中断。如果该位是1，则将在页表中查到的页框号复制到输出寄存器的高3位中，再加上输入虚拟地址的低12位偏移量。如此就构成了15位的物理地址。输出寄存器的内容随即被作为物理地址送到内存总线。</li><li>此处讨论<strong>缺页中断</strong>（或称为<strong>缺页错误</strong>）发生的事：假如操作系统访问虚拟页面B产生缺页中断，决定放弃页框1（对应虚拟页面A），那么它将把产生缺页中断所对应的虚拟页面（页面B）装入页框1的起始物理地址，并对MMU映射做两处修改：首先，它要将原来页框1所对应的虚拟页面（页面A）的表项设为未映射，使以后任何对原来虚拟页面（页面A）的访问都导致陷阱。随后，把引起缺页中断（页面B）的的表项设为映射，因此在引起陷阱的指令重新启动时，它将虚拟页面B映射为物理地址页框1中的某个地址。</li></ul><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>虚拟地址被分成虚拟页号（高地址）和偏移量（低地址）两部分。不同的划分对应了不同的页面大小。</p><p>虚拟页号可作为页表的索引，以找到该虚拟页面对应的页表项。由页表项可以找到对应的页框。然后把页框号拼接到偏移量的高位端，以替换调虚拟页号，形成送往内存的物理地址。</p><p>页表的目的是把虚拟页面映射为页框，把虚拟地址中的虚拟页面域替换成页框域，从而形成物理地址（本篇博客讨论的情况均不涉及虚拟机，每个虚拟机都需要有自己的虚拟内存，因此页表组织变得很复杂，包括影子页表和嵌套页表）。</p><p>页表项的结构：</p><p><img src="https://user-images.githubusercontent.com/49378661/99282795-1ee90280-286f-11eb-87ad-832ffbe5945b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/99282795-1ee90280-286f-11eb-87ad-832ffbe5945b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201116223627719"></p><ul><li>页框号：最重要的就是页框号，页映射的目的就是找到这个值</li><li>“在/不在”位：是1时表示该表项是有效的，可以使用；是0时则表示该表项对应的虚拟页面现在不在内存中，访问该页面会引起一个缺页中断。</li><li>保护位：指出一个页允许什么样的方式访问，最简单的形式是只有一位，0表示读/写，1表示只读；更先进的方式是使用三位，各位分别表示是否启用读、写、执行该页面。</li><li>修改位：记录页面的使用情况，在写入一个页时自动设置修改位。如果一个页面已经被修改过（即它是“脏”的），则必须把它写会磁盘。如果没有被修改过（即它是“干净”的），可以直接被丢弃，因为它在磁盘上的副本仍然是有效的。<strong>脏位</strong>，反映看该页面的状态。</li><li>访问位：不论是读还是写，系统都会在该页面被访问时设置访问位。用于页面置换算法中。</li><li>禁止该页面被高速缓存：对于映射到设备寄存器而不是常规内存的页面很重要。具有独立的I/O空间而不使用内存映射I/O的机器不需要这一位。</li></ul><h3 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h3><p>每次访问内存都需要进行虚拟地址到物理地址的映射，每条指令进行一两次或更多页表访问是必要的。如果执行一条指令需要1ns，页表查询必须在0.2ns之内完成，以避免映射成为一个主要瓶颈。</p><p>现代计算机使用至少32位的虚拟地址。假设页面大小为4KB，32位的地址空间将有100万页，那么页表必然有100万条表项，而且每个进程都需要自己的页表。64位地址空间简直多到超乎你的想象。</p><p>转换检测缓冲区：</p><ul><li> 大多数程序总是对少量的页面进行多次的访问，只有很少的页表项会被反复读取，而其他大的页表项很少被访问。利用这种特性有一种解决方案：为计算机设计一个小型的硬件设备，将虚拟地址直接映射到物理地址，而不必再访问页表。这种设备称为转换检测缓冲区（Translation Lookaside Buffers，TLB），有时又称为相联存储器或快表。它通常在MMU中，包含少量的表项，在实际中很少会超过256个。每个表项记录了一个页面的相关信息，包括虚拟页号、页面的修改位、保护码和该页锁对应的物理页框，还有另外一位用来记录这个表项是否有效（即是否在使用）。</li><li> TLB的工作过程：将一个虚拟地址放入MMU中进行转换时，硬件首先通过将该虚拟页号与TLB中所有表项同时（并行）进行匹配，判断虚拟页面是否在其中。如果发现在，并且不违反保护码，则将页框号直接从TLB中取出而不必再访问页表。如果违反了保护码，则会产生一个保护错误，就像对页表进行非法操作一样。如果虚拟页号不在TLB中，此时就会去进行正常的页表查询。接着从TLB中淘汰掉一个表项，然后用找到的页表项代替它。当一个表项被清除除TLB时，将修改位复制到内存中的页表项，而除了访问位，其他的值不变。当页表项中从页表中装入TLB中时，所有的值都来自内存。</li></ul><p>软件TLB管理：</p><ul><li>现代许多的机器，几乎所有的页面管理都在软件中实现。TLB被操作系统显示地加载，当发生TLB访问失效时，生成一个TLB失效并将问题交给操作系统解决。系统找到该页面，然后从TLB中删除一个项，接着装载一个新的项，最后再执行先前出错的指令。TLB失效比缺页中断更加频繁。</li><li>如果TLB大到（如64个表项）可以减少失效率时，TLB的软件管理就会变得足够有效。</li><li>在减少TLB失效的同时，又要在发生TLB失效时减少处理开销。有时候操作系统能用“直觉”指出哪些页面下一步可能会被用到并预先为它们在TLB中装载表项。</li><li>（软件、硬件）处理TLB失效常用的办法都是找到页表并执行索引操作以定位将要访问的页面。软件做这样的搜索时，通过在内存中的固定位置维护一个大的（如4KB）TLB表项的软件高速缓存（该高速缓存的页面一直保存在TLB中）来减少TLB失效。</li><li>两种不同的TLB失效：<ul><li>软失效：一个页面访问在内存中而不在TLB中，此时要做的是更新TLB，不需要产生磁盘I/O。（10~20个机器指令，几纳秒）</li><li>硬失效：页面本身不在内存中（当然也不TLB中），此时需要一次磁盘存取以装入该页面。（几毫秒，硬失效的处理时间往往是软失效的百万倍）：在也表中查找相应的映射被称为<strong>页表遍历</strong>，假设页表遍历没有在进程的页表汇总找到需要的页，从而产生了一个缺页错误，此时有三种可能：<ul><li>所需要的页面就在内存中，但未记录在该进程的页表里。比如该页面可能已由其他其他进程从硬盘中调入内存，这种情况只需要把所需要的页面正确映射到页表中，而不是从磁盘调入。这是一种软失效，称为<strong>次要缺页错误</strong>。</li><li>需要从硬盘重新调入页面，这就是<strong>严重缺页错误</strong>。</li><li>程序访问了一个非法地址，根本不需要向TLB中新增映射。此时，操作系统一般会通过报告<strong>段错误</strong>来终止该程序。只有第三种缺页属于程序错误，其他缺页情况都会被硬件或操作系统以降低性能为代价而自动修复。</li></ul></li></ul></li></ul><h3 id="针对大内存的页表"><a href="#针对大内存的页表" class="headerlink" title="针对大内存的页表"></a>针对大内存的页表</h3><p>两种办解决巨大的虚拟地址空间？</p><ol><li><p>多级页表：32位的虚拟地址被划分为10位的PT1域，10位的PT2域和12位的Offset(偏移量)域。因为偏移量是12位，所以页面大小是4KB，共有220个页面。假设每个进程都占用了4G的线性地址空间，页表共含1M个表项，每个表项占4个字节，那么每个进程的页表要占据4M的内存空间。为了节省页表占用的空间，我们使用两级页表。每个进程都会被分配一个页目录，但是只有被实际使用页表才会被分配到内存里面。一级页表需要一次分配所有页表空间，两级页表则可以在需要的时候再分配页表空间。</p><ul><li><p>引入多级页表的原因是避免把全部页表一直保存在内存中（特别是一些从不需要的页表）：<br><img src="https://img-blog.csdnimg.cn/20190810205728364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjA5NzQx,size_16,color_FFFFFF,t_70#pic_center" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20190810205728364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMjA5NzQx,size_16,color_FFFFFF,t_70#pic_center" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p></li><li><p>在左边的是顶级页表（页目录表），它有1024个表项，对应于10位的PT1域。当一个虚拟地址被送到MMU时，MMU首先提取PT1域并把该值作为访问顶级页表的索引。因为整个4GB（即32位）虚拟地址空间已经按4KB大小分块，所以顶级页表中这1024个表项的每一个都表示4M的块地址范围。二级页表的每一项都表示4KB的地址范围。Offset对4096个地址进行编址。</p></li><li><p>由索引顶级页表得到的表项中含有二级页表的地址或页框号。顶级页表的表项0指向程序正文的页表，表项1指向数据的页表，表项1023指向堆栈的页表，其他的表项未用，现在把PT2域作为访问选定的二级页表的索引，以便找到该虚拟页面的对应页框号。</p></li><li><p>虽然虚拟地址空间超过100万个页面，实际上只需要4个页表：顶级页表，0-4M（正文段），4M-8M（数据段）和顶端4M（堆栈段）的二级页表。顶级页表中1021个表项的“在/不在”都设成0，当访问他们时强制产生一个缺页中断。</p></li><li><p>二级页表可扩充为三级、四级或更多级。级数越多，灵活性就越大。</p></li><li><p><strong>页目录指针表</strong>。每一级的页表项由32位扩展到了64位，这样处理器就能寻址到4GB以外的地址空间。</p></li></ul></li></ol><hr><h2 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h2><blockquote><p>当发生缺页中断时，操作系统必须在内存中选择一个页面将其换出内存，来为即将调入的页面腾出空间。</p></blockquote><ol><li>此算法不可能实现。在发生缺页中断的时候，在内存中的页面有的很快就会被访问，而有的页面可能要到10、100、1000条指令后才会被访问。此时要置换最迟被访问的页面，把因调用被替换的页面而引起的中断推迟到将来，越久越好。当缺页中断发生时，操作系统无法知道各个页面下一次将在什么时候被访问，因此这个算法是无法被实现的。</li><li>这个算法可以用来对其他可实现算法的性能进行比较。</li></ol><hr><h2 id="最近未使用页面置换算法（NRU，Not-Recently-Used）"><a href="#最近未使用页面置换算法（NRU，Not-Recently-Used）" class="headerlink" title="最近未使用页面置换算法（NRU，Not Recently Used）"></a>最近未使用页面置换算法（NRU，Not Recently Used）</h2><ol><li><p>当页面被访问（读或写）时设置R位，页面被写入（修改）时设置M位。</p></li><li><p>当启动一个进程时，它的所有页面的两个位都由操作系统设为0，R位被定期地（比如在每次时钟中断时）清零，以区别最近没有被访问的页面和被访问的页面。</p></li><li><p>当发生缺页中断时，操作系统检查所有的页面并根据它们当前的R位和M位的值，把它们分为4类：</p><ul><li>第0类：没有被访问，没有被修改。</li><li>第1类：没有被访问，已被修改（M）。</li><li>第2类：已被访问，没有被修改（R）。</li><li>第3类：已被访问，已被修改（RM）。</li></ul></li><li><p>NRU 算法随机地从类编号最小的非空类中挑选一个页面淘汰。在一个时间滴答中（大约20ms）淘汰一个没有被访问的已修改页面要比淘汰一个被频繁使用的“干净”页面好。NRU算法的主要优点是易于理解和能够有效地被实现，虽然它的性能不是最好的，但是已经够用了。</p></li><li><p>算法思路：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰。</p><ul><li>所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。</li></ul></li><li><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//判断数组中是否已有x，若有返回其下标值，没有则返回-1</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="keyword">if</span>(x==a[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//初始化数组为-1</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      a[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">      a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> m=a[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;n<span class="number">-1</span>; j++)</span><br><span class="line">      a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//输出当前数组元素</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>; <span class="comment">//模仿栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入物理块数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    init(<span class="built_in">stack</span>,n); <span class="comment">//初始化数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入内存访问序列：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x)) &#123;    <span class="comment">//自动读数</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;访问页面%d:\n&quot;</span>,x);</span><br><span class="line">      top++; <span class="comment">//读数后top自动+1</span></span><br><span class="line">      <span class="keyword">if</span>(top==<span class="number">0</span>) <span class="comment">//若数组无元素</span></span><br><span class="line">        <span class="built_in">stack</span>[top]=x; <span class="comment">//插入一个元素</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(top&lt;n) &#123; <span class="comment">//若在物理块范围内</span></span><br><span class="line">        <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,n,x)==<span class="number">-1</span>) <span class="comment">//若数组中不存在待插入元素</span></span><br><span class="line">          <span class="built_in">stack</span>[top]=x; ree<span class="comment">//新元素从尾部插入</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//若数组中存在待插入元素</span></span><br><span class="line">          move(<span class="built_in">stack</span>,top,judge(<span class="built_in">stack</span>,n,x)); <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">          top--; <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//超过物理块数的元素</span></span><br><span class="line">        <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,n,x)==<span class="number">-1</span>) &#123; <span class="comment">//若数组中不存在待插入元素</span></span><br><span class="line">          insert(<span class="built_in">stack</span>,n,x);</span><br><span class="line">        　<span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line">          top--; <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//若数组中存在待插入元素</span></span><br><span class="line">          move(<span class="built_in">stack</span>,n,judge(<span class="built_in">stack</span>,n,x)); <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">          top--;  <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      print(<span class="built_in">stack</span>,n); <span class="comment">//读一个序列号，输出当前数组元素</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="先进先出页面置换算法（FIFO）"><a href="#先进先出页面置换算法（FIFO）" class="headerlink" title="先进先出页面置换算法（FIFO）"></a>先进先出页面置换算法（FIFO）</h2><p>开销同样较小的FIFO算法，最新进入的页面放在表尾，最早进入的页面放在表头。当缺页中断时，淘汰表头的页面并把新调入的页面加到表尾。这种算法的缺点是可能会把有用的页面淘汰掉。</p><p><img src="https://img-blog.csdnimg.cn/20200523191127778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTAyODQ0,size_16,color_FFFFFF,t_70" class="lazyload" data-srcset="https://img-blog.csdnimg.cn/20200523191127778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTAyODQ0,size_16,color_FFFFFF,t_70" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在这里插入图片描述"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> totalCmdNum 320 <span class="comment">// 指令总数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BlockNum 4 <span class="comment">// 内存块总数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存块结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> id; <span class="comment">// 物理地址</span></span><br><span class="line">    <span class="keyword">int</span> page; <span class="comment">// 页号(默认为-1)</span></span><br><span class="line">    <span class="keyword">int</span> keepTime; <span class="comment">// 在内存中驻留的时间</span></span><br><span class="line">&#125; Block;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cmdNum = <span class="number">0</span>; <span class="comment">// 指令执行次数</span></span><br><span class="line"><span class="keyword">int</span> curCmd; <span class="comment">// 当前正在执行的指令</span></span><br><span class="line"><span class="keyword">int</span> isExecute[totalCmdNum]; <span class="comment">// 判断每条指令是否执行的标志数组</span></span><br><span class="line"><span class="keyword">double</span> lostPage = <span class="number">0</span>; <span class="comment">// 缺页次数</span></span><br><span class="line">Block *blocks[BlockNum]; <span class="comment">// 内存块指针数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化标志数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCmdNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 0代表未执行</span></span><br><span class="line">      isExecute[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置随机数种子</span></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">  <span class="comment">// 初始化内存块数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BlockNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 分配空间</span></span><br><span class="line">      blocks[i] = (Block *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Block));</span><br><span class="line">      blocks[i]-&gt;id = i + <span class="number">1</span>; <span class="comment">// 物理地址</span></span><br><span class="line">      blocks[i]-&gt;page = <span class="number">-1</span>; <span class="comment">// -1 代表此页还未分配</span></span><br><span class="line">      blocks[i]-&gt;keepTime = <span class="number">0</span>; <span class="comment">// 内存驻留时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 产生指令</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">genCmd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cmdNum++; <span class="comment">// 累计指令条数</span></span><br><span class="line">    <span class="keyword">if</span> (cmdNum == <span class="number">1</span>) &#123;</span><br><span class="line">      curCmd = rand() % totalCmdNum;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmdNum == <span class="number">2</span>) &#123;</span><br><span class="line">      curCmd++; <span class="comment">// 顺序执行下一条指令</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmdNum &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((cmdNum - <span class="number">2</span>) % <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 前地址部分</span></span><br><span class="line">          curCmd = rand() % (curCmd - <span class="number">2</span>);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          curCmd++; <span class="comment">// 顺序执行下一条指令</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="comment">// 后地址部分</span></span><br><span class="line">          curCmd = curCmd + <span class="number">1</span> + rand() % (totalCmdNum - curCmd);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    isExecute[curCmd] = <span class="number">1</span>; <span class="comment">// 1代表该指令已被执行(可以重复执行)</span></span><br><span class="line">    <span class="keyword">return</span> curCmd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断所有指令是否全部执行了一遍</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isFinish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// 遍历所有指令执行情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalCmdNum; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isExecute[i] == <span class="number">0</span>) &#123;</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作业调度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> page = genCmd() / <span class="number">10</span>; <span class="comment">// 根据指令号计算页号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; BlockNum; i++) &#123;</span><br><span class="line">    <span class="comment">// 如果访问的指令在内存中，则显示其物理地址</span></span><br><span class="line">      <span class="keyword">if</span> (blocks[i]-&gt;page == page) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指令%3d在内存块%d中\n&quot;</span>, curCmd, blocks[i]-&gt;id);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果访问的指令不在内存中</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= BlockNum) &#123;</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; BlockNum; i++) &#123; <span class="comment">// 寻找未分配的内存块</span></span><br><span class="line">        <span class="keyword">if</span> (blocks[i]-&gt;page == <span class="number">-1</span>) &#123;</span><br><span class="line">          blocks[i]-&gt;page = page;</span><br><span class="line">          <span class="comment">//printf(&quot;内存块未分配\n&quot;);</span></span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;指令%3d在内存块%d中\n&quot;</span>, curCmd, blocks[i]-&gt;id);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果所有内存块都已被分配</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= BlockNum) &#123;</span><br><span class="line">      <span class="keyword">int</span> oldestBlock = <span class="number">0</span>; <span class="comment">// 最先被分配的内存块</span></span><br><span class="line">      <span class="keyword">int</span> maxKeepTime = blocks[<span class="number">0</span>]-&gt;keepTime; <span class="comment">// 最长内存驻留时间</span></span><br><span class="line">      i = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (; i &lt; BlockNum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (blocks[i]-&gt;keepTime &gt; maxKeepTime) &#123;</span><br><span class="line">          oldestBlock = blocks[i]-&gt;id;</span><br><span class="line">          maxKeepTime = blocks[i]-&gt;keepTime;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      blocks[oldestBlock]-&gt;page = page;</span><br><span class="line">      blocks[oldestBlock]-&gt;keepTime = <span class="number">0</span>;</span><br><span class="line">      lostPage++; <span class="comment">// 累计缺页次数</span></span><br><span class="line">      <span class="comment">//printf(&quot;缺页了\n&quot;);</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;指令%3d在内存块%d中\n&quot;</span>, curCmd, blocks[oldestBlock]-&gt;id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; BlockNum; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (blocks[i]-&gt;page != <span class="number">-1</span>) &#123;</span><br><span class="line">        blocks[i]-&gt;keepTime++; <span class="comment">// 累计驻留时间</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(); <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      dispatchJob(); <span class="comment">// 作业调度</span></span><br><span class="line">      <span class="keyword">if</span> (isFinish()) &#123;  <span class="comment">// 判断作业是否运行完成</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n共执行指令%d条\n&quot;</span>, cmdNum);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;缺页率约为:%.1lf%%\n&quot;</span>, (lostPage / cmdNum)*<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="第二次机会页面置换算法（SC，Second-Chance）"><a href="#第二次机会页面置换算法（SC，Second-Chance）" class="headerlink" title="第二次机会页面置换算法（SC，Second Chance）"></a>第二次机会页面置换算法（SC，Second Chance）</h2><ol><li>对FIFO算法的改进，对FIFO算法做一个简单的修改：检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位置0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入时间使它就像刚装入的一样，然后继续搜索。</li><li>第二次机会（second chance）算法是寻找一个在最近的时钟间隔内没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。假设所有页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。最后又会回到原来的表头页面，此时它的R位已经被清除了，因此这个页面会被淘汰，所以这个算法总是可以结束的。</li><li>假设在时间20发生了一次缺页中断，这时最老的页面是A，它是在时刻0到达的。如果A的R位是0，则将它淘汰出内存，或者把它写回磁盘（如果它已被修改过），或者只是简单地放弃（如果它是“干净”的）；另一方面，如果其R位已经设置了，则将A放到链表的尾部并且重新设置“装入时间”为当前时刻（20），然后清除R位。然后从B页面开始继续搜索合适的页面。</li><li>第二次机会算法就是寻找一个最近的时钟间隔以来没有被访问过的页面。如果所有的页面都被访问过了，该算法就简化为纯粹的FIFO算法。特别地，想象一下，假设图3-15a中所有的页面的R位都被设置了，操作系统将会一个接一个地把每个页面都移动到链表的尾部并清除被移动的页面的R位。算法又将回到页面A，此时它的R位已经被清除了，因此A页面将被淘汰，所以这个算法总是可以结束的。</li></ol><hr><h2 id="时钟页面置换算法（CLOCK）"><a href="#时钟页面置换算法（CLOCK）" class="headerlink" title="时钟页面置换算法（CLOCK）"></a>时钟页面置换算法（CLOCK）</h2><ol><li><p>对第二次机会算法的改进，第二次机会算法经常要在链表中移动页面，既降低了效率又不是很必要。</p></li><li><p>一个更好的做法就是把所有的页面都保存在一个类似钟面的环形链表中，一个表指针指向最老的页面。当发生缺页中断时，首先检查表指针指向的页面，如果它的R位是0就淘汰该页面，并把新的页面插入这个位置，然后把表指针前移一个位置。如果R位是1就清除R位并把表指针前移一个位置；重复这个过程一直到找到一个R位为0的页面为止。</p></li><li><p>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * clock_pro.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  Created on: 2019年12月6日</span></span><br><span class="line"><span class="comment"> *      Author: zyli</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxblocks 3</span></span><br><span class="line"><span class="keyword">int</span> blocks[Maxblocks] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> access[Maxblocks] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> modify[Maxblocks] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> pages_in_blocks = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> is_modified = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> aimed_i=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_aimed</span><span class="params">(<span class="keyword">int</span> pn)</span> </span>&#123;</span><br><span class="line">    aimed_i=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(blocks[i]==pn) &#123;</span><br><span class="line">        aimed_i=i;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> taotaip=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!access[i]&amp;&amp;!modify[i]) &#123;</span><br><span class="line">          taotaip=blocks[i];</span><br><span class="line">          <span class="keyword">for</span>(; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">            blocks[i]=blocks[i+<span class="number">1</span>];</span><br><span class="line">            access[i]=access[i+<span class="number">1</span>];</span><br><span class="line">            modify[i]=modify[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>(!j) <span class="built_in">printf</span>(<span class="string">&quot;第一圈有（0，0）的，是页面  %d，淘汰！把新页面放入队尾\n&quot;</span>,taotaip);</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;第三圈有（0，0）的，是页面  %d，淘汰！把新页面放入队尾\n&quot;</span>,taotaip);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">if</span>(!j) <span class="built_in">printf</span>(<span class="string">&quot;第一圈没有（0，0）的，接着找（0，1）的\n&quot;</span>);</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;第三圈没有（0，0）的，即上一圈（第二圈）全为（0，1）\n&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!(!access[i]&amp;&amp;modify[i])) &#123;</span><br><span class="line">          access[i]=<span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          taotaip=blocks[i];</span><br><span class="line">          <span class="keyword">for</span>(; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">            blocks[i]=blocks[i+<span class="number">1</span>];</span><br><span class="line">            access[i]=access[i+<span class="number">1</span>];</span><br><span class="line">            modify[i]=modify[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">if</span>(!j) <span class="built_in">printf</span>(<span class="string">&quot;第二圈有（0，1）的，是页面  %d，淘汰！第一个（0，1）之前的页面访问位全部置为0，并把新页面放入队尾\n&quot;</span>,taotaip);</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;第四圈必有（0，1）的，将第一个（0，1）的，即页面%d淘汰！把新页面放入队尾\n&quot;</span>,taotaip);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;第二圈没有（0，1）的，但把所有访问位置为0了，接着第三圈找（0，0）的\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clock_pro</span><span class="params">(<span class="keyword">int</span> pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pages_in_blocks&lt;Maxblocks) &#123;</span><br><span class="line">      <span class="keyword">if</span>(is_aimed(pn)) &#123;</span><br><span class="line">        access[aimed_i]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入页面是否被修改%d    (0/1)\n&quot;</span>,pn);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;is_modified);</span><br><span class="line">        <span class="keyword">if</span>(is_modified) modify[aimed_i]=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        blocks[pages_in_blocks]=pn;</span><br><span class="line">        access[pages_in_blocks]=<span class="number">1</span>;</span><br><span class="line">        modify[pages_in_blocks]=<span class="number">0</span>;</span><br><span class="line">        pages_in_blocks++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(is_aimed(pn)) &#123;</span><br><span class="line">        access[aimed_i]=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入页面是否被修改%d    (0/1)\n&quot;</span>,pn);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;is_modified);</span><br><span class="line">        <span class="keyword">if</span>(is_modified) modify[aimed_i]=<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        loop();</span><br><span class="line">        blocks[Maxblocks<span class="number">-1</span>]=pn;</span><br><span class="line">        access[Maxblocks<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">        modify[Maxblocks<span class="number">-1</span>]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_blocks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cato=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;此时内存块里状态为：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pages_in_blocks; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(!access[i] &amp;&amp; !modify[i]) cato=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(!access[i] &amp;&amp;  modify[i]) cato=<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">if</span>( access[i] &amp;&amp; !modify[i]) cato=<span class="number">3</span>;</span><br><span class="line">      <span class="keyword">if</span>( access[i] &amp;&amp;  modify[i]) cato=<span class="number">4</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d    %d    %d  ,对应第%d类型页面\n&quot;</span>,blocks[i],access[i],modify[i],cato);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;Maxblocks; i++) &#123;</span><br><span class="line">      blocks[i]=<span class="number">-1</span>;</span><br><span class="line">      access[i]=<span class="number">0</span>;</span><br><span class="line">      modify[i]=<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">      is_modified=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;输入此时进程对哪个页面访问,输入-1结束程序\n&quot;</span>);</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">      <span class="keyword">if</span>(n&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">        clock_pro(n);</span><br><span class="line">        print_blocks();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="最近最少使用页面置换算法（LRU，Least-Recently-Used）"><a href="#最近最少使用页面置换算法（LRU，Least-Recently-Used）" class="headerlink" title="最近最少使用页面置换算法（LRU，Least Recently Used）"></a>最近最少使用页面置换算法（LRU，Least Recently Used）</h2><ol><li><p>在缺页中断发生时，置换未使用时间最长的页面。</p></li><li><p>LRU理论上是可以实现的，但是代价很高。维护一个所有页面的链表，最近最多使用的页面在表头，最近最少使用的页面在表尾。困难的是在每次访问内存时都必须要更新整个链表。</p></li><li><p>假设用硬件实现：硬件有一个64位计数器C，它在每条指令执行完后自动加1，每个页表项必须有一个足够容纳这个计数器值的域。在每次访问完内存后，将当前的C值保存到被访问页面的页表项中。一旦发生缺页中断，操作系统就检查所有页表项中计数器的值，找到值最小的一个页面，这个页面就是最近最少使用的页面，但是只有非常少的计算机拥有这样的硬件。</p></li><li><p>算法过程：用一个数组来存储数据，给每一个数据项标记一个访问时间戳，每次插入新数据项的时候，先把数组中存在的数据项的时间戳自增，并将新数据项的时间戳置为0并插入到数组中。每次访问数组中的数据项的时候，将被访问的数据项的时间戳置为0。当数组空间已满时，将时间戳最大的数据项淘汰，所以要用此方法，必须定义一个二维数组或者是结构体，我结合了时间戳、栈和顺序表的思路，重新设计了一个较好的方法。</p></li><li><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//判断数组中是否已有x，若有返回其下标值，没有则返回-1</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="keyword">if</span>(x==a[i])</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//初始化数组为-1</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      a[i]=<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">      a[i]=a[i+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n,<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> m=a[i];</span><br><span class="line">    <span class="keyword">for</span>(j=i; j&lt;n<span class="number">-1</span>; j++)</span><br><span class="line">      a[j]=a[j+<span class="number">1</span>];</span><br><span class="line">    a[n<span class="number">-1</span>]=m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">//输出当前数组元素</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">      <span class="keyword">if</span>(a[i]!=<span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[MAX];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>; <span class="comment">//模仿栈的定义</span></span><br><span class="line">    <span class="keyword">int</span> n,x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入物理块数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    init(<span class="built_in">stack</span>,n);  <span class="comment">//初始化数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入内存访问序列：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x)) &#123; <span class="comment">//自动读数</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;访问页面%d:\n&quot;</span>,x);</span><br><span class="line">      top++; <span class="comment">//读数后top自动+1</span></span><br><span class="line">      <span class="keyword">if</span>(top==<span class="number">0</span>) <span class="comment">//若数组无元素</span></span><br><span class="line">        <span class="built_in">stack</span>[top]=x; <span class="comment">//插入一个元素</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(top&lt;n) &#123; <span class="comment">//若在物理块范围内</span></span><br><span class="line">        <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,n,x)==<span class="number">-1</span>) <span class="comment">//若数组中不存在待插入元素</span></span><br><span class="line">          <span class="built_in">stack</span>[top]=x; <span class="comment">//新元素从尾部插入</span></span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//若数组中存在待插入元素</span></span><br><span class="line">          move(<span class="built_in">stack</span>,top,judge(<span class="built_in">stack</span>,n,x)); <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">          top--; <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//超过物理块数的元素</span></span><br><span class="line">        <span class="keyword">if</span>(judge(<span class="built_in">stack</span>,n,x)==<span class="number">-1</span>) &#123; <span class="comment">//若数组中不存在待插入元素</span></span><br><span class="line">          insert(<span class="built_in">stack</span>,n,x);</span><br><span class="line">        　<span class="comment">//栈法插入(第一个元素出，后面元素前移，新元素从尾部入)</span></span><br><span class="line">          top--; <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//若数组中存在待插入元素</span></span><br><span class="line">          move(<span class="built_in">stack</span>,n,judge(<span class="built_in">stack</span>,n,x)); <span class="comment">//移动下标为i的元素到尾部</span></span><br><span class="line">          top--; <span class="comment">//因为没有插入新元素，回滚top值</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      print(<span class="built_in">stack</span>,n); <span class="comment">//读一个序列号，输出当前数组元素</span></span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="最不常用页面置换算法（NFU）（Not-Frequently-Used）"><a href="#最不常用页面置换算法（NFU）（Not-Frequently-Used）" class="headerlink" title="最不常用页面置换算法（NFU）（Not Frequently Used）"></a>最不常用页面置换算法（NFU）（Not Frequently Used）</h2><ol><li>用一个软件模拟LRU，该算法将每个页面与一个软件计数器相关联。计数器的初值为0。每次时钟中断时，由操作系统扫描内存中所有的页面，将每个页面的R位（它是0或1）加到它的计数器上。这个计数器大体上跟踪了各个页面被访问的频繁程度。发生缺页中断时，则置换计数器值最小的页面。</li><li>NFU的缺点是它不从不忘记任何事，比如一个页面之前频繁被访问，导致这个它的计数器很大，但是后来它不被访问了，而它的计数器的值还是很大，所以它一直不会被置换出去。</li></ol><hr><h2 id="老化算法"><a href="#老化算法" class="headerlink" title="老化算法"></a>老化算法</h2><ol><li>老化算法是对NFU算法的修改，其修改包括两个部分，首先，在R位被加进之前将计数器右移一位，其次，将R位加到计数器最左端的位而不是最右端的位。</li><li>老化算法中的计数器只有有限位数，如果时钟滴答是20ms，8位一般是够用的。假如一个页面160ms没有被访问过，那么它很可能并不重要。</li></ol><hr><h2 id="工作集页面置换算法"><a href="#工作集页面置换算法" class="headerlink" title="工作集页面置换算法"></a>工作集页面置换算法</h2><ol><li>一个进程当前正在使用的页面的集合称为它的工作集。</li><li>若每执行几条指令就产生一次缺页中断，那么就称这个程序发生了颠簸。</li><li>在单纯的分页系统中，刚启动进程时，在内存中并没有页面。在CPU试图读取第一条指令时就会产生一次缺页中断，使操作系统装入含有第一条指令的页面，其他由访问全局数据和堆栈引起的缺页中断通常会紧接着发生。一段时间后，进程需要的大部分页面都已经在内存了，进程开始在较少缺页中断的情况下运行。这个策略被称为请求调页。</li><li>有不少分页系统会设法跟踪进程的工作集，以确保在让进程运行以前，它的工作集就已经在内存中了。该方法称为工作集模型，大大减少缺页中断率。在进程前装入其工作集页面也称为预先调页。工作集是随时间变化的。</li><li>事实上大多数程序会任意访问一小部分页面，工作集随时间缓慢变化。当程序重新开始时，就有可能根据它上次结束时的工作集对要用到的页面做一个合理的推测，预先调页就是在程序IXUS运行之前预先装入推测的工作集的页面。</li><li>按照以前的方法，定义工作集为前1000万次内存访问锁使用过的页面的集合，那么现在就可以这样定义：工作集即是过去10ms中的内存访问所用到的页面的集合。这样的模型很合适而且更容易实现。要注意到，每个进程只计算它自己的执行时间。因此，如果一个进程在T时刻开始，在(T+100ms)的时刻使用了40msCPU时间，对工作集而言，它的时间就是40ms。一个程序从它开始执行到当前所实际使用的CPU时间总数通常称作当前实际运行时间。通过这个近似的方法，进程的工作集可以被称为在过去的τ秒实际运行时间中它所访问过的页面的集合。</li><li>基于工作集的页面置换算法就是找出一个不在工作集中的页面并淘汰它。每个表项至少包含两条信息：上次使用该页面的近似时间和R（访问位）。</li><li>过程：<ul><li>扫描所有的页面检查R位</li><li> 若（R == 1）：设置上次使用时间为当前实际时间，以表示缺页中断时该页面正在被使用</li><li>若（R == 0 且生存时间&gt;τ）：移出这个页面，该页面在当前时钟滴答中未被访问，不在工作集中，用新的页面置换它。扫描会继续进行以更新剩余的表项。</li><li>若（R == 0 且生存时间≤τ）：记住最小时间。如果该页面R==0且生存时间小于或等于τ，则页面仍在工作集中。把页面临时保存下来，但是要记住生存时间最长（“上次使用时间”的最小值）。如果扫描完整个页表却没有找到合适的淘汰的页面，如果找到了一个或多个R == 0的页面，就淘汰生存时间最长的页面。</li></ul></li><li>在最坏的情况下，在当前时钟滴答中，所有的页面都被访问过了，也就是所有的R都为1，因此就随机选择一个页面淘汰，如果有的话最好选一个干净页面。</li></ol><hr><h2 id="工作集时钟页面置换算法"><a href="#工作集时钟页面置换算法" class="headerlink" title="工作集时钟页面置换算法"></a>工作集时钟页面置换算法</h2><ol><li>在工作集页面置换算法中中，当缺页中断发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法是比较费时的。</li><li>基于时钟算法，并且使用了工作集信息，被称为WSClock（工作集时钟）算法。由于它实现简单，性能较好，所以在实际工作中得到了广泛应用。</li><li>与时钟算法一样，所需的数据结构是一个以页框为元素的循环表。最初，该表示空的，当装入第一个页面后，把它加到该表中。随着更多的页面加入，它们形成一个环。每个表项包含来自基本工作集算法的上次使用时间，以及R位和M位。</li><li>与时钟算法一样，每次缺页中断时，首先检查指针指向的页面。如果R位是1，该页面在当前时钟滴答中就被使用过，那么该页面就不适合被淘汰。然后把该页面的R位置为0，指针指向下一个页面，并重复该算法。</li><li>如果R位是0，查看生存时间，如果生存时间大于τ并且该页面是干净的，它就不在工作集中，而且在磁盘上它有一个有效的副本。申请此页框，并把新页面放在其中。如果该页面已经被修改过，就不立即申请此页框，为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作，有可能存在一个旧的而且干净的页面可以立即使用。</li><li>原则上，所有的页面都有可能因为磁盘I/O在某个时钟周期被调度，为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回n个页面。一旦达到该限制，就不允许调度新的写操作。</li><li>指针经过一圈返回它的起点，有两种情况：<ul><li>至少调用了一次写操作<ul><li>执行了写操作的页面已经是干净的了，置换遇到的第一个干净页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能已经把写操作重排序了。</li></ul></li><li>没有调用过写操作<ul><li>所有的页面都在工作集中，否则将至少执行了一个写操作。由于缺乏额外的信息，一个简单的方法就是随便置换一个干净的页面来使用，扫描中需要记录干净页面的位置。如果不存在干净页面，就选定当前页面并把它协会磁盘。</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（七）：虚拟存储器</title>
      <link href="b56da1eb9025/"/>
      <url>b56da1eb9025/</url>
      
        <content type="html"><![CDATA[<h2 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h2><h3 id="交换技术与覆盖技术"><a href="#交换技术与覆盖技术" class="headerlink" title="交换技术与覆盖技术"></a>交换技术与覆盖技术</h3><ol><li>是在多道环境下扩充内存的方法，用以解决在较小的存储空间中运行较大程序时遇到的矛盾。</li><li>交换技术被广泛用于小型分时系统中，交换技术的发展导致了虚存技术的出现；覆盖技术主要用在早期的操作系统中。</li><li>交换技术与覆盖技术异同点：<ul><li>共同点：进程的程序和数据主要放在外存，当前需要执行的部分放在内存，内外存之间进行信息交换。</li><li>不同点：如何控制交换。</li></ul></li><li>覆盖技术：<ul><li>把程序划分为若干个功能上相对独立的程序段，按照其自身的逻辑结构将那些不会同时执行的程序段共享同一块内存区域。</li><li>程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段（内存“扩大”了）。</li><li>覆盖：一个作业的若干程序段，或几个作业的某些部分共享某一个存储空间</li><li>一般要求作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖</li></ul></li><li>覆盖技术的缺点：<ul><li>对用户不透明，增加了用户负担</li><li>目前这一技术用于小型系统中的系统程序的内存管理上</li><li>MS-DOS的启动过程中，多次使用覆盖技术；启动之后，用户程序区TPA的高端部分与COMMAND.COM暂驻模块也是一种覆盖结构</li></ul></li><li>交换技术：<ul><li>当内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域，这种技术是进程在内存与外存之间的动态调度。</li><li>这种技术多用于分时系统中。</li></ul></li><li>交换技术实现中的几个问题：<ul><li>选择原则：将哪个进程换出内存？<ul><li>例如：分时系统中，时间片轮转法或基于优先数的调度算法，在选择换出进程时，要确定换出的进程是要长时间等待的。</li><li>需要特殊考虑的是：任何等待I/O进程中存在的问题。</li><li>解决：从来不换出处于等待I/O状态的进程。</li><li>有些I/O进程因DMA（直接存储器访问）而不能换出内存或换出前需要操作系统的特殊帮助。</li></ul></li><li>如何确定交换时机？<ul><li>只要不用或者很少再用就换出。</li><li>只在内存空间不够或有不够的危险时换出。</li></ul></li><li>交换时需要做哪些工作？<ul><li>盘交换区：足够大，存放所有用户程序的所有内存映像的拷贝。</li><li>直接存取：必须能够对这些用户程序的内存映像进行存取操作。</li></ul></li><li>如何确定换入内存时位置？（换出后再换入的内存位置一定要在换出前的原来位置上吗？）<ul><li>受地址“绑定”技术的影响，即绝对地址产生时机的限制</li></ul></li></ul></li><li>覆盖与交换的比较：<ul><li>与覆盖技术相比，交换技术不要求用户给出程序段之间的逻辑覆盖结构；而且，交换发生在进程或作业之间。</li><li>而覆盖发生在同一进程或作业内。</li><li>覆盖只能覆盖那些与覆盖段无关的程序段。</li></ul></li></ol><h3 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h3><p><img src="https://user-images.githubusercontent.com/49378661/103187712-7a8fbc80-4900-11eb-98c1-96e3598fca1d.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187712-7a8fbc80-4900-11eb-98c1-96e3598fca1d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228090026269"></p><ol><li>程序装入内存时可能会出现如下问题：<ul><li>程序太大，要求的空间超出了内存总容量</li><li>有大量作业要求运行，但内存不能容下所有作业</li></ul></li><li>常规存储器管理方式的特征<ul><li>一次性：要求作业全部装入内存才能运行。</li><li>驻留性：程序装入内存后便一直驻留内存，直至运行结束。</li></ul></li><li>虚拟存储器的基本思想是：程序、数据、堆栈的大小可以超过内存的大小，操作系统把程序当前使用的部分保留在内存，而把其它部分保存在磁盘上，并在需要时在内存和磁盘之间动态交换。</li><li>虚拟存储器支持多道程序设计技术。</li><li>虚拟存储器定义：是指具有请求调入功能和置换功能， 能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而其成本却又接近于外存。</li><li>注意：一个虚拟存储器的最大容量是由计算机的地址结构确定的。如：若CPU的有效地址长度为32位，则程序可以寻址范围是0～(2^32)-1 ，即虚存容量为 4GB。</li><li>虚拟存储器的容量与主存的实际大小没有直接的关系，而是由主存与辅存的容量之和所确定。</li></ol><h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><ol><li>虚拟存储器的实现都是建立在离散分配的存储管理方式基础上的。</li><li>主要有：<ul><li>请求分页系统</li><li>请求分段系统</li></ul></li><li>请求分页系统：<ul><li>在分页系统的基础上增加了请求调页功能和页面置换功能</li><li>硬件支持：<ul><li>请求分页的页表机制，它是在纯分页的页表机制上增加若干项而形成的，作为请求分页的数据结构；</li><li>缺页中断机构，即每当用户程序要访问的页面尚未调入内存时 便产生一缺页中断，以请求OS将所缺的页调入内存；</li><li>地址变换机构， 它同样是在纯分页地址变换机构的基础上发展形成的</li></ul></li><li>实现请求分页的软件：用于实现请求调页的软件和实现页面置换的软件</li></ul></li><li>请求分段系统：为了实现请求分段，系统同样需要必要的硬件支持：<ul><li>请求分段的段表机制。这是在纯分段的段表机制基础上，增加若干项而形成的；</li><li>缺段中断机构。每当用户程序所要访问的段尚未调入内存时，产生一缺段中断，请求OS将所缺的段调入内存；</li><li>地址变换机构。与请求调页类似，实现请求调段和置换功能也需要得到OS的支持。</li></ul></li></ol><h3 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h3><ol><li>虚拟存储器的特征有：<ul><li>离散性（最基本的特征）</li><li>多次性：一个作业被分成多次调入内存运行。</li><li>对换性：允许在作业的运行过程中进行换进、换出。</li><li>虚拟性（最重要的特征）：能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ul></li><li>以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术。</li></ol><hr><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="请求分页中的硬件支持"><a href="#请求分页中的硬件支持" class="headerlink" title="请求分页中的硬件支持"></a>请求分页中的硬件支持</h3><ol><li>系统需要解决的问题：<ul><li>系统如何获知进程当前所需页面不在主存</li><li>当发现缺页时，如何把所缺页面调入主存</li><li>当主存中没有空闲的页框时，为了要接受一个新页，需要把老的一页淘汰出去，根据什么策略选择欲淘汰的页面</li></ul></li><li>页描述子的扩充（页表机制）：<br><img src="https://user-images.githubusercontent.com/49378661/103187718-87141500-4900-11eb-8cc0-69467f725f6f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187718-87141500-4900-11eb-8cc0-69467f725f6f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228092544632"><ul><li>状态位P（中断位）指示该页是在内存还是在外存</li><li>访问位 A 用于记录本页在一段时间内被访问的次数或记录本页在最近多长时间未被访问</li><li>修改位 M 表示该页在内存中是否被修改过</li><li>外存地址该页在外存上的地址，通常是物理块号</li></ul></li><li>缺页中断机构<ul><li>在请求分页系统中，每当所要访问的页面不在内存时，便产生一缺页中断。相应的中断处理程序把控制转向缺页中断子程序，执行此子程序，即把所缺页面装入主存，然后处理机重新执行缺页时打断的指令。这时，就将顺利形成物理地址。</li><li>缺页中断与一般中断的区别：<ul><li>在指令执行期间产生和处理中断信号</li><li>一条指令在执行期间可能产生多次缺页中断</li></ul></li></ul></li><li>涉及6次缺页中断的指令 ：<br><img src="https://user-images.githubusercontent.com/49378661/103187726-8ed3b980-4900-11eb-9925-212e7e0e7251.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187726-8ed3b980-4900-11eb-9925-212e7e0e7251.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228092644545"></li><li>如果在快表中未找到该页的页表项，则应再到内存中去查找页表，再从找到的页表项中的状态位P，该页是否调入内存。其结果可能是：<ul><li>该页已经调入内存，这是应将此页的页表项写入快表，当快表已满时，应先调出按某种算法所确定的页的页表项，然后再写入该页的页表项。</li><li>该页尚未调入内存，这时便应产生缺页中断，请求OS从外存中把该页调入内存。</li></ul></li><li>请求分页中的地址变换过程：<br><img src="https://user-images.githubusercontent.com/49378661/103187738-9dba6c00-4900-11eb-9f7a-7fc0041665a2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187738-9dba6c00-4900-11eb-9f7a-7fc0041665a2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228092824992"></li></ol><h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><ol><li>最小物理块数的确定：<ul><li>指保证进程正常运行所需的最小物理块数。当系统分配的物理块数少于此值时，进程将无法运行。</li><li>进程应获得的最小物理块数与计算机的硬件结构有关，取决于指令的格式、 功能和寻址方式。</li><li>对于单地址指令且采用直接寻址方式的机器，则所需最少2个物理块。其中，一块存放指令页面，另一块则存放数据页面。</li><li>不同的作业要求不同。例如，允许间接寻址的机器，至少要求有3个物理块；而直接寻址方式所需的最少物理块数为2：<br><img src="https://user-images.githubusercontent.com/49378661/103187741-a3b04d00-4900-11eb-84a5-9d0e103502d8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187741-a3b04d00-4900-11eb-84a5-9d0e103502d8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228093354472"></li><li>对于长度是两个或多于两个字节指令的机器，其指令本身可能跨两个页面，且源和目标地址所涉及的区域也可能跨两个页面，至少需要6个物理块。</li></ul></li><li>物理块的分配策略：在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。于是可组合出以下三种适用的策略：<ul><li>固定分配局部置换(Fixed Allocation, Local Replacement) <ul><li>问题：分配块数难确定，太少，缺页频繁，吞吐量降低；太多，内存驻留进程数减少，CPU或其它资源可能空闲。</li></ul></li><li>可变分配全局置换(Variable Allocation, Global Replacement)<ul><li>先分配给各进程一定数的物理块，系统有一空闲物理块队列，缺页时从空闲队列取，若空闲队列空时，在选页调出。</li></ul></li><li>可变分配局部置换(Variable Allocation, Local Replacemen)<ul><li>先分配给各进程一定数的物理块，缺页时从该进程在内存的页选一换出，若其频繁缺页，系统再分配若干附加物理块。</li></ul></li></ul></li><li>物理块分配算法：<ul><li>平均分配算法：<ul><li>这是将系统中所有可供分配的物理块，平均分配给各个进程。</li><li>例如，当系统中有100个物理块，有5个进程在运行时，每个进程可分得20个物理块。这种方式貌似公平，但实际上是不公平的，因为它未考虑到各进程本身的大小。如有一个进程其大小为200页，只分配给它20个块，这样，它必然会有很高的缺页率；而另一个进程只有10页，却有10个物理块闲置未用。</li></ul></li><li>按比例分配算法：<ul><li>这是根据进程的大小按比例分配物理块的算法。如果系统中共有n个进程，每个进程的页面数为Si，则系统中各进程页面数的总和为：<br><img src="https://user-images.githubusercontent.com/49378661/103187747-ab6ff180-4900-11eb-91f7-c859df8a1679.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187747-ab6ff180-4900-11eb-91f7-c859df8a1679.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228094203079"><ul><li>又假定系统中可用的物理块总数为m，则每个进程所能分到的物理块数为bi，将有：<br><img src="https://user-images.githubusercontent.com/49378661/103187751-b165d280-4900-11eb-9f04-904b470c1067.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187751-b165d280-4900-11eb-9f04-904b470c1067.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228094233465"><ul><li>b应该取整，它必须大于最小物理块数。</li></ul></li></ul></li></ul></li><li>考虑优先权的分配算法：<ul><li>在实际应用中，为了照顾到重要的、紧迫的用户程序能尽快地完成， 应为它分配较多的内存空间</li><li>通常采取的方法是把内存中可供分配的所有物理块分成两部分：一部分按比例地分配给各进程；另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程</li><li>在重要的系统，如实时控制系统，则可能是完全按优先权为各进程分配其物理块的</li></ul></li></ul></li></ol><h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><ol><li>何时调入页面：<ul><li>预调页策略：采用一种以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存，成功率50%。</li><li>请求调页策略：<ul><li>当进程在运行中需要访问某部分程序和数据时，若发现其所在的页面不在内存，便提出请求，由OS将其所需页面调入内存。</li><li>目前的虚拟存储中大多采用此种策略。</li></ul></li></ul></li><li>从何处调入页面<ul><li>在请求分页系统中的外存分为两部分：<br><img src="https://user-images.githubusercontent.com/49378661/103187753-b6c31d00-4900-11eb-9a1a-7172f3ba2e9f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187753-b6c31d00-4900-11eb-9a1a-7172f3ba2e9f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228104618480"><ul><li>用于存放文件的文件区</li><li>用于存放对换页面的对换区</li></ul></li><li>通常，由于对换区是采用连续分配方式，而文件区是采用离散分配方式，故对换区的磁盘I/O速度比文件区的高。这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下三种情况：<ul><li>系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前， 便须将与该进程有关的文件，从文件区拷贝到对换区。</li><li>系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出，以后再调入时，仍从文件区直接调入。但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li><li>由于与进程有关的文件都放在文件区，故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。由于UNIX系统允许页面共享，因此，某进程所请求的页面有可能已被其它进程调入内存，此时也就无须再从对换区调入。</li></ul></li></ul></li><li>页面调入过程<br><img src="https://user-images.githubusercontent.com/49378661/103187762-bcb8fe00-4900-11eb-9ab9-35e3b78161be.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187762-bcb8fe00-4900-11eb-9ab9-35e3b78161be.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228105551265"><ul><li>每当程序所要访问的页面未在内存时，便向CPU发出一缺页中断，中断处理程序首先保留CPU环境，分析中断原因后，转入缺页中断处理程序。该程序通过查找页表，得到该页在外存的物理块地址。</li><li>若此时内存能容纳新页，则启动磁盘I/O将所缺之页调入内存，然后修改页表</li><li>若内存已满，则须先按照某种置换算法从内存中选出一页准备换出：<ul><li>页未被修改过，可不必将该页写回磁盘</li><li>页已被修改过， 则必须将它写回磁盘，然后再把所缺的页调入内存， 并修改页表中的相应表项，置其状态位为“1”，并将此页表项写入快表中。</li></ul></li><li>在缺页调入内存后，利用修改后的页表，去形成所要访问数据的物理地址，再去访问内存数据</li></ul></li></ol><hr><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><blockquote><p>这里简略介绍主要的几个页面置换算法，算法详解请看：<a href="https://github.com/OzzieNicholas/Blog/issues/115">页面置换算法</a></p></blockquote><h3 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h3><ol><li><p>采用最佳置换算法可保证获得最低的缺页率。</p></li><li><p>但由于人们目前还无法预知一个进程在内存的若干个页面中，哪一个页面是未来最长时间内不再被访问的，因而该算法也是无法实现的，但是可利用该算法去评价其它算法。</p></li><li><p>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串：7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1进程运行时， 先将7，0，1三个页面装入内存。 以后，当进程要访问页面2时将会产生缺页中断。此时OS根据最佳置换算法，将淘汰页面7：<br><img src="https://user-images.githubusercontent.com/49378661/103187783-c8a4c000-4900-11eb-9319-071739383e9a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187783-c8a4c000-4900-11eb-9319-071739383e9a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228110714217"></p></li></ol><h3 id="先进先出置换算法（FIFO）"><a href="#先进先出置换算法（FIFO）" class="headerlink" title="先进先出置换算法（FIFO）"></a>先进先出置换算法（FIFO）</h3><ol><li>该算法总是淘汰最先进入内存的页面，即选择在内存中的驻留时间最久的页面予以淘汰。该算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为替换指针，使它总是指向最老页面。</li><li>但该算法与进程实际运行的规律不相适应，因为在进程中，有些页面经常被访问，含有全局变量、常用函数、例程等的页面，FIFO置换算法并不能保证这些页面不被淘汰：<br><img src="https://user-images.githubusercontent.com/49378661/103187786-ce020a80-4900-11eb-8d31-09ef498e6bff.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187786-ce020a80-4900-11eb-8d31-09ef498e6bff.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228110912825"></li></ol><h3 id="最近最久未使用置换算法（LRU）"><a href="#最近最久未使用置换算法（LRU）" class="headerlink" title="最近最久未使用置换算法（LRU）"></a>最近最久未使用置换算法（LRU）</h3><ol><li>FIFO置换算法之所以性能较差，是因为它所依据的条件是各个页面调入内存的时间，而页面调入的先后并不能反映页面的使用情况。而最近最久未使用（LRU）的页面置换算法，则是根据页面调入内存后的使用情况。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似。因此，LRU置换算法是选择最近最久未使用的页面予以淘汰。 </li><li>算法描述：选择最后一次访问时间距离当前时间最长的一页并淘汰之。即淘汰没有使用的时间最长的页。实现代价很高（时间戳或硬件方法）<br><img src="https://user-images.githubusercontent.com/49378661/103187796-d78b7280-4900-11eb-969f-4b1c2de3246e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187796-d78b7280-4900-11eb-969f-4b1c2de3246e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228111053986"></li><li>把LRU算法作为页面置换算法是比较好的，它对于各种类型的程序都能适用，但实现起来有相当大的难度，因为它要求系统具有较多的支持硬件。所要解决的问题有：<ul><li> 一个进程在内存中的各个页面各有多久时间未被进程访问；</li><li> 如何快速地知道哪一页最近最久未使用的页面。</li><li>为此，须利用以下两类支持硬件：<ul><li>移位寄存器：定时右移</li><li>栈：当进程访问某页时，将其移出压入“栈顶”，“栈底”换出。</li></ul></li></ul></li><li>影响缺页次数的因素：<ul><li>分配给进程的物理页面数</li><li>页面本身的大小</li><li>程序的编制方法</li><li>页面淘汰算法</li></ul></li></ol><hr><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><h3 id="请求分段中的硬件支持"><a href="#请求分段中的硬件支持" class="headerlink" title="请求分段中的硬件支持"></a>请求分段中的硬件支持</h3><ol><li>段表机制：<br><img src="https://user-images.githubusercontent.com/49378661/103187808-dd815380-4900-11eb-9ed0-dd03142e3cbc.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187808-dd815380-4900-11eb-9ed0-dd03142e3cbc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228111838455"><ul><li>存取方式：用于标识本分段存取属性是只执行、只读还是允许读/写</li><li>存在位P：用于指示该段是否已调入内存</li><li>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页在最近多长时间未被访问。</li><li>修改位M：表示该段在调入内存后是否被修改过</li><li>外存地址：本段在外存上的地址，盘块块号</li><li>增补位：本段在运行过程中是否做过动态增长</li></ul></li><li>请求分段系统中的中断处理过程：<br><img src="https://user-images.githubusercontent.com/49378661/103187811-e2de9e00-4900-11eb-9c55-1e49128a56de.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187811-e2de9e00-4900-11eb-9c55-1e49128a56de.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228112024741"><ul><li>从中可以看出，对缺段中断的处理要比对缺页中断的处理复杂，因为段是不定长的。</li></ul></li><li>地址变换机构：请求分段系统中的地址变换机构，是在分段系统地址变换机构的基础上形成的。因为被访问的段并非全在内存，因而在地址变换时，若发现所要访问的段不在内存时，必须先将所缺的段调入内存，并修改了段表之后，才能再利用段表进行地址变换。为此，在地址变换机制中又增加了某些功能，如缺段中断的请求及其处理等。<ul><li>下图表示出了请求分段系统的地址变换过程：（段号为S，段内地址为W）<br><img src="https://user-images.githubusercontent.com/49378661/103187813-e70abb80-4900-11eb-96c4-81d6bee7ae34.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187813-e70abb80-4900-11eb-96c4-81d6bee7ae34.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228112236527"></li></ul></li></ol><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><ol><li>共享段表<br><img src="https://user-images.githubusercontent.com/49378661/103187817-ec680600-4900-11eb-838c-1823d13d7e8c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187817-ec680600-4900-11eb-838c-1823d13d7e8c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228112434878"><ul><li>为了实现分段共享，可在系统中配置一张共享段表所有各共享段都在共享段表中占有一表项。</li><li>共享进程计数count<ul><li>记录有多少个进程需要共享该分段</li></ul></li><li>存取控制字段<ul><li>对于一个共享段，应给不同的进程以不同的权限</li></ul></li><li>段号<ul><li>对于一个共享段，不同的进程可以各用不同的段号去共享该段</li></ul></li></ul></li><li>共享段的分配<ul><li>对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在共享段表中增加一表项，填写有关数据，把count置为1；</li><li>当又有其它进程需要调用该共享段时，无须再为该段分配内存，而只需在调用进程的段表中，增加一表项，填写该共享段的物理地址；在共享段的段表中，填上调用进程的进程名、存取控制等，再执行count∶=count+1操作，以表明有两个进程共享该段</li></ul></li><li>共享段的回收：<ul><li>撤消在该进程段表中共享段所对应的表项</li><li>执行count∶=count-1操作</li><li>若结果为0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；</li><li>否则(减1结果不为0)，则只是取消调用者进程在共享段表中的有关记录。</li></ul></li><li>分段保护<ul><li>越界检查<ul><li>在段表寄存器中放有段表长度信息；同样，在段表中也为每个段设置有段长字段。</li><li>在进行存储访问时，首先，将逻辑地址空间的段号与段表长度进行比较，如果段号等于或大于段表长度，将发出地址越界中断信号；</li><li>其次，还要检查段内地址是否等于或大于段长，若大于段长，将产生地址越界中断信号，从而保证了每个进程只能在自己的地址空间内运行。</li></ul></li><li>存取控制检查：在段表的每个表项中，都设置了一个“存取控制”字段，用于规定对该段的访问方式。通常的访问方式有：<ul><li>只读：只允许程序对该段中的程序或数据进行读访问；</li><li>只执行：只允许程序调用该段去执行，但不准读该段的内容，也不允许对该段执行写操作；</li><li>读/写：允许程序对该段进行读写访问。</li></ul></li><li>环保护机构：它是一种功能较完善的保护机构。在该机制中规定：低编号的环具有高优先权，OS核心处于0环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序，则被安排在外环上。<br><img src="https://user-images.githubusercontent.com/49378661/103187821-f25de700-4900-11eb-8827-754ced518acf.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103187821-f25de700-4900-11eb-8827-754ced518acf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201228113131184"><ul><li>低编号的环具有高优先权，操作系统位于最核心环</li><li>内环可访问外环数据：一个程序可以访问驻留在相同环或较低特权环中的数据</li><li>外环可请求内环服务：一个程序可以调用驻留在相同环或较高特权环中的服务</li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（六）：存储管理方式</title>
      <link href="8850f5f3d4be/"/>
      <url>8850f5f3d4be/</url>
      
        <content type="html"><![CDATA[<h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><p>在分页存储管理的方式中，如果不具备页面对换功能，则称为基本的（纯）分页管理方式，它不具有支持实现虚拟存储器的功能，它要求把每个作业全部装入内存后方能运行。</p><p>离散分配方式：</p><ul><li>连续分配方式要求为一个进程分配连续的内存空间，会形成许多“碎片”，尽管采用“紧凑”技术可以解决这个问题，但要为移动大量信息花去不少的处理机时间，代价较高。</li><li>如果允许一个进程直接分散地装入到许多不相邻接的分区中，称为离散分配方式。</li><li>离散分配方式有分页存储管理方式和分段存储管理方式两种。</li><li>分页：把用户程序按逻辑页划分成大小相等的部分，称为页或虚页。从0开始编制页号，页内地址是相对于0编址。</li></ul><h3 id="页面与页表"><a href="#页面与页表" class="headerlink" title="页面与页表"></a>页面与页表</h3><ol><li>页面和物理块：<ul><li>页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并加以编号，从0开始编制页号，页内地址是相对于0编址。</li><li>物理块：内存按页的大小划分为大小相等的区域，称为物理块（物理页面，页框(frame)，帧），同样加以编号，如0＃块、1＃块等等</li><li>在为进程分配内存时，以块为单位将进程中的若干个页分别装入到多个可以不相邻接的物理块中。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</li><li>页面大小：页面的大小应选择的适中，且页面大小应是2的幂，通常为512 B~8 KB<ul><li>页面若太小：虽然可使内存碎片减小，从而减少了内存碎片的总空间， 有利于提高内存利用率，但也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存； 此外，还会降低页面换进换出的效率</li><li>页面若太大：虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大。</li></ul></li><li>例如：系统页面大小为1KB，逻辑地址为2170，求页号与页内偏移量<ul><li>页号 P=INT[2170/1024]=2。</li><li>页内偏移量d=2170 mod 1024 =122<ul><li>第0页 0~1023</li><li>第1页 1024~2047</li><li>第2页 2048~3071</li></ul></li><li>综上所述，表示为(2,122)</li></ul></li></ul></li><li>主存分配：把用户程序的任一页分配到内存中的任一物理块，从而实现非连续的内存分配。<ul><li>问题：如何管理、如何进行地址变换。</li></ul></li><li>页表<ul><li>分页系统中，将进程的每一页离散地存储在内存的任一物理块中，为每个进程建立一张页面映像表，简称页表。</li><li>作用：实现页号到物理块号的映射。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103163362-1dc8cf00-4838-11eb-8052-b4240d7ecf69.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163362-1dc8cf00-4838-11eb-8052-b4240d7ecf69.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227104729354"></li><li>页表列出了用户程序的逻辑地址与其在主存中的物理地址间的对应关系。</li><li>一个页表中包含若干个表目，表目的自然序号对应于用户程序中的页号，表目中的块号是该页对应的物理块号。</li><li>页表的每一个表目除了包含指向页框的指针外，还包括一个存取控制字段，表目也称为页描述子。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103163364-26210a00-4838-11eb-8eba-19d7afd4715c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163364-26210a00-4838-11eb-8eba-19d7afd4715c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227104856781"></li></ul></li></ol><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><ol><li>基本地址变换机构：<ul><li>实现从逻辑地址到物理地址的转换，将逻辑地址中的页号转换为内存中的物理块号，通过页表来完成。</li><li>页表的实现<ul><li>寄存器：变换速度快、成本高，适应小型系统。</li><li>页表驻留在内存：速度较低、成本低，适应大系统。</li></ul></li><li>页表大多驻留在内存中，在系统中设置页表寄存器PTR(Page – Table Register)，在其中存放页表在内存中的始址和页表的长度。</li><li>进程未执行时，页表的始址和页表长度存放在本进程的PCB中，当调度程序调度到某进程时，才将这两个数据装入页表寄存器。</li></ul></li><li>地址结构：例如：32位地址，0<del>11为偏移量，12</del>31为页号，最大可以有1M（2^20）页，每页4KB（2^12） 。<br><img src="https://user-images.githubusercontent.com/49378661/103163365-2caf8180-4838-11eb-9f2b-36b1218d0da9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163365-2caf8180-4838-11eb-9f2b-36b1218d0da9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227105344282"></li><li>基本的地址变换机构：<br><img src="https://user-images.githubusercontent.com/49378661/103163368-33d68f80-4838-11eb-9ce4-ed65b187c643.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163368-33d68f80-4838-11eb-9ce4-ed65b187c643.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227105455114"><ul><li>每个进程对应一页表，其信息（如长度、始址）放在PCB中，执行时将其首地址装入页表寄存器。</li><li>当进程要访问某个进程逻辑地址中的数据时，分为页号和页内地址两部分。</li><li>如果页号大于或等于页表长度，则表示本次所访问的地址已经超越进程的地址空间。</li></ul></li><li>地址变换过程：<br><img src="https://user-images.githubusercontent.com/49378661/103163382-4b157d00-4838-11eb-803c-05e7bc323d2e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163382-4b157d00-4838-11eb-803c-05e7bc323d2e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227105520984"><ul><li>指令 LOAD 1,2500 的地址变换过程（块大小为1024B）。</li><li>地址变换过程：<ul><li>把虚拟地址2500转换成页号P=2，位移量W=452；</li><li>如果页号2大于页表大小，则中断；否则继续；</li><li>页号2与页表起址1000运算（1000+2*20，设页描述子大小为20）得到页描述子地址为1040；</li><li>从页描述子中读取块号8；</li><li>根据页描述子的“存取控制”判断该指令是否被允许访问内存，如果不允许，则中断；否则继续；</li><li>块号8与位移量452运算（8*1024+452=9644，1024为页面大小）得到物理地址9644；</li><li>执行LOAD操作。</li></ul></li></ul></li><li>具有快表的地址变换机构： 由于页表是存放在内存中的，这使CPU每次要存取一个数据时，都要两次访问内存。<ul><li>第一次是访问内存中的页表，从中找到该页的物理块号，将此块号与页内偏移量W拼接以形成物理地址。</li><li>第二次访问内存时，才是从第一步所得地址中获得所需数据（或向此地址中写入数据），并将此页号与高速缓存中的所有页码进行比较。</li></ul></li><li>在具有快表的地址变换机构中，为提高地址变换速度，在地址变换机构中增设一个具有并行查询能力的高速缓冲寄存器，又称为“联想寄存器”（Associative Memory）或“快表”，用以存放当前访问的那些页表项，快表通常可存放16-512个表项，如果设计得当，命中率可达90％以上。<br><img src="https://user-images.githubusercontent.com/49378661/103163386-510b5e00-4838-11eb-86f4-cf8b7904d194.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163386-510b5e00-4838-11eb-86f4-cf8b7904d194.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227110035491"></li></ol><h3 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h3><ol><li>现代的大多数计算机系统，都支持非常大的逻辑地址空间(232~264)。在这样的环境下，页表就变得非常大，要占用相当大的内存空间。<ul><li>例如，对于一个具有32位逻辑地址空间的分页系统，若规定页面大小为4 KB即212 B，则在每个进程页表中的页表项可达1M(220)个之多。若每个表项占用4个字节(32bit)， 故每个进程仅仅其页表就要占用4 MB的内存空间，而且还要求是连续的。</li></ul></li><li>可以采用这样两个方法来解决这一问题：<ul><li>采用离散分配方式来解决难以找到一块连续的大内存空间的问题</li><li>只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入</li></ul></li><li>两级页表(Two-Level Page Table) ：可利用将页表分页，并离散地将各个页面分别存放在不同的物理块中，同样要为离散分配的页表再建立一张页表，称为外层页表（Outer Page Table），每个页表项中记录了页表页面的物理块号：<br><img src="https://user-images.githubusercontent.com/49378661/103163392-58cb0280-4838-11eb-9ec5-c1ef3b3c39b0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163392-58cb0280-4838-11eb-9ec5-c1ef3b3c39b0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227110546635"></li><li>两级页表结构：<br><img src="https://user-images.githubusercontent.com/49378661/103163394-5ec0e380-4838-11eb-9eb6-e74f496bbc3e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163394-5ec0e380-4838-11eb-9eb6-e74f496bbc3e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227110604118"><ul><li>每个物理块为4KB，恰好放一个1页页表（1024个项，每项4Byte），共需1024个这样的块。</li></ul></li><li>具有两级页表的地址变换机构:<br><img src="https://user-images.githubusercontent.com/49378661/103163396-63859780-4838-11eb-97cc-4fa77bbe86ec.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163396-63859780-4838-11eb-97cc-4fa77bbe86ec.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227110658547"></li></ol><hr><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><h3 id="分段存储管理方式的引入"><a href="#分段存储管理方式的引入" class="headerlink" title="分段存储管理方式的引入"></a>分段存储管理方式的引入</h3><ol><li>基本分段存储管理：<br><img src="https://user-images.githubusercontent.com/49378661/103163401-6e402c80-4838-11eb-98fc-458cdb5b68ae.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163401-6e402c80-4838-11eb-98fc-458cdb5b68ae.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227110808234"><ul><li>不便于信息共享、保护、动态增长和链接。</li></ul></li><li>分页存储管理的主要目的是为了提高内存利用率，满足用户在编程和使用上的要求。</li><li>分段管理的主要目的：<ul><li>方便编程：通常，一个作业是由若干个自然段组成。因而，用户希望能把自己的作业按照逻辑关系划分为若干个段；每个段都有自己的名字和长度；要访问的逻辑地址是由段名（段号）和段内偏移量决定；每个段都从0开始编址。这样，用户程序在执行中可用段名和段内地址进行访问。用户作业通常按逻辑关系分若干个段：<ul><li><code>LOAD 1, [A]|&lt;D&gt;</code></li><li><code>STORE 1,[B]|&lt;C&gt;</code></li></ul></li><li>信息共享：通常，在实现程序和数据的共享时，都是以信息的逻辑单位为基础的。为了实现的共享，也希望存储管理能与用户程序分段的组织方式相适应。<ul><li>程序与数据的共享是以信息的逻辑单位为基础</li></ul></li><li>信息保护：在多道程序环境下，为了防止其它程序对某种程序在内存中的数据有意无意的破坏，必须采用保护措施，对内存中信息的保护，同样是对信息的逻辑单位进行保护。因此，采用分段的组织和管理方式，对于实现保护功能，将是更有效和方便的。</li><li>动态增长：在实际使用中，往往有些段特别是数据段，会不断地增长，而事先又无法确切地知道数据段会增长到多大。这种动态增长的情况是其它几种存储管理方式都难于应付的；而分段存储管理方式却能较好地解决这一问题。</li><li>动态链接：通常，用户源程序经过编译所形成的若干个目标程序，还须再经过链接以形成可执行程序后，方能执行，进行的链接称为静态链接。动态链接是指在作业运行之前，并不把几个目标程序段链接起来。</li></ul></li></ol><h3 id="分段系统的基本原理"><a href="#分段系统的基本原理" class="headerlink" title="分段系统的基本原理"></a>分段系统的基本原理</h3><ol><li>分段存储管理方式中，作业的地址空间被分成若干个段(segment)，每个段定义了一组逻辑信息。</li><li>分段地址中的地址具有如下结构：<br><img src="https://user-images.githubusercontent.com/49378661/103163403-76986780-4838-11eb-91f0-70cea4fde8a0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163403-76986780-4838-11eb-91f0-70cea4fde8a0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227111636806"></li><li>分段方式已得到许多编译程序的支持。</li><li>段表：<br><img src="https://user-images.githubusercontent.com/49378661/103163406-7c8e4880-4838-11eb-9ea4-354d3ddd02aa.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163406-7c8e4880-4838-11eb-9ea4-354d3ddd02aa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227111730997"><ul><li>在分段式存储管理系统中，为每个分段分配一个连续的分区，而进程中的各个段可以离散地移入内存中的不同的分区中</li><li>系统为每个进程建立一张段映射表，简称为“段表”</li><li>每个段在段表中占一个表项，其中记录了该段在内存中的起始地址（又称为“基址”）和段的长度</li><li>它记录了段号，段的首（地）址和长度之间的关系，每一个程序设置一个段表，放在内存,属于进程的现场信息。</li><li>利用段表实现地址映射：<br><img src="https://user-images.githubusercontent.com/49378661/103163407-857f1a00-4838-11eb-9a14-2c38a0f8cc59.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163407-857f1a00-4838-11eb-9a14-2c38a0f8cc59.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227111905896"></li></ul></li><li>分段系统的地址变换过程：<br><img src="https://user-images.githubusercontent.com/49378661/103163408-8a43ce00-4838-11eb-9eec-334e8808375f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163408-8a43ce00-4838-11eb-9eec-334e8808375f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227112117967"></li><li>地址映射及存储保护机制：<br><img src="https://user-images.githubusercontent.com/49378661/103163411-8e6feb80-4838-11eb-9383-9385906d99d3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163411-8e6feb80-4838-11eb-9383-9385906d99d3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227112132863"></li><li>分页和分段的主要区别：<ul><li>页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率。或者说，分页仅仅是由于系统管理的需要而不是用户的需要。段则是信息的逻辑单位，它含有一组其意义相对完整的信息。 分段的目的是为了能更好地满足用户的需要。</li><li>页的大小固定且由系统决定，由系统把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而在系统中只能有一种大小的页面；而段的长度却不固定， 决定于用户所编写的程序，通常由编译程序在对源程序进行编译时，根据信息的性质来划分。</li><li>分页的作业地址空间是一维的，即单一的线性地址空间，程序员只需利用一个记忆符，即可表示一个地址； 而分段的作业地址空间则是二维的，程序员在标识一个地址时，既需给出段名， 又需给出段内地址。 </li><li>整理如下：<br><img src="https://user-images.githubusercontent.com/49378661/103163417-99c31700-4838-11eb-84e7-8a3d3ece5b97.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163417-99c31700-4838-11eb-84e7-8a3d3ece5b97.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227112502743"></li></ul></li></ol><h3 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h3><ol><li>分段存储的一个优点是易于实现段的共享，即允许若干个进程共享一个或多个分段。</li><li>分页系统中虽然也能实现程序和数据的共享，但远不如分段系统方便。</li><li>可重入代码（Reentrant Code）又称为“纯代码”（Pure Code）是一种允许多个进程同时访问的代码。可重入代码是一种不允许任何进程对它进行修改的代码。</li><li>分页系统中共享editor的示意图：<br><img src="https://user-images.githubusercontent.com/49378661/103163418-9f206180-4838-11eb-9a7d-7dbc7ef8ac7e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163418-9f206180-4838-11eb-9a7d-7dbc7ef8ac7e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227113136273"><br><img src="https://user-images.githubusercontent.com/49378661/103163419-a47dac00-4838-11eb-8967-d9440ff36d37.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163419-a47dac00-4838-11eb-8967-d9440ff36d37.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227113207737"></li><li>分段管理的优缺点：<ul><li>优点：<ul><li>便于动态申请内存</li><li>管理和使用统一化</li><li>便于共享</li><li>便于动态链接</li></ul></li><li>缺点：产生碎片，段还需要连续的存储空间。</li></ul></li></ol><h3 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h3><ol><li>基本原理<ul><li>是分段和分页原理的结合</li><li>将用户程序分成若干个段，再把每一段分成若干个页，并为每一段赋予一个段名</li><li>段页式管理中，地址机构由段号、段内页号及页内地址三部分所组成</li></ul></li><li>作业地址空间和地址结构：<br><img src="https://user-images.githubusercontent.com/49378661/103163421-a9daf680-4838-11eb-997d-b43d5141b350.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163421-a9daf680-4838-11eb-997d-b43d5141b350.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227113413393"></li><li>在段页式系统中，为了实现从逻辑地址到物理地址的变换，系统中需同时配置段表和页表。由于允许将一个段中的页进行离散分配，因而使段表的内容略有变化：它不在是段的内存始址和段长，而是页表始址和页表长度。</li><li>利用段表和页表实现地址映射：<br> <img src="https://user-images.githubusercontent.com/49378661/103163423-ae9faa80-4838-11eb-9a72-53ab537e695f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163423-ae9faa80-4838-11eb-9a72-53ab537e695f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227113515630"></li><li>在段页式系统中，需三次访问内存：<ul><li>第一次访问，是访问内存中的段表。</li><li>第二次访问，是访问内存中的页表。</li><li>第三次访问，才是真正从第二次访问所得的地址中，取出指令或数据。</li></ul></li><li>段页式系统中的地址变换过程：<br><img src="https://user-images.githubusercontent.com/49378661/103163424-b3645e80-4838-11eb-81f0-77b25a5958c2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103163424-b3645e80-4838-11eb-81f0-77b25a5958c2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227113712167"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（五）：存储器管理概述</title>
      <link href="0f07f5c9c9f3/"/>
      <url>0f07f5c9c9f3/</url>
      
        <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><ol><li>计算机的基本物理组成：<br><img src="https://user-images.githubusercontent.com/49378661/103162682-7c894b00-482e-11eb-9fcb-d0cd6fb9983d.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162682-7c894b00-482e-11eb-9fcb-d0cd6fb9983d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227092649167"></li><li>指令的执行过程：<br><img src="https://user-images.githubusercontent.com/49378661/103162683-827f2c00-482e-11eb-8ac4-cb037d65e3f7.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162683-827f2c00-482e-11eb-8ac4-cb037d65e3f7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227092741404"></li><li>CPU与内存的关系：<br><img src="https://user-images.githubusercontent.com/49378661/103162685-87dc7680-482e-11eb-904c-db117d1cbf1b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162685-87dc7680-482e-11eb-904c-db117d1cbf1b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227092914256"></li><li>传输数据流程简图：<br><img src="https://user-images.githubusercontent.com/49378661/103162686-8dd25780-482e-11eb-9b3a-03d18603fa05.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162686-8dd25780-482e-11eb-9b3a-03d18603fa05.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227093017226"></li><li>存储器是计算机系统重要的组成部分，虽然存储器的容量不断扩大，但仍不能满足要求，因此存储器管理是操作系统的重要工作。</li><li>存储器包括内存（主存）和外存（磁盘）</li><li>存储器的功能是保存数据，存储器的发展方向是高速、大容量和小体积。<ul><li>内存在访问速度方面的发展：DRAM、SDRAM、SRAM等；</li><li>硬盘技术在大容量方面的发展：接口标准、存储密度等。</li></ul></li><li>主存储器管理技术分为两大类：<ul><li>实存储器管理；</li><li>虚拟存储器管理。</li></ul></li><li>存储器的物理组织、多级存储器：<ul><li>存储组织是指在存储技术和CPU寻址技术许可的范围内组织合理的存储结构。其依据是访问速度匹配关系、容量要求和价格。主要有以下结构：<ul><li>“寄存器-内存-外存” 结构</li><li>“寄存器-缓存-内存-外存”结构；</li></ul></li><li>微机中的存储层次组织：<ul><li>访问速度越慢，容量越大，价格越便宜；</li><li>最佳状态应是各层次的存储器都处于均衡的繁忙状态（如：缓存命中率正好使主存读写保持繁忙）。</li></ul></li></ul></li><li>存储器的层次：<br><img src="https://user-images.githubusercontent.com/49378661/103162689-9c207380-482e-11eb-8e0b-253da5852a95.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162689-9c207380-482e-11eb-8e0b-253da5852a95.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227093626746"></li><li>高速缓存（Cache）：CPU要读取一个数据时，首先从Cache(SRAM)中查找，如果找到就立即读取并送给CPU处理；如果没有找到，就用相对慢的速度从内存中读取并送给CPU处理，同时把这个数据所在的数据块调入Cache中，可以使得以后对整块数据的读取都从Cache中进行，不必再调用内存。 </li></ol><hr><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><ol><li>多道程序环境下，程序要运行必须为之创建进程，而创建进程的第一件事就是分配内存。</li><li>源程序要运行通常经过编译（compile）-&gt; 链接(link) -&gt; 装入(load)等几个步骤：<br><img src="https://user-images.githubusercontent.com/49378661/103162691-a3478180-482e-11eb-9395-974df816f9d9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162691-a3478180-482e-11eb-9395-974df816f9d9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227093949602"></li><li>程序的装入：<ul><li>绝对装入方式<ul><li>事先确定了程序将驻留在内存的什么位置，即在内存中的绝对地址。</li><li>装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</li><li>绝对地址的产生：<ul><li>程序员直接赋予。不仅要求程序员熟悉内存使用情况，而且一旦程序或数据被修改后，可能要改变程序中的所有地址。通常在程序中采用符号地址，在编译或汇编时，再将符号地址转换为绝对地址。</li><li>编译或汇编时产生</li></ul></li><li>缺点：绝对装入方式只能将目标模块装入到内存中事先指定的位置。在多道程序环境下，不可能预知目标模块放在内存中的地址，因此绝对装入方式不适合在多道环境下使用。</li></ul></li><li>可重定位装入方式<ul><li>程序中目标模块的地址通常从0开始，其他地址都是相对于0计算——相对地址</li><li>把在装入时对目标程序中指令和数据的地址修改过程称为重定位，又因为地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162694-ab072600-482e-11eb-8059-26c68359a666.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162694-ab072600-482e-11eb-8059-26c68359a666.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227094355521"></li><li>缺点：<ul><li>不断的分配和回收，造成内存中小空闲块很多，总空闲空间量够，但分配不了。<ul><li>理论上的解决办法：办法：紧凑（移动），但该装入方法不支持。</li></ul></li><li>可重定位方式不允许程序运行时在内存中移动位置。</li></ul></li></ul></li><li>动态运行时装入方式<ul><li>动态运行时的装入程序，是在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址都仍是相对地址</li></ul></li></ul></li><li>程序的链接：<ul><li>静态链接方式<ul><li>在程序运行前，先将各目标模块及所需的库函数链接成一个完整的装配模块，以后不再拆开</li><li>在将这几个目标模块装配成一个装入模块时，须解决以下两个问题 <ul><li>对相对地址进行修改 </li><li>变换外部调用符号</li></ul></li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162700-b35f6100-482e-11eb-971e-bc402819fdd1.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162700-b35f6100-482e-11eb-971e-bc402819fdd1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227095046714"></li></ul></li><li>装入时动态链接<ul><li>将用户的源程序编译后所得的一组目标模块在装入内存时采用边装入边链接的方式<ul><li>便于修改和更新</li><li>便于实现对目标模块的共享 </li></ul></li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162702-b9554200-482e-11eb-9d78-ecdf8b8f33fa.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162702-b9554200-482e-11eb-9d78-ecdf8b8f33fa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227095102200"></li><li>缺点：应用程序在每次运行的模块可能不相同。</li></ul></li><li>运行时动态链接<ul><li>运行时动态链接方式将对某些模块的链接推迟到执行时才进行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。</li><li>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162706-be19f600-482e-11eb-8748-397ea2cbc126.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162706-be19f600-482e-11eb-8748-397ea2cbc126.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227095248945"></li></ul></li></ul></li></ol><hr><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ol><li>连续分配方式为一个用户程序分配一个连续的内存空间。</li><li>单一连续分配是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。</li><li>把内存分为<ul><li>系统区：OS使用，通常放在内存低址部分</li><li>用户区：用户可使用的全部内存空间</li></ul></li><li>存储器保护机构不健全，易造成系统破坏。</li><li>优缺点：<ul><li>优点：易于管理</li><li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存</li></ul></li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162711-cc681200-482e-11eb-95cd-d0198f94e114.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162711-cc681200-482e-11eb-95cd-d0198f94e114.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227095554384"></li></ol><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ol><li>最简单的可运行多道程序的存储管理方式。</li><li>内存用户空间划分为若干个固定大小的区域，每个分区中只装入一道作业。</li><li>划分分区的方法 <ul><li>分区大小相等：即使所有的内存分区大小相等<ul><li>太大：浪费</li><li>太小：不够用</li></ul></li><li>分区大小不等：根据程序大小决定所使用的分区，划分为多个大、中、小搭配的分区<ul><li>大班在大教室、小班在小教室</li></ul></li></ul></li><li>内存分配 ：分区的信息根据分区使用表管理<br><img src="https://user-images.githubusercontent.com/49378661/103162714-d38f2000-482e-11eb-96a6-dfee495b3fd3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162714-d38f2000-482e-11eb-96a6-dfee495b3fd3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227095801553"><ul><li>问题：并发进程数受分区个数的制约！</li><li>出现：有内存却不能运行程序或大进程无法运行！</li></ul></li></ol><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><ol><li>根据进程的实际需要，动态地为之分配内存空间。</li><li>分配中数据结构 <ul><li>空闲分区表 记录每个空闲分区的情况</li><li>空闲分区链 实现对空闲分区的分配和链接</li></ul></li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162716-d9850100-482e-11eb-98a1-1025acbbc840.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162716-d9850100-482e-11eb-98a1-1025acbbc840.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227100142398"></li></ol><h3 id="基于顺序搜索的动态分区分配算法"><a href="#基于顺序搜索的动态分区分配算法" class="headerlink" title="基于顺序搜索的动态分区分配算法"></a>基于顺序搜索的动态分区分配算法</h3><blockquote><p>分配算法主要有：首次适应算法FF、循环首次适应算法、最佳适应算法、最坏适应算法</p><p>首次适应被认为最好、最快。其次是循环，最佳最差（每次分配后剩下小碎片，难再分，不得不经常压缩内存，反而浪费CPU）</p></blockquote><ol><li>首次适应算法FF：<ul><li>空闲分区链以地址递增顺序链接</li><li>分配时从链首开始查找，找到一个大小可满足的空闲分区，划出一块给请求者</li><li>优点：简单；优先利用低地址空闲区，保留高地址大空闲区</li><li>缺点：会造成在低地址部分很多难以利用的小空闲分区，查找效率低</li></ul></li><li>循环首次适应算法：<ul><li>每次分配时从上一次找到空闲分区的下一个空闲区开始查找</li><li>优点：减少查找空闲分区开销，空闲分区分布更均匀</li><li>缺点：缺乏大的空闲区</li></ul></li><li>最佳适应算法：<ul><li>空闲区按容量由小到大排序</li><li>每次分配时，把能满足要求、又是最小的分区分配给作业</li><li>优点：不缺乏大的空闲区</li><li>缺点：会在存储器中留直许多难以利用的小分区——“零头（或碎片）”；查找效率低</li></ul></li><li>最坏适应算法：<ul><li>空闲区按容量由大到小排序</li><li>每次分配时，把能满足要求、又是最大的分区分配给作业</li><li>优点：剩余的空间最大化，不出现太小的“零头”</li><li>缺点：缺乏大的空闲区</li></ul></li><li>分区分配操作 <ul><li>回收内存</li><li>进程运行结束释放内存时，系统根据回收区的首地址，把它插入到空闲链表中。根据回收区的位置，有四种情况需处理：<ul><li>情况1：回收区与插入点的前一个空闲分区相邻接</li><li>情况2：回收区与插入点的后一个空闲分区相邻接 </li><li>情况3：回收区同时与插入点的前、后两个分区相邻接</li><li>情况4：回收区不与任何空闲区邻接</li><li>以上4种情况分别对应如下：<br><img src="https://user-images.githubusercontent.com/49378661/103162718-e275d280-482e-11eb-8b6d-90dd6678a9dd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162718-e275d280-482e-11eb-8b6d-90dd6678a9dd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227100931183"></li></ul></li></ul></li><li>分区式存储管理的优缺点：<ul><li>优点：<ul><li>便于动态申请内存</li><li>便于共享内存</li><li>便于动态链接</li></ul></li><li>缺点：碎片问题(外碎片)，要求连续的内存空间，内存利用率不高，受实际内存容量限制。</li></ul></li><li>碎片问题：经过一段时间的分配回收后，内存中存在很多很小的空闲块。它们每一个都很小，不足以满足分配要求；但其总和满足分配要求，这些空闲块被称为碎片。<ul><li>问题解决：<ul><li>紧凑技术：通过在内存移动程序，将所有小的空闲区域合并为大的空闲区域。缺点是开销大，而且移动时机不好把握。</li></ul></li></ul></li></ol><h3 id="基于索引搜索的动态分区分配算法"><a href="#基于索引搜索的动态分区分配算法" class="headerlink" title="基于索引搜索的动态分区分配算法"></a>基于索引搜索的动态分区分配算法</h3><h3 id="动态可重定位分区分配"><a href="#动态可重定位分区分配" class="headerlink" title="动态可重定位分区分配"></a>动态可重定位分区分配</h3><ol><li>动态重定位的引入：<br><img src="https://user-images.githubusercontent.com/49378661/103162724-e9044a00-482e-11eb-83e4-416d4b930c1b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162724-e9044a00-482e-11eb-83e4-416d4b930c1b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227101429041"><ul><li>连续分配存在的问题：必须有足够大的连续空间才能分配。可以用“拼接”或“紧凑”方法来解决：<br><img src="https://user-images.githubusercontent.com/49378661/103162725-eefa2b00-482e-11eb-9b59-936b66ae252b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162725-eefa2b00-482e-11eb-9b59-936b66ae252b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227101528057"></li></ul></li><li>动态重定位的实现<ul><li>作业装入内存后的所有地址仍是相对地址，将相对地址转换成物理地址的工作在指令执行时进行</li><li>需要有硬件地址变换机构的支持</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162727-f4f00c00-482e-11eb-8c0f-216e72dd2793.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162727-f4f00c00-482e-11eb-8c0f-216e72dd2793.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227101612000"></li></ul></li><li>动态重定位分区分配算法：<ul><li>与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，增加了“紧凑”功能，通常是在找不到足够大的空闲分区来满足用户需求时，进行紧凑。</li><li>在一个分区释放后立即移动。</li><li>当请求得不到满足时再移动。</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103162730-fae5ed00-482e-11eb-9f57-35154bfddab0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103162730-fae5ed00-482e-11eb-9f57-35154bfddab0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201227101744015"></li></ul></li><li>可重定位分区的优缺点<ul><li>优点：决了可变分区分配所引入的“外零头”问题。消除内存碎片，提高内存利用率。</li><li>缺点：提高硬件成本，紧凑时花费CPU时间。</li></ul></li></ol><hr><h2 id="对换（Swapping）"><a href="#对换（Swapping）" class="headerlink" title="对换（Swapping）"></a>对换（Swapping）</h2><ol><li>对换的引入：<ul><li>对换（也称交换）技术，最早用在单用户系统，在内存中仅驻留一道用户作业。</li><li>所有其它作业都驻留在外存的后备队列上，只调入一个作业进入内存运行；此作业的时间片用完时，该作业调至外存，再将后备队列上的另一个作业调入内存；也让它运行一个时间片的时间，然后又将它调出，再调下一个作业进入内存。</li><li>因为其效率太低，其CPU大约有一半的时间，都处于空闲状态。</li></ul></li><li>所谓“对换”，是指把内存中暂时不能运行的进程或者暂时不用的程序和数据，调出到外存上，以便腾出足够的内存空间，再把已具备运行条件的进程或进程所需要的程序和数据，调入内存。对换是提高内存利用率的有效措施。<ul><li>如果对换是以整个进程为单位，称为“整体对换”或“进程对换”。</li><li>如果对换是以“页”或“段”为单位进行的，则称为“页面对换”或“分段对换”，又统称为“部分对换”。</li></ul></li><li>为了实现进程对换，系统必须能实现以下三方面的功能：<ul><li>（1）对换空间的管理；</li><li>（2）进程的换出；</li><li>（3）进程的换入。</li></ul></li><li>对换空间的管理<ul><li>外存中对换区主要存放从内存中换出的进程，对换空间管理的主要目标是提高进程换入和换出的速度。</li><li>对换区中空闲盘块的管理：在系统中配置相应的数据结构，记录外存的使用情况。形式与内存在动态分区分配方式中所用数据结构相似，即用空闲分区表或空闲分区链。在空闲分区表中的每个表目中应包含两项， 即对换区的首址及其大小，它们的单位是盘块号和盘块数。</li><li>对换区的分配采用连续分配方式，分配算法可以是首次适应算法、循环首次适应算法或最佳适应算法。</li></ul></li><li>进程的换出与换入<ul><li>进程的换出：系统先选择处于“阻塞”状态且优先级最低的进程作为换出进程，然后启动盘块，将该进程的程序和数据传送到磁盘的对换区上。若传送未出现错误，便回收其所占用的内存空间，并对该进程的进程控制块做相应的修改</li><li>进程的换入：系统应定时地查看所有进程的状态，从中找出“就绪”状态但已换出的进程，将其中换出时间(换出到磁盘上)最久的进程作为换入进程，将之换入，直至已无可换入的进程或无可换出的进程为止</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（四）：死锁</title>
      <link href="35479f43ab63/"/>
      <url>35479f43ab63/</url>
      
        <content type="html"><![CDATA[<h2 id="死锁概述"><a href="#死锁概述" class="headerlink" title="死锁概述"></a>死锁概述</h2><ol><li>死锁概念：指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进。如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃。</li><li>死锁的定义：在一组进程发生死锁的情况下，这组死锁进程中的每一个进程，都在等待另一个死锁进程所占有的资源。 </li><li>关于死锁的一些结论：<ul><li>参与死锁的进程最少是两个；</li><li>参与死锁的进程至少有两个已经占有资源；</li><li>参与死锁的所有进程都在等待资源；</li><li>参与死锁的进程是当前系统中所有进程的子集。</li></ul></li><li>资源问题：在系统中有许多不同类型的资源，其中可以引起死锁的主要是，需要采用互斥访问方法的、不可以被抢占的资源，即在前面介绍的临界资源。系统中这类资源有很多，如打印机、数据文件、队列、信号量等。<ul><li>可重用性资源和消耗性资源：<ul><li>可重用性资源：可重用性资源是一种可供用户重复使用多次的资源，它具有如下性质：<ul><li>每一个可重用性资源中的单元只能分配给一个进程使用，不允许多个进程共享。</li><li>进程在使用可重用性资源时，须按照这样的顺序：<ul><li>请求资源。如果请求资源失败，请求进程将会被阻塞或循环等待；</li><li>使用资源。进程对资源进行操作，如用打印机进行打印；</li><li>释放资源。当进程使用完后自己释放资源。</li></ul></li><li>系统中每一类可重用性资源中的单元数目是相对固定的，进程在运行期间既不能创建也不能删除它。</li></ul></li><li>可消耗性资源：可消耗性资源又称为临时性资源，它是在进程运行期间，由进程动态地创建和消耗的，它具有如下性质：<ul><li>每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0；</li><li>每一类可消耗性资源的单元数目在进程运行期间是可以不断变化的，有时它可以有许多，有时可能为0；</li><li>进程在运行过程中，可以请求若干个可消耗性资源单元，用于进程自己的消耗，不再将它们返回给该资源类中。</li></ul></li></ul></li><li>可抢占性资源和不可抢占性资源：<ul><li>可抢占性资源：指某进程在获得这类资源后，该资源可以再被其它进程或系统抢占。</li><li>不可抢占性资源：一旦系统把某资源分配给该进程后，就不能将它强行收回，只能在进程用完后自行释放。</li></ul></li></ul></li><li>计算机系统中的死锁：<ul><li>竞争不可抢占性资源引起死锁：通常系统中所拥有的不可抢占性资源其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局。如下表示共享文件时的死锁情况 ：<br><img src="https://user-images.githubusercontent.com/49378661/103154352-eaebf000-47d1-11eb-85fd-406fa0081bcf.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154352-eaebf000-47d1-11eb-85fd-406fa0081bcf.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226220554807"></li><li>竞争可消耗资源引起死锁：如下表示在三个进程之间，在利用消息通信机制进行通信时所形成的死锁情况：<br><img src="https://user-images.githubusercontent.com/49378661/103154358-f3dcc180-47d1-11eb-95e3-6eeef29a9f22.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154358-f3dcc180-47d1-11eb-95e3-6eeef29a9f22.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226220631013"></li><li>进程推进顺序不当引起死锁：<br><img src="https://user-images.githubusercontent.com/49378661/103154364-f93a0c00-47d1-11eb-8b8b-3e8d2f811062.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154364-f93a0c00-47d1-11eb-8b8b-3e8d2f811062.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226221141686"><ul><li>若并发进程 P1 和 P2 按曲线④所示的顺序推进，它们将进入不安全区D内。此时P1保持了资源R1, P2保持了资源R2，系统处于不安全状态。因为这时两进程再向前推进，便可能发生死锁。例如，当 P1 运行到 P1:Request(R2) 时，将因 R2 已被 P2 占用而阻塞；当 P2 运行到 P2: Request(R1) 时，也将因 R1 已被 P1 占用而阻塞，于是发生了进程死锁。</li></ul></li></ul></li><li>产生死锁的必要条件：<ul><li>互斥条件：进程对所分配到的资源进行排它性的使用。</li><li>请求和保持条件：进程已经至少保持了一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有。</li><li>不剥夺条件：进程已获得的资源在未使用完之前不能被剥夺。</li><li>环路等待条件：在发生死锁时，必然存在一个 “进程—资源” 循环等待的环形链。</li></ul></li><li>处理死锁的基本方法：<ul><li>预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止发生死锁。</li><li>避免死锁：不须采用各种限制措施去破坏产生死锁的必要条件，防止系统进入不安全状态，从而避免发生死锁，只需在事先加以较弱的限制条件。</li><li>检测死锁：不须检查系统是否已进入不安全区，允许系统在运行过程中发生死锁。</li><li>解除死锁：常用的实施方法是撤消或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。</li></ul></li></ol><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><ol><li>破坏 “请求和保持” 条件：所有进程在开始运行之前必须一次性的申请整个运行过程所需的全部资源。<ul><li>优点：简单、易于实现、安全。</li><li>缺点：资源浪费严重、进程延迟运行。</li></ul></li><li>破坏 “不可抢占” 条件：进程逐个地申请所需资源，当一个已经保持了某些资源的进程申请新资源而不能得到满足时，必须放弃所有已保持的资源。<ul><li>缺点：实现复杂、代价高昂；延长了进程的周转时间，还增加了系统开销，降低了系统的吞吐量。</li></ul></li><li>破坏 “循环等待” 条件：系统将所有资源按类型分配序号并排队，所有进程申请资源必须按序号递增的顺序。<ul><li>优点：资源利用率系统吞吐量较高。</li><li>缺点：在资源管理和资源申请方面仍有问题</li><li>例如：<br><img src="https://user-images.githubusercontent.com/49378661/103154382-ffc88380-47d1-11eb-980b-6f8ff3c6d080.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154382-ffc88380-47d1-11eb-980b-6f8ff3c6d080.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226222310780"><ul><li>存在问题：资源的需求顺序不等于序号，仍存在资源浪费。</li></ul></li><li>其资源利用率和系统吞吐量，都有较明显的改善，但也存在下述严重问题：<ul><li>资源所分配的序号，必须相对稳定，这就限制了新设备类型的增加。</li><li>进程使用各资源的顺序，与系统规定的顺序不同，造成对资源的浪费。</li><li>按规定次序申请资源的方法，必然会限制了用户简单、自主地编程。</li></ul></li></ul></li></ol><hr><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><ol><li>系统安全状态：<ul><li>在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程； 否则，令进程等待。</li><li>所谓安全状态，是指系统能按某种进程顺序（P1, P2, …，Pn，称&lt;P1, P2, …, Pn&gt;序列为安全序列），来为每个进程Pi分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</li></ul></li><li>安全状态举例：<ul><li>假定系统中有三个进程 P1、 P2 和 P3，共有12台磁带机。</li><li>进程 P1 总共要求 10 台磁带机，P2 和 P3 分别要求 4 台和 9 台。</li><li>假设在T0时刻，进程P1、P2和P3已分别获得5台、2台和2台磁带机，尚有3台空闲未分配，如下表所示：<br><img src="https://user-images.githubusercontent.com/49378661/103154400-0656fb00-47d2-11eb-91b7-a49dc0417868.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154400-0656fb00-47d2-11eb-91b7-a49dc0417868.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226230430737"></li><li>如果不按照安全序列分配资源，则系统可能会由安全状态进入不安全状态。例如，在T0时刻以后，P3又请求1台磁带机，若此时系统把剩余3台中的1台分配给P3，则系统便进入不安全状态。<br><img src="https://user-images.githubusercontent.com/49378661/103154404-0e169f80-47d2-11eb-846f-25a004e78112.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154404-0e169f80-47d2-11eb-846f-25a004e78112.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226230522592"></li></ul></li><li>利用银行家算法避免死锁：<ul><li>银行家算法中的数据结构：<ul><li>可利用资源向量Available。这是一个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果Available[j] = K，则表示系统中现有Rj类资源K个。 </li><li>最大需求矩阵Max。这是一个n×m的矩阵，它定义了系统中n个进程中的每一个进程对m类资源的最大需求。如果Max[i,j] = K，则表示进程i需要Rj类资源的最大数目为K。</li><li>分配矩阵Allocation。这也是一个n×m的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果Allocation[i,j]=K，表示进程i当前已分得Rj类资源的数目为K。</li><li>需求矩阵Need。这也是一个n×m的矩阵，用以表示每一个进程尚需的各类资源数。如果Need[i,j] = K，则表示进程i还需要Rj类资源K个，方能完成其任务。  </li><li>即：<br><img src="https://user-images.githubusercontent.com/49378661/103154408-14a51700-47d2-11eb-883c-0f6baca14ae7.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154408-14a51700-47d2-11eb-883c-0f6baca14ae7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226230652599"></li></ul></li><li>银行家算法步骤：设Requesti是进程Pi的请求向量，如果Requesti[j] = K，表示进程Pi需要K个Rj类型的资源。当Pi发出资源请求后，系统按下述步骤进行检查：<ul><li>（1）如果Requesti[j] ≤ Need[i,j]，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li><li>（2）如果Requesti[j] ≤ Available[j]，便转向步骤(3)；否则， 表示尚无足够资源，Pi须等待。 </li><li>（3）系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值：<ul><li>Available[j] := Available[j] - Requesti[j];</li><li>Allocation[i,j] := Allocation[i,j] + Requesti[j];</li><li>Need[i,j] := Need[i,j] - Requesti[j];</li></ul></li><li>（4）系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。</li></ul></li></ul></li><li>安全性算法：<ul><li>（1）设置两个向量：<ul><li>工作向量Work: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有m个元素，在执行安全算法开始时，Work := Available; </li><li>Finish: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先做Finish[i] := false; 当有足够资源分配给进程时， 再令Finish[i] := true。 </li></ul></li><li>（2）从进程集合中找到一个能满足下述条件的进程；<ul><li>Finish[i] = false; </li><li>Need[i,j] ≤ Work[j];</li><li>若找到， 执行步骤(3)， 否则，执行步骤(4)。</li></ul></li><li>（3）当进程Pi获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<ul><li>Work[j] := Work[i] + Allocation[i,j];</li><li>Finish[i] := true;</li><li>执行步骤（2）</li></ul></li><li>（4）如果所有进程的Finish[i] = true都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。</li></ul></li></ol><hr><h2 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h2><ol><li>资源分配图：系统死锁可利用资源分配图来描述。该图是由一组结点N和一组边E所组成的一个对偶G =（N，E），具有下述形成的定义和限制：<ul><li>N被分为两个互斥的子集，一组进程结点P=（p1，p2，…，pn），一组资源结点R={r1，r2，…，rn}，N=P∪R。如下图：<br><img src="https://user-images.githubusercontent.com/49378661/103154410-1a9af800-47d2-11eb-9597-52bace82a99e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154410-1a9af800-47d2-11eb-9597-52bace82a99e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226231338799"></li><li>资源分配图表示法：<ul><li>资源类：用方框表示（资源的不同类型）</li><li>资源实例：用方框中的圆点表示（存在于每个资源中）</li><li>进程：用圆圈中加进程名表示</li><li>分配边：资源实例进程的一条有向边</li><li>申请边：进程资源类的一条有向边</li></ul></li></ul></li><li>死锁定理：如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。<ul><li>有环有死锁：<br><img src="https://user-images.githubusercontent.com/49378661/103154413-1f5fac00-47d2-11eb-8799-ff3599881bd2.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154413-1f5fac00-47d2-11eb-8799-ff3599881bd2.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226231544993"></li><li>有环无死锁：<br><img src="https://user-images.githubusercontent.com/49378661/103154415-24246000-47d2-11eb-8f21-d5f305f226af.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103154415-24246000-47d2-11eb-8f21-d5f305f226af.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226231600608"></li></ul></li><li>死锁定理——资源分配图化简：<ul><li>找出一个既不阻塞又非独立的进程结点pi，在顺利的情况下pi可获得资源而继续运行，再释放所有资源。消去pi所有的请求边和分配边，将其变为孤立结点。</li><li>再把相应的资源分配给一个等待该资源的进程，即将某进程的申请边变为分配边。</li><li>在进行一系列化简后若能消去图中所有的边，使所有进程结点成为孤立结点，则称该图是可完全简化的；否则是不可完全简化的。</li><li>已经证明：所有的化简顺序都得到相同的不可简化图。同样可以证明，S为死锁的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件称为死锁定理。</li></ul></li></ol><hr><h2 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h2><ol><li><p>当发现有进程死锁后，便应立即把它从死锁状态中解脱出来。</p></li><li><p>常用的方法：</p><ul><li>抢占资源：从其他进程剥夺足够的资源给死锁进程，以解除死锁状态。</li><li>终止进程：<ul><li>撤消所有死锁进程。</li><li>按照某种顺序逐个地撤消代价最小的进程，直至有足够的资源可用，使死锁状态消除；所谓代价是指优先级、运行代价、进程的重要性和价值等。</li></ul></li></ul></li><li><p>终止进程的方法：</p><ul><li>终止所有死锁进程：<ul><li>这是一种最简单的方法，即是终止所有的死锁进程，死锁自然也就解除了。</li><li>但所付出的代价可能会很大。因为其中有些进程可能已经运行了很长时间，已接近结束，一旦被终止真可谓“功亏一篑”，以后还得从头再来。还可能会有其它方面的代价，在此不再一一列举。</li></ul></li><li>逐个终止进程：<ul><li>稍微温和的方法是，按照某种顺序，逐个地终止进程，直至有足够的资源，以打破循环等待，把系统从死锁状态解脱出来为止。</li><li>但该方法所付出的代价也可能很大。因为每终止一个进程，都需要用死锁检测算法确定系统死锁是否已经被解除，若未解除还需再终止另一个进程。另外，在采取逐个终止进程策略时，还涉及到应采用什么策略选择一个要终止的进程。选择策略最主要的依据是，为死锁解除所付出的“代价最小”。但怎么样才算是“代价最小”，很难有一个精确的度量。 </li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（三）：处理机调度</title>
      <link href="29326ada3e53/"/>
      <url>29326ada3e53/</url>
      
        <content type="html"><![CDATA[<h2 id="处理机调度的层次和调度算法的目标"><a href="#处理机调度的层次和调度算法的目标" class="headerlink" title="处理机调度的层次和调度算法的目标"></a>处理机调度的层次和调度算法的目标</h2><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ol><li>高级调度：<ul><li>作业调度或长程调度，也称为接纳调度。</li><li>主要任务是按一定的原则对外存上处于后备状态的作业进行选择，给选中的作业分配内存、输入/输出设备等必要的资源，并建立相应的进程，放入就绪队列，以使该作业的进程获得竞争处理机的权利。</li><li>高级调度的时间尺度通常是分钟、小时或天。</li><li>在每次作业调度时，须决定：<ul><li>接纳多少个作业：取决于多道程序度，即允许多少个作业同时在内存中运行。<ul><li>要进行适当地折中，作业太多会使服务质量下降，作业太少会使资源利用率低。</li></ul></li><li>接纳哪些作业：取决于作业调度算法，常用的作业调度算法包括先来先服务、短作业优先、作业优先权调度、响应比调度算法</li></ul></li></ul></li><li>低级调度：<ul><li>进程调度或短程调度。</li><li>主要任务是按照某种策略和方法选取一个处于就绪状态的进程，将处理机分配给它。</li><li>常见的低级调度有非抢占式和抢占式两种。</li><li>低级调度的时间尺度通常是毫秒级的。由于低级调度算法的频繁使用，要求在实现时做到高效。</li></ul></li><li>中级调度：<ul><li>引入目的是为了提高内存利用率和系统吞吐量，使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们调至外存上去等待。</li><li>主要任务是按照给定的原则和策略，将处于外存对换区中的重又具备运行条件的就绪进程调入内存，或将处于内存就绪状态或内存阻塞状态的进程交换到外存对换区。</li></ul></li><li>概念解释：<ul><li>多道程序度：即允许多少个作业同时在内存中运行。</li><li>周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔。</li><li>吞吐量：是指在单位时间内系统所完成的作业数。</li></ul></li></ol><h3 id="处理机调度算法的目标"><a href="#处理机调度算法的目标" class="headerlink" title="处理机调度算法的目标"></a>处理机调度算法的目标</h3><ol><li>处理机调度算法的共同目标：<ul><li>资源利用率。为提高系统的资源利用率，应使系统中的处理机和其它所有资源都尽可能地保持忙碌状态，其中最重要的处理机利用率可用以下方法计算：<br><img src="https://user-images.githubusercontent.com/49378661/103152294-a48e9500-47c1-11eb-9c33-c94e5cd60c43.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152294-a48e9500-47c1-11eb-9c33-c94e5cd60c43.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221084458317"></li><li>公平性。公平性是指应使诸进程都获得合理的CPU 时间，不会发生进程饥饿现象。公平性是相对的，对相同类型的进程应获得相同的服务；但对于不同类型的进程，由于其紧急程度或重要性的不同，则应提供不同的服务。</li><li>平衡性。由于在系统中可能具有多种类型的进程，有的属于计算型作业，有的属于I/O型。为使系统中的CPU和各种外部设备都能经常处于忙碌状态，调度算法应尽可能保持系统资源使用的平衡性。</li><li>策略强制执行。对所制订的策略其中包括安全策略，只要需要，就必须予以准确地执行，即使会造成某些工作的延迟也要执行。</li></ul></li><li>批处理系统的目标：<ul><li>平均周转时间短。应使作业周转时间和作业的平均周转时间尽可能短。否则，会使许多用户的等待时间过长，这将会引起用户特别是短作业用户的不满。可把平均周转时间描述为：<br><img src="https://user-images.githubusercontent.com/49378661/103152297-af492a00-47c1-11eb-9b07-2813343ce761.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152297-af492a00-47c1-11eb-9b07-2813343ce761.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221084710157"><ul><li>为了进一步反映调度的性能，更清晰地描述各进程在其周转时间中，等待和执行时间的具体分配状况，往往使用带权周转时间，即作业的周转时间T与系统为它提供服务的时间Ts之比，即W = T/Ts。而平均带权周转时间则可表示为：<br><img src="https://user-images.githubusercontent.com/49378661/103152298-b53f0b00-47c1-11eb-9796-e8580420734f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152298-b53f0b00-47c1-11eb-9796-e8580420734f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221085315684"></li></ul></li><li>系统吞吐量高。由于吞吐量是指在单位时间内系统所完成的作业数，因而它与批处理作业的平均长度有关。事实上，如果单纯是为了获得高的系统吞吐量，就应尽量多地选择短作业运行。</li><li>处理机利用率高。对于大、中型计算机，CPU价格十分昂贵，致使处理机的利用率成为衡量系统性能的十分重要的指标；而调度方式和算法又对处理机的利用率起着十分重要的作用。如果单纯是为使处理机利用率高，应尽量多地选择计算量大的作业运行。由上所述可以看出，这些要求之间是存在着一定矛盾的。</li></ul></li><li>实时系统的目标：<ul><li>截止时间的保证。</li><li>可预测性。</li></ul></li><li>分时系统的目标：<ul><li>响应时间快。</li><li>均衡性。</li></ul></li></ol><hr><h2 id="作业与作业调度"><a href="#作业与作业调度" class="headerlink" title="作业与作业调度"></a>作业与作业调度</h2><blockquote><p>在多道批处理系统中，作业是用户提交给系统的一项相对独立的工作。</p><p>操作员把用户提交的作业通过相应的输入设备输入到磁盘存储器，并保存在一个后备作业队列中。再由作业调度程序将其从外存调入内存。</p></blockquote><h3 id="作业和作业步"><a href="#作业和作业步" class="headerlink" title="作业和作业步"></a>作业和作业步</h3><p>作业：作业是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合，包括用户程序、所需的数据及命令等。</p><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><p>为了管理和调度作业，在多道批处理系统中，为每个作业设置了一个作业控制块JCB，它是作业在系统中存在的标志，其中保存了系统对作业进行管理和调度所需的全部信息。通常在JCB中包含的内容有：作业标识、用户名称、用户账号、作业类型(CPU 繁忙型、I/O 繁忙型、批量型、终端型)、作业状态、调度信息(优先级、作业运行时间)、资源需求(预计运行时间、要求内存大小等)、资源使用情况等。</p><h3 id="作业运行的三个阶段和三种状态"><a href="#作业运行的三个阶段和三种状态" class="headerlink" title="作业运行的三个阶段和三种状态"></a>作业运行的三个阶段和三种状态</h3><p>作业从进入系统到运行结束，通常需要经历收容、运行和完成三个阶段。相应的作业也就有“后备状态”、“运行状态”和“完成状态”。即：</p><table><thead><tr><th align="center">作业阶段</th><th align="center">作业状态</th></tr></thead><tbody><tr><td align="center">收容阶段</td><td align="center">后备状态</td></tr><tr><td align="center">运行阶段</td><td align="center">运行状态</td></tr><tr><td align="center">完成阶段</td><td align="center">完成状态</td></tr></tbody></table><p><img src="https://user-images.githubusercontent.com/49378661/103152305-c556ea80-47c1-11eb-92c0-1be42f2379d8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152305-c556ea80-47c1-11eb-92c0-1be42f2379d8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221090244332"></p><h3 id="作业调度的主要任务"><a href="#作业调度的主要任务" class="headerlink" title="作业调度的主要任务"></a>作业调度的主要任务</h3><ol><li>作业调度的主要任务是，根据JCB中的信息，检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。因此，也把作业调度称为接纳调度在每次执行作业调度时，都需做出以下两个决定。<ul><li>接纳多少个作业</li><li>接纳哪些作业</li></ul></li><li>先来先服务 (first-come first-served，FCFS) 调度算法：<ul><li>FCFS 是最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。</li><li>当在作业调度中采用该算法时，系统将按照作业到达的先后次序来进行调度，或者说它是优先考虑在系统中等待时间最长的作业，而不管该作业所需执行时间的长短，从后备作业队列中选择几个最先进入该队列的作业，将它们调入内存，为它们分配资源和创建进程。然后把它放入就绪队列。</li><li>在采用FCFS算法时，人—机无法实现交互。</li><li>该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理。</li></ul></li><li>短作业优先 (short job first，SJF) 的调度算法：<ul><li>由于在实际情况中，短作业(进程)占有很大比例，为了能使它们能比长作业优先执行，而产生了短作业优先调度算法。</li><li>SJF算法是以作业的长短来计算优先级，作业越短，其优先级越高。作业的长短是以作业所要求的运行时间来衡量的。</li><li>SJF算法可以分别用于作业调度和进程调度。在把短作业优先调度算法用于作业调度时，它将从外存的作业后备队列中选择若干个估计运行时间最短的作业，优先将它们调入内存运行。</li><li>SJF调度算法较之FCFS算法有了明显的改进，但仍然存在不容忽视的缺点：<ul><li>必须预知作业的运行时间。在采用这种算法时，要先知道每个作业的运行时间。即使是程序员也很难准确估计作业的运行时间，如果估计过低，系统就可能按估计的时间终止作业的运行，但此时作业并未完成，故一般都会偏长估计。</li><li>对长作业非常不利，长作业的周转时间会明显地增长。更严重的是，该算法完全忽视作业的等待时间，可能使作业等待时间过长，出现饥饿现象。</li></ul></li></ul></li><li>优先级调度算法 (priority-scheduling algorithm，PSA) 和 高响应比优先调度算法 (Highest Response Ratio Next，HRRN) ：<ul><li>我们可以这样来看作业的优先级，对于先来先服务调度算法，作业的等待时间就是作业的优先级，等待时间越长，其优先级越高。对于短作业优先调度算法，作业的长短就是作业的优先级，作业所需运行的时间越短，其优先级越高。但上述两种优先级都不能反映作业的紧迫程度。</li><li>在批处理系统中，FCFS算法所考虑的只是作业的等待时间，而忽视了作业的运行时间。而SJF算法正好与之相反，只考虑作业的运行时间，而忽视了作业的等待时间。高响应比优先调度算法则是既考虑了作业的等待时间，又考虑作业运行时间的调度算法，因此既照顾了短作业，又不致使长作业的等待时间过长，从而改善了处理机调度的性能。</li><li>高响应比优先算法是如何实现的呢? 如果我们能为每个作业引入一个动态优先级，即优先级是可以改变的，令它随等待时间延长而增加，这将使长作业的优先级在等待期间不断地增加，等到足够的时间后，必然有机会获得处理机。该优先级的变化规律可描述为：<br><img src="https://user-images.githubusercontent.com/49378661/103152313-d0aa1600-47c1-11eb-831c-3f8c39c24f68.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152313-d0aa1600-47c1-11eb-831c-3f8c39c24f68.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221093952644"></li><li>由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级又相当于响应比RP。据此，优先又可表示为：<br><img src="https://user-images.githubusercontent.com/49378661/103152316-d6076080-47c1-11eb-9305-e8ed09d80767.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152316-d6076080-47c1-11eb-9305-e8ed09d80767.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201221094042767"></li></ul></li></ol><hr><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="进程调度的任务、机制和方式"><a href="#进程调度的任务、机制和方式" class="headerlink" title="进程调度的任务、机制和方式"></a>进程调度的任务、机制和方式</h3><ol><li>进程调度的任务主要有：<ul><li>保存处理机的现场信息。</li><li>按某种算法选取进程。</li><li>把处理器分配给进程。</li></ul></li><li>为了实现进程调度，在进程调度机制中，应具有排队器、分派器、上下文切换器三个基本部分，如图：<br><img src="https://user-images.githubusercontent.com/49378661/103152319-db64ab00-47c1-11eb-9eab-fadf995dca32.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152319-db64ab00-47c1-11eb-9eab-fadf995dca32.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226203339987"></li><li>进程调度方式：<ul><li>非抢占方式：当某一进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才把处理机分配给更为重要或紧迫的进程。<ul><li>优点：算法简单，系统开销小；缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束。</li><li>引起进程调度的因素：<ul><li>正在执行的进程执行完毕， 或因发生某事件而不能再继续执行；</li><li>执行中的进程因提出I/O请求而暂停执行；</li><li>在进程通信或同步过程中执行了某种原语操作，如wait、Block、Wakeup原语。</li></ul></li></ul></li><li>抢占方式：当某一进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。<ul><li>优点：适于时间要求严格的实时系统；缺点：调度算法复杂，系统开销大。</li><li>主要有以下原则：<ul><li>优先权原则：允许高优先权的新到进程抢占当前进程的处理机。</li><li>短作业（进程）优先原则：允许执行时间短的新到进程抢占当前进程的处理机。</li><li>时间片原则：时间片用完后停止执行，重新进行调度，适用于分时系统。</li></ul></li></ul></li></ul></li></ol><h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3><ol><li>轮转法的基本原理：在轮转(RR)法中，系统将所有的就绪进程按 FCFS 策略排成一个就绪队列。系统可设置每隔一定时间（如30 ms）便产生一次中断，去激活进程调度程序进行调度，把 CPU 分配给队首进程，并令其执行一个时间片。当它运行完毕后，又把处理机分配给就绪队列中新的队首进程，也让它执行一个时间片。这样，就可以保证就绪队列中的所有进程在确定的时间段内，都能获得一个时间片的处理机时间。</li><li>进程切换时机：在 RR 调度算法中，应在何时进行进程的切换，可分为两种情况：<ul><li>若一个时间片尚未用完，正在运行的进程便已经完成，就立即激活调度程序，将它从就绪队列中删除，再调度就绪队列中队首的进程运行，并启动一个新的时间片。</li><li>在一个时间片用完时，计时器中断处理程序被激活。如果进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。</li></ul></li><li>时间片大小的确定：在轮转算法中，时间片的大小对系统性能有很大的影响。下图给出了时间片大小对响应时间的影响，其中图(a)是时间片略大于典型交互的时间，而图(b)是时间片小于典型交互的时间：<br><img src="https://user-images.githubusercontent.com/49378661/103152321-e1f32280-47c1-11eb-82b9-8c9e0f48cc0f.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152321-e1f32280-47c1-11eb-82b9-8c9e0f48cc0f.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226204618362"><ul><li>下图给出了时间片分别为q = 1和q = 4时对平均周转时间的影响：<br><img src="https://user-images.githubusercontent.com/49378661/103152329-eddee480-47c1-11eb-8fb1-925078eb0f69.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152329-eddee480-47c1-11eb-8fb1-925078eb0f69.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226204624441"></li></ul></li></ol><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><ol><li>优先级调度算法的类型：优先级进程调度算法，是把处理机分配给就绪队列中优先级最高的进程。这时，又可进一步把该算法分成如下两种：<ul><li>非抢占式优先级调度算法。</li><li>抢占式优先级调度算法。</li></ul></li><li>优先级的类型：<ul><li>静态优先级：静态优先级是在创建进程时确定的，在进程的整个运行期间保持不变。优先级是利用某一范围内的一个整数来表示的，例如0～255中的某一整数，又把该整数称为优先数。确定进程优先级大小的依据有如下三个：<ul><li>进程类型。</li><li>进程对资源的需求。</li><li>用户要求。</li></ul></li><li>动态优先级：动态优先级是指在创建进程之初，先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变，以便获得更好的调度性能。</li></ul></li></ol><h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><p>如前所述的各种调度算法，尤其在应用于进程调度时，由于系统中仅设置一个进程的就绪队列，即低级调度算法是固定的、单一的，无法满足系统中不同用户对进程调度策略的不同要求，在多处理机系统中，这种单一调度策略实现机制的缺点更显突出，由此，多级队列调度算法能够在一定程度上弥补这一缺点。</p><h3 id="多队列反馈调度算法"><a href="#多队列反馈调度算法" class="headerlink" title="多队列反馈调度算法"></a>多队列反馈调度算法</h3><ol><li>调度机制：<ul><li>设置多个就绪队列。如图：<br><img src="https://user-images.githubusercontent.com/49378661/103152332-f46d5c00-47c1-11eb-92f4-8bb5952acfa9.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152332-f46d5c00-47c1-11eb-92f4-8bb5952acfa9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226205018343"></li><li>每个队列都采用FCFS算法。<ul><li>当新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则等待调度。</li><li>当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。否则，即它在一个时间片结束时尚未完成，调度程序将其转入第二队列的末尾等待调度；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，依此类推。</li><li>当进程最后被降到第n队列后，在第n队列中便采取按PR方式运行。</li></ul></li><li>按队列优先级调度。<ul><li>调度程序首先调度最高优先级队列中的诸进程运行。</li><li>仅当第一队列空闲时才调度第二队列中的进程运行；换言之，仅当第1～(i-1)所有队列均空时，才会调度第i队列中的进程运行。</li><li>如果处理机正在第 i 队列中为某进程服务时又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i队列的末尾，而把处理机分配给新到的高优先级进程。</li></ul></li></ul></li><li>调度算法的性能：在多级反馈队列调度算法中，如果规定第一个队列的时间片略大于多数人机交互所需之处理时间时，便能较好地满足各种类型用户的需要。<ul><li>用户类型可分为：<ul><li>终端型用户。</li><li>短批处理作业用户。</li><li>长批处理作业用户。</li></ul></li></ul></li></ol><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol><li>在实施公平调度算法时系统中必须具有这样一些功能：<ul><li>跟踪计算每个进程自创建以来已经执行的处理时间。</li><li>计算每个进程应获得的处理机时间，即自创建以来的时间除以n。</li><li>计算进程获得处理机时间的比率，即进程实际执行的处理时间和应获得的处理机时间之比。</li><li>比较各进程获得处理机时间的比率。如进程A的比率最低，为0.5，而进程B的比率为0.8，进程C的比率为1.2等。</li><li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率为止。</li></ul></li><li>保证调度算法：<ul><li>保证调度算法是另外一种类型的调度算法，它向用户所做出的保证并不是优先运行，而是明确的性能保证，该算法可以做到调度的公平性。</li><li>一种比较容易实现的性能保证是处理机分配的公平性。</li><li>如果在系统中有 n 个相同类型的进程同时运行，为公平起见，须保证每个进程都获得相同的处理机时间 1/n。</li></ul></li><li>公平分享调度算法：<ul><li>分配给每个进程相同的处理机时间，显然，这对诸进程而言，是体现了一定程度的公平，但如果各个用户所拥有的进程数不同，就会发生对用户的不公平问题。</li></ul></li></ol><hr><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>在实时系统中，可能存在着两类不同性质的实时任务，即 HRT 任务和 SRT 任务，它们都联系着一个截止时间。为保证系统能正常工作，实时调度必须能满足实时任务对截止时间的要求。为此，实现实时调度应具备一定的条件。</p><ol><li>实现实时调度的基本条件：<ul><li>提供必要的信息。为了实现实时调度，系统应向调度程序提供有关任务的信息：<ul><li>就绪时间，是指某任务成为就绪状态的起始时间，在周期任务的情况下，它是事先预知的一串时间序列。</li><li>开始截止时间和完成截止时间，对于典型的实时应用，只须知道开始截止时间，或者完成截止时间。</li><li>处理时间，一个任务从开始执行，直至完成时所需的时间。</li><li>资源要求，任务执行时所需的一组资源。</li><li>优先级，如果某任务的开始截止时间错过，势必引起故障，则应为该任务赋予“绝对”优先级；如果其开始截止时间的错过，对任务的继续运行无重大影响，则可为其赋予“相对”优先级，供调度程序参考。</li></ul></li><li>系统处理能力强。在实时系统中，若处理机的处理能力不够强，则有可能因处理机忙不过，而致使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。<ul><li>假定系统中有 m 个周期性的硬实时任务 HRT，它们的处理时间可表示为 Ci，周期时间表示为 Pi，则在单处理机情况下，必须满足下面的限制条件系统才是可调度的：<br><img src="https://user-images.githubusercontent.com/49378661/103152342-018a4b00-47c2-11eb-9868-077e7d7fe5e0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152342-018a4b00-47c2-11eb-9868-077e7d7fe5e0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226210057114"></li><li>提高系统处理能力的途径有：<ul><li>采用单处理机系统。但须增强其处理能力，以显著地减少对每一个任务的处理时间；</li><li>采用多处理机系统。假定系统中的处理机数为N，则应将上述的限制条件改为：<br><img src="https://user-images.githubusercontent.com/49378661/103152349-064eff00-47c2-11eb-8453-9d50ebcb10e1.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152349-064eff00-47c2-11eb-8453-9d50ebcb10e1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226210133863"></li></ul></li></ul></li><li>采用抢占式调度机制。在含有 HRT 任务的实时系统中，广泛采用抢占机制。这样便可满足 HRT 任务对截止时间的要求，但这种调度机制比较复杂。</li><li>具有快速切换机制。为保证硬实时任务能及时运行，在系统中还应具有快速切换机制，使之能进行任务的快速切换。该机制应具有如下两方面的能力：<ul><li>对中断的快速响应能力。对紧迫的外部事件请求中断能及时响应，要求系统具有快速硬件中断机构，还应使禁止中断的时间间隔尽量短，以免耽误时机（其它紧迫任务）。</li><li>快速的任务分派能力。为了提高分派程序进行任务切换时的速度，应使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。</li></ul></li></ul></li><li>实时调度算法的分类（可以按不同方式对实时调度算法加以分类）：<ul><li>根据实时任务性质，可将实时调度的算法分为：<ul><li>硬实时调度算法</li><li>软实时调度算法</li></ul></li><li>按调度方式，则可分为：<ul><li>非抢占调度算法。又可分为：<ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li></ul></li><li>抢占调度算法。可根据抢占发生时间的不同而进一步分成：<ul><li>基于时钟中断的抢占式优先级调度算法。</li><li>立即抢占的优先级调度算法。</li></ul></li></ul></li></ul></li><li>优先级倒置：<ul><li>优先级倒置的形成：当前OS广泛采用优先级调度算法和抢占方式，然而在系统中存在着影响进程运行的资源而可能产生“优先级倒置”的现象，即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。例如：<br><img src="https://user-images.githubusercontent.com/49378661/103152354-0cdd7680-47c2-11eb-842b-db2a01daca6b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152354-0cdd7680-47c2-11eb-842b-db2a01daca6b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226212243502"><ul><li>P3最先执行，在执行了 P(mutex) 操作后，进入到临界区 CS-3。在时刻a，P2就绪，因为它比 P3 的优先级高，P2 抢占了 P3 的处理机而运行。</li></ul></li><li>优先级倒置的解决方法：<ul><li>一种简单的解决方法 —— 动态优先级继承，规定：假如进程 P3 在进入临界区后，P3 所占用的处理机就不允许被抢占。 例如：<br><img src="https://user-images.githubusercontent.com/49378661/103152357-11a22a80-47c2-11eb-99ba-eb0695d587ae.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/103152357-11a22a80-47c2-11eb-99ba-eb0695d587ae.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201226212516807"></li></ul></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（二）：进程的初步认识</title>
      <link href="279bab449d3d/"/>
      <url>279bab449d3d/</url>
      
        <content type="html"><![CDATA[<h2 id="进程与线程的知识体系图"><a href="#进程与线程的知识体系图" class="headerlink" title="进程与线程的知识体系图"></a>进程与线程的知识体系图</h2><p><img src="https://user-images.githubusercontent.com/49378661/98496888-9de1a800-227d-11eb-94a0-065bdaacb230.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98496888-9de1a800-227d-11eb-94a0-065bdaacb230.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109084704273"></p><blockquote><p>在之后的文章中会陆续讲到，这里我们只说线程的知识</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>操作系统中最核心的概念就是进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内<br>容都是围绕着进程展开的。进程是操作系统提供的最古老也是最重要的概念之一。即使可以使用的<br>CPU只有一一个，它们也支持（伪） 并发操作。它们会将一 一个单独的CPU抽象为多个虚拟机的CPU。<br>可以说，没有进程的抽象，现代操作系统将不复存在。</p><p><img src="https://user-images.githubusercontent.com/49378661/98496964-ccf81980-227d-11eb-88ef-edb7fa1385a1.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98496964-ccf81980-227d-11eb-88ef-edb7fa1385a1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109085235569"></p><p>在许多多道程序系统中， CPU会在进程间快速切换，使每个程说序运行几十或者几百毫秒。然而，严格<br>意义来说，在某一个瞬间，CPU只能运行一个进程，然而我们如果把时间定位为1秒内的话，它可能<br>运行多个进程。这样就会让我们产生并行的错觉。有时候人们说的伪并行（pseudoparallelism)<br>其实就是这种情况，以此来区分多处理器系统（该系统由两个或多个CPU来共享同一个物理内存）</p><blockquote><p>再解释一下伪并行：伪并行是指单核或多核处理器同时执行多个进程，从而使程序更快。<br>通过以非常有限的时间间隔在程序之间快速切换CPU，因此会产生并行感。</p><p>缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。</p></blockquote><p>因为CPU执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪，所<br>以，在经过多年的努力后，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得<br>并行更加容易理解和分析。下面我们就来探讨一下进程模型</p><h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p>在进程模型中，所有计算机上运行的软件，通常也包括操作系统，被组织为若干顺序进程，简称为进程（process) 。 一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟CPU，但是实际情况是CPU会在各个进程之间进行来回切换。<br><img src="https://user-images.githubusercontent.com/49378661/98497019-ef8a3280-227d-11eb-8db8-78c4fe056fd6.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497019-ef8a3280-227d-11eb-8db8-78c4fe056fd6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109090338163"></p><p>如上图所示，这是一个具有4个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化：<br><img src="https://user-images.githubusercontent.com/49378661/98497035-f6b14080-227d-11eb-966e-974c70391734.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497035-f6b14080-227d-11eb-966e-974c70391734.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109090459710"></p><p>在上图中，这4道程序被抽象为4个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一 一段时间后，所有的进程都运行了，但在任何一个给定的瞬间仅有一个进程真正运行：<br><img src="https://user-images.githubusercontent.com/49378661/98497048-fca72180-227d-11eb-8bea-12df8a803c75.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497048-fca72180-227d-11eb-8bea-12df8a803c75.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109091326053"></p><p>因此，当我们说一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU)，每一个核<br>也只能一次运行一个线程。</p><p>由于CPU会在各个进程之间来回快速切换，所以每个进程在CPU中的运行时间是无法确定的。并且<br>当同一个进程再次在CPU中运行时，其在CPU内部的运行时间往往也是不固定的。这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务。另外需要注意的是，如果一个进程运行 了两遍，则被认为是两个进程。那么我们了解到进程模型后，那么进程是如何创建的呢？</p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><p>操作系统需要一些方式来创建进程。下面是一 些创建进程的方式</p><ul><li>系统初始化（init)</li><li>正在运行的程序执行了创建进程的系统调用（比如fork)</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ul><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h3><p>启动操作系统时，通常会创建若干个进程。</p><p>其中有些是前台进程（numerous processes) ，也就是同用户进行交互并替他们完成工作的进程。</p><p>一些运行在后台，并不与特定的用户进行交互，例如，设计一个进程来接收发来的电子邮件，这个进程大部分的时间都在休眠，但是只要邮件到来后这个进程就会被唤醒。</p><p>还可以设计一个进程来接收对该计算机上网页的传入请求，在请求到达的进程唤醒来处理网页的传入请求。</p><p>进程运行在后台用来处理一些活动像是 e-mail, web网页，新闻，打印等等被称为守护进（daemons)。大型系统会有很多守护进程。在UNIX中，ps 程序可以列出正在运行的进程，在Windows中，可以使用任务管理器。</p><h3 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h3><p>除了在启动阶段创建进程之外，一些新的进程也可以在后面创建。通常，一个正在运行的进程会发出系统调用用来创建一个或多个新进程来帮助其完成工作。例如，如果有大量的数据需要经过网络调取并进行顺序处理，那么创建一个进程读数据，并把数据放到共享缓冲区中，而让第二个进程取走并正确处理会比较容易些。在多处理器中，让每个进程运行在不同的CPU上也可以使工作做的更快。</p><h3 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h3><p>在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的UNIX系统中运行X,新进程将接管启动它的窗口。在Windows中启动进程时，它一般没有窗口，但是它可以创建一个或多个窗口。每个窗口都可以运行进程。通过鼠标或者命令就可以切换窗口并与进程进行交互。</p><h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>最后一种创建进程的情形会在大型机的批处理系统中应用。用户在这种系统中提交批处理作业。</p><p>当操作系统决定它有资源来运行另一个任务时，它将创建一个新进程并从其中的输入队列中运行下一个作业。</p><p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。</p><p>该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。</p><p>该系统调用告诉操作系统创建一个新进程， 并直接或间接指示在其中运行哪个程序。</p><p>在UNIX中，仅有一个系统调用来创建一个新的进程，这个系统调用就是fork 。这个调用会创建一<br>个与调用进程相关的副本。在fork后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和<br>相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个<br>新的程序。例如，当一个用户在shell中输出sort命令时，shell 会fork 一个子进程然后子进程去执行sort命令。这两步过程的原因是允许子进程在fork之后但在execve之前操作其文件描述符，以完成标准输入，标准输出和标准错误的重定向。</p><p>而在Windows中，情况正相反，一个简单的Win32功能调用CreateProcess ，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有10个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以<br>及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。除了CreateProcess Win 32中大概有100个其他的函数用于处理进程的管理，同步以及相关的事务。</p><p>下面是UNIX操作系统和Windows操作系统系统调用的对比：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497063-03359900-227e-11eb-891b-88667de5f354.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497063-03359900-227e-11eb-891b-88667de5f354.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109093537417"></p><p>在UNIX和Windows中，进程创建之后，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中修改了一个词，这个修改将对另一个进程不可见。</p><p>在UNIX中，子进程的地址空间是父进程的一个拷贝，但是确是两个不同的地址空间；不可写的内存区域是共享的。某些UNIX实现是正是在两者之间共享，因为它不能被修改。或者，子进程共享父进程的所有内存，但是这种情况下内存通过写时复制（copy- on- write)共享， 这意味着一旦两者之一想要修改部分内存，则这块内存首先被明确的复制，以确保修改发生在私有内存区域。</p><p>再次强调，可写的内存是不能被共享的。 但是，对于一个新创建的进程来说，确实有可能共享创建者的资源，比如可以共享打开的文件。在Windows中，从一开始父进程的地址空间和子进程的地址空间就是不同的。</p><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><p>进程在创建之后，它就开始运行并做完成任务。然而，进程早晚会发生终止，但是通常是由于以下情况触发：</p><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>严重错误（非自愿的）</li><li>被其他进程杀死（非自愿的）</li></ul><h3 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h3><p>多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。</p><p>这个调用在UNIX中是exit，在Windows中是ExitProcess 。</p><p>面向屏幕中的软件也支持自愿终止操作。字处理软件、Internet 浏览器和类似的程序中总有一个供用户点击的图标或菜单项，用来通知进程删除它锁打开的任何临时文件，然后终止。</p><h3 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h3><p>进程发生终止的第二个原因是发现严重错误，例如，如果用户执行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CC foo.c</span><br></pre></td></tr></table></figure><p>为了能够编译foo.c但是该文件不存在，于是编译器就会发出声明并退出。在给出了错误参数时，面向<br>屏幕的交互式进程通常并不会直接退出，因为这从用户的角度来说并不合理，用户需要知道发生了什么并想要进行重试，所以这时候应用程序通常会弹出一个对话框告知用户发生了系统错误，是需要重试还是退出。</p><h3 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h3><p>进程终止的第三个原因是由进程引起的错误，通常是由于程序中的错误所导致的。例如，执行了一条非法指令，引用不存在的内存，或者除数是0等。</p><p>在有些系统比如UNIX中，进程可以通知操作系统，它希望自行处理某种类型的错误，在这类错误中，进程会收到信号（中断），而不是在这类错误出现时直接终止进程。</p><h3 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h3><p>第四个终止进程的原因是，某个进程执行系统调用告诉操作系统杀死某个进程。</p><p>在UNIX中，这个系统调用是kill。在Win32中对应的函数是TerminateProcess（注意不是系统调用）。</p><h2 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h2><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h3 id="UNIX进程体系"><a href="#UNIX进程体系" class="headerlink" title="UNIX进程体系"></a>UNIX进程体系</h3><p>在UNIX中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一<br>个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有<br>活动进程）。</p><p>每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号kill 掉。</p><p>另一个例子，可以用来说明层次的作用：考虑UNIX 在启动时如何初始化自己。一个称为init的特殊进程出现在启动映像中。当init进程开始运行时，它会读取一个文件，文件会告诉它有多少个终端。然后为每个终端创建一个新进程。 这些进程等待用户登录。如果登录成功，该登录进程就执行一个shell 来等待接收用户输入指令，这些命令可能会启动更多的进程，以此类推。因此，整个操作系统中所有的进程都隶属于一个单个以init为根的进程树：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">init─┬─NetworkManager（5427)</span><br><span class="line">        ├─NetworkManagerD（5441)</span><br><span class="line">        ├─acpid（5210)</span><br><span class="line">        ├─apache2（6966)─┬─apache2（2890)</span><br><span class="line">        │               ├─apache2（2893)</span><br><span class="line">        │               ├─apache2（7163)</span><br><span class="line">        │               ├─apache2（7165)</span><br><span class="line">        │               ├─apache2（7166)</span><br><span class="line">        │               ├─apache2（7167)</span><br><span class="line">        │               └─apache2（7168)</span><br><span class="line">        ├─atd（6369)</span><br><span class="line">        ├─avahi-daemon（5658)───avahi-daemon（5659)</span><br><span class="line">        ├─bonobo-activati（7816)───&#123;bonobo-activati&#125;（7817)</span><br></pre></td></tr></table></figure><h3 id="Windows进程体系"><a href="#Windows进程体系" class="headerlink" title="Windows进程体系"></a>Windows进程体系</h3><p>相反，Windows中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是<br>在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该询柄可以用来控制子进程。</p><p>然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在UNIX中，进程不能剥夺其子进程的进程权。（这样看来， 还是Windows比较渣）。</p><h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮<br>助。例如，一个进程的结果可以作为另一个进程的输入，在shell命令中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程是cat ，将三个文件级联并输出。</p><p>第二个进程是grep ，它从输入中选择具有包含关键字tree的内容。</p><p>根据这两个进程的相对速度（这取决于两个程序的相对复杂度和各自所分配到的CPU时间片），可能会发生下面这种情况：grep 准备就绪开始运行，但是输入进程还没有完成，于是必须阻塞grep进程，直到输入完毕。<br>当一个进程开始运行时，它可能会经历下面这几种状态（下图为进程状态切换图）：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497118-22342b00-227e-11eb-9074-9c30e007c0b4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497118-22342b00-227e-11eb-9074-9c30e007c0b4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109105506449"></p><p>图中会涉及三种状态：</p><ol><li>运行态，运行态指的就是进程实际占用CPU时间片运行时</li><li>就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li>阻塞态，除非某种外部事件发生，否则进程不能运行</li></ol><p>逻辑上来说，运行态和就绪态是很相似的。这两种情况下都表示进程可运行，但是第二种情况没有获<br>得CPU时间分片。</p><p>第三种状态与前两种状态不同的原因是这个进程不能运行，CPU空闲时也不能运行。</p><p>三种状态会涉及四种状态间的切换，在操作系统发现进程不能继续执行时会发生状态1的轮转，在某些<br>系统中进程执行系统调用，例如pause ，来获取一个阻塞的状态。在其他系统中包括UNIX，当进程从管道或特殊文件（例如终端） 中读取没有可用的输入时，该进程会被自动终止。</p><p>转换2和转换3都是由进程调度程序（操作系统的一部分）引起的，进程本身不知道调度程序的存在。</p><p>转换2的出现说明进程调度器认定当前进程已经运行了足够长的时间，是时候让其他进程运行CPU时间片了。当所有其他进程都运行过后，这时候该是让第一个进程重新获得CPU时间片的时候了，就会发生转换3。</p><p>程序调度指的是，决定哪个进程优先被运行和运行多久，这是很重要的一点。已经设计出许多算<br>法来尝试平衡系统整体效率与各个流程之间的竞争需求。</p><p>当进程等待的一个外部事件发生时（如从外部输入一些数据后），则发生转换4。如果此时没有其他进<br>程在运行，则立刻触发转换3,该进程便开始运行，否则该进程会处于就绪阶段，等待CPU空闲后再<br>轮到它运行。</p><p>从上面的观点引入了下面的模型：</p><p><img src="https://user-images.githubusercontent.com/49378661/98497133-2a8c6600-227e-11eb-9120-af97d8e2bc51.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497133-2a8c6600-227e-11eb-9120-af97d8e2bc51.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109110000239"></p><p>基于进程的操作系统中最底层的是中断和调度处理，在该层之上是顺序进程。</p><p>操作系统最底层的就是调度程序，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。</p><p>事实上，调度程序只是一段非常小的程序。</p><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是进程表（process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状<br>况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再次启动，就像从未被中断过一样。</p><p>下面展示了一个典型系统中的关键字段</p><p><img src="https://user-images.githubusercontent.com/49378661/98497144-2fe9b080-227e-11eb-8b9a-2710bd808168.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/98497144-2fe9b080-227e-11eb-8b9a-2710bd808168.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201109110430257"></p><p>典型的进程表表项中的一些字段</p><p>第一列内容与进程管理有关，第二列内容与存储管理 有关，第三列内容与文件管理有关。</p><p>存储管理的text segment、data segment、stack segment更多了解见下面这篇文章：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247484788&idx=1&sn=8a17224cabe09d3bd564dfdf22e2ff5d&chksm=fc45f887cb3271914f0e688a3cce4d7e3ce9077cdde199648e72aa92ad08fba2047b4483b7e8&token=504034995&lang=zh_CN%23rd">程序员需要了解的硬核知识之汇编语言（全）</a></p><p>现在我们应该对进程表有个大致的了解了，就可以在对单个CPU.上如何运行多个顺序进程的错觉做更<br>多的解释。</p><p>与每一/0类相关联的是一个称作中断向量（interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。</p><p>假设当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。</p><p>然后软件就随即接管一切剩余的工作。</p><p>当中断结束后，操作系统会调用一个C程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进<br>程就绪，接着调用调度程序，决定随后运行哪个进程。</p><p>然后将控制权转移给一 一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程：</p><ol><li>硬件压入堆栈程序计数器等</li><li>硬件从中断向量装 入新的程序计数器</li><li>汇编语言过程保存寄存器的值</li><li>汇编语言过程设置新的堆栈</li><li>C中断服务器运行（典型的读和缓存写入）</li><li>调度器决定下面哪个程序先运行</li><li>C过程返回至汇编代码</li><li>汇编语言过程开始运行新的当前进程</li></ol><p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统（一）：认识操作系统</title>
      <link href="bfb7f7b98435/"/>
      <url>bfb7f7b98435/</url>
      
        <content type="html"><![CDATA[<h2 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h2><ol><li>现代计算机系统由一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成。<br><img src="https://user-images.githubusercontent.com/49378661/97126827-e758d000-1772-11eb-98e6-e29dbc8ec6e3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126827-e758d000-1772-11eb-98e6-e29dbc8ec6e3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026083834317"></li><li>在硬件的基础上，计算机安装了一层软件，这些软件能够通过响应用户输入的指令达到控制硬件的效果，从而满足用户的需求，这种软件被称之为 “操作系统”，</li><li>我们一般常见的操作系统主要有：Windows、Linux、FreeBSD 或 OS X，这种带有图形界面的操作系统，被统称为 “图形用户界面（GUI）”，而基于文本、命令行通常被统称为 “Shell”，如下是我们所探讨的操作系统的部件（这是一个操作系统的简化图）：<br><img src="https://user-images.githubusercontent.com/49378661/97126859-ffc8ea80-1772-11eb-9b7a-a87a8c9107fd.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126859-ffc8ea80-1772-11eb-9b7a-a87a8c9107fd.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026083935975"><ul><li>最下面是硬件，硬件包括芯片、电路板、磁盘、键盘、显示器等我们上面提到的设备，硬件之上是软件。</li><li>大部分计算机有两种运行模式：“内核态” 和 “用户态”，软件中最基础的部分是操作系统，它运行在内核态中，内核态也被称为 “管态” 和 “核心态”，它们都是操作系统的运行状态，只是叫法不同而已。操作系统具有硬件的访问权，可以在执行机器能够运行的任何指令。软件的其余部分运行在用户态下。</li><li>“用户接口程序（Shell 或者 GUI）”处于用户态中，并且它们处在用户态的最底层，允许用户运行其他的程序，例如 Web 浏览器、电子邮件阅读器、音乐播放器等等，而且，越靠近用户态的应用程序越容易编写。假如你不喜欢某个电子邮件阅读器，你可以随意换一个软件，但你不能自行写一个操作系统或者是中断处理程序，这个程序是由硬件保护的，防止外部对其进行修改。</li></ul></li></ol><h2 id="计算机硬件简介"><a href="#计算机硬件简介" class="headerlink" title="计算机硬件简介"></a>计算机硬件简介</h2><h3 id="操作系统与硬件"><a href="#操作系统与硬件" class="headerlink" title="操作系统与硬件"></a>操作系统与硬件</h3><ol><li>操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源，因此，操作系统必须足够了解硬件的运行，所以这里要先介绍现代计算机中的硬件。</li><li>从概念上来看，一个简单的个人电脑可以被抽象为上面这种相似的模型，CPU、内存、I/O设备都和总线串联起来并通过总线与其他设备进行通信。<ul><li>简单个人计算机的组件：<br><img src="https://user-images.githubusercontent.com/49378661/97126920-26872100-1773-11eb-990e-28caadd150f8.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126920-26872100-1773-11eb-990e-28caadd150f8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026084030631"></li></ul></li></ol><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ol><li>CPU是计算机的大脑，它主要和内存进行交互，从内存中提取指令并执行它。一个CPU的执行周期是从内存中提取第一条指令、 解码并决定它的类型和操作数，执行，然后再提取、解码执行后续的指令。重复该循环直到程序运行完毕。</li><li>每个 CPU 都有一组可以执行的特定指令集。因此，X86 的 CPU 不能执行 ARM 的程序并且ARM 的 CPU 也不能执行 X86 的程序。由于访问内存获取执行或数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些寄存器来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。</li><li>除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。<ul><li>其中之一就是程序计数器(program counter) ，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。另一个寄存器是堆栈指针(stack pointer) ，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。</li><li>还有一个寄存器是PSW(Program Status Word)程序状态字寄存器，这个寄存器是由操作系统维护的 8 个字节（64位） long类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW。用户程序通常可以读取整个PSW,但通常只能写入其某些字段。PSW在系统调用和 1/ 0 中起着重要作用。</li></ul></li><li>操作系统必须了解所有的寄存器。在时间多路复用(time multiplexing) 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时， 操作系统会保存所有寄存器的值，以便于后续重新运行该程序。为了提升性能，CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。 许多现代的 CPU 都具有同时读取多条指令的机制。例如，一个CPU可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对N+ 1条指令解码，还可以读取N + 2条指令。像这样的组织形式被称为流水线(pipeline) 。<br><img src="https://user-images.githubusercontent.com/49378661/97126952-3d2d7800-1773-11eb-8eca-9fcb00d5f7c3.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126952-3d2d7800-1773-11eb-8eca-9fcb00d5f7c3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092152254"><ul><li>比流水线更先进的设计是超标量(superscalar) CPU，该设计如下：<br><img src="https://user-images.githubusercontent.com/49378661/97126965-43bbef80-1773-11eb-853e-e6b72b54e0b0.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126965-43bbef80-1773-11eb-853e-e6b72b54e0b0.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092300000"><ul><li>在上面这个设计中，存在多个执行单元，例如，一个用来进行整数运算、一个用来浮点数运算、一个用来布尔运算。两个或者更多的指令被一次性取出、 解码并放入缓冲区中，直至它们执行完毕。只要一个执行单元空闲，就会去检查缓冲区是否有可以执行的指令。如果有，就把指令从缓冲区中取出并执行。</li><li>这种设计的含义是应用程序通常是无序执行的。在大多数情况下，硬件负责保证这种运算的结果与顺序执行指令时的结果相同。</li></ul></li></ul></li><li>除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有两种模式，即前面已经提到的内核态和用户态。通常情况下，PSW 寄存器中的一个二进制位会控制当前状态是内核态还是用户态。<ul><li>当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下， 剩下的一部分运行在用户态下。<ul><li>注意，设置 PSW 模式的二进制位为内核态也是禁止的。</li></ul></li><li>用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 l/O 和内存保护的所有指令是禁止执行的。</li><li>为了获取操作系统的服务，用户程序必须使用系统调用(system call)，系统调用会转换为内核态并且调用操作系统。TRAP 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。我们会在后面探讨操作系统的调用细节。</li></ul></li><li>需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。</li></ol><h3 id="多线程和多核芯片"><a href="#多线程和多核芯片" class="headerlink" title="多线程和多核芯片"></a>多线程和多核芯片</h3><ol><li><p>多线程或超线程的特性起初是奔腾处理器（Intel Pentinum 4）引入的。</p></li><li><p>多线程允许 CPU 保持两个不同的线程状态并且在纳秒级(nanosecond)的时间完成切换，近似地说，线程是一种轻量级的进程。</p></li><li><p>例如，如果一个进程想要从内存中读取指令（这通常会经历几个时钟周期），多线程CPU则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。</p></li><li><p>对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的CPU。比如一个有两个CPU的操作系统，并且每个CPU运行两个线程，那么这对于操作系统来说就可能是4个CPU。</p></li><li><p>除了多线程之外，现在许多 CPU 芯片上都具有四个、八个或更多完整的处理器或内核。多核芯片在其上有效地承载了四个微型芯片，每个微型芯片都有自己的独立CPU。</p></li><li><p>如图是带有共享 L2 缓存的 4 核芯片：<br><img src="https://user-images.githubusercontent.com/49378661/97126976-4b7b9400-1773-11eb-8496-6856adb9d712.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126976-4b7b9400-1773-11eb-8496-6856adb9d712.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921092304767"><br><img src="https://user-images.githubusercontent.com/49378661/97126989-50d8de80-1773-11eb-8c8b-4d0f1f492dec.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97126989-50d8de80-1773-11eb-8c8b-4d0f1f492dec.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921093826668"></p><ul><li>而带有分离 L2缓存的 4 核芯片则如下：<br><img src="https://user-images.githubusercontent.com/49378661/97127060-8a114e80-1773-11eb-873a-607bb5415978.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127060-8a114e80-1773-11eb-873a-607bb5415978.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921094004991"></li></ul></li><li><p>而说到线代的 GPU，则是指有成千上万个微核组成的处理器，它们擅长处理大量并行的简单计算。</p></li></ol><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><p>计算机的第二个主要的组件就是内存，目前采用了不同的处理方式，存储系统采用一种分层次的结构：<br><img src="https://user-images.githubusercontent.com/49378661/97127274-23d8fb80-1774-11eb-815b-f0db39a46cd4.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127274-23d8fb80-1774-11eb-815b-f0db39a46cd4.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20200921094359988"></p><p>顶层的存储器访问效率最高，但是容量最小，成本也最高，以此类推。</p><h3 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h3><ol><li><p>位于寄存器下面的是高速缓存，它多数由硬件控制。主存被分割成高速缓存行（cache lines） 为64字节，内存地址的 0 一 63 对应高速缓存行0，地址 64- 127 对应高速缓存行的1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是高速缓存命中(cache hit)。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。</p></li><li><p>高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。</p></li><li><p>随机存储器（RAM） ：内存中最重要的一 种，表示既可以从中读取数据，也可以写入数据。当机器关闭时，内存中的信息会丢失。</p></li><li><p>大量的可用资源被划分为小的部分，这些可用资源的一部分会获得比其他资源更频繁的使用权， 缓存经常用来提升性能。操作系统无时无刻的不在使用缓存。例如，大多数操作系统在主机内存中保留（部分）频繁使用的文件，以避免重复从磁盘重复获取。举个例子，类似于 <code>/home/ ast/projects/minix3/src/kernel/clock.c</code>，这样的场路径名转换成的文件所在磁盘地址的结果也可以保存缓存中，以避免重复寻址。另外，当一个Web页面(URL)的地址转换为网络地址（P地址）后，这个转换结果也可以缓存起来供将来使用。</p></li><li><p>在任何缓存系统中，都会有下面这几个噬需解决的问题：</p><ul><li>何时把新的内容放进缓存</li><li>把新的内容应该放在缓存的哪一行</li><li>在需要空闲空间时，应该把哪块内容从缓存中移除</li><li>应该把移除的内容放在某个较大存储器的何处</li><li>并不是每个问题都与每种缓存情况有关。对于CPU缓存中的主存缓存行，当有缓存未命中时，就会调入新的内容。通常通过所引用内存地址的高位计算应该使用的缓存行。</li></ul></li><li><p>缓存是解决问题的一种好的方式，所以现代CPU设计了两种缓存。第一级缓存或者说是 L1 cache，总是位于CPU内部，用来将已解码的指令调入CPU的执行引擎。对于那些频繁使用的关键字，多数芯片有第二个L1 cache。典型的L1 cache的大小为16 KB。另外，往往还设有二级缓存，也就是L2 cache，用来存放最近使用过的关键字，一 一般是兆字节为单位。L1 cache和L2 cache最大的不同在于是否存在延迟。访问L1 cache没有任何的延迟，然而访问L2 cache会有1 — 2个时钟周期的延后。</p><blockquote><p>什么是时钟周期？<br>计算机处理器或CPU的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz） 或千兆赫（GHz）。例如， 一个4 GHz处理器每秒执行4,000,000,000个时钟周期。</p><p>计算机处理器可以在每个时钟周期执行一条或多 条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的CPU在每个时钟周期只能执行一条指令， 而现代处理器在每个时钟周期可以执行多条指令。</p></blockquote></li></ol><h3 id="主存"><a href="#主存" class="headerlink" title="主存"></a>主存</h3><ol><li>在上面的层次结构中再下一层是主存，这是内存系统的主力军，主存通常叫做RAM（Random AccessMenmory）。</li><li>除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容。</li><li>ROM（Read Only Memory）中的内容一 旦存储后就不会再被修改。它非常快而且便宜。（如果有 人问你，有没有什么又快又便宜的内存设备，那就是ROM了）在计算机中，用于启动计算机的引导加载模块（也就是bootstrap ）就存放在ROM中。另外，一些I/O卡也采用ROM处理底层设备控制。</li><li>EEPROM（Electrically Erasable PROM） 和闪存（flash menory）也是非易失性的，但是与ROM相反，它们可以擦除和重写。不过重写它们需要比写入RAM更多的时间，所以它们的使用方式与ROM相同，但是与ROM不同的是他们可以通过重写字段来纠正程序中出现的错误。<ul><li>闪存也通常用来作为便携性的存储媒介。闪存是数码相机中的胶卷，是便携式音乐播放器的磁盘。闪存的速度介于RAM和磁盘之间。另外，与磁盘存储器不同的是，如果闪存擦除的次数太多，会出现磨损。</li><li>还有一类是CMOS，它是易失性的。许多计算机都会使用CMOS存储器保持当前时间和日期。</li></ul></li></ol><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ol><li><p>磁盘（也就是硬盘），同RAM相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了 三个数量级。磁盘访问慢的原因是磁盘的构造不同。</p><ul><li>磁盘驱动器的构造：<br><img src="https://user-images.githubusercontent.com/49378661/97127508-c2655c80-1774-11eb-8e81-5b802c30e80c.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127508-c2655c80-1774-11eb-8e81-5b802c30e80c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026090018123"></li></ul></li><li><p>每个磁道划分若干扇区（如图），扇区的值是512字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要1ms。而随机移到一个柱面的典型时间为5ms至10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是50MB/s ，而高速磁盘的速率是160MB/s 。需要注意，固态硬盘(Solid State Disk, SSD) 不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在存储器（闪存）中， 与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。<br><img src="https://user-images.githubusercontent.com/49378661/97127140-ccd32680-1773-11eb-9561-e6924a995377.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127140-ccd32680-1773-11eb-9561-e6924a995377.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026090510293"></p></li><li><p>许多计算机支持一种著名的虚拟内存机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在RAM中的物理地址。这种映像由CPU中的一个称为存储器管理单元(Memory Management Unit, MMU) 的部件来完成。</p></li><li><p>缓存和MMU的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为上下文切换（ context switch) ，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。</p></li></ol><h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><ol><li><p>I/O设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。</p></li><li><p>I/O设备另一部分是设备本身，设备本身有一一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。</p></li><li><p>每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为设备驱动程序(device driver) 。每个控制器厂 家都应该针对不同的操作系统提供不同的设备驱动程序。</p></li><li><p>为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。要将设备驱动程序装入操作系统，一般有三个途径：</p><ul><li>第一个途径是将内核与设备启动程序重新连接，然后重启系统。这是UNIX 系统采用的工作方式</li><li>第二个途径是在一个操作系统文件中设置一个入口， 通知该文件需要一个设备驱动程序， 然后重新启动系统。在重新系统时，操作系统回寻找有关的设备启动程序并把它装载，这是Windows 采用的工作方式</li><li>第三个途径是操作系统能够在运行时接收新的设备驱动程序并立刻安装，无需重启操作系统，这种方式采用的少，但是正变得普及起来。热插拔设备，比如USB和IEE 1394都需要动态可装载的设备驱动程序。</li></ul></li><li><p>每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序回从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了I/O 端口空间。</p></li><li><p>在操作系统中，中断是非常重要的，所以这需要更加细致的讨论一下：</p><p>启动设备并发出中断的过程：<br><img src="https://user-images.githubusercontent.com/49378661/97127519-d315d280-1774-11eb-86b8-ece24306133b.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127519-d315d280-1774-11eb-86b8-ece24306133b.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026091609088"></p><ul><li>如上图所示，这是一个三步的I/O过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。</li><li>然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤2中使用某些总线向中断控制器发送信号。</li><li>如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在CPU的一个引脚上面声明，这就是步骤3。</li><li>在第4步中，中断控制器把该设备的编号放在总线上，这样CPU可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。</li><li>一旦CPU决定去实施中断后，程序计数器和PSW就会被压入到当前堆栈中并且CPU会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作中断向量(interrupt vector) 。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和PSW寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令， 这个过程如下：<br><img src="https://user-images.githubusercontent.com/49378661/97127175-dfe5f680-1773-11eb-96fd-40a6ba465d4a.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127175-dfe5f680-1773-11eb-96fd-40a6ba465d4a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026091959369"></li></ul></li></ol><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ol><li><p>随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括IBM PC总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理1/O设备以及CPU到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现：<br><img src="https://user-images.githubusercontent.com/49378661/97127186-e3797d80-1773-11eb-8149-163c8b7ca64e.png" class="lazyload" data-srcset="https://user-images.githubusercontent.com/49378661/97127186-e3797d80-1773-11eb-8149-163c8b7ca64e.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image-20201026092111966"></p><ul><li>上图中的 x86 系统包含很多总线，高速缓存、内存、PCle、 PCI、 USB、SATA 和DMI,每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是PCIe(Peri pheral Component Interconnect Express)总线。</li></ul></li></ol><h3 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h3><ol><li><p>在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一 般有BIOS芯片、I/O控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。</p></li><li><p>在母板上有一个称为基本输入输出系统(Basic Input Output System， BIOS) 的程序。在BIOS内有底层I/O软件，包括读键盘、写屏幕、磁盘I/O以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS中发现错误时，可以由操作系统进行更新。</p></li><li><p>在计算机启动(booted) 时，BIOS 开启，它会首先检查所安装的RAM的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描PCle和PCI总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一 一次启动时的设备不同，则新的设备将被重新配置。</p></li><li><p>然后，BIOS通过尝试存储在CMOS 存储器中的设备清单 尝试启动设备</p><blockquote><p>CMOS是Complementary Metal 0xide Sem iconductor （互补金属氧化物半导体）的缩写 。它是指制造大规模集成电路芯片用的一种技术或用这种技术制造出来的芯片，是电脑主板上的一块可读写的RAM 芯片。 因为可读写的特性，所以在电脑主板上用来保存BIOS设置完电脑硬件参数后的数据，这个芯片仅仅是用来存放数据的。</p><p>而对BIOS中各项参数的设定要通过专门的程序。BIOS 设置程序一般都被厂商整合在芯片中，在开机时通过特定的按键就可进入BIOS设置程序，方便地对系统进行设置。因此BIOS设置有时也被叫做CMOS设置。</p></blockquote></li><li><p>用户可以在系统启动后进入一个BIOS配置程序，对设备清单进行修改。然后，判断是否能够从外部CD-ROM和USB驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。</p></li><li><p>然后操作系统会询问BIOS获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入CD- ROM驱动（由设备制造商提供）或者从Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学校课程 </category>
          
          <category> 计算机操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
